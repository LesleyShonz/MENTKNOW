{"ast":null,"code":"import { EASINGS } from \"../easings.mjs\";\nvar min = Math.min;\nvar RATE_OF_PRESSURE_CHANGE = 0.275;\nfunction setStrokePointRadii(strokePoints, options) {\n  var _options$size = options.size,\n    size = _options$size === void 0 ? 16 : _options$size,\n    _options$thinning = options.thinning,\n    thinning = _options$thinning === void 0 ? 0.5 : _options$thinning,\n    _options$simulatePres = options.simulatePressure,\n    simulatePressure = _options$simulatePres === void 0 ? true : _options$simulatePres,\n    _options$easing = options.easing,\n    easing = _options$easing === void 0 ? function (t) {\n      return t;\n    } : _options$easing,\n    _options$start = options.start,\n    start = _options$start === void 0 ? {} : _options$start,\n    _options$end = options.end,\n    end = _options$end === void 0 ? {} : _options$end;\n  var _start$easing = start.easing,\n    taperStartEase = _start$easing === void 0 ? EASINGS.easeOutQuad : _start$easing;\n  var _end$easing = end.easing,\n    taperEndEase = _end$easing === void 0 ? EASINGS.easeOutCubic : _end$easing;\n  var totalLength = strokePoints[strokePoints.length - 1].runningLength;\n  var firstRadius;\n  var prevPressure = strokePoints[0].pressure;\n  var strokePoint;\n  if (!simulatePressure && totalLength < size) {\n    var max = strokePoints.reduce(function (max2, curr) {\n      return Math.max(max2, curr.pressure);\n    }, 0.5);\n    strokePoints.forEach(function (sp) {\n      sp.pressure = max;\n      sp.radius = size * easing(0.5 - thinning * (0.5 - sp.pressure));\n    });\n    return strokePoints;\n  } else {\n    var p;\n    for (var i = 0, n = strokePoints.length; i < n; i++) {\n      strokePoint = strokePoints[i];\n      if (strokePoint.runningLength > size * 5) break;\n      var sp = min(1, strokePoint.distance / size);\n      if (simulatePressure) {\n        var rp = min(1, 1 - sp);\n        p = min(1, prevPressure + (rp - prevPressure) * (sp * RATE_OF_PRESSURE_CHANGE));\n      } else {\n        p = min(1, prevPressure + (strokePoint.pressure - prevPressure) * 0.5);\n      }\n      prevPressure = prevPressure + (p - prevPressure) * 0.5;\n    }\n    for (var _i = 0; _i < strokePoints.length; _i++) {\n      strokePoint = strokePoints[_i];\n      if (thinning) {\n        var _strokePoint = strokePoint,\n          pressure = _strokePoint.pressure;\n        var _sp = min(1, strokePoint.distance / size);\n        if (simulatePressure) {\n          var _rp = min(1, 1 - _sp);\n          pressure = min(1, prevPressure + (_rp - prevPressure) * (_sp * RATE_OF_PRESSURE_CHANGE));\n        } else {\n          pressure = min(1, prevPressure + (pressure - prevPressure) * (_sp * RATE_OF_PRESSURE_CHANGE));\n        }\n        strokePoint.radius = size * easing(0.5 - thinning * (0.5 - pressure));\n        prevPressure = pressure;\n      } else {\n        strokePoint.radius = size / 2;\n      }\n      if (firstRadius === void 0) {\n        firstRadius = strokePoint.radius;\n      }\n    }\n  }\n  var taperStart = start.taper === false ? 0 : start.taper === true ? Math.max(size, totalLength) : start.taper;\n  var taperEnd = end.taper === false ? 0 : end.taper === true ? Math.max(size, totalLength) : end.taper;\n  if (taperStart || taperEnd) {\n    for (var _i2 = 0; _i2 < strokePoints.length; _i2++) {\n      strokePoint = strokePoints[_i2];\n      var _strokePoint2 = strokePoint,\n        runningLength = _strokePoint2.runningLength;\n      var ts = runningLength < taperStart ? taperStartEase(runningLength / taperStart) : 1;\n      var te = totalLength - runningLength < taperEnd ? taperEndEase((totalLength - runningLength) / taperEnd) : 1;\n      strokePoint.radius = Math.max(0.01, strokePoint.radius * Math.min(ts, te));\n    }\n  }\n  return strokePoints;\n}\nexport { setStrokePointRadii };","map":{"version":3,"names":["EASINGS","min","Math","RATE_OF_PRESSURE_CHANGE","setStrokePointRadii","strokePoints","options","_options$size","size","_options$thinning","thinning","_options$simulatePres","simulatePressure","_options$easing","easing","t","_options$start","start","_options$end","end","_start$easing","taperStartEase","easeOutQuad","_end$easing","taperEndEase","easeOutCubic","totalLength","length","runningLength","firstRadius","prevPressure","pressure","strokePoint","max","reduce","max2","curr","forEach","sp","radius","p","i","n","distance","rp","_strokePoint","taperStart","taper","taperEnd","_strokePoint2","ts","te"],"sources":["/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@tldraw/primitives/src/lib/freehand/setStrokePointRadii.ts"],"sourcesContent":["import { EASINGS } from '../easings'\nimport { StrokeOptions, StrokePoint } from './types'\n\nconst { min } = Math\n\n// This is the rate of change for simulated pressure. It could be an option.\nconst RATE_OF_PRESSURE_CHANGE = 0.275\n\n/** @public */\nexport function setStrokePointRadii(strokePoints: StrokePoint[], options: StrokeOptions) {\n\tconst {\n\t\tsize = 16,\n\t\tthinning = 0.5,\n\t\tsimulatePressure = true,\n\t\teasing = (t) => t,\n\t\tstart = {},\n\t\tend = {},\n\t} = options\n\n\tconst { easing: taperStartEase = EASINGS.easeOutQuad } = start\n\tconst { easing: taperEndEase = EASINGS.easeOutCubic } = end\n\n\tconst totalLength = strokePoints[strokePoints.length - 1].runningLength\n\n\tlet firstRadius: number | undefined\n\tlet prevPressure = strokePoints[0].pressure\n\tlet strokePoint: StrokePoint\n\n\tif (!simulatePressure && totalLength < size) {\n\t\tconst max = strokePoints.reduce((max, curr) => Math.max(max, curr.pressure), 0.5)\n\t\tstrokePoints.forEach((sp) => {\n\t\t\tsp.pressure = max\n\t\t\tsp.radius = size * easing(0.5 - thinning * (0.5 - sp.pressure))\n\t\t})\n\t\treturn strokePoints\n\t} else {\n\t\t// Calculate initial pressure based on the average of the first\n\t\t// n number of points. This prevents \"dots\" at the start of the\n\t\t// line. Drawn lines almost always start slow!\n\t\tlet p: number\n\t\tfor (let i = 0, n = strokePoints.length; i < n; i++) {\n\t\t\tstrokePoint = strokePoints[i]\n\t\t\tif (strokePoint.runningLength > size * 5) break\n\t\t\tconst sp = min(1, strokePoint.distance / size)\n\t\t\tif (simulatePressure) {\n\t\t\t\tconst rp = min(1, 1 - sp)\n\t\t\t\tp = min(1, prevPressure + (rp - prevPressure) * (sp * RATE_OF_PRESSURE_CHANGE))\n\t\t\t} else {\n\t\t\t\tp = min(1, prevPressure + (strokePoint.pressure - prevPressure) * 0.5)\n\t\t\t}\n\t\t\tprevPressure = prevPressure + (p - prevPressure) * 0.5\n\t\t}\n\n\t\t// Now calculate pressure and radius for each point\n\t\tfor (let i = 0; i < strokePoints.length; i++) {\n\t\t\tstrokePoint = strokePoints[i]\n\t\t\tif (thinning) {\n\t\t\t\tlet { pressure } = strokePoint\n\t\t\t\tconst sp = min(1, strokePoint.distance / size)\n\t\t\t\tif (simulatePressure) {\n\t\t\t\t\t// If we're simulating pressure, then do so based on the distance\n\t\t\t\t\t// between the current point and the previous point, and the size\n\t\t\t\t\t// of the stroke.\n\t\t\t\t\tconst rp = min(1, 1 - sp)\n\t\t\t\t\tpressure = min(1, prevPressure + (rp - prevPressure) * (sp * RATE_OF_PRESSURE_CHANGE))\n\t\t\t\t} else {\n\t\t\t\t\t// Otherwise, use the input pressure slightly smoothed based on the\n\t\t\t\t\t// distance between the current point and the previous point.\n\t\t\t\t\tpressure = min(\n\t\t\t\t\t\t1,\n\t\t\t\t\t\tprevPressure + (pressure - prevPressure) * (sp * RATE_OF_PRESSURE_CHANGE)\n\t\t\t\t\t)\n\t\t\t\t}\n\n\t\t\t\tstrokePoint.radius = size * easing(0.5 - thinning * (0.5 - pressure))\n\n\t\t\t\tprevPressure = pressure\n\t\t\t} else {\n\t\t\t\tstrokePoint.radius = size / 2\n\t\t\t}\n\n\t\t\tif (firstRadius === undefined) {\n\t\t\t\tfirstRadius = strokePoint.radius\n\t\t\t}\n\t\t}\n\t}\n\n\tconst taperStart =\n\t\tstart.taper === false\n\t\t\t? 0\n\t\t\t: start.taper === true\n\t\t\t? Math.max(size, totalLength)\n\t\t\t: (start.taper as number)\n\n\tconst taperEnd =\n\t\tend.taper === false\n\t\t\t? 0\n\t\t\t: end.taper === true\n\t\t\t? Math.max(size, totalLength)\n\t\t\t: (end.taper as number)\n\n\tif (taperStart || taperEnd) {\n\t\tfor (let i = 0; i < strokePoints.length; i++) {\n\t\t\tstrokePoint = strokePoints[i]\n\t\t\t/*\n\t\t\t\tApply tapering\n\n\t\t\t\tIf the current length is within the taper distance at either the\n\t\t\t\tstart or the end, calculate the taper strengths. Apply the smaller \n\t\t\t\tof the two taper strengths to the radius.\n\t\t\t*/\n\n\t\t\tconst { runningLength } = strokePoint\n\n\t\t\tconst ts = runningLength < taperStart ? taperStartEase(runningLength / taperStart) : 1\n\n\t\t\tconst te =\n\t\t\t\ttotalLength - runningLength < taperEnd\n\t\t\t\t\t? taperEndEase((totalLength - runningLength) / taperEnd)\n\t\t\t\t\t: 1\n\n\t\t\tstrokePoint.radius = Math.max(0.01, strokePoint.radius * Math.min(ts, te))\n\t\t}\n\t}\n\n\treturn strokePoints\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}