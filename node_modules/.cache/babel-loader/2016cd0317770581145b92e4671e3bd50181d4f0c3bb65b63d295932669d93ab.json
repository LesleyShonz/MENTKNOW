{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _objectSpread from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _toConsumableArray from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _classCallCheck from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _inherits from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _defineProperty from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport { Matrix2d, snapAngle, toFixed, Vec2d } from \"@tldraw/primitives\";\nimport { createShapeId } from \"@tldraw/tlschema\";\nimport { last, structuredClone } from \"@tldraw/utils\";\nimport { DRAG_DISTANCE } from \"../../../../constants.mjs\";\nimport { uniqueId } from \"../../../../utils/data.mjs\";\nimport { StateNode } from \"../../../tools/StateNode.mjs\";\nimport { HighlightShapeUtil } from \"../../highlight/HighlightShapeUtil.mjs\";\nimport { STROKE_SIZES } from \"../../shared/default-shape-constants.mjs\";\nimport { DrawShapeUtil } from \"../DrawShapeUtil.mjs\";\nvar Drawing = /*#__PURE__*/function (_StateNode) {\n  _inherits(Drawing, _StateNode);\n  var _super = _createSuper(Drawing);\n  function Drawing() {\n    var _this;\n    _classCallCheck(this, Drawing);\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    _this = _super.call.apply(_super, [this].concat(args));\n    _defineProperty(_assertThisInitialized(_this), \"info\", {});\n    _defineProperty(_assertThisInitialized(_this), \"initialShape\", void 0);\n    _defineProperty(_assertThisInitialized(_this), \"shapeType\", _this.parent.id === \"highlight\" ? HighlightShapeUtil : DrawShapeUtil);\n    _defineProperty(_assertThisInitialized(_this), \"util\", _this.editor.getShapeUtil(_this.shapeType));\n    _defineProperty(_assertThisInitialized(_this), \"isPen\", false);\n    _defineProperty(_assertThisInitialized(_this), \"segmentMode\", \"free\");\n    _defineProperty(_assertThisInitialized(_this), \"didJustShiftClickToExtendPreviousShapeLine\", false);\n    _defineProperty(_assertThisInitialized(_this), \"pagePointWhereCurrentSegmentChanged\", {});\n    _defineProperty(_assertThisInitialized(_this), \"pagePointWhereNextSegmentChanged\", null);\n    _defineProperty(_assertThisInitialized(_this), \"lastRecordedPoint\", {});\n    _defineProperty(_assertThisInitialized(_this), \"mergeNextPoint\", false);\n    _defineProperty(_assertThisInitialized(_this), \"currentLineLength\", 0);\n    _defineProperty(_assertThisInitialized(_this), \"canDraw\", false);\n    _defineProperty(_assertThisInitialized(_this), \"onEnter\", function (info) {\n      _this.info = info;\n      _this.canDraw = !_this.editor.isMenuOpen;\n      _this.lastRecordedPoint = _this.editor.inputs.currentPagePoint.clone();\n      if (_this.canDraw) {\n        _this.startShape();\n      }\n    });\n    _defineProperty(_assertThisInitialized(_this), \"onPointerMove\", function () {\n      var _assertThisInitialize = _assertThisInitialized(_this),\n        inputs = _assertThisInitialize.editor.inputs;\n      if (_this.isPen !== inputs.isPen) {\n        _this.cancel();\n      }\n      if (!_this.canDraw && inputs.isDragging) {\n        _this.startShape();\n        _this.canDraw = true;\n      }\n      if (_this.canDraw) {\n        if (inputs.isPen) {\n          if (Vec2d.Dist(inputs.currentPagePoint, _this.lastRecordedPoint) >= 1 / _this.editor.zoomLevel) {\n            _this.lastRecordedPoint = inputs.currentPagePoint.clone();\n            _this.mergeNextPoint = false;\n          } else {\n            _this.mergeNextPoint = true;\n          }\n        } else {\n          _this.mergeNextPoint = false;\n        }\n        _this.updateShapes();\n      }\n    });\n    _defineProperty(_assertThisInitialized(_this), \"onKeyDown\", function (info) {\n      if (info.key === \"Shift\") {\n        switch (_this.segmentMode) {\n          case \"free\":\n            {\n              _this.segmentMode = \"starting_straight\";\n              _this.pagePointWhereNextSegmentChanged = _this.editor.inputs.currentPagePoint.clone();\n              break;\n            }\n          case \"starting_free\":\n            {\n              _this.segmentMode = \"starting_straight\";\n            }\n        }\n      }\n      _this.updateShapes();\n    });\n    _defineProperty(_assertThisInitialized(_this), \"onKeyUp\", function (info) {\n      if (info.key === \"Shift\") {\n        _this.editor.snaps.clear();\n        switch (_this.segmentMode) {\n          case \"straight\":\n            {\n              _this.segmentMode = \"starting_free\";\n              _this.pagePointWhereNextSegmentChanged = _this.editor.inputs.currentPagePoint.clone();\n              break;\n            }\n          case \"starting_straight\":\n            {\n              _this.pagePointWhereNextSegmentChanged = null;\n              _this.segmentMode = \"free\";\n              break;\n            }\n        }\n      }\n      _this.updateShapes();\n    });\n    _defineProperty(_assertThisInitialized(_this), \"onExit\", function () {\n      _this.editor.snaps.clear();\n      _this.pagePointWhereCurrentSegmentChanged = _this.editor.inputs.currentPagePoint.clone();\n    });\n    _defineProperty(_assertThisInitialized(_this), \"onPointerUp\", function () {\n      _this.complete();\n    });\n    _defineProperty(_assertThisInitialized(_this), \"onCancel\", function () {\n      _this.cancel();\n    });\n    _defineProperty(_assertThisInitialized(_this), \"onComplete\", function () {\n      _this.complete();\n    });\n    _defineProperty(_assertThisInitialized(_this), \"onInterrupt\", function () {\n      if (_this.editor.inputs.isDragging) {\n        return;\n      }\n      _this.editor.bail();\n      _this.cancel();\n    });\n    return _this;\n  }\n  _createClass(Drawing, [{\n    key: \"canClose\",\n    value: function canClose() {\n      return this.shapeType.type !== \"highlight\";\n    }\n  }, {\n    key: \"getIsClosed\",\n    value: function getIsClosed(segments, size) {\n      if (!this.canClose()) return false;\n      var strokeWidth = STROKE_SIZES[size];\n      var firstPoint = segments[0].points[0];\n      var lastSegment = segments[segments.length - 1];\n      var lastPoint = lastSegment.points[lastSegment.points.length - 1];\n      return firstPoint !== lastPoint && this.currentLineLength > strokeWidth * 4 && Vec2d.Dist(firstPoint, lastPoint) < strokeWidth * 2;\n    }\n  }, {\n    key: \"startShape\",\n    value: function startShape() {\n      var _this$editor$inputs = this.editor.inputs,\n        originPagePoint = _this$editor$inputs.originPagePoint,\n        isPen = _this$editor$inputs.isPen;\n      this.editor.mark(\"draw create start\");\n      this.isPen = isPen;\n      var pressure = this.isPen ? this.info.point.z * 1.25 : 0.5;\n      this.segmentMode = this.editor.inputs.shiftKey ? \"straight\" : \"free\";\n      this.didJustShiftClickToExtendPreviousShapeLine = false;\n      this.lastRecordedPoint = originPagePoint.clone();\n      if (this.initialShape) {\n        var shape = this.editor.getShapeById(this.initialShape.id);\n        if (shape && this.segmentMode === \"straight\") {\n          this.didJustShiftClickToExtendPreviousShapeLine = true;\n          var prevSegment = last(shape.props.segments);\n          if (!prevSegment) throw Error(\"Expected a previous segment!\");\n          var prevPoint = last(prevSegment.points);\n          if (!prevPoint) throw Error(\"Expected a previous point!\");\n          var _this$editor$getPoint = this.editor.getPointInShapeSpace(shape, originPagePoint).toFixed(),\n            x = _this$editor$getPoint.x,\n            y = _this$editor$getPoint.y;\n          var pressure2 = this.isPen ? this.info.point.z * 1.25 : 0.5;\n          var newSegment = {\n            type: this.segmentMode,\n            points: [{\n              x: prevPoint.x,\n              y: prevPoint.y,\n              z: +pressure2.toFixed(2)\n            }, {\n              x: x,\n              y: y,\n              z: +pressure2.toFixed(2)\n            }]\n          };\n          var prevPointPageSpace = Matrix2d.applyToPoint(this.editor.getPageTransformById(shape.id), prevPoint);\n          this.pagePointWhereCurrentSegmentChanged = prevPointPageSpace;\n          this.pagePointWhereNextSegmentChanged = null;\n          var segments = [].concat(_toConsumableArray(shape.props.segments), [newSegment]);\n          this.currentLineLength = this.getLineLength(segments);\n          var shapePartial = {\n            id: shape.id,\n            type: this.shapeType.type,\n            props: {\n              segments: segments\n            }\n          };\n          if (this.canClose()) {\n            ;\n            shapePartial.props.isClosed = this.getIsClosed(segments, shape.props.size);\n          }\n          this.editor.updateShapes([shapePartial]);\n          return;\n        }\n      }\n      this.pagePointWhereCurrentSegmentChanged = originPagePoint.clone();\n      var id = createShapeId();\n      this.editor.createShapes([{\n        id: id,\n        type: this.shapeType.type,\n        x: originPagePoint.x,\n        y: originPagePoint.y,\n        props: {\n          isPen: this.isPen,\n          segments: [{\n            type: this.segmentMode,\n            points: [{\n              x: 0,\n              y: 0,\n              z: +pressure.toFixed(2)\n            }]\n          }]\n        }\n      }]);\n      this.currentLineLength = 0;\n      this.initialShape = this.editor.getShapeById(id);\n    }\n  }, {\n    key: \"updateShapes\",\n    value: function updateShapes() {\n      var inputs = this.editor.inputs;\n      var initialShape = this.initialShape;\n      if (!initialShape) return;\n      var id = initialShape.id,\n        size = initialShape.props.size;\n      var shape = this.editor.getShapeById(id);\n      if (!shape) return;\n      var segments = shape.props.segments;\n      var _this$editor$getPoint2 = this.editor.getPointInShapeSpace(shape, inputs.currentPagePoint).toFixed(),\n        x = _this$editor$getPoint2.x,\n        y = _this$editor$getPoint2.y,\n        z = _this$editor$getPoint2.z;\n      var newPoint = {\n        x: x,\n        y: y,\n        z: this.isPen ? +(z * 1.25).toFixed(2) : 0.5\n      };\n      switch (this.segmentMode) {\n        case \"starting_straight\":\n          {\n            var pagePointWhereNextSegmentChanged = this.pagePointWhereNextSegmentChanged;\n            if (pagePointWhereNextSegmentChanged === null) {\n              throw Error(\"We should have a point where the segment changed\");\n            }\n            var hasMovedFarEnough = Vec2d.Dist(pagePointWhereNextSegmentChanged, inputs.currentPagePoint) > DRAG_DISTANCE;\n            if (hasMovedFarEnough) {\n              this.pagePointWhereCurrentSegmentChanged = this.pagePointWhereNextSegmentChanged.clone();\n              this.pagePointWhereNextSegmentChanged = null;\n              this.segmentMode = \"straight\";\n              var prevSegment = last(segments);\n              if (!prevSegment) throw Error(\"Expected a previous segment!\");\n              var prevLastPoint = last(prevSegment.points);\n              if (!prevLastPoint) throw Error(\"Expected a previous last point!\");\n              var newSegment;\n              var newLastPoint = this.editor.getPointInShapeSpace(shape, this.pagePointWhereCurrentSegmentChanged).toFixed().toJson();\n              if (prevSegment.type === \"straight\") {\n                this.currentLineLength += Vec2d.Dist(prevLastPoint, newLastPoint);\n                newSegment = {\n                  type: \"straight\",\n                  points: [_objectSpread({}, prevLastPoint), newLastPoint]\n                };\n                var transform = this.editor.getPageTransform(shape);\n                this.pagePointWhereCurrentSegmentChanged = Matrix2d.applyToPoint(transform, prevLastPoint);\n              } else {\n                newSegment = {\n                  type: \"straight\",\n                  points: [newLastPoint, newPoint]\n                };\n              }\n              var shapePartial = {\n                id: id,\n                type: this.shapeType.type,\n                props: {\n                  segments: [].concat(_toConsumableArray(segments), [newSegment])\n                }\n              };\n              if (this.canClose()) {\n                ;\n                shapePartial.props.isClosed = this.getIsClosed(segments, size);\n              }\n              this.editor.updateShapes([shapePartial], true);\n            }\n            break;\n          }\n        case \"starting_free\":\n          {\n            var _pagePointWhereNextSegmentChanged = this.pagePointWhereNextSegmentChanged;\n            if (_pagePointWhereNextSegmentChanged === null) {\n              throw Error(\"We should have a point where the segment changed\");\n            }\n            var _hasMovedFarEnough = Vec2d.Dist(_pagePointWhereNextSegmentChanged, inputs.currentPagePoint) > DRAG_DISTANCE;\n            if (_hasMovedFarEnough) {\n              this.pagePointWhereCurrentSegmentChanged = this.pagePointWhereNextSegmentChanged.clone();\n              this.pagePointWhereNextSegmentChanged = null;\n              this.segmentMode = \"free\";\n              var newSegments = segments.slice();\n              var prevStraightSegment = newSegments[newSegments.length - 1];\n              var prevPoint = last(prevStraightSegment.points);\n              if (!prevPoint) {\n                throw Error(\"No previous point!\");\n              }\n              var newFreeSegment = {\n                type: \"free\",\n                points: _toConsumableArray(Vec2d.PointsBetween(prevPoint, newPoint, 6).map(function (p) {\n                  return p.toFixed().toJson();\n                }))\n              };\n              var finalSegments = [].concat(_toConsumableArray(newSegments), [newFreeSegment]);\n              this.currentLineLength = this.getLineLength(finalSegments);\n              var _shapePartial = {\n                id: id,\n                type: this.shapeType.type,\n                props: {\n                  segments: finalSegments\n                }\n              };\n              if (this.canClose()) {\n                ;\n                _shapePartial.props.isClosed = this.getIsClosed(finalSegments, size);\n              }\n              this.editor.updateShapes([_shapePartial], true);\n            }\n            break;\n          }\n        case \"straight\":\n          {\n            var _newSegments = segments.slice();\n            var _newSegment = _newSegments[_newSegments.length - 1];\n            var pagePointWhereCurrentSegmentChanged = this.pagePointWhereCurrentSegmentChanged;\n            var _this$editor$inputs2 = this.editor.inputs,\n              currentPagePoint = _this$editor$inputs2.currentPagePoint,\n              ctrlKey = _this$editor$inputs2.ctrlKey;\n            if (!pagePointWhereCurrentSegmentChanged) throw Error(\"We should have a point where the segment changed\");\n            var pagePoint;\n            var shouldSnapToAngle = false;\n            if (this.didJustShiftClickToExtendPreviousShapeLine) {\n              if (this.editor.inputs.isDragging) {\n                shouldSnapToAngle = !ctrlKey;\n                this.didJustShiftClickToExtendPreviousShapeLine = false;\n              } else {}\n            } else {\n              shouldSnapToAngle = !ctrlKey;\n            }\n            var newPoint2 = this.editor.getPointInShapeSpace(shape, currentPagePoint).toFixed().toJson();\n            var didSnap = false;\n            var snapSegment = void 0;\n            var shouldSnap = this.editor.isSnapMode ? !ctrlKey : ctrlKey;\n            if (shouldSnap) {\n              if (_newSegments.length > 2) {\n                var nearestPoint = void 0;\n                var minDistance = 8 / this.editor.zoomLevel;\n                for (var i = 0, n = segments.length - 2; i < n; i++) {\n                  var segment = segments[i];\n                  if (!segment) break;\n                  if (segment.type === \"free\") continue;\n                  var first = segment.points[0];\n                  var lastPoint = last(segment.points);\n                  if (!(first && lastPoint)) continue;\n                  var nearestPointOnSegment = Vec2d.NearestPointOnLineSegment(first, lastPoint, newPoint2);\n                  var distance = Vec2d.Dist(nearestPointOnSegment, newPoint2);\n                  if (distance < minDistance) {\n                    nearestPoint = nearestPointOnSegment.toFixed().toJson();\n                    minDistance = distance;\n                    snapSegment = segment;\n                    break;\n                  }\n                }\n                if (nearestPoint) {\n                  didSnap = true;\n                  newPoint2 = nearestPoint;\n                }\n              }\n            }\n            if (didSnap && snapSegment) {\n              var _transform = this.editor.getPageTransform(shape);\n              var _first = snapSegment.points[0];\n              var _lastPoint = last(snapSegment.points);\n              if (!_lastPoint) throw Error(\"Expected a last point!\");\n              var A = Matrix2d.applyToPoint(_transform, _first);\n              var B = Matrix2d.applyToPoint(_transform, _lastPoint);\n              var snappedPoint = Matrix2d.applyToPoint(_transform, newPoint2);\n              this.editor.snaps.setLines([{\n                id: uniqueId(),\n                type: \"points\",\n                points: [A, snappedPoint, B]\n              }]);\n            } else {\n              this.editor.snaps.clear();\n              if (shouldSnapToAngle) {\n                var currentAngle = Vec2d.Angle(pagePointWhereCurrentSegmentChanged, currentPagePoint);\n                var snappedAngle = snapAngle(currentAngle, 24);\n                var angleDiff = snappedAngle - currentAngle;\n                pagePoint = Vec2d.RotWith(currentPagePoint, pagePointWhereCurrentSegmentChanged, angleDiff);\n              } else {\n                pagePoint = currentPagePoint;\n              }\n              newPoint2 = this.editor.getPointInShapeSpace(shape, pagePoint).toFixed().toJson();\n            }\n            this.currentLineLength += Vec2d.Dist(_newSegment.points[0], newPoint2);\n            _newSegments[_newSegments.length - 1] = _objectSpread(_objectSpread({}, _newSegment), {}, {\n              type: \"straight\",\n              points: [_newSegment.points[0], newPoint2]\n            });\n            var _shapePartial2 = {\n              id: id,\n              type: this.shapeType.type,\n              props: {\n                segments: _newSegments\n              }\n            };\n            if (this.canClose()) {\n              ;\n              _shapePartial2.props.isClosed = this.getIsClosed(segments, size);\n            }\n            this.editor.updateShapes([_shapePartial2], true);\n            break;\n          }\n        case \"free\":\n          {\n            var _newSegments2 = segments.slice();\n            var _newSegment2 = _newSegments2[_newSegments2.length - 1];\n            var newPoints = _toConsumableArray(_newSegment2.points);\n            if (newPoints.length && this.mergeNextPoint) {\n              var z2 = newPoints[newPoints.length - 1].z;\n              newPoints[newPoints.length - 1] = {\n                x: newPoint.x,\n                y: newPoint.y,\n                z: z2 ? Math.max(z2, newPoint.z) : newPoint.z\n              };\n            } else {\n              this.currentLineLength += Vec2d.Dist(newPoints[newPoints.length - 1], newPoint);\n              newPoints.push(newPoint);\n            }\n            _newSegments2[_newSegments2.length - 1] = _objectSpread(_objectSpread({}, _newSegment2), {}, {\n              points: newPoints\n            });\n            this.currentLineLength = this.getLineLength(_newSegments2);\n            var _shapePartial3 = {\n              id: id,\n              type: this.shapeType.type,\n              props: {\n                segments: _newSegments2\n              }\n            };\n            if (this.canClose()) {\n              ;\n              _shapePartial3.props.isClosed = this.getIsClosed(_newSegments2, size);\n            }\n            this.editor.updateShapes([_shapePartial3], true);\n            if (newPoints.length > 500) {\n              this.editor.updateShapes([{\n                id: id,\n                type: this.shapeType.type,\n                props: {\n                  isComplete: true\n                }\n              }]);\n              var _currentPagePoint = this.editor.inputs.currentPagePoint;\n              var newShapeId = createShapeId();\n              this.editor.createShapes([{\n                id: newShapeId,\n                type: this.shapeType.type,\n                x: toFixed(_currentPagePoint.x),\n                y: toFixed(_currentPagePoint.y),\n                props: {\n                  isPen: this.isPen,\n                  segments: [{\n                    type: \"free\",\n                    points: [{\n                      x: 0,\n                      y: 0,\n                      z: this.isPen ? +(z * 1.25).toFixed() : 0.5\n                    }]\n                  }]\n                }\n              }]);\n              this.initialShape = structuredClone(this.editor.getShapeById(newShapeId));\n              this.mergeNextPoint = false;\n              this.lastRecordedPoint = this.editor.inputs.currentPagePoint.clone();\n              this.currentLineLength = 0;\n            }\n            break;\n          }\n      }\n    }\n  }, {\n    key: \"getLineLength\",\n    value: function getLineLength(segments) {\n      var length = 0;\n      var _iterator = _createForOfIteratorHelper(segments),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var segment = _step.value;\n          for (var i = 0; i < segment.points.length - 1; i++) {\n            var A = segment.points[i];\n            var B = segment.points[i + 1];\n            length += Vec2d.Sub(B, A).len2();\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return Math.sqrt(length);\n    }\n  }, {\n    key: \"complete\",\n    value: function complete() {\n      if (!this.canDraw) {\n        this.cancel();\n        return;\n      }\n      var initialShape = this.initialShape;\n      if (!initialShape) return;\n      this.editor.updateShapes([{\n        id: initialShape.id,\n        type: initialShape.type,\n        props: {\n          isComplete: true\n        }\n      }]);\n      this.parent.transition(\"idle\", {});\n    }\n  }, {\n    key: \"cancel\",\n    value: function cancel() {\n      this.parent.transition(\"idle\", this.info);\n    }\n  }]);\n  return Drawing;\n}(StateNode);\n_defineProperty(Drawing, \"id\", \"drawing\");\nexport { Drawing };","map":{"version":3,"names":["Matrix2d","snapAngle","toFixed","Vec2d","createShapeId","last","structuredClone","DRAG_DISTANCE","uniqueId","StateNode","HighlightShapeUtil","STROKE_SIZES","DrawShapeUtil","Drawing","_StateNode","_inherits","_super","_createSuper","_this","_classCallCheck","_len","arguments","length","args","Array","_key","call","apply","concat","_defineProperty","_assertThisInitialized","parent","id","editor","getShapeUtil","shapeType","info","canDraw","isMenuOpen","lastRecordedPoint","inputs","currentPagePoint","clone","startShape","_assertThisInitialize","isPen","cancel","isDragging","Dist","zoomLevel","mergeNextPoint","updateShapes","key","segmentMode","pagePointWhereNextSegmentChanged","snaps","clear","pagePointWhereCurrentSegmentChanged","complete","bail","_createClass","value","canClose","type","getIsClosed","segments","size","strokeWidth","firstPoint","points","lastSegment","lastPoint","currentLineLength","_this$editor$inputs","originPagePoint","mark","pressure","point","z","shiftKey","didJustShiftClickToExtendPreviousShapeLine","initialShape","shape","getShapeById","prevSegment","props","Error","prevPoint","_this$editor$getPoint","getPointInShapeSpace","x","y","pressure2","newSegment","prevPointPageSpace","applyToPoint","getPageTransformById","_toConsumableArray","getLineLength","shapePartial","isClosed","createShapes","_this$editor$getPoint2","newPoint","hasMovedFarEnough","prevLastPoint","newLastPoint","toJson","_objectSpread","transform","getPageTransform","newSegments","slice","prevStraightSegment","newFreeSegment","PointsBetween","map","p","finalSegments","_this$editor$inputs2","ctrlKey","pagePoint","shouldSnapToAngle","newPoint2","didSnap","snapSegment","shouldSnap","isSnapMode","nearestPoint","minDistance","i","n","segment","first","nearestPointOnSegment","NearestPointOnLineSegment","distance","A","B","snappedPoint","setLines","currentAngle","Angle","snappedAngle","angleDiff","RotWith","newPoints","z2","Math","max","push","isComplete","newShapeId","_iterator","_createForOfIteratorHelper","_step","s","done","Sub","len2","err","e","f","sqrt","transition"],"sources":["/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@tldraw/editor/src/lib/editor/shapes/draw/toolStates/Drawing.ts"],"sourcesContent":["import { Matrix2d, snapAngle, toFixed, Vec2d } from '@tldraw/primitives'\nimport {\n\tcreateShapeId,\n\tTLDefaultSizeStyle,\n\tTLDrawShape,\n\tTLDrawShapeSegment,\n\tTLHighlightShape,\n\tTLShapePartial,\n\tVec2dModel,\n} from '@tldraw/tlschema'\nimport { last, structuredClone } from '@tldraw/utils'\nimport { DRAG_DISTANCE } from '../../../../constants'\nimport { uniqueId } from '../../../../utils/data'\nimport { StateNode } from '../../../tools/StateNode'\nimport { TLEventHandlers, TLPointerEventInfo } from '../../../types/event-types'\nimport { HighlightShapeUtil } from '../../highlight/HighlightShapeUtil'\nimport { STROKE_SIZES } from '../../shared/default-shape-constants'\nimport { DrawShapeUtil } from '../DrawShapeUtil'\n\ntype DrawableShape = TLDrawShape | TLHighlightShape\n\nexport class Drawing extends StateNode {\n\tstatic override id = 'drawing'\n\n\tinfo = {} as TLPointerEventInfo\n\n\tinitialShape?: DrawableShape\n\n\tshapeType = this.parent.id === 'highlight' ? HighlightShapeUtil : DrawShapeUtil\n\n\tutil = this.editor.getShapeUtil(this.shapeType)\n\n\tisPen = false\n\n\tsegmentMode = 'free' as 'free' | 'straight' | 'starting_straight' | 'starting_free'\n\n\tdidJustShiftClickToExtendPreviousShapeLine = false\n\n\tpagePointWhereCurrentSegmentChanged = {} as Vec2d\n\n\tpagePointWhereNextSegmentChanged = null as Vec2d | null\n\n\tlastRecordedPoint = {} as Vec2d\n\tmergeNextPoint = false\n\tcurrentLineLength = 0\n\n\tcanDraw = false\n\n\tonEnter = (info: TLPointerEventInfo) => {\n\t\tthis.info = info\n\t\tthis.canDraw = !this.editor.isMenuOpen\n\t\tthis.lastRecordedPoint = this.editor.inputs.currentPagePoint.clone()\n\t\tif (this.canDraw) {\n\t\t\tthis.startShape()\n\t\t}\n\t}\n\n\tonPointerMove: TLEventHandlers['onPointerMove'] = () => {\n\t\tconst {\n\t\t\teditor: { inputs },\n\t\t} = this\n\n\t\tif (this.isPen !== inputs.isPen) {\n\t\t\t// The user made a palm gesture before starting a pen gesture;\n\t\t\t// ideally we'd start the new shape here but we could also just bail\n\t\t\t// as the next interaction will work correctly\n\t\t\tthis.cancel()\n\t\t}\n\n\t\t// If we came in from a menu but have no started dragging...\n\t\tif (!this.canDraw && inputs.isDragging) {\n\t\t\tthis.startShape()\n\t\t\tthis.canDraw = true // bad name\n\t\t}\n\n\t\tif (this.canDraw) {\n\t\t\t// Don't update the shape if we haven't moved far enough from the last time we recorded a point\n\t\t\tif (inputs.isPen) {\n\t\t\t\tif (\n\t\t\t\t\tVec2d.Dist(inputs.currentPagePoint, this.lastRecordedPoint) >=\n\t\t\t\t\t1 / this.editor.zoomLevel\n\t\t\t\t) {\n\t\t\t\t\tthis.lastRecordedPoint = inputs.currentPagePoint.clone()\n\t\t\t\t\tthis.mergeNextPoint = false\n\t\t\t\t} else {\n\t\t\t\t\tthis.mergeNextPoint = true\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.mergeNextPoint = false\n\t\t\t}\n\n\t\t\tthis.updateShapes()\n\t\t}\n\t}\n\n\tonKeyDown: TLEventHandlers['onKeyDown'] = (info) => {\n\t\tif (info.key === 'Shift') {\n\t\t\tswitch (this.segmentMode) {\n\t\t\t\tcase 'free': {\n\t\t\t\t\t// We've just entered straight mode, go to straight mode\n\t\t\t\t\tthis.segmentMode = 'starting_straight'\n\t\t\t\t\tthis.pagePointWhereNextSegmentChanged = this.editor.inputs.currentPagePoint.clone()\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tcase 'starting_free': {\n\t\t\t\t\tthis.segmentMode = 'starting_straight'\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis.updateShapes()\n\t}\n\n\tonKeyUp: TLEventHandlers['onKeyUp'] = (info) => {\n\t\tif (info.key === 'Shift') {\n\t\t\tthis.editor.snaps.clear()\n\n\t\t\tswitch (this.segmentMode) {\n\t\t\t\tcase 'straight': {\n\t\t\t\t\t// We've just exited straight mode, go back to free mode\n\t\t\t\t\tthis.segmentMode = 'starting_free'\n\t\t\t\t\tthis.pagePointWhereNextSegmentChanged = this.editor.inputs.currentPagePoint.clone()\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tcase 'starting_straight': {\n\t\t\t\t\tthis.pagePointWhereNextSegmentChanged = null\n\t\t\t\t\tthis.segmentMode = 'free'\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.updateShapes()\n\t}\n\n\tonExit? = () => {\n\t\tthis.editor.snaps.clear()\n\t\tthis.pagePointWhereCurrentSegmentChanged = this.editor.inputs.currentPagePoint.clone()\n\t}\n\n\tcanClose() {\n\t\treturn this.shapeType.type !== 'highlight'\n\t}\n\n\tgetIsClosed(segments: TLDrawShapeSegment[], size: TLDefaultSizeStyle) {\n\t\tif (!this.canClose()) return false\n\n\t\tconst strokeWidth = STROKE_SIZES[size]\n\t\tconst firstPoint = segments[0].points[0]\n\t\tconst lastSegment = segments[segments.length - 1]\n\t\tconst lastPoint = lastSegment.points[lastSegment.points.length - 1]\n\n\t\treturn (\n\t\t\tfirstPoint !== lastPoint &&\n\t\t\tthis.currentLineLength > strokeWidth * 4 &&\n\t\t\tVec2d.Dist(firstPoint, lastPoint) < strokeWidth * 2\n\t\t)\n\t}\n\n\tprivate startShape() {\n\t\tconst {\n\t\t\tinputs: { originPagePoint, isPen },\n\t\t} = this.editor\n\n\t\tthis.editor.mark('draw create start')\n\n\t\tthis.isPen = isPen\n\n\t\tconst pressure = this.isPen ? this.info.point.z! * 1.25 : 0.5\n\n\t\tthis.segmentMode = this.editor.inputs.shiftKey ? 'straight' : 'free'\n\n\t\tthis.didJustShiftClickToExtendPreviousShapeLine = false\n\n\t\tthis.lastRecordedPoint = originPagePoint.clone()\n\n\t\tif (this.initialShape) {\n\t\t\tconst shape = this.editor.getShapeById<DrawableShape>(this.initialShape.id)\n\n\t\t\tif (shape && this.segmentMode === 'straight') {\n\t\t\t\t// Connect dots\n\n\t\t\t\tthis.didJustShiftClickToExtendPreviousShapeLine = true\n\n\t\t\t\tconst prevSegment = last(shape.props.segments)\n\t\t\t\tif (!prevSegment) throw Error('Expected a previous segment!')\n\t\t\t\tconst prevPoint = last(prevSegment.points)\n\t\t\t\tif (!prevPoint) throw Error('Expected a previous point!')\n\n\t\t\t\tconst { x, y } = this.editor.getPointInShapeSpace(shape, originPagePoint).toFixed()\n\n\t\t\t\tconst pressure = this.isPen ? this.info.point.z! * 1.25 : 0.5\n\n\t\t\t\tconst newSegment: TLDrawShapeSegment = {\n\t\t\t\t\ttype: this.segmentMode,\n\t\t\t\t\tpoints: [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tx: prevPoint.x,\n\t\t\t\t\t\t\ty: prevPoint.y,\n\t\t\t\t\t\t\tz: +pressure.toFixed(2),\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tx,\n\t\t\t\t\t\t\ty,\n\t\t\t\t\t\t\tz: +pressure.toFixed(2),\n\t\t\t\t\t\t},\n\t\t\t\t\t],\n\t\t\t\t}\n\n\t\t\t\t// Convert prevPoint to page space\n\t\t\t\tconst prevPointPageSpace = Matrix2d.applyToPoint(\n\t\t\t\t\tthis.editor.getPageTransformById(shape.id)!,\n\t\t\t\t\tprevPoint\n\t\t\t\t)\n\t\t\t\tthis.pagePointWhereCurrentSegmentChanged = prevPointPageSpace\n\t\t\t\tthis.pagePointWhereNextSegmentChanged = null\n\t\t\t\tconst segments = [...shape.props.segments, newSegment]\n\n\t\t\t\tthis.currentLineLength = this.getLineLength(segments)\n\n\t\t\t\tconst shapePartial: TLShapePartial<DrawableShape> = {\n\t\t\t\t\tid: shape.id,\n\t\t\t\t\ttype: this.shapeType.type,\n\t\t\t\t\tprops: {\n\t\t\t\t\t\tsegments,\n\t\t\t\t\t},\n\t\t\t\t}\n\n\t\t\t\tif (this.canClose()) {\n\t\t\t\t\t;(shapePartial as TLShapePartial<TLDrawShape>).props!.isClosed = this.getIsClosed(\n\t\t\t\t\t\tsegments,\n\t\t\t\t\t\tshape.props.size\n\t\t\t\t\t)\n\t\t\t\t}\n\n\t\t\t\tthis.editor.updateShapes<TLDrawShape | TLHighlightShape>([shapePartial])\n\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\t// Create a new shape\n\n\t\tthis.pagePointWhereCurrentSegmentChanged = originPagePoint.clone()\n\t\tconst id = createShapeId()\n\n\t\tthis.editor.createShapes<DrawableShape>([\n\t\t\t{\n\t\t\t\tid,\n\t\t\t\ttype: this.shapeType.type,\n\t\t\t\tx: originPagePoint.x,\n\t\t\t\ty: originPagePoint.y,\n\t\t\t\tprops: {\n\t\t\t\t\tisPen: this.isPen,\n\t\t\t\t\tsegments: [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttype: this.segmentMode,\n\t\t\t\t\t\t\tpoints: [\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tx: 0,\n\t\t\t\t\t\t\t\t\ty: 0,\n\t\t\t\t\t\t\t\t\tz: +pressure.toFixed(2),\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t],\n\t\t\t\t\t\t},\n\t\t\t\t\t],\n\t\t\t\t},\n\t\t\t},\n\t\t])\n\t\tthis.currentLineLength = 0\n\t\tthis.initialShape = this.editor.getShapeById<DrawableShape>(id)\n\t}\n\n\tprivate updateShapes() {\n\t\tconst { inputs } = this.editor\n\t\tconst { initialShape } = this\n\n\t\tif (!initialShape) return\n\n\t\tconst {\n\t\t\tid,\n\t\t\tprops: { size },\n\t\t} = initialShape\n\n\t\tconst shape = this.editor.getShapeById<DrawableShape>(id)!\n\n\t\tif (!shape) return\n\n\t\tconst { segments } = shape.props\n\n\t\tconst { x, y, z } = this.editor.getPointInShapeSpace(shape, inputs.currentPagePoint).toFixed()\n\n\t\tconst newPoint = { x, y, z: this.isPen ? +(z! * 1.25).toFixed(2) : 0.5 }\n\n\t\tswitch (this.segmentMode) {\n\t\t\tcase 'starting_straight': {\n\t\t\t\tconst { pagePointWhereNextSegmentChanged } = this\n\n\t\t\t\tif (pagePointWhereNextSegmentChanged === null) {\n\t\t\t\t\tthrow Error('We should have a point where the segment changed')\n\t\t\t\t}\n\n\t\t\t\tconst hasMovedFarEnough =\n\t\t\t\t\tVec2d.Dist(pagePointWhereNextSegmentChanged, inputs.currentPagePoint) > DRAG_DISTANCE\n\n\t\t\t\t// Find the distance from where the pointer was when shift was released and\n\t\t\t\t// where it is now; if it's far enough away, then update the page point where\n\t\t\t\t// the current segment changed (to match the pagepoint where next segment changed)\n\t\t\t\t// and set the pagepoint where next segment changed to null.\n\t\t\t\tif (hasMovedFarEnough) {\n\t\t\t\t\tthis.pagePointWhereCurrentSegmentChanged = this.pagePointWhereNextSegmentChanged!.clone()\n\t\t\t\t\tthis.pagePointWhereNextSegmentChanged = null\n\n\t\t\t\t\t// Set the new mode\n\t\t\t\t\tthis.segmentMode = 'straight'\n\n\t\t\t\t\tconst prevSegment = last(segments)\n\t\t\t\t\tif (!prevSegment) throw Error('Expected a previous segment!')\n\n\t\t\t\t\tconst prevLastPoint = last(prevSegment.points)\n\t\t\t\t\tif (!prevLastPoint) throw Error('Expected a previous last point!')\n\n\t\t\t\t\tlet newSegment: TLDrawShapeSegment\n\n\t\t\t\t\tconst newLastPoint = this.editor\n\t\t\t\t\t\t.getPointInShapeSpace(shape, this.pagePointWhereCurrentSegmentChanged)\n\t\t\t\t\t\t.toFixed()\n\t\t\t\t\t\t.toJson()\n\n\t\t\t\t\tif (prevSegment.type === 'straight') {\n\t\t\t\t\t\tthis.currentLineLength += Vec2d.Dist(prevLastPoint, newLastPoint)\n\n\t\t\t\t\t\tnewSegment = {\n\t\t\t\t\t\t\ttype: 'straight',\n\t\t\t\t\t\t\tpoints: [{ ...prevLastPoint }, newLastPoint],\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst transform = this.editor.getPageTransform(shape)!\n\n\t\t\t\t\t\tthis.pagePointWhereCurrentSegmentChanged = Matrix2d.applyToPoint(\n\t\t\t\t\t\t\ttransform,\n\t\t\t\t\t\t\tprevLastPoint\n\t\t\t\t\t\t)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnewSegment = {\n\t\t\t\t\t\t\ttype: 'straight',\n\t\t\t\t\t\t\tpoints: [newLastPoint, newPoint],\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tconst shapePartial: TLShapePartial<DrawableShape> = {\n\t\t\t\t\t\tid,\n\t\t\t\t\t\ttype: this.shapeType.type,\n\t\t\t\t\t\tprops: {\n\t\t\t\t\t\t\tsegments: [...segments, newSegment],\n\t\t\t\t\t\t},\n\t\t\t\t\t}\n\n\t\t\t\t\tif (this.canClose()) {\n\t\t\t\t\t\t;(shapePartial as TLShapePartial<TLDrawShape>).props!.isClosed = this.getIsClosed(\n\t\t\t\t\t\t\tsegments,\n\t\t\t\t\t\t\tsize\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.editor.updateShapes<TLDrawShape | TLHighlightShape>([shapePartial], true)\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase 'starting_free': {\n\t\t\t\tconst { pagePointWhereNextSegmentChanged } = this\n\n\t\t\t\tif (pagePointWhereNextSegmentChanged === null) {\n\t\t\t\t\tthrow Error('We should have a point where the segment changed')\n\t\t\t\t}\n\n\t\t\t\tconst hasMovedFarEnough =\n\t\t\t\t\tVec2d.Dist(pagePointWhereNextSegmentChanged, inputs.currentPagePoint) > DRAG_DISTANCE\n\n\t\t\t\t// Find the distance from where the pointer was when shift was released and\n\t\t\t\t// where it is now; if it's far enough away, then update the page point where\n\t\t\t\t// the current segment changed (to match the pagepoint where next segment changed)\n\t\t\t\t// and set the pagepoint where next segment changed to null.\n\t\t\t\tif (hasMovedFarEnough) {\n\t\t\t\t\tthis.pagePointWhereCurrentSegmentChanged = this.pagePointWhereNextSegmentChanged!.clone()\n\t\t\t\t\tthis.pagePointWhereNextSegmentChanged = null\n\n\t\t\t\t\t// Set the new mode\n\t\t\t\t\tthis.segmentMode = 'free'\n\n\t\t\t\t\tconst newSegments = segments.slice()\n\t\t\t\t\tconst prevStraightSegment = newSegments[newSegments.length - 1]\n\t\t\t\t\tconst prevPoint = last(prevStraightSegment.points)\n\n\t\t\t\t\tif (!prevPoint) {\n\t\t\t\t\t\tthrow Error('No previous point!')\n\t\t\t\t\t}\n\n\t\t\t\t\t// Create the new free segment and interpolate the points between where the last line\n\t\t\t\t\t// ended and where the pointer is now\n\t\t\t\t\tconst newFreeSegment: TLDrawShapeSegment = {\n\t\t\t\t\t\ttype: 'free',\n\t\t\t\t\t\tpoints: [\n\t\t\t\t\t\t\t...Vec2d.PointsBetween(prevPoint, newPoint, 6).map((p) => p.toFixed().toJson()),\n\t\t\t\t\t\t],\n\t\t\t\t\t}\n\n\t\t\t\t\tconst finalSegments = [...newSegments, newFreeSegment]\n\t\t\t\t\tthis.currentLineLength = this.getLineLength(finalSegments)\n\n\t\t\t\t\tconst shapePartial: TLShapePartial<DrawableShape> = {\n\t\t\t\t\t\tid,\n\t\t\t\t\t\ttype: this.shapeType.type,\n\t\t\t\t\t\tprops: {\n\t\t\t\t\t\t\tsegments: finalSegments,\n\t\t\t\t\t\t},\n\t\t\t\t\t}\n\n\t\t\t\t\tif (this.canClose()) {\n\t\t\t\t\t\t;(shapePartial as TLShapePartial<TLDrawShape>).props!.isClosed = this.getIsClosed(\n\t\t\t\t\t\t\tfinalSegments,\n\t\t\t\t\t\t\tsize\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.editor.updateShapes([shapePartial], true)\n\t\t\t\t}\n\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase 'straight': {\n\t\t\t\tconst newSegments = segments.slice()\n\t\t\t\tconst newSegment = newSegments[newSegments.length - 1]\n\n\t\t\t\tconst { pagePointWhereCurrentSegmentChanged } = this\n\t\t\t\tconst { currentPagePoint, ctrlKey } = this.editor.inputs\n\n\t\t\t\tif (!pagePointWhereCurrentSegmentChanged)\n\t\t\t\t\tthrow Error('We should have a point where the segment changed')\n\n\t\t\t\tlet pagePoint: Vec2dModel\n\t\t\t\tlet shouldSnapToAngle = false\n\n\t\t\t\tif (this.didJustShiftClickToExtendPreviousShapeLine) {\n\t\t\t\t\tif (this.editor.inputs.isDragging) {\n\t\t\t\t\t\t// If we've just shift clicked to extend a line, only snap once we've started dragging\n\t\t\t\t\t\tshouldSnapToAngle = !ctrlKey\n\t\t\t\t\t\tthis.didJustShiftClickToExtendPreviousShapeLine = false\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// noop\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// If we're not shift clicking to extend a line, but we're holding shift, then we should snap\n\t\t\t\t\tshouldSnapToAngle = !ctrlKey // don't snap angle while snapping line\n\t\t\t\t}\n\n\t\t\t\tlet newPoint = this.editor.getPointInShapeSpace(shape, currentPagePoint).toFixed().toJson()\n\t\t\t\tlet didSnap = false\n\t\t\t\tlet snapSegment: TLDrawShapeSegment | undefined = undefined\n\n\t\t\t\tconst shouldSnap = this.editor.isSnapMode ? !ctrlKey : ctrlKey\n\n\t\t\t\tif (shouldSnap) {\n\t\t\t\t\tif (newSegments.length > 2) {\n\t\t\t\t\t\tlet nearestPoint: Vec2dModel | undefined = undefined\n\t\t\t\t\t\tlet minDistance = 8 / this.editor.zoomLevel\n\n\t\t\t\t\t\t// Don't try to snap to the last two segments\n\t\t\t\t\t\tfor (let i = 0, n = segments.length - 2; i < n; i++) {\n\t\t\t\t\t\t\tconst segment = segments[i]\n\t\t\t\t\t\t\tif (!segment) break\n\t\t\t\t\t\t\tif (segment.type === 'free') continue\n\n\t\t\t\t\t\t\tconst first = segment.points[0]\n\t\t\t\t\t\t\tconst lastPoint = last(segment.points)\n\t\t\t\t\t\t\tif (!(first && lastPoint)) continue\n\n\t\t\t\t\t\t\t// Snap to the nearest point on the segment, if it's closer than the previous snapped point\n\t\t\t\t\t\t\tconst nearestPointOnSegment = Vec2d.NearestPointOnLineSegment(\n\t\t\t\t\t\t\t\tfirst,\n\t\t\t\t\t\t\t\tlastPoint,\n\t\t\t\t\t\t\t\tnewPoint\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\tconst distance = Vec2d.Dist(nearestPointOnSegment, newPoint)\n\n\t\t\t\t\t\t\tif (distance < minDistance) {\n\t\t\t\t\t\t\t\tnearestPoint = nearestPointOnSegment.toFixed().toJson()\n\t\t\t\t\t\t\t\tminDistance = distance\n\t\t\t\t\t\t\t\tsnapSegment = segment\n\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (nearestPoint) {\n\t\t\t\t\t\t\tdidSnap = true\n\t\t\t\t\t\t\tnewPoint = nearestPoint\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (didSnap && snapSegment) {\n\t\t\t\t\tconst transform = this.editor.getPageTransform(shape)!\n\t\t\t\t\tconst first = snapSegment.points[0]\n\t\t\t\t\tconst lastPoint = last(snapSegment.points)\n\t\t\t\t\tif (!lastPoint) throw Error('Expected a last point!')\n\n\t\t\t\t\tconst A = Matrix2d.applyToPoint(transform, first)\n\n\t\t\t\t\tconst B = Matrix2d.applyToPoint(transform, lastPoint)\n\n\t\t\t\t\tconst snappedPoint = Matrix2d.applyToPoint(transform, newPoint)\n\n\t\t\t\t\tthis.editor.snaps.setLines([\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tid: uniqueId(),\n\t\t\t\t\t\t\ttype: 'points',\n\t\t\t\t\t\t\tpoints: [A, snappedPoint, B],\n\t\t\t\t\t\t},\n\t\t\t\t\t])\n\t\t\t\t} else {\n\t\t\t\t\tthis.editor.snaps.clear()\n\n\t\t\t\t\tif (shouldSnapToAngle) {\n\t\t\t\t\t\t// Snap line angle to nearest 15 degrees\n\t\t\t\t\t\tconst currentAngle = Vec2d.Angle(pagePointWhereCurrentSegmentChanged, currentPagePoint)\n\t\t\t\t\t\tconst snappedAngle = snapAngle(currentAngle, 24)\n\t\t\t\t\t\tconst angleDiff = snappedAngle - currentAngle\n\n\t\t\t\t\t\tpagePoint = Vec2d.RotWith(\n\t\t\t\t\t\t\tcurrentPagePoint,\n\t\t\t\t\t\t\tpagePointWhereCurrentSegmentChanged,\n\t\t\t\t\t\t\tangleDiff\n\t\t\t\t\t\t)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpagePoint = currentPagePoint\n\t\t\t\t\t}\n\n\t\t\t\t\tnewPoint = this.editor.getPointInShapeSpace(shape, pagePoint).toFixed().toJson()\n\t\t\t\t}\n\n\t\t\t\t// If the previous segment is a one point free shape and is the first segment of the line,\n\t\t\t\t// then the user just did a click-and-immediately-press-shift to create a new straight line\n\t\t\t\t// without continuing the previous line. In this case, we want to remove the previous segment.\n\n\t\t\t\tthis.currentLineLength += Vec2d.Dist(newSegment.points[0], newPoint)\n\n\t\t\t\tnewSegments[newSegments.length - 1] = {\n\t\t\t\t\t...newSegment,\n\t\t\t\t\ttype: 'straight',\n\t\t\t\t\tpoints: [newSegment.points[0], newPoint],\n\t\t\t\t}\n\n\t\t\t\tconst shapePartial: TLShapePartial<DrawableShape> = {\n\t\t\t\t\tid,\n\t\t\t\t\ttype: this.shapeType.type,\n\t\t\t\t\tprops: {\n\t\t\t\t\t\tsegments: newSegments,\n\t\t\t\t\t},\n\t\t\t\t}\n\n\t\t\t\tif (this.canClose()) {\n\t\t\t\t\t;(shapePartial as TLShapePartial<TLDrawShape>).props!.isClosed = this.getIsClosed(\n\t\t\t\t\t\tsegments,\n\t\t\t\t\t\tsize\n\t\t\t\t\t)\n\t\t\t\t}\n\n\t\t\t\tthis.editor.updateShapes([shapePartial], true)\n\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase 'free': {\n\t\t\t\tconst newSegments = segments.slice()\n\t\t\t\tconst newSegment = newSegments[newSegments.length - 1]\n\t\t\t\tconst newPoints = [...newSegment.points]\n\n\t\t\t\tif (newPoints.length && this.mergeNextPoint) {\n\t\t\t\t\tconst { z } = newPoints[newPoints.length - 1]\n\t\t\t\t\tnewPoints[newPoints.length - 1] = {\n\t\t\t\t\t\tx: newPoint.x,\n\t\t\t\t\t\ty: newPoint.y,\n\t\t\t\t\t\tz: z ? Math.max(z, newPoint.z) : newPoint.z,\n\t\t\t\t\t}\n\t\t\t\t\t// Note: we could recompute the line length here, but it's not really necessary\n\t\t\t\t\t// this.currentLineLength = this.getLineLength(newSegments)\n\t\t\t\t} else {\n\t\t\t\t\tthis.currentLineLength += Vec2d.Dist(newPoints[newPoints.length - 1], newPoint)\n\t\t\t\t\tnewPoints.push(newPoint)\n\t\t\t\t}\n\n\t\t\t\tnewSegments[newSegments.length - 1] = {\n\t\t\t\t\t...newSegment,\n\t\t\t\t\tpoints: newPoints,\n\t\t\t\t}\n\n\t\t\t\tthis.currentLineLength = this.getLineLength(newSegments)\n\n\t\t\t\tconst shapePartial: TLShapePartial<DrawableShape> = {\n\t\t\t\t\tid,\n\t\t\t\t\ttype: this.shapeType.type,\n\t\t\t\t\tprops: {\n\t\t\t\t\t\tsegments: newSegments,\n\t\t\t\t\t},\n\t\t\t\t}\n\n\t\t\t\tif (this.canClose()) {\n\t\t\t\t\t;(shapePartial as TLShapePartial<TLDrawShape>).props!.isClosed = this.getIsClosed(\n\t\t\t\t\t\tnewSegments,\n\t\t\t\t\t\tsize\n\t\t\t\t\t)\n\t\t\t\t}\n\n\t\t\t\tthis.editor.updateShapes([shapePartial], true)\n\n\t\t\t\t// Set a maximum length for the lines array; after 200 points, complete the line.\n\t\t\t\tif (newPoints.length > 500) {\n\t\t\t\t\tthis.editor.updateShapes([{ id, type: this.shapeType.type, props: { isComplete: true } }])\n\n\t\t\t\t\tconst { currentPagePoint } = this.editor.inputs\n\n\t\t\t\t\tconst newShapeId = createShapeId()\n\n\t\t\t\t\tthis.editor.createShapes<DrawableShape>([\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tid: newShapeId,\n\t\t\t\t\t\t\ttype: this.shapeType.type,\n\t\t\t\t\t\t\tx: toFixed(currentPagePoint.x),\n\t\t\t\t\t\t\ty: toFixed(currentPagePoint.y),\n\t\t\t\t\t\t\tprops: {\n\t\t\t\t\t\t\t\tisPen: this.isPen,\n\t\t\t\t\t\t\t\tsegments: [\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\ttype: 'free',\n\t\t\t\t\t\t\t\t\t\tpoints: [{ x: 0, y: 0, z: this.isPen ? +(z! * 1.25).toFixed() : 0.5 }],\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t])\n\n\t\t\t\t\tthis.initialShape = structuredClone(this.editor.getShapeById<DrawableShape>(newShapeId)!)\n\t\t\t\t\tthis.mergeNextPoint = false\n\t\t\t\t\tthis.lastRecordedPoint = this.editor.inputs.currentPagePoint.clone()\n\t\t\t\t\tthis.currentLineLength = 0\n\t\t\t\t}\n\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate getLineLength(segments: TLDrawShapeSegment[]) {\n\t\tlet length = 0\n\n\t\tfor (const segment of segments) {\n\t\t\tfor (let i = 0; i < segment.points.length - 1; i++) {\n\t\t\t\tconst A = segment.points[i]\n\t\t\t\tconst B = segment.points[i + 1]\n\t\t\t\tlength += Vec2d.Sub(B, A).len2()\n\t\t\t}\n\t\t}\n\n\t\treturn Math.sqrt(length)\n\t}\n\n\toverride onPointerUp: TLEventHandlers['onPointerUp'] = () => {\n\t\tthis.complete()\n\t}\n\n\toverride onCancel: TLEventHandlers['onCancel'] = () => {\n\t\tthis.cancel()\n\t}\n\n\toverride onComplete: TLEventHandlers['onComplete'] = () => {\n\t\tthis.complete()\n\t}\n\n\toverride onInterrupt: TLEventHandlers['onInterrupt'] = () => {\n\t\tif (this.editor.inputs.isDragging) {\n\t\t\treturn\n\t\t}\n\n\t\tthis.editor.bail()\n\t\tthis.cancel()\n\t}\n\n\tcomplete() {\n\t\t// If we weren't focused when the drawing shape started, and if\n\t\t// we haven't dragged far enough to start dragging, then don't do\n\t\t// anything here. Most likely we clicked back into the canvas from\n\t\t// a menu or other UI element.\n\t\tif (!this.canDraw) {\n\t\t\tthis.cancel()\n\t\t\treturn\n\t\t}\n\n\t\tconst { initialShape } = this\n\t\tif (!initialShape) return\n\t\tthis.editor.updateShapes([\n\t\t\t{ id: initialShape.id, type: initialShape.type, props: { isComplete: true } },\n\t\t])\n\n\t\tthis.parent.transition('idle', {})\n\t}\n\n\tcancel() {\n\t\tthis.parent.transition('idle', this.info)\n\t}\n}\n"],"mappings":";;;;;;;;;AAAA,SAASA,QAAA,EAAUC,SAAA,EAAWC,OAAA,EAASC,KAAA,QAAa;AACpD,SACCC,aAAA,QAOM;AACP,SAASC,IAAA,EAAMC,eAAA,QAAuB;AACtC,SAASC,aAAA,QAAqB;AAC9B,SAASC,QAAA,QAAgB;AACzB,SAASC,SAAA,QAAiB;AAE1B,SAASC,kBAAA,QAA0B;AACnC,SAASC,YAAA,QAAoB;AAC7B,SAASC,aAAA,QAAqB;AAAA,IAIjBC,OAAA,0BAAAC,UAAA;EAAAC,SAAA,CAAAF,OAAA,EAAAC,UAAA;EAAA,IAAAE,MAAA,GAAAC,YAAA,CAAAJ,OAAA;EAAA,SAAAA,QAAA;IAAA,IAAAK,KAAA;IAAAC,eAAA,OAAAN,OAAA;IAAA,SAAAO,IAAA,GAAAC,SAAA,CAAAC,MAAA,EAAAC,IAAA,OAAAC,KAAA,CAAAJ,IAAA,GAAAK,IAAA,MAAAA,IAAA,GAAAL,IAAA,EAAAK,IAAA;MAAAF,IAAA,CAAAE,IAAA,IAAAJ,SAAA,CAAAI,IAAA;IAAA;IAAAP,KAAA,GAAAF,MAAA,CAAAU,IAAA,CAAAC,KAAA,CAAAX,MAAA,SAAAY,MAAA,CAAAL,IAAA;IAAAM,eAAA,CAAAC,sBAAA,CAAAZ,KAAA,WAGL,CAAC;IAAAW,eAAA,CAAAC,sBAAA,CAAAZ,KAAA;IAAAW,eAAA,CAAAC,sBAAA,CAAAZ,KAAA,gBAIIA,KAAA,CAAKa,MAAA,CAAOC,EAAA,KAAO,cAActB,kBAAA,GAAqBE,aAAA;IAAAiB,eAAA,CAAAC,sBAAA,CAAAZ,KAAA,WAE3DA,KAAA,CAAKe,MAAA,CAAOC,YAAA,CAAahB,KAAA,CAAKiB,SAAS;IAAAN,eAAA,CAAAC,sBAAA,CAAAZ,KAAA,YAEtC;IAAAW,eAAA,CAAAC,sBAAA,CAAAZ,KAAA,kBAEM;IAAAW,eAAA,CAAAC,sBAAA,CAAAZ,KAAA,iDAE+B;IAAAW,eAAA,CAAAC,sBAAA,CAAAZ,KAAA,0CAEP,CAAC;IAAAW,eAAA,CAAAC,sBAAA,CAAAZ,KAAA,uCAEJ;IAAAW,eAAA,CAAAC,sBAAA,CAAAZ,KAAA,wBAEf,CAAC;IAAAW,eAAA,CAAAC,sBAAA,CAAAZ,KAAA,qBACJ;IAAAW,eAAA,CAAAC,sBAAA,CAAAZ,KAAA,wBACG;IAAAW,eAAA,CAAAC,sBAAA,CAAAZ,KAAA,cAEV;IAAAW,eAAA,CAAAC,sBAAA,CAAAZ,KAAA,cAEA,UAACkB,IAAA,EAA6B;MACvClB,KAAA,CAAKkB,IAAA,GAAOA,IAAA;MACZlB,KAAA,CAAKmB,OAAA,GAAU,CAACnB,KAAA,CAAKe,MAAA,CAAOK,UAAA;MAC5BpB,KAAA,CAAKqB,iBAAA,GAAoBrB,KAAA,CAAKe,MAAA,CAAOO,MAAA,CAAOC,gBAAA,CAAiBC,KAAA,CAAM;MACnE,IAAIxB,KAAA,CAAKmB,OAAA,EAAS;QACjBnB,KAAA,CAAKyB,UAAA,CAAW;MACjB;IACD;IAAAd,eAAA,CAAAC,sBAAA,CAAAZ,KAAA,oBAEkD,YAAM;MACvD,IAAA0B,qBAAA,GAAAd,sBAAA,CAAAZ,KAAA;QACWsB,MAAA,GAAAI,qBAAA,CAAVX,MAAA,CAAUO,MAAA;MAGX,IAAItB,KAAA,CAAK2B,KAAA,KAAUL,MAAA,CAAOK,KAAA,EAAO;QAIhC3B,KAAA,CAAK4B,MAAA,CAAO;MACb;MAGA,IAAI,CAAC5B,KAAA,CAAKmB,OAAA,IAAWG,MAAA,CAAOO,UAAA,EAAY;QACvC7B,KAAA,CAAKyB,UAAA,CAAW;QAChBzB,KAAA,CAAKmB,OAAA,GAAU;MAChB;MAEA,IAAInB,KAAA,CAAKmB,OAAA,EAAS;QAEjB,IAAIG,MAAA,CAAOK,KAAA,EAAO;UACjB,IACC1C,KAAA,CAAM6C,IAAA,CAAKR,MAAA,CAAOC,gBAAA,EAAkBvB,KAAA,CAAKqB,iBAAiB,KAC1D,IAAIrB,KAAA,CAAKe,MAAA,CAAOgB,SAAA,EACf;YACD/B,KAAA,CAAKqB,iBAAA,GAAoBC,MAAA,CAAOC,gBAAA,CAAiBC,KAAA,CAAM;YACvDxB,KAAA,CAAKgC,cAAA,GAAiB;UACvB,OAAO;YACNhC,KAAA,CAAKgC,cAAA,GAAiB;UACvB;QACD,OAAO;UACNhC,KAAA,CAAKgC,cAAA,GAAiB;QACvB;QAEAhC,KAAA,CAAKiC,YAAA,CAAa;MACnB;IACD;IAAAtB,eAAA,CAAAC,sBAAA,CAAAZ,KAAA,gBAE0C,UAACkB,IAAA,EAAS;MACnD,IAAIA,IAAA,CAAKgB,GAAA,KAAQ,SAAS;QACzB,QAAQlC,KAAA,CAAKmC,WAAA;UACZ,KAAK;YAAQ;cAEZnC,KAAA,CAAKmC,WAAA,GAAc;cACnBnC,KAAA,CAAKoC,gCAAA,GAAmCpC,KAAA,CAAKe,MAAA,CAAOO,MAAA,CAAOC,gBAAA,CAAiBC,KAAA,CAAM;cAClF;YACD;UACA,KAAK;YAAiB;cACrBxB,KAAA,CAAKmC,WAAA,GAAc;YACpB;QACD;MACD;MACAnC,KAAA,CAAKiC,YAAA,CAAa;IACnB;IAAAtB,eAAA,CAAAC,sBAAA,CAAAZ,KAAA,cAEsC,UAACkB,IAAA,EAAS;MAC/C,IAAIA,IAAA,CAAKgB,GAAA,KAAQ,SAAS;QACzBlC,KAAA,CAAKe,MAAA,CAAOsB,KAAA,CAAMC,KAAA,CAAM;QAExB,QAAQtC,KAAA,CAAKmC,WAAA;UACZ,KAAK;YAAY;cAEhBnC,KAAA,CAAKmC,WAAA,GAAc;cACnBnC,KAAA,CAAKoC,gCAAA,GAAmCpC,KAAA,CAAKe,MAAA,CAAOO,MAAA,CAAOC,gBAAA,CAAiBC,KAAA,CAAM;cAClF;YACD;UACA,KAAK;YAAqB;cACzBxB,KAAA,CAAKoC,gCAAA,GAAmC;cACxCpC,KAAA,CAAKmC,WAAA,GAAc;cACnB;YACD;QACD;MACD;MAEAnC,KAAA,CAAKiC,YAAA,CAAa;IACnB;IAAAtB,eAAA,CAAAC,sBAAA,CAAAZ,KAAA,aAEU,YAAM;MACfA,KAAA,CAAKe,MAAA,CAAOsB,KAAA,CAAMC,KAAA,CAAM;MACxBtC,KAAA,CAAKuC,mCAAA,GAAsCvC,KAAA,CAAKe,MAAA,CAAOO,MAAA,CAAOC,gBAAA,CAAiBC,KAAA,CAAM;IACtF;IAAAb,eAAA,CAAAC,sBAAA,CAAAZ,KAAA,kBA+gBuD,YAAM;MAC5DA,KAAA,CAAKwC,QAAA,CAAS;IACf;IAAA7B,eAAA,CAAAC,sBAAA,CAAAZ,KAAA,eAEiD,YAAM;MACtDA,KAAA,CAAK4B,MAAA,CAAO;IACb;IAAAjB,eAAA,CAAAC,sBAAA,CAAAZ,KAAA,iBAEqD,YAAM;MAC1DA,KAAA,CAAKwC,QAAA,CAAS;IACf;IAAA7B,eAAA,CAAAC,sBAAA,CAAAZ,KAAA,kBAEuD,YAAM;MAC5D,IAAIA,KAAA,CAAKe,MAAA,CAAOO,MAAA,CAAOO,UAAA,EAAY;QAClC;MACD;MAEA7B,KAAA,CAAKe,MAAA,CAAO0B,IAAA,CAAK;MACjBzC,KAAA,CAAK4B,MAAA,CAAO;IACb;IAAA,OAAA5B,KAAA;EAAA;EAAA0C,YAAA,CAAA/C,OAAA;IAAAuC,GAAA;IAAAS,KAAA,EAhiBA,SAAAC,SAAA,EAAW;MACV,OAAO,KAAK3B,SAAA,CAAU4B,IAAA,KAAS;IAChC;EAAA;IAAAX,GAAA;IAAAS,KAAA,EAEA,SAAAG,YAAYC,QAAA,EAAgCC,IAAA,EAA0B;MACrE,IAAI,CAAC,KAAKJ,QAAA,CAAS,GAAG,OAAO;MAE7B,IAAMK,WAAA,GAAcxD,YAAA,CAAauD,IAAI;MACrC,IAAME,UAAA,GAAaH,QAAA,CAAS,CAAC,EAAEI,MAAA,CAAO,CAAC;MACvC,IAAMC,WAAA,GAAcL,QAAA,CAASA,QAAA,CAAS3C,MAAA,GAAS,CAAC;MAChD,IAAMiD,SAAA,GAAYD,WAAA,CAAYD,MAAA,CAAOC,WAAA,CAAYD,MAAA,CAAO/C,MAAA,GAAS,CAAC;MAElE,OACC8C,UAAA,KAAeG,SAAA,IACf,KAAKC,iBAAA,GAAoBL,WAAA,GAAc,KACvChE,KAAA,CAAM6C,IAAA,CAAKoB,UAAA,EAAYG,SAAS,IAAIJ,WAAA,GAAc;IAEpD;EAAA;IAAAf,GAAA;IAAAS,KAAA,EAEQ,SAAAlB,WAAA,EAAa;MACpB,IAAA8B,mBAAA,GAEI,KAAKxC,MAAA,CADRO,MAAA;QAAUkC,eAAA,GAAAD,mBAAA,CAAAC,eAAA;QAAiB7B,KAAA,GAAA4B,mBAAA,CAAA5B,KAAA;MAG5B,KAAKZ,MAAA,CAAO0C,IAAA,CAAK,mBAAmB;MAEpC,KAAK9B,KAAA,GAAQA,KAAA;MAEb,IAAM+B,QAAA,GAAW,KAAK/B,KAAA,GAAQ,KAAKT,IAAA,CAAKyC,KAAA,CAAMC,CAAA,GAAK,OAAO;MAE1D,KAAKzB,WAAA,GAAc,KAAKpB,MAAA,CAAOO,MAAA,CAAOuC,QAAA,GAAW,aAAa;MAE9D,KAAKC,0CAAA,GAA6C;MAElD,KAAKzC,iBAAA,GAAoBmC,eAAA,CAAgBhC,KAAA,CAAM;MAE/C,IAAI,KAAKuC,YAAA,EAAc;QACtB,IAAMC,KAAA,GAAQ,KAAKjD,MAAA,CAAOkD,YAAA,CAA4B,KAAKF,YAAA,CAAajD,EAAE;QAE1E,IAAIkD,KAAA,IAAS,KAAK7B,WAAA,KAAgB,YAAY;UAG7C,KAAK2B,0CAAA,GAA6C;UAElD,IAAMI,WAAA,GAAc/E,IAAA,CAAK6E,KAAA,CAAMG,KAAA,CAAMpB,QAAQ;UAC7C,IAAI,CAACmB,WAAA,EAAa,MAAME,KAAA,CAAM,8BAA8B;UAC5D,IAAMC,SAAA,GAAYlF,IAAA,CAAK+E,WAAA,CAAYf,MAAM;UACzC,IAAI,CAACkB,SAAA,EAAW,MAAMD,KAAA,CAAM,4BAA4B;UAExD,IAAAE,qBAAA,GAAiB,KAAKvD,MAAA,CAAOwD,oBAAA,CAAqBP,KAAA,EAAOR,eAAe,EAAExE,OAAA,CAAQ;YAA1EwF,CAAA,GAAAF,qBAAA,CAAAE,CAAA;YAAGC,CAAA,GAAAH,qBAAA,CAAAG,CAAA;UAEX,IAAMC,SAAA,GAAW,KAAK/C,KAAA,GAAQ,KAAKT,IAAA,CAAKyC,KAAA,CAAMC,CAAA,GAAK,OAAO;UAE1D,IAAMe,UAAA,GAAiC;YACtC9B,IAAA,EAAM,KAAKV,WAAA;YACXgB,MAAA,EAAQ,CACP;cACCqB,CAAA,EAAGH,SAAA,CAAUG,CAAA;cACbC,CAAA,EAAGJ,SAAA,CAAUI,CAAA;cACbb,CAAA,EAAG,CAACc,SAAA,CAAS1F,OAAA,CAAQ,CAAC;YACvB,GACA;cACCwF,CAAA,EAAAA,CAAA;cACAC,CAAA,EAAAA,CAAA;cACAb,CAAA,EAAG,CAACc,SAAA,CAAS1F,OAAA,CAAQ,CAAC;YACvB;UAEF;UAGA,IAAM4F,kBAAA,GAAqB9F,QAAA,CAAS+F,YAAA,CACnC,KAAK9D,MAAA,CAAO+D,oBAAA,CAAqBd,KAAA,CAAMlD,EAAE,GACzCuD,SACD;UACA,KAAK9B,mCAAA,GAAsCqC,kBAAA;UAC3C,KAAKxC,gCAAA,GAAmC;UACxC,IAAMW,QAAA,MAAArC,MAAA,CAAAqE,kBAAA,CAAef,KAAA,CAAMG,KAAA,CAAMpB,QAAA,IAAU4B,UAAU;UAErD,KAAKrB,iBAAA,GAAoB,KAAK0B,aAAA,CAAcjC,QAAQ;UAEpD,IAAMkC,YAAA,GAA8C;YACnDnE,EAAA,EAAIkD,KAAA,CAAMlD,EAAA;YACV+B,IAAA,EAAM,KAAK5B,SAAA,CAAU4B,IAAA;YACrBsB,KAAA,EAAO;cACNpB,QAAA,EAAAA;YACD;UACD;UAEA,IAAI,KAAKH,QAAA,CAAS,GAAG;YACpB;YAAEqC,YAAA,CAA6Cd,KAAA,CAAOe,QAAA,GAAW,KAAKpC,WAAA,CACrEC,QAAA,EACAiB,KAAA,CAAMG,KAAA,CAAMnB,IACb;UACD;UAEA,KAAKjC,MAAA,CAAOkB,YAAA,CAA6C,CAACgD,YAAY,CAAC;UAEvE;QACD;MACD;MAIA,KAAK1C,mCAAA,GAAsCiB,eAAA,CAAgBhC,KAAA,CAAM;MACjE,IAAMV,EAAA,GAAK5B,aAAA,CAAc;MAEzB,KAAK6B,MAAA,CAAOoE,YAAA,CAA4B,CACvC;QACCrE,EAAA,EAAAA,EAAA;QACA+B,IAAA,EAAM,KAAK5B,SAAA,CAAU4B,IAAA;QACrB2B,CAAA,EAAGhB,eAAA,CAAgBgB,CAAA;QACnBC,CAAA,EAAGjB,eAAA,CAAgBiB,CAAA;QACnBN,KAAA,EAAO;UACNxC,KAAA,EAAO,KAAKA,KAAA;UACZoB,QAAA,EAAU,CACT;YACCF,IAAA,EAAM,KAAKV,WAAA;YACXgB,MAAA,EAAQ,CACP;cACCqB,CAAA,EAAG;cACHC,CAAA,EAAG;cACHb,CAAA,EAAG,CAACF,QAAA,CAAS1E,OAAA,CAAQ,CAAC;YACvB;UAEF;QAEF;MACD,EACA;MACD,KAAKsE,iBAAA,GAAoB;MACzB,KAAKS,YAAA,GAAe,KAAKhD,MAAA,CAAOkD,YAAA,CAA4BnD,EAAE;IAC/D;EAAA;IAAAoB,GAAA;IAAAS,KAAA,EAEQ,SAAAV,aAAA,EAAe;MACtB,IAAQX,MAAA,GAAW,KAAKP,MAAA,CAAhBO,MAAA;MACR,IAAQyC,YAAA,GAAiB,KAAjBA,YAAA;MAER,IAAI,CAACA,YAAA,EAAc;MAEnB,IACCjD,EAAA,GAEGiD,YAAA,CAFHjD,EAAA;QACSkC,IAAA,GACNe,YAAA,CADHI,KAAA,CAASnB,IAAA;MAGV,IAAMgB,KAAA,GAAQ,KAAKjD,MAAA,CAAOkD,YAAA,CAA4BnD,EAAE;MAExD,IAAI,CAACkD,KAAA,EAAO;MAEZ,IAAQjB,QAAA,GAAaiB,KAAA,CAAMG,KAAA,CAAnBpB,QAAA;MAER,IAAAqC,sBAAA,GAAoB,KAAKrE,MAAA,CAAOwD,oBAAA,CAAqBP,KAAA,EAAO1C,MAAA,CAAOC,gBAAgB,EAAEvC,OAAA,CAAQ;QAArFwF,CAAA,GAAAY,sBAAA,CAAAZ,CAAA;QAAGC,CAAA,GAAAW,sBAAA,CAAAX,CAAA;QAAGb,CAAA,GAAAwB,sBAAA,CAAAxB,CAAA;MAEd,IAAMyB,QAAA,GAAW;QAAEb,CAAA,EAAAA,CAAA;QAAGC,CAAA,EAAAA,CAAA;QAAGb,CAAA,EAAG,KAAKjC,KAAA,GAAQ,EAAEiC,CAAA,GAAK,MAAM5E,OAAA,CAAQ,CAAC,IAAI;MAAI;MAEvE,QAAQ,KAAKmD,WAAA;QACZ,KAAK;UAAqB;YACzB,IAAQC,gCAAA,GAAqC,KAArCA,gCAAA;YAER,IAAIA,gCAAA,KAAqC,MAAM;cAC9C,MAAMgC,KAAA,CAAM,kDAAkD;YAC/D;YAEA,IAAMkB,iBAAA,GACLrG,KAAA,CAAM6C,IAAA,CAAKM,gCAAA,EAAkCd,MAAA,CAAOC,gBAAgB,IAAIlC,aAAA;YAMzE,IAAIiG,iBAAA,EAAmB;cACtB,KAAK/C,mCAAA,GAAsC,KAAKH,gCAAA,CAAkCZ,KAAA,CAAM;cACxF,KAAKY,gCAAA,GAAmC;cAGxC,KAAKD,WAAA,GAAc;cAEnB,IAAM+B,WAAA,GAAc/E,IAAA,CAAK4D,QAAQ;cACjC,IAAI,CAACmB,WAAA,EAAa,MAAME,KAAA,CAAM,8BAA8B;cAE5D,IAAMmB,aAAA,GAAgBpG,IAAA,CAAK+E,WAAA,CAAYf,MAAM;cAC7C,IAAI,CAACoC,aAAA,EAAe,MAAMnB,KAAA,CAAM,iCAAiC;cAEjE,IAAIO,UAAA;cAEJ,IAAMa,YAAA,GAAe,KAAKzE,MAAA,CACxBwD,oBAAA,CAAqBP,KAAA,EAAO,KAAKzB,mCAAmC,EACpEvD,OAAA,CAAQ,EACRyG,MAAA,CAAO;cAET,IAAIvB,WAAA,CAAYrB,IAAA,KAAS,YAAY;gBACpC,KAAKS,iBAAA,IAAqBrE,KAAA,CAAM6C,IAAA,CAAKyD,aAAA,EAAeC,YAAY;gBAEhEb,UAAA,GAAa;kBACZ9B,IAAA,EAAM;kBACNM,MAAA,EAAQ,CAAAuC,aAAA,KAAMH,aAAA,GAAiBC,YAAY;gBAC5C;gBAEA,IAAMG,SAAA,GAAY,KAAK5E,MAAA,CAAO6E,gBAAA,CAAiB5B,KAAK;gBAEpD,KAAKzB,mCAAA,GAAsCzD,QAAA,CAAS+F,YAAA,CACnDc,SAAA,EACAJ,aACD;cACD,OAAO;gBACNZ,UAAA,GAAa;kBACZ9B,IAAA,EAAM;kBACNM,MAAA,EAAQ,CAACqC,YAAA,EAAcH,QAAQ;gBAChC;cACD;cAEA,IAAMJ,YAAA,GAA8C;gBACnDnE,EAAA,EAAAA,EAAA;gBACA+B,IAAA,EAAM,KAAK5B,SAAA,CAAU4B,IAAA;gBACrBsB,KAAA,EAAO;kBACNpB,QAAA,KAAArC,MAAA,CAAAqE,kBAAA,CAAchC,QAAA,IAAU4B,UAAU;gBACnC;cACD;cAEA,IAAI,KAAK/B,QAAA,CAAS,GAAG;gBACpB;gBAAEqC,YAAA,CAA6Cd,KAAA,CAAOe,QAAA,GAAW,KAAKpC,WAAA,CACrEC,QAAA,EACAC,IACD;cACD;cAEA,KAAKjC,MAAA,CAAOkB,YAAA,CAA6C,CAACgD,YAAY,GAAG,IAAI;YAC9E;YACA;UACD;QACA,KAAK;UAAiB;YACrB,IAAQ7C,iCAAA,GAAqC,KAArCA,gCAAA;YAER,IAAIA,iCAAA,KAAqC,MAAM;cAC9C,MAAMgC,KAAA,CAAM,kDAAkD;YAC/D;YAEA,IAAMkB,kBAAA,GACLrG,KAAA,CAAM6C,IAAA,CAAKM,iCAAA,EAAkCd,MAAA,CAAOC,gBAAgB,IAAIlC,aAAA;YAMzE,IAAIiG,kBAAA,EAAmB;cACtB,KAAK/C,mCAAA,GAAsC,KAAKH,gCAAA,CAAkCZ,KAAA,CAAM;cACxF,KAAKY,gCAAA,GAAmC;cAGxC,KAAKD,WAAA,GAAc;cAEnB,IAAM0D,WAAA,GAAc9C,QAAA,CAAS+C,KAAA,CAAM;cACnC,IAAMC,mBAAA,GAAsBF,WAAA,CAAYA,WAAA,CAAYzF,MAAA,GAAS,CAAC;cAC9D,IAAMiE,SAAA,GAAYlF,IAAA,CAAK4G,mBAAA,CAAoB5C,MAAM;cAEjD,IAAI,CAACkB,SAAA,EAAW;gBACf,MAAMD,KAAA,CAAM,oBAAoB;cACjC;cAIA,IAAM4B,cAAA,GAAqC;gBAC1CnD,IAAA,EAAM;gBACNM,MAAA,EAAA4B,kBAAA,CACI9F,KAAA,CAAMgH,aAAA,CAAc5B,SAAA,EAAWgB,QAAA,EAAU,CAAC,EAAEa,GAAA,CAAI,UAACC,CAAA;kBAAA,OAAMA,CAAA,CAAEnH,OAAA,CAAQ,EAAEyG,MAAA,CAAO,CAAC;gBAAA;cAEhF;cAEA,IAAMW,aAAA,MAAA1F,MAAA,CAAAqE,kBAAA,CAAoBc,WAAA,IAAaG,cAAc;cACrD,KAAK1C,iBAAA,GAAoB,KAAK0B,aAAA,CAAcoB,aAAa;cAEzD,IAAMnB,aAAA,GAA8C;gBACnDnE,EAAA,EAAAA,EAAA;gBACA+B,IAAA,EAAM,KAAK5B,SAAA,CAAU4B,IAAA;gBACrBsB,KAAA,EAAO;kBACNpB,QAAA,EAAUqD;gBACX;cACD;cAEA,IAAI,KAAKxD,QAAA,CAAS,GAAG;gBACpB;gBAAEqC,aAAA,CAA6Cd,KAAA,CAAOe,QAAA,GAAW,KAAKpC,WAAA,CACrEsD,aAAA,EACApD,IACD;cACD;cAEA,KAAKjC,MAAA,CAAOkB,YAAA,CAAa,CAACgD,aAAY,GAAG,IAAI;YAC9C;YAEA;UACD;QACA,KAAK;UAAY;YAChB,IAAMY,YAAA,GAAc9C,QAAA,CAAS+C,KAAA,CAAM;YACnC,IAAMnB,WAAA,GAAakB,YAAA,CAAYA,YAAA,CAAYzF,MAAA,GAAS,CAAC;YAErD,IAAQmC,mCAAA,GAAwC,KAAxCA,mCAAA;YACR,IAAA8D,oBAAA,GAAsC,KAAKtF,MAAA,CAAOO,MAAA;cAA1CC,gBAAA,GAAA8E,oBAAA,CAAA9E,gBAAA;cAAkB+E,OAAA,GAAAD,oBAAA,CAAAC,OAAA;YAE1B,IAAI,CAAC/D,mCAAA,EACJ,MAAM6B,KAAA,CAAM,kDAAkD;YAE/D,IAAImC,SAAA;YACJ,IAAIC,iBAAA,GAAoB;YAExB,IAAI,KAAK1C,0CAAA,EAA4C;cACpD,IAAI,KAAK/C,MAAA,CAAOO,MAAA,CAAOO,UAAA,EAAY;gBAElC2E,iBAAA,GAAoB,CAACF,OAAA;gBACrB,KAAKxC,0CAAA,GAA6C;cACnD,OAAO,CAEP;YACD,OAAO;cAEN0C,iBAAA,GAAoB,CAACF,OAAA;YACtB;YAEA,IAAIG,SAAA,GAAW,KAAK1F,MAAA,CAAOwD,oBAAA,CAAqBP,KAAA,EAAOzC,gBAAgB,EAAEvC,OAAA,CAAQ,EAAEyG,MAAA,CAAO;YAC1F,IAAIiB,OAAA,GAAU;YACd,IAAIC,WAAA,GAA8C;YAElD,IAAMC,UAAA,GAAa,KAAK7F,MAAA,CAAO8F,UAAA,GAAa,CAACP,OAAA,GAAUA,OAAA;YAEvD,IAAIM,UAAA,EAAY;cACf,IAAIf,YAAA,CAAYzF,MAAA,GAAS,GAAG;gBAC3B,IAAI0G,YAAA,GAAuC;gBAC3C,IAAIC,WAAA,GAAc,IAAI,KAAKhG,MAAA,CAAOgB,SAAA;gBAGlC,SAASiF,CAAA,GAAI,GAAGC,CAAA,GAAIlE,QAAA,CAAS3C,MAAA,GAAS,GAAG4G,CAAA,GAAIC,CAAA,EAAGD,CAAA,IAAK;kBACpD,IAAME,OAAA,GAAUnE,QAAA,CAASiE,CAAC;kBAC1B,IAAI,CAACE,OAAA,EAAS;kBACd,IAAIA,OAAA,CAAQrE,IAAA,KAAS,QAAQ;kBAE7B,IAAMsE,KAAA,GAAQD,OAAA,CAAQ/D,MAAA,CAAO,CAAC;kBAC9B,IAAME,SAAA,GAAYlE,IAAA,CAAK+H,OAAA,CAAQ/D,MAAM;kBACrC,IAAI,EAAEgE,KAAA,IAAS9D,SAAA,GAAY;kBAG3B,IAAM+D,qBAAA,GAAwBnI,KAAA,CAAMoI,yBAAA,CACnCF,KAAA,EACA9D,SAAA,EACAoD,SACD;kBACA,IAAMa,QAAA,GAAWrI,KAAA,CAAM6C,IAAA,CAAKsF,qBAAA,EAAuBX,SAAQ;kBAE3D,IAAIa,QAAA,GAAWP,WAAA,EAAa;oBAC3BD,YAAA,GAAeM,qBAAA,CAAsBpI,OAAA,CAAQ,EAAEyG,MAAA,CAAO;oBACtDsB,WAAA,GAAcO,QAAA;oBACdX,WAAA,GAAcO,OAAA;oBACd;kBACD;gBACD;gBAEA,IAAIJ,YAAA,EAAc;kBACjBJ,OAAA,GAAU;kBACVD,SAAA,GAAWK,YAAA;gBACZ;cACD;YACD;YAEA,IAAIJ,OAAA,IAAWC,WAAA,EAAa;cAC3B,IAAMhB,UAAA,GAAY,KAAK5E,MAAA,CAAO6E,gBAAA,CAAiB5B,KAAK;cACpD,IAAMmD,MAAA,GAAQR,WAAA,CAAYxD,MAAA,CAAO,CAAC;cAClC,IAAME,UAAA,GAAYlE,IAAA,CAAKwH,WAAA,CAAYxD,MAAM;cACzC,IAAI,CAACE,UAAA,EAAW,MAAMe,KAAA,CAAM,wBAAwB;cAEpD,IAAMmD,CAAA,GAAIzI,QAAA,CAAS+F,YAAA,CAAac,UAAA,EAAWwB,MAAK;cAEhD,IAAMK,CAAA,GAAI1I,QAAA,CAAS+F,YAAA,CAAac,UAAA,EAAWtC,UAAS;cAEpD,IAAMoE,YAAA,GAAe3I,QAAA,CAAS+F,YAAA,CAAac,UAAA,EAAWc,SAAQ;cAE9D,KAAK1F,MAAA,CAAOsB,KAAA,CAAMqF,QAAA,CAAS,CAC1B;gBACC5G,EAAA,EAAIxB,QAAA,CAAS;gBACbuD,IAAA,EAAM;gBACNM,MAAA,EAAQ,CAACoE,CAAA,EAAGE,YAAA,EAAcD,CAAC;cAC5B,EACA;YACF,OAAO;cACN,KAAKzG,MAAA,CAAOsB,KAAA,CAAMC,KAAA,CAAM;cAExB,IAAIkE,iBAAA,EAAmB;gBAEtB,IAAMmB,YAAA,GAAe1I,KAAA,CAAM2I,KAAA,CAAMrF,mCAAA,EAAqChB,gBAAgB;gBACtF,IAAMsG,YAAA,GAAe9I,SAAA,CAAU4I,YAAA,EAAc,EAAE;gBAC/C,IAAMG,SAAA,GAAYD,YAAA,GAAeF,YAAA;gBAEjCpB,SAAA,GAAYtH,KAAA,CAAM8I,OAAA,CACjBxG,gBAAA,EACAgB,mCAAA,EACAuF,SACD;cACD,OAAO;gBACNvB,SAAA,GAAYhF,gBAAA;cACb;cAEAkF,SAAA,GAAW,KAAK1F,MAAA,CAAOwD,oBAAA,CAAqBP,KAAA,EAAOuC,SAAS,EAAEvH,OAAA,CAAQ,EAAEyG,MAAA,CAAO;YAChF;YAMA,KAAKnC,iBAAA,IAAqBrE,KAAA,CAAM6C,IAAA,CAAK6C,WAAA,CAAWxB,MAAA,CAAO,CAAC,GAAGsD,SAAQ;YAEnEZ,YAAA,CAAYA,YAAA,CAAYzF,MAAA,GAAS,CAAC,IAAAsF,aAAA,CAAAA,aAAA,KAC9Bf,WAAA;cACH9B,IAAA,EAAM;cACNM,MAAA,EAAQ,CAACwB,WAAA,CAAWxB,MAAA,CAAO,CAAC,GAAGsD,SAAQ;YAAA,EACxC;YAEA,IAAMxB,cAAA,GAA8C;cACnDnE,EAAA,EAAAA,EAAA;cACA+B,IAAA,EAAM,KAAK5B,SAAA,CAAU4B,IAAA;cACrBsB,KAAA,EAAO;gBACNpB,QAAA,EAAU8C;cACX;YACD;YAEA,IAAI,KAAKjD,QAAA,CAAS,GAAG;cACpB;cAAEqC,cAAA,CAA6Cd,KAAA,CAAOe,QAAA,GAAW,KAAKpC,WAAA,CACrEC,QAAA,EACAC,IACD;YACD;YAEA,KAAKjC,MAAA,CAAOkB,YAAA,CAAa,CAACgD,cAAY,GAAG,IAAI;YAE7C;UACD;QACA,KAAK;UAAQ;YACZ,IAAMY,aAAA,GAAc9C,QAAA,CAAS+C,KAAA,CAAM;YACnC,IAAMnB,YAAA,GAAakB,aAAA,CAAYA,aAAA,CAAYzF,MAAA,GAAS,CAAC;YACrD,IAAM4H,SAAA,GAAAjD,kBAAA,CAAgBJ,YAAA,CAAWxB,MAAM;YAEvC,IAAI6E,SAAA,CAAU5H,MAAA,IAAU,KAAK4B,cAAA,EAAgB;cAC5C,IAAQiG,EAAA,GAAMD,SAAA,CAAUA,SAAA,CAAU5H,MAAA,GAAS,CAAC,EAApCwD,CAAA;cACRoE,SAAA,CAAUA,SAAA,CAAU5H,MAAA,GAAS,CAAC,IAAI;gBACjCoE,CAAA,EAAGa,QAAA,CAASb,CAAA;gBACZC,CAAA,EAAGY,QAAA,CAASZ,CAAA;gBACZb,CAAA,EAAGqE,EAAA,GAAIC,IAAA,CAAKC,GAAA,CAAIF,EAAA,EAAG5C,QAAA,CAASzB,CAAC,IAAIyB,QAAA,CAASzB;cAC3C;YAGD,OAAO;cACN,KAAKN,iBAAA,IAAqBrE,KAAA,CAAM6C,IAAA,CAAKkG,SAAA,CAAUA,SAAA,CAAU5H,MAAA,GAAS,CAAC,GAAGiF,QAAQ;cAC9E2C,SAAA,CAAUI,IAAA,CAAK/C,QAAQ;YACxB;YAEAQ,aAAA,CAAYA,aAAA,CAAYzF,MAAA,GAAS,CAAC,IAAAsF,aAAA,CAAAA,aAAA,KAC9Bf,YAAA;cACHxB,MAAA,EAAQ6E;YAAA,EACT;YAEA,KAAK1E,iBAAA,GAAoB,KAAK0B,aAAA,CAAca,aAAW;YAEvD,IAAMZ,cAAA,GAA8C;cACnDnE,EAAA,EAAAA,EAAA;cACA+B,IAAA,EAAM,KAAK5B,SAAA,CAAU4B,IAAA;cACrBsB,KAAA,EAAO;gBACNpB,QAAA,EAAU8C;cACX;YACD;YAEA,IAAI,KAAKjD,QAAA,CAAS,GAAG;cACpB;cAAEqC,cAAA,CAA6Cd,KAAA,CAAOe,QAAA,GAAW,KAAKpC,WAAA,CACrE+C,aAAA,EACA7C,IACD;YACD;YAEA,KAAKjC,MAAA,CAAOkB,YAAA,CAAa,CAACgD,cAAY,GAAG,IAAI;YAG7C,IAAI+C,SAAA,CAAU5H,MAAA,GAAS,KAAK;cAC3B,KAAKW,MAAA,CAAOkB,YAAA,CAAa,CAAC;gBAAEnB,EAAA,EAAAA,EAAA;gBAAI+B,IAAA,EAAM,KAAK5B,SAAA,CAAU4B,IAAA;gBAAMsB,KAAA,EAAO;kBAAEkE,UAAA,EAAY;gBAAK;cAAE,CAAC,CAAC;cAEzF,IAAQ9G,iBAAA,GAAqB,KAAKR,MAAA,CAAOO,MAAA,CAAjCC,gBAAA;cAER,IAAM+G,UAAA,GAAapJ,aAAA,CAAc;cAEjC,KAAK6B,MAAA,CAAOoE,YAAA,CAA4B,CACvC;gBACCrE,EAAA,EAAIwH,UAAA;gBACJzF,IAAA,EAAM,KAAK5B,SAAA,CAAU4B,IAAA;gBACrB2B,CAAA,EAAGxF,OAAA,CAAQuC,iBAAA,CAAiBiD,CAAC;gBAC7BC,CAAA,EAAGzF,OAAA,CAAQuC,iBAAA,CAAiBkD,CAAC;gBAC7BN,KAAA,EAAO;kBACNxC,KAAA,EAAO,KAAKA,KAAA;kBACZoB,QAAA,EAAU,CACT;oBACCF,IAAA,EAAM;oBACNM,MAAA,EAAQ,CAAC;sBAAEqB,CAAA,EAAG;sBAAGC,CAAA,EAAG;sBAAGb,CAAA,EAAG,KAAKjC,KAAA,GAAQ,EAAEiC,CAAA,GAAK,MAAM5E,OAAA,CAAQ,IAAI;oBAAI,CAAC;kBACtE;gBAEF;cACD,EACA;cAED,KAAK+E,YAAA,GAAe3E,eAAA,CAAgB,KAAK2B,MAAA,CAAOkD,YAAA,CAA4BqE,UAAU,CAAE;cACxF,KAAKtG,cAAA,GAAiB;cACtB,KAAKX,iBAAA,GAAoB,KAAKN,MAAA,CAAOO,MAAA,CAAOC,gBAAA,CAAiBC,KAAA,CAAM;cACnE,KAAK8B,iBAAA,GAAoB;YAC1B;YAEA;UACD;MACD;IACD;EAAA;IAAApB,GAAA;IAAAS,KAAA,EAEQ,SAAAqC,cAAcjC,QAAA,EAAgC;MACrD,IAAI3C,MAAA,GAAS;MAAA,IAAAmI,SAAA,GAAAC,0BAAA,CAESzF,QAAA;QAAA0F,KAAA;MAAA;QAAtB,KAAAF,SAAA,CAAAG,CAAA,MAAAD,KAAA,GAAAF,SAAA,CAAAtB,CAAA,IAAA0B,IAAA,GAAgC;UAAA,IAArBzB,OAAA,GAAAuB,KAAA,CAAA9F,KAAA;UACV,SAASqE,CAAA,GAAI,GAAGA,CAAA,GAAIE,OAAA,CAAQ/D,MAAA,CAAO/C,MAAA,GAAS,GAAG4G,CAAA,IAAK;YACnD,IAAMO,CAAA,GAAIL,OAAA,CAAQ/D,MAAA,CAAO6D,CAAC;YAC1B,IAAMQ,CAAA,GAAIN,OAAA,CAAQ/D,MAAA,CAAO6D,CAAA,GAAI,CAAC;YAC9B5G,MAAA,IAAUnB,KAAA,CAAM2J,GAAA,CAAIpB,CAAA,EAAGD,CAAC,EAAEsB,IAAA,CAAK;UAChC;QACD;MAAA,SAAAC,GAAA;QAAAP,SAAA,CAAAQ,CAAA,CAAAD,GAAA;MAAA;QAAAP,SAAA,CAAAS,CAAA;MAAA;MAEA,OAAOd,IAAA,CAAKe,IAAA,CAAK7I,MAAM;IACxB;EAAA;IAAA8B,GAAA;IAAAS,KAAA,EAuBA,SAAAH,SAAA,EAAW;MAKV,IAAI,CAAC,KAAKrB,OAAA,EAAS;QAClB,KAAKS,MAAA,CAAO;QACZ;MACD;MAEA,IAAQmC,YAAA,GAAiB,KAAjBA,YAAA;MACR,IAAI,CAACA,YAAA,EAAc;MACnB,KAAKhD,MAAA,CAAOkB,YAAA,CAAa,CACxB;QAAEnB,EAAA,EAAIiD,YAAA,CAAajD,EAAA;QAAI+B,IAAA,EAAMkB,YAAA,CAAalB,IAAA;QAAMsB,KAAA,EAAO;UAAEkE,UAAA,EAAY;QAAK;MAAE,EAC5E;MAED,KAAKxH,MAAA,CAAOqI,UAAA,CAAW,QAAQ,CAAC,CAAC;IAClC;EAAA;IAAAhH,GAAA;IAAAS,KAAA,EAEA,SAAAf,OAAA,EAAS;MACR,KAAKf,MAAA,CAAOqI,UAAA,CAAW,QAAQ,KAAKhI,IAAI;IACzC;EAAA;EAAA,OAAAvB,OAAA;AAAA,EA7qB4BJ,SAAA;AAAAoB,eAAA,CAAhBhB,OAAA,QACS"},"metadata":{},"sourceType":"module","externalDependencies":[]}