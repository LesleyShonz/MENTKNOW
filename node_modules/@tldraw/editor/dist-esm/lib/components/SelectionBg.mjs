import { jsx } from "react/jsx-runtime";
import { Matrix2d, toDomPrecision } from "@tldraw/primitives";
import * as React from "react";
import { track } from "signia-react";
import { useEditor } from "../hooks/useEditor.mjs";
import { releasePointerCapture, setPointerCapture } from "../utils/dom.mjs";
import { getPointerInfo } from "../utils/svg.mjs";
const SelectionBg = track(function SelectionBg2() {
  const editor = useEditor();
  const events = React.useMemo(() => {
    const onPointerDown = (e) => {
      if (e.isKilled)
        return;
      setPointerCapture(e.currentTarget, e);
      const info = {
        type: "pointer",
        target: "selection",
        name: "pointer_down",
        ...getPointerInfo(e, editor.getContainer())
      };
      editor.dispatch(info);
    };
    const onPointerMove = (e) => {
      if (e.isKilled)
        return;
      const info = {
        type: "pointer",
        target: "selection",
        name: "pointer_move",
        ...getPointerInfo(e, editor.getContainer())
      };
      editor.dispatch(info);
    };
    const onPointerUp = (e) => {
      if (e.isKilled)
        return;
      releasePointerCapture(e.currentTarget, e);
      const info = {
        type: "pointer",
        target: "selection",
        name: "pointer_up",
        ...getPointerInfo(e, editor.getContainer())
      };
      editor.dispatch(info);
    };
    const onPointerEnter = (e) => {
      if (e.isKilled)
        return;
      const info = {
        type: "pointer",
        target: "selection",
        name: "pointer_enter",
        ...getPointerInfo(e, editor.getContainer())
      };
      editor.dispatch(info);
    };
    const onPointerLeave = (e) => {
      if (e.isKilled)
        return;
      const info = {
        type: "pointer",
        target: "selection",
        name: "pointer_leave",
        ...getPointerInfo(e, editor.getContainer())
      };
      editor.dispatch(info);
    };
    return {
      onPointerDown,
      onPointerMove,
      onPointerUp,
      onPointerEnter,
      onPointerLeave
    };
  }, [editor]);
  const { selectionBounds: bounds, selectedIds } = editor;
  if (!bounds)
    return null;
  const shouldDisplay = editor.isInAny(
    "select.idle",
    "select.brushing",
    "select.scribble_brushing",
    "select.pointing_shape",
    "select.pointing_selection",
    "text.resizing"
  );
  if (selectedIds.length === 1) {
    const shape = editor.getShapeById(selectedIds[0]);
    if (!shape) {
      return null;
    }
    const util = editor.getShapeUtil(shape);
    if (util.hideSelectionBoundsBg(shape)) {
      return null;
    }
  }
  const transform = Matrix2d.toCssString(
    Matrix2d.Compose(
      Matrix2d.Translate(bounds.minX, bounds.minY),
      Matrix2d.Rotate(editor.selectionRotation)
    )
  );
  return /* @__PURE__ */ jsx(
    "div",
    {
      className: "tl-selection__bg",
      draggable: false,
      style: {
        transform,
        width: toDomPrecision(Math.max(1, bounds.width)),
        height: toDomPrecision(Math.max(1, bounds.height)),
        pointerEvents: shouldDisplay ? "all" : "none",
        opacity: shouldDisplay ? 1 : 0
      },
      ...events
    }
  );
});
export {
  SelectionBg
};
//# sourceMappingURL=SelectionBg.mjs.map
