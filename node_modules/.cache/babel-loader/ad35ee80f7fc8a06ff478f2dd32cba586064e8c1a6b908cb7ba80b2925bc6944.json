{"ast":null,"code":"import _slicedToArray from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _createForOfIteratorHelper from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport { Fragment, jsx, jsxs } from \"react/jsx-runtime\";\nimport { getRoundedInkyPolygonPath, getRoundedPolygonPoints } from \"@tldraw/primitives\";\nimport * as React from \"react\";\nimport { getShapeFillSvg, getSvgWithShapeFill, ShapeFill } from \"../../shared/ShapeFill.mjs\";\nvar DrawStylePolygon = React.memo(function DrawStylePolygon2(_ref) {\n  var id = _ref.id,\n    outline = _ref.outline,\n    lines = _ref.lines,\n    fill = _ref.fill,\n    color = _ref.color,\n    strokeWidth = _ref.strokeWidth;\n  var polygonPoints = getRoundedPolygonPoints(id, outline, strokeWidth / 3, strokeWidth * 2, 2);\n  var strokePathData = getRoundedInkyPolygonPath(polygonPoints);\n  if (lines) {\n    var _iterator = _createForOfIteratorHelper(lines),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var _step$value = _slicedToArray(_step.value, 2),\n          A = _step$value[0],\n          B = _step$value[1];\n        strokePathData += \"M\".concat(A.x, \",\").concat(A.y, \"L\").concat(B.x, \",\").concat(B.y);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  }\n  var innerPolygonPoints = getRoundedPolygonPoints(id, outline, 0, strokeWidth * 2, 1);\n  var innerPathData = getRoundedInkyPolygonPath(innerPolygonPoints);\n  return /* @__PURE__ */jsxs(Fragment, {\n    children: [/* @__PURE__ */jsx(ShapeFill, {\n      d: innerPathData,\n      fill: fill,\n      color: color\n    }), /* @__PURE__ */jsx(\"path\", {\n      d: strokePathData,\n      stroke: \"var(--palette-\".concat(color, \")\"),\n      strokeWidth: strokeWidth,\n      fill: \"none\"\n    })]\n  });\n});\nfunction DrawStylePolygonSvg(_ref2) {\n  var id = _ref2.id,\n    outline = _ref2.outline,\n    lines = _ref2.lines,\n    fill = _ref2.fill,\n    color = _ref2.color,\n    colors = _ref2.colors,\n    strokeWidth = _ref2.strokeWidth;\n  var polygonPoints = getRoundedPolygonPoints(id, outline, strokeWidth / 3, strokeWidth * 2, 2);\n  var strokePathData = getRoundedInkyPolygonPath(polygonPoints);\n  if (lines) {\n    var _iterator2 = _createForOfIteratorHelper(lines),\n      _step2;\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var _step2$value = _slicedToArray(_step2.value, 2),\n          A = _step2$value[0],\n          B = _step2$value[1];\n        strokePathData += \"M\".concat(A.x, \",\").concat(A.y, \"L\").concat(B.x, \",\").concat(B.y);\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n  }\n  var innerPolygonPoints = getRoundedPolygonPoints(id, outline, 0, strokeWidth * 2, 1);\n  var innerPathData = getRoundedInkyPolygonPath(innerPolygonPoints);\n  var strokeElement = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n  strokeElement.setAttribute(\"d\", strokePathData);\n  strokeElement.setAttribute(\"fill\", \"none\");\n  strokeElement.setAttribute(\"stroke\", colors.fill[color]);\n  strokeElement.setAttribute(\"stroke-width\", strokeWidth.toString());\n  var fillElement = getShapeFillSvg({\n    d: innerPathData,\n    fill: fill,\n    color: color,\n    colors: colors\n  });\n  return getSvgWithShapeFill(strokeElement, fillElement);\n}\nexport { DrawStylePolygon, DrawStylePolygonSvg };","map":{"version":3,"names":["Fragment","jsx","jsxs","getRoundedInkyPolygonPath","getRoundedPolygonPoints","React","getShapeFillSvg","getSvgWithShapeFill","ShapeFill","DrawStylePolygon","memo","DrawStylePolygon2","_ref","id","outline","lines","fill","color","strokeWidth","polygonPoints","strokePathData","_iterator","_createForOfIteratorHelper","_step","s","n","done","_step$value","_slicedToArray","value","A","B","concat","x","y","err","e","f","innerPolygonPoints","innerPathData","children","d","stroke","DrawStylePolygonSvg","_ref2","colors","_iterator2","_step2","_step2$value","strokeElement","document","createElementNS","setAttribute","toString","fillElement"],"sources":["/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@tldraw/editor/src/lib/editor/shapes/geo/components/DrawStylePolygon.tsx"],"sourcesContent":["import { getRoundedInkyPolygonPath, getRoundedPolygonPoints, VecLike } from '@tldraw/primitives'\nimport { TLGeoShape } from '@tldraw/tlschema'\nimport * as React from 'react'\nimport { getShapeFillSvg, getSvgWithShapeFill, ShapeFill } from '../../shared/ShapeFill'\nimport { TLExportColors } from '../../shared/TLExportColors'\n\nexport const DrawStylePolygon = React.memo(function DrawStylePolygon({\n\tid,\n\toutline,\n\tlines,\n\tfill,\n\tcolor,\n\tstrokeWidth,\n}: Pick<TLGeoShape['props'], 'fill' | 'color'> & {\n\tid: TLGeoShape['id']\n\toutline: VecLike[]\n\tstrokeWidth: number\n\tlines?: VecLike[][]\n}) {\n\tconst polygonPoints = getRoundedPolygonPoints(id, outline, strokeWidth / 3, strokeWidth * 2, 2)\n\tlet strokePathData = getRoundedInkyPolygonPath(polygonPoints)\n\n\tif (lines) {\n\t\tfor (const [A, B] of lines) {\n\t\t\tstrokePathData += `M${A.x},${A.y}L${B.x},${B.y}`\n\t\t}\n\t}\n\n\tconst innerPolygonPoints = getRoundedPolygonPoints(id, outline, 0, strokeWidth * 2, 1)\n\tconst innerPathData = getRoundedInkyPolygonPath(innerPolygonPoints)\n\n\treturn (\n\t\t<>\n\t\t\t<ShapeFill d={innerPathData} fill={fill} color={color} />\n\t\t\t<path\n\t\t\t\td={strokePathData}\n\t\t\t\tstroke={`var(--palette-${color})`}\n\t\t\t\tstrokeWidth={strokeWidth}\n\t\t\t\tfill=\"none\"\n\t\t\t/>\n\t\t</>\n\t)\n})\n\nexport function DrawStylePolygonSvg({\n\tid,\n\toutline,\n\tlines,\n\tfill,\n\tcolor,\n\tcolors,\n\tstrokeWidth,\n}: Pick<TLGeoShape['props'], 'fill' | 'color'> & {\n\tid: TLGeoShape['id']\n\toutline: VecLike[]\n\tlines?: VecLike[][]\n\tstrokeWidth: number\n\tcolors: TLExportColors\n}) {\n\tconst polygonPoints = getRoundedPolygonPoints(id, outline, strokeWidth / 3, strokeWidth * 2, 2)\n\n\tlet strokePathData = getRoundedInkyPolygonPath(polygonPoints)\n\n\tif (lines) {\n\t\tfor (const [A, B] of lines) {\n\t\t\tstrokePathData += `M${A.x},${A.y}L${B.x},${B.y}`\n\t\t}\n\t}\n\n\tconst innerPolygonPoints = getRoundedPolygonPoints(id, outline, 0, strokeWidth * 2, 1)\n\tconst innerPathData = getRoundedInkyPolygonPath(innerPolygonPoints)\n\n\tconst strokeElement = document.createElementNS('http://www.w3.org/2000/svg', 'path')\n\tstrokeElement.setAttribute('d', strokePathData)\n\tstrokeElement.setAttribute('fill', 'none')\n\tstrokeElement.setAttribute('stroke', colors.fill[color])\n\tstrokeElement.setAttribute('stroke-width', strokeWidth.toString())\n\n\t// Get the fill element, if any\n\tconst fillElement = getShapeFillSvg({\n\t\td: innerPathData,\n\t\tfill,\n\t\tcolor,\n\t\tcolors,\n\t})\n\n\treturn getSvgWithShapeFill(strokeElement, fillElement)\n}\n\n// function getPolygonDrawPoints(id: string, outline: VecLike[], strokeWidth: number) {\n// \tconst points: Vec2d[] = []\n\n// \tconst getRandom = rng(id)\n\n// \tconst start = Math.round(Math.abs(getRandom()) * outline.length)\n\n// \tconst corners = outline.map((p) =>\n// \t\tVec2d.AddXY(p, (getRandom() * strokeWidth) / 4, (getRandom() * strokeWidth) / 4)\n// \t)\n\n// \tconst len = corners.length\n\n// \tfor (let i = 0, n = len + 1; i < n; i++) {\n// \t\tconst At = corners[(start + i) % len]\n// \t\tconst Bt = corners[(start + i + 1) % len]\n\n// \t\tconst dist = Math.min(Vec2d.Dist(At, Bt) / 2, strokeWidth / 2)\n// \t\tconst A = Vec2d.Nudge(At, Bt, dist)\n\n// \t\tconst D = Vec2d.Med(At, Bt)\n\n// \t\tif (i === 0) {\n// \t\t\tBt.z = 0.7\n// \t\t\tpoints.push(new Vec2d(D.x, D.y, 0.7), Bt)\n// \t\t} else if (i === outline.length) {\n// \t\t\tconst lastSegPoints = Vec2d.PointsBetween(A, D, 4)\n// \t\t\tlastSegPoints.forEach((p) => (p.z = 0.7))\n// \t\t\tpoints.push(...lastSegPoints)\n// \t\t} else {\n// \t\t\tpoints.push(...Vec2d.PointsBetween(A, Bt, 6))\n// \t\t}\n// \t}\n\n// \treturn points\n// }\n\n// export function getPolygonIndicatorPath(id: string, outline: VecLike[], strokeWidth: number) {\n// \tconst points = getPolygonDrawPoints(id, outline, strokeWidth)\n// \tconst options = getPolygonStrokeOptions(strokeWidth)\n// \tconst strokePoints = getStrokePoints(points, options)\n\n// \treturn getSvgPathFromStrokePoints(strokePoints, true)\n// }\n\n// function getPolygonStrokeOptions(strokeWidth: number) {\n// \treturn {\n// \t\tsize: 1 + strokeWidth * 0.618,\n// \t\tlast: true,\n// \t\tsimulatePressure: false,\n// \t\tstreamline: 0.25,\n// \t\tthinning: 0.9,\n// \t}\n// }\n\n// function getPolygonstrokePathData(id: string, outline: VecLike[], strokeWidth: number) {\n// \t// draw a line between all of the points\n// \tlet d = `M${outline[0].x},${outline[0].y}`\n// \td += 'Z'\n\n// \tfor (const { x, y } of outline) {\n// \t\td += `${x},${y}`\n// \t}\n\n// \treturn d\n// }\n\n// function SimpleInkyPolygon(id: string, outline: VecLike[], offset: number) {\n// \tconst random = rng(id)\n// \tlet p = outline[0]\n\n// \tlet ox = random() * offset\n// \tlet oy = random() * offset\n\n// \tlet polylineA = `M${p.x - ox},${p.y - oy}L`\n// \tlet polylineB = `${p.x + ox},${p.y + oy} `\n\n// \tfor (let i = 1, n = outline.length; i < n; i++) {\n// \t\tp = outline[i]\n// \t\tox = random() * offset\n// \t\toy = random() * offset\n\n// \t\tpolylineA += `${p.x - ox},${p.y - oy} `\n// \t\tpolylineB += `${p.x + ox},${p.y + oy} `\n// \t}\n\n// \tpolylineB += 'Z'\n\n// \tpolylineA += polylineB\n\n// \treturn polylineA\n// }\n\n// function CubicInkyPolygon(id: string, outline: VecLike[], offset: number) {\n// \tconst random = rng(id)\n// \tlet p0 = outline[0]\n// \tlet p1 = p0\n\n// \tlet ox: number\n// \tlet oy: number\n\n// \tlet polylineA = `M${p0.x},${p0.y} L`\n// \tlet polylineB = `M${p0.x},${p0.y}`\n\n// \tfor (let i = 0, n = outline.length; i < n; i++) {\n// \t\tp0 = outline[i]\n// \t\tp1 = outline[(i + 1) % n]\n\n// \t\tpolylineA += `${p1.x},${p1.y} `\n\n// \t\tox = random() * offset\n// \t\toy = random() * offset\n// \t\tconst c1 = Vec2d.Lrp(p0, p1, 0.25)\n// \t\tconst c2 = Vec2d.Lrp(p0, p1, 0.75)\n\n// \t\tpolylineB += `C${c1.x + ox},${c1.y + oy} ${c2.x - ox},${c2.y - oy} ${p1.x},${p1.y}`\n// \t}\n\n// \tpolylineB += 'Z'\n\n// \tpolylineA += polylineB\n\n// \treturn polylineA\n// }\n\n// function QuadraticInkyPolygon(id: string, outline: VecLike[], offset: number) {\n// \tconst random = rng(id)\n// \tlet p0 = outline[0]\n// \tlet p1 = p0\n\n// \tlet polylineA = `M${p0.x},${p0.y} Q`\n\n// \tconst len = outline.length\n\n// \tfor (let i = 0, n = len * 2; i < n; i++) {\n// \t\tp0 = outline[i % len]\n// \t\tp1 = outline[(i + 1) % len]\n// \t\tconst dist = Vec2d.Dist(p0, p1)\n\n// \t\tconst c1 = Vec2d.Lrp(p0, p1, 0.5 + random() / 2)\n// \t\tpolylineA += `${c1.x + random() * Math.min(dist / 10, offset)},${\n// \t\t\tc1.y + random() * Math.min(dist / 10, offset)\n// \t\t} ${p1.x + (random() * offset) / 2},${p1.y + (random() * offset) / 2} `\n// \t}\n\n// \tpolylineA += 'Z'\n\n// \treturn polylineA\n// }\n\n// function GlobyInkyPolygon(id: string, outline: VecLike[], offset: number) {\n// \tconst random = rng(id)\n// \tlet p0 = outline[0]\n// \tlet p1 = p0\n\n// \tlet polylineA = `M${p0.x},${p0.y} Q`\n\n// \tconst len = outline.length\n\n// \tfor (let i = 0, n = len * 2; i < n; i++) {\n// \t\tp0 = outline[i % len]\n// \t\tp1 = outline[(i + 1) % len]\n// \t\tconst dist = Vec2d.Dist(p0, p1)\n\n// \t\tconst c1 = Vec2d.Lrp(p0, p1, 0.5 + random() / 2)\n// \t\tpolylineA += `${c1.x + random() * Math.min(dist / 10, offset)},${\n// \t\t\tc1.y + random() * Math.min(dist / 10, offset)\n// \t\t} ${p1.x + (random() * offset) / 2},${p1.y + (random() * offset) / 2} `\n// \t}\n\n// \tpolylineA += 'Z'\n\n// \treturn polylineA\n// }\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}