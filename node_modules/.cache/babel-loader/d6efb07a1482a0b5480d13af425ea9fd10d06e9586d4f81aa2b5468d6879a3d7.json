{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _slicedToArray from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport { intersectSets } from \"./setUtils.mjs\";\nfunction objectMatchesQuery(query, object) {\n  for (var _i = 0, _Object$entries = Object.entries(query); _i < _Object$entries.length; _i++) {\n    var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),\n      key = _Object$entries$_i[0],\n      _matcher = _Object$entries$_i[1];\n    var matcher = _matcher;\n    var value = object[key];\n    if (\"eq\" in matcher && value !== matcher.eq) return false;\n    if (\"neq\" in matcher && value === matcher.neq) return false;\n    if (\"gt\" in matcher && (typeof value !== \"number\" || value <= matcher.gt)) return false;\n  }\n  return true;\n}\nfunction executeQuery(store, typeName, query) {\n  var matchIds = Object.fromEntries(Object.keys(query).map(function (key) {\n    return [key, /* @__PURE__ */new Set()];\n  }));\n  for (var _i2 = 0, _Object$entries2 = Object.entries(query); _i2 < _Object$entries2.length; _i2++) {\n    var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i2], 2),\n      k = _Object$entries2$_i[0],\n      matcher = _Object$entries2$_i[1];\n    if (\"eq\" in matcher) {\n      var index = store.index(typeName, k);\n      var ids = index.value.get(matcher.eq);\n      if (ids) {\n        var _iterator = _createForOfIteratorHelper(ids),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var id = _step.value;\n            matchIds[k].add(id);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      }\n    } else if (\"neq\" in matcher) {\n      var _index = store.index(typeName, k);\n      var _iterator2 = _createForOfIteratorHelper(_index.value),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var _step2$value = _slicedToArray(_step2.value, 2),\n            value = _step2$value[0],\n            _ids = _step2$value[1];\n          if (value !== matcher.neq) {\n            var _iterator3 = _createForOfIteratorHelper(_ids),\n              _step3;\n            try {\n              for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                var _id = _step3.value;\n                matchIds[k].add(_id);\n              }\n            } catch (err) {\n              _iterator3.e(err);\n            } finally {\n              _iterator3.f();\n            }\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    } else if (\"gt\" in matcher) {\n      var _index2 = store.index(typeName, k);\n      var _iterator4 = _createForOfIteratorHelper(_index2.value),\n        _step4;\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var _step4$value = _slicedToArray(_step4.value, 2),\n            _value = _step4$value[0],\n            _ids2 = _step4$value[1];\n          if (_value > matcher.gt) {\n            var _iterator5 = _createForOfIteratorHelper(_ids2),\n              _step5;\n            try {\n              for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n                var _id2 = _step5.value;\n                matchIds[k].add(_id2);\n              }\n            } catch (err) {\n              _iterator5.e(err);\n            } finally {\n              _iterator5.f();\n            }\n          }\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n    }\n  }\n  return intersectSets(Object.values(matchIds));\n}\nexport { executeQuery, objectMatchesQuery };","map":{"version":3,"names":["intersectSets","objectMatchesQuery","query","object","_i","_Object$entries","Object","entries","length","_Object$entries$_i","_slicedToArray","key","_matcher","matcher","value","eq","neq","gt","executeQuery","store","typeName","matchIds","fromEntries","keys","map","Set","_i2","_Object$entries2","_Object$entries2$_i","k","index","ids","get","_iterator","_createForOfIteratorHelper","_step","s","n","done","id","add","err","e","f","_iterator2","_step2","_step2$value","_iterator3","_step3","_iterator4","_step4","_step4$value","_iterator5","_step5","values"],"sources":["/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@tldraw/store/src/lib/executeQuery.ts"],"sourcesContent":["import { IdOf, UnknownRecord } from './BaseRecord'\nimport { intersectSets } from './setUtils'\nimport { StoreQueries } from './StoreQueries'\n\nexport type ValueMatcher<T> = { eq: T } | { neq: T } | { gt: number }\n\nexport type QueryExpression<R extends object> = {\n\t[k in keyof R & string]?: ValueMatcher<R[k]>\n\t// todo: handle nesting\n\t// | (R[k] extends object ? { match: QueryExpression<R[k]> } : never)\n}\n\nexport function objectMatchesQuery<T extends object>(query: QueryExpression<T>, object: T) {\n\tfor (const [key, _matcher] of Object.entries(query)) {\n\t\tconst matcher = _matcher as ValueMatcher<T>\n\t\tconst value = object[key as keyof T]\n\t\t// if you add matching logic here, make sure you also update executeQuery,\n\t\t// where initial data is pulled out of the indexes, since that requires different\n\t\t// matching logic\n\t\tif ('eq' in matcher && value !== matcher.eq) return false\n\t\tif ('neq' in matcher && value === matcher.neq) return false\n\t\tif ('gt' in matcher && (typeof value !== 'number' || value <= matcher.gt)) return false\n\t}\n\treturn true\n}\n\nexport function executeQuery<R extends UnknownRecord, TypeName extends R['typeName']>(\n\tstore: StoreQueries<R>,\n\ttypeName: TypeName,\n\tquery: QueryExpression<Extract<R, { typeName: TypeName }>>\n): Set<IdOf<Extract<R, { typeName: TypeName }>>> {\n\tconst matchIds = Object.fromEntries(Object.keys(query).map((key) => [key, new Set()]))\n\n\tfor (const [k, matcher] of Object.entries(query)) {\n\t\tif ('eq' in matcher) {\n\t\t\tconst index = store.index(typeName, k as any)\n\t\t\tconst ids = index.value.get(matcher.eq)\n\t\t\tif (ids) {\n\t\t\t\tfor (const id of ids) {\n\t\t\t\t\tmatchIds[k].add(id)\n\t\t\t\t}\n\t\t\t}\n\t\t} else if ('neq' in matcher) {\n\t\t\tconst index = store.index(typeName, k as any)\n\t\t\tfor (const [value, ids] of index.value) {\n\t\t\t\tif (value !== matcher.neq) {\n\t\t\t\t\tfor (const id of ids) {\n\t\t\t\t\t\tmatchIds[k].add(id)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if ('gt' in matcher) {\n\t\t\tconst index = store.index(typeName, k as any)\n\t\t\tfor (const [value, ids] of index.value) {\n\t\t\t\tif (value > matcher.gt) {\n\t\t\t\t\tfor (const id of ids) {\n\t\t\t\t\t\tmatchIds[k].add(id)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn intersectSets(Object.values(matchIds)) as Set<IdOf<Extract<R, { typeName: TypeName }>>>\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}