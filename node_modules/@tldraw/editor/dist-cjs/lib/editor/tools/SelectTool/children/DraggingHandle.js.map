{
  "version": 3,
  "sources": ["../../../../../../src/lib/editor/tools/SelectTool/children/DraggingHandle.ts"],
  "sourcesContent": ["import { sortByIndex } from '@tldraw/indices'\nimport { Matrix2d, snapAngle, Vec2d } from '@tldraw/primitives'\nimport {\n\tTLArrowShape,\n\tTLArrowShapeTerminal,\n\tTLHandle,\n\tTLShapeId,\n\tTLShapePartial,\n} from '@tldraw/tlschema'\nimport { deepCopy } from '@tldraw/utils'\nimport {\n\tTLCancelEvent,\n\tTLEnterEventHandler,\n\tTLEventHandlers,\n\tTLKeyboardEvent,\n\tTLPointerEventInfo,\n} from '../../../types/event-types'\nimport { StateNode } from '../../StateNode'\n\nexport class DraggingHandle extends StateNode {\n\tstatic id = 'dragging_handle'\n\n\tshapeId = '' as TLShapeId\n\tinitialHandle = {} as TLHandle\n\tinitialAdjacentHandle = null as TLHandle | null\n\n\tmarkId = ''\n\tinitialPageTransform: any\n\tinitialPageRotation: any\n\n\tinfo = {} as TLPointerEventInfo & {\n\t\tshape: TLArrowShape\n\t\ttarget: 'handle'\n\t\tonInteractionEnd?: string\n\t\tisCreating: boolean\n\t}\n\n\tisPrecise = false\n\tisPreciseId = null as TLShapeId | null\n\tpointingId = null as TLShapeId | null\n\n\tonEnter: TLEnterEventHandler = (\n\t\tinfo: TLPointerEventInfo & {\n\t\t\tshape: TLArrowShape\n\t\t\ttarget: 'handle'\n\t\t\tonInteractionEnd?: string\n\t\t\tisCreating: boolean\n\t\t}\n\t) => {\n\t\tconst { shape, isCreating, handle } = info\n\t\tthis.info = info\n\t\tthis.shapeId = shape.id\n\t\tthis.markId = isCreating ? 'creating' : this.editor.mark('dragging handle')\n\t\tthis.initialHandle = deepCopy(handle)\n\t\tthis.initialPageTransform = this.editor.getPageTransform(shape)!\n\t\tthis.initialPageRotation = this.editor.getPageRotation(shape)!\n\n\t\tthis.editor.setCursor({ type: isCreating ? 'cross' : 'grabbing', rotation: 0 })\n\n\t\t// <!-- Only relevant to arrows\n\t\tconst handles = this.editor.getShapeUtil(shape).handles(shape).sort(sortByIndex)\n\t\tconst index = handles.findIndex((h) => h.id === info.handle.id)\n\n\t\t// Find the adjacent handle\n\t\tthis.initialAdjacentHandle = null\n\n\t\t// Start from the handle and work forward\n\t\tfor (let i = index + 1; i < handles.length; i++) {\n\t\t\tconst handle = handles[i]\n\t\t\tif (handle.type === 'vertex' && handle.id !== 'middle' && handle.id !== info.handle.id) {\n\t\t\t\tthis.initialAdjacentHandle = handle\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\t// If still no handle, start from the end and work backward\n\t\tif (!this.initialAdjacentHandle) {\n\t\t\tfor (let i = handles.length - 1; i >= 0; i--) {\n\t\t\t\tconst handle = handles[i]\n\t\t\t\tif (handle.type === 'vertex' && handle.id !== 'middle' && handle.id !== info.handle.id) {\n\t\t\t\t\tthis.initialAdjacentHandle = handle\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst initialTerminal = shape.props[info.handle.id as 'start' | 'end']\n\n\t\tthis.isPrecise = false\n\n\t\tif (initialTerminal?.type === 'binding') {\n\t\t\tthis.editor.setHintingIds([initialTerminal.boundShapeId])\n\n\t\t\tthis.isPrecise = !Vec2d.Equals(initialTerminal.normalizedAnchor, { x: 0.5, y: 0.5 })\n\t\t\tif (this.isPrecise) {\n\t\t\t\tthis.isPreciseId = initialTerminal.boundShapeId\n\t\t\t} else {\n\t\t\t\tthis.resetExactTimeout()\n\t\t\t}\n\t\t}\n\t\t// -->\n\n\t\tthis.update()\n\t}\n\n\t// Only relevant to arrows\n\tprivate exactTimeout = -1 as any\n\n\t// Only relevant to arrows\n\tprivate resetExactTimeout() {\n\t\tif (this.exactTimeout !== -1) {\n\t\t\tthis.clearExactTimeout()\n\t\t}\n\n\t\tthis.exactTimeout = setTimeout(() => {\n\t\t\tif (this.isActive && !this.isPrecise) {\n\t\t\t\tthis.isPrecise = true\n\t\t\t\tthis.isPreciseId = this.pointingId\n\t\t\t\tthis.update()\n\t\t\t}\n\t\t\tthis.exactTimeout = -1\n\t\t}, 750)\n\t}\n\n\t// Only relevant to arrows\n\tprivate clearExactTimeout() {\n\t\tif (this.exactTimeout !== -1) {\n\t\t\tclearTimeout(this.exactTimeout)\n\t\t\tthis.exactTimeout = -1\n\t\t}\n\t}\n\n\tonPointerMove: TLEventHandlers['onPointerMove'] = () => {\n\t\tthis.update()\n\t}\n\n\tonKeyDown: TLKeyboardEvent | undefined = () => {\n\t\tthis.update()\n\t}\n\n\tonKeyUp: TLKeyboardEvent | undefined = () => {\n\t\tthis.update()\n\t}\n\n\tonPointerUp: TLEventHandlers['onPointerUp'] = () => {\n\t\tthis.complete()\n\t}\n\n\tonComplete: TLEventHandlers['onComplete'] = () => {\n\t\tthis.complete()\n\t}\n\n\tonCancel: TLCancelEvent = () => {\n\t\tthis.cancel()\n\t}\n\n\tonExit = () => {\n\t\tthis.editor.setHintingIds([])\n\t\tthis.editor.snaps.clear()\n\t\tthis.editor.setCursor({ type: 'default' })\n\t}\n\n\tprivate complete() {\n\t\tthis.editor.snaps.clear()\n\n\t\tconst { onInteractionEnd } = this.info\n\t\tif (this.editor.instanceState.isToolLocked && onInteractionEnd) {\n\t\t\t// Return to the tool that was active before this one,\n\t\t\t// but only if tool lock is turned on!\n\t\t\tthis.editor.setSelectedTool(onInteractionEnd, { shapeId: this.shapeId })\n\t\t\treturn\n\t\t}\n\n\t\tthis.parent.transition('idle', {})\n\t}\n\n\tprivate cancel() {\n\t\tthis.editor.bailToMark(this.markId)\n\t\tthis.editor.snaps.clear()\n\n\t\tconst { onInteractionEnd } = this.info\n\t\tif (onInteractionEnd) {\n\t\t\t// Return to the tool that was active before this one,\n\t\t\t// whether tool lock is turned on or not!\n\t\t\tthis.editor.setSelectedTool(onInteractionEnd, { shapeId: this.shapeId })\n\t\t\treturn\n\t\t}\n\n\t\tthis.parent.transition('idle', {})\n\t}\n\n\tprivate update() {\n\t\tconst { editor, shapeId } = this\n\t\tconst { initialHandle, initialPageRotation, initialAdjacentHandle } = this\n\t\tconst {\n\t\t\tisSnapMode,\n\t\t\thintingIds,\n\t\t\tsnaps,\n\t\t\tinputs: { currentPagePoint, originPagePoint, shiftKey, ctrlKey, altKey, pointerVelocity },\n\t\t} = editor\n\n\t\tconst shape = editor.getShapeById(shapeId)\n\t\tif (!shape) return\n\n\t\tconst util = editor.getShapeUtil(shape)\n\n\t\tlet point = currentPagePoint\n\t\t\t.clone()\n\t\t\t.sub(originPagePoint)\n\t\t\t.rot(-initialPageRotation)\n\t\t\t.add(initialHandle)\n\n\t\tif (shiftKey && initialAdjacentHandle && initialHandle.id !== 'middle') {\n\t\t\tconst angle = Vec2d.Angle(initialAdjacentHandle, point)\n\t\t\tconst snappedAngle = snapAngle(angle, 24)\n\t\t\tconst angleDifference = snappedAngle - angle\n\t\t\tpoint = Vec2d.RotWith(point, initialAdjacentHandle, angleDifference)\n\t\t}\n\n\t\t// Clear any existing snaps\n\t\teditor.snaps.clear()\n\n\t\tif (isSnapMode ? !ctrlKey : ctrlKey) {\n\t\t\t// We're snapping\n\t\t\tconst pageTransform = editor.getPageTransformById(shape.id)\n\t\t\tif (!pageTransform) throw Error('Expected a page transform')\n\n\t\t\t// Get all the outline segments from the shape\n\t\t\tconst additionalSegments = util\n\t\t\t\t.outlineSegments(shape)\n\t\t\t\t.map((segment) => Matrix2d.applyToPoints(pageTransform, segment))\n\n\t\t\t// We want to skip the segments that include the handle, so\n\t\t\t// find the index of the handle that shares the same index property\n\t\t\t// as the initial dragging handle; this catches a quirk of create handles\n\t\t\tconst handleIndex = util\n\t\t\t\t.handles(shape)\n\t\t\t\t.filter(({ type }) => type === 'vertex')\n\t\t\t\t.sort(sortByIndex)\n\t\t\t\t.findIndex(({ index }) => initialHandle.index === index)\n\n\t\t\tadditionalSegments.splice(handleIndex - 1, 2)\n\n\t\t\tconst snapDelta = snaps.getSnappingHandleDelta({\n\t\t\t\tadditionalSegments,\n\t\t\t\thandlePoint: Matrix2d.applyToPoint(pageTransform, point),\n\t\t\t})\n\n\t\t\tif (snapDelta) {\n\t\t\t\tpoint.add(editor.getDeltaInShapeSpace(shape, snapDelta))\n\t\t\t}\n\t\t}\n\n\t\tconst changes = util.onHandleChange?.(shape, {\n\t\t\thandle: {\n\t\t\t\t...initialHandle,\n\t\t\t\tx: point.x,\n\t\t\t\ty: point.y,\n\t\t\t},\n\t\t\tisPrecise: this.isPrecise || altKey,\n\t\t})\n\n\t\tconst next: TLShapePartial<any> = { ...shape, ...changes }\n\n\t\t// Arrows\n\t\tif (initialHandle.canBind) {\n\t\t\tconst bindingAfter = (next.props as any)[initialHandle.id] as TLArrowShapeTerminal | undefined\n\n\t\t\tif (bindingAfter?.type === 'binding') {\n\t\t\t\tif (hintingIds[0] !== bindingAfter.boundShapeId) {\n\t\t\t\t\teditor.setHintingIds([bindingAfter.boundShapeId])\n\t\t\t\t\tthis.pointingId = bindingAfter.boundShapeId\n\t\t\t\t\tthis.isPrecise = pointerVelocity.len() < 0.5 || altKey\n\t\t\t\t\tthis.isPreciseId = this.isPrecise ? bindingAfter.boundShapeId : null\n\t\t\t\t\tthis.resetExactTimeout()\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (hintingIds.length > 0) {\n\t\t\t\t\teditor.setHintingIds([])\n\t\t\t\t\tthis.pointingId = null\n\t\t\t\t\tthis.isPrecise = false\n\t\t\t\t\tthis.isPreciseId = null\n\t\t\t\t\tthis.resetExactTimeout()\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (changes) {\n\t\t\teditor.updateShapes([next], true)\n\t\t}\n\t}\n}\n"],
  "mappings": "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",
  "names": ["handle"]
}
