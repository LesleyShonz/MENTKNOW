{
  "version": 3,
  "sources": ["../../../src/lib/editor/Editor.ts"],
  "sourcesContent": ["import {\n\tgetIndexAbove,\n\tgetIndexBetween,\n\tgetIndices,\n\tgetIndicesAbove,\n\tgetIndicesBetween,\n\tsortByIndex,\n} from '@tldraw/indices'\nimport {\n\tBox2d,\n\tEASINGS,\n\tMatLike,\n\tMatrix2d,\n\tMatrix2dModel,\n\tPI2,\n\tVec2d,\n\tVecLike,\n\tapproximately,\n\tareAnglesCompatible,\n\tclamp,\n\tintersectPolygonPolygon,\n\tpointInPolygon,\n} from '@tldraw/primitives'\nimport { ComputedCache, RecordType } from '@tldraw/store'\nimport {\n\tBox2dModel,\n\tCameraRecordType,\n\tDefaultColorStyle,\n\tDefaultFontStyle,\n\tInstancePageStateRecordType,\n\tPageRecordType,\n\tStyleProp,\n\tTLArrowShape,\n\tTLAsset,\n\tTLAssetId,\n\tTLAssetPartial,\n\tTLCursor,\n\tTLCursorType,\n\tTLDOCUMENT_ID,\n\tTLDocument,\n\tTLFrameShape,\n\tTLGroupShape,\n\tTLINSTANCE_ID,\n\tTLImageAsset,\n\tTLInstance,\n\tTLInstancePageState,\n\tTLPOINTER_ID,\n\tTLPage,\n\tTLPageId,\n\tTLParentId,\n\tTLRecord,\n\tTLScribble,\n\tTLShape,\n\tTLShapeId,\n\tTLShapePartial,\n\tTLStore,\n\tTLUnknownShape,\n\tTLVideoAsset,\n\tVec2dModel,\n\tcreateShapeId,\n\tgetShapePropKeysByStyle,\n\tisPageId,\n\tisShape,\n\tisShapeId,\n} from '@tldraw/tlschema'\nimport {\n\tannotateError,\n\tassert,\n\tcompact,\n\tdedupe,\n\tdeepCopy,\n\tgetOwnProperty,\n\thasOwnProperty,\n\tobjectMapFromEntries,\n\tpartition,\n\tsortById,\n\tstructuredClone,\n} from '@tldraw/utils'\nimport { EventEmitter } from 'eventemitter3'\nimport { nanoid } from 'nanoid'\nimport { EMPTY_ARRAY, atom, computed, transact } from 'signia'\nimport { TLUser, createTLUser } from '../config/createTLUser'\nimport { checkShapesAndAddCore } from '../config/defaultShapes'\nimport { AnyTLShapeInfo } from '../config/defineShape'\nimport {\n\tANIMATION_MEDIUM_MS,\n\tCAMERA_MAX_RENDERING_INTERVAL,\n\tCAMERA_MOVING_TIMEOUT,\n\tCOARSE_DRAG_DISTANCE,\n\tCOLLABORATOR_TIMEOUT,\n\tDEFAULT_ANIMATION_OPTIONS,\n\tDRAG_DISTANCE,\n\tFOLLOW_CHASE_PAN_SNAP,\n\tFOLLOW_CHASE_PAN_UNSNAP,\n\tFOLLOW_CHASE_PROPORTION,\n\tFOLLOW_CHASE_ZOOM_SNAP,\n\tFOLLOW_CHASE_ZOOM_UNSNAP,\n\tGRID_INCREMENT,\n\tHAND_TOOL_FRICTION,\n\tINTERNAL_POINTER_IDS,\n\tMAJOR_NUDGE_FACTOR,\n\tMAX_PAGES,\n\tMAX_SHAPES_PER_PAGE,\n\tMAX_ZOOM,\n\tMINOR_NUDGE_FACTOR,\n\tMIN_ZOOM,\n\tSVG_PADDING,\n\tZOOMS,\n} from '../constants'\nimport { exportPatternSvgDefs } from '../hooks/usePattern'\nimport { ReadonlySharedStyleMap, SharedStyle, SharedStyleMap } from '../utils/SharedStylesMap'\nimport { WeakMapCache } from '../utils/WeakMapCache'\nimport { dataUrlToFile } from '../utils/assets'\nimport { getIncrementedName, uniqueId } from '../utils/data'\nimport { applyRotationToSnapshotShapes, getRotationSnapshot } from '../utils/rotation'\nimport { arrowBindingsIndex } from './derivations/arrowBindingsIndex'\nimport { parentsToChildrenWithIndexes } from './derivations/parentsToChildrenWithIndexes'\nimport { deriveShapeIdsInCurrentPage } from './derivations/shapeIdsInCurrentPage'\nimport { ActiveAreaManager, getActiveAreaScreenSpace } from './managers/ActiveAreaManager'\nimport { ClickManager } from './managers/ClickManager'\nimport { DprManager } from './managers/DprManager'\nimport { ExternalContentManager, TLExternalContent } from './managers/ExternalContentManager'\nimport { HistoryManager } from './managers/HistoryManager'\nimport { SnapManager } from './managers/SnapManager'\nimport { TextManager } from './managers/TextManager'\nimport { TickManager } from './managers/TickManager'\nimport { UserPreferencesManager } from './managers/UserPreferencesManager'\nimport { ShapeUtil, TLResizeMode } from './shapes/ShapeUtil'\nimport { ArrowShapeUtil } from './shapes/arrow/ArrowShapeUtil'\nimport { getCurvedArrowInfo } from './shapes/arrow/arrow/curved-arrow'\nimport { getArrowTerminalsInArrowSpace, getIsArrowStraight } from './shapes/arrow/arrow/shared'\nimport { getStraightArrowInfo } from './shapes/arrow/arrow/straight-arrow'\nimport { FrameShapeUtil } from './shapes/frame/FrameShapeUtil'\nimport { GroupShapeUtil } from './shapes/group/GroupShapeUtil'\nimport { TLExportColors } from './shapes/shared/TLExportColors'\nimport { TextShapeUtil } from './shapes/text/TextShapeUtil'\nimport { RootState } from './tools/RootState'\nimport { StateNode, TLStateNodeConstructor } from './tools/StateNode'\nimport { TLContent } from './types/clipboard-types'\nimport { TLEventMap } from './types/emit-types'\nimport { TLEventInfo, TLPinchEventInfo, TLPointerEventInfo } from './types/event-types'\nimport { RequiredKeys } from './types/misc-types'\nimport { TLResizeHandle } from './types/selection-types'\n\n/** @public */\nexport type TLAnimationOptions = Partial<{\n\tduration: number\n\teasing: typeof EASINGS.easeInOutCubic\n}>\n\n/** @public */\nexport type TLViewportOptions = Partial<{\n\t/** Whether to animate the viewport change or not. Defaults to true. */\n\tstopFollowing: boolean\n}>\n\n/** @public */\nexport interface TLEditorOptions {\n\t/**\n\t * The Store instance to use for keeping the app's data. This may be prepopulated, e.g. by loading\n\t * from a server or database.\n\t */\n\tstore: TLStore\n\t/**\n\t * An array of shapes to use in the editor. These will be used to create and manage shapes in the editor.\n\t */\n\tshapes: readonly AnyTLShapeInfo[]\n\t/**\n\t * An array of tools to use in the editor. These will be used to handle events and manage user interactions in the editor.\n\t */\n\ttools: readonly TLStateNodeConstructor[]\n\t/**\n\t * A user defined externally to replace the default user.\n\t */\n\tuser?: TLUser\n\t/**\n\t * Should return a containing html element which has all the styles applied to the editor. If not\n\t * given, the body element will be used.\n\t */\n\tgetContainer: () => HTMLElement\n}\n\n/** @public */\nexport class Editor extends EventEmitter<TLEventMap> {\n\tconstructor({ store, user, shapes, tools, getContainer }: TLEditorOptions) {\n\t\tsuper()\n\n\t\tthis.store = store\n\n\t\tthis.user = new UserPreferencesManager(user ?? createTLUser())\n\n\t\tthis.getContainer = getContainer ?? (() => document.body)\n\n\t\tthis.textMeasure = new TextManager(this)\n\n\t\tthis.root = new RootState(this)\n\n\t\tconst allShapes = checkShapesAndAddCore(shapes)\n\n\t\tconst shapeTypesInSchema = new Set(\n\t\t\tObject.keys(store.schema.types.shape.migrations.subTypeMigrations!)\n\t\t)\n\t\tfor (const shape of allShapes) {\n\t\t\tif (!shapeTypesInSchema.has(shape.type)) {\n\t\t\t\tthrow Error(\n\t\t\t\t\t`Editor and store have different shapes: \"${shape.type}\" was passed into the editor but not the schema`\n\t\t\t\t)\n\t\t\t}\n\t\t\tshapeTypesInSchema.delete(shape.type)\n\t\t}\n\t\tif (shapeTypesInSchema.size > 0) {\n\t\t\tthrow Error(\n\t\t\t\t`Editor and store have different shapes: \"${\n\t\t\t\t\t[...shapeTypesInSchema][0]\n\t\t\t\t}\" is present in the store schema but not provided to the editor`\n\t\t\t)\n\t\t}\n\t\tconst shapeUtils = {} as Record<string, ShapeUtil>\n\t\tconst allStylesById = new Map<string, StyleProp<unknown>>()\n\n\t\tfor (const { util: Util, props } of allShapes) {\n\t\t\tconst propKeysByStyle = getShapePropKeysByStyle(props ?? {})\n\t\t\tshapeUtils[Util.type] = new Util(this, Util.type, propKeysByStyle)\n\n\t\t\tfor (const style of propKeysByStyle.keys()) {\n\t\t\t\tif (!allStylesById.has(style.id)) {\n\t\t\t\t\tallStylesById.set(style.id, style)\n\t\t\t\t} else if (allStylesById.get(style.id) !== style) {\n\t\t\t\t\tthrow Error(\n\t\t\t\t\t\t`Multiple style props with id \"${style.id}\" in use. Style prop IDs must be unique.`\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.shapeUtils = shapeUtils\n\n\t\t// Tools.\n\t\t// Accept tools from constructor parameters which may not conflict with the root note's default or\n\t\t// \"baked in\" tools, select and zoom.\n\t\tfor (const { tool: Tool } of allShapes) {\n\t\t\tif (Tool) {\n\t\t\t\tif (hasOwnProperty(this.root.children!, Tool.id)) {\n\t\t\t\t\tthrow Error(`Can't override tool with id \"${Tool.id}\"`)\n\t\t\t\t}\n\t\t\t\tthis.root.children![Tool.id] = new Tool(this)\n\t\t\t}\n\t\t}\n\t\tfor (const Tool of tools) {\n\t\t\tif (hasOwnProperty(this.root.children!, Tool.id)) {\n\t\t\t\tthrow Error(`Can't override tool with id \"${Tool.id}\"`)\n\t\t\t}\n\t\t\tthis.root.children![Tool.id] = new Tool(this)\n\t\t}\n\n\t\tif (typeof window !== 'undefined' && 'navigator' in window) {\n\t\t\tthis.isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent)\n\t\t\tthis.isIos = !!navigator.userAgent.match(/iPad/i) || !!navigator.userAgent.match(/iPhone/i)\n\t\t\tthis.isChromeForIos = /crios.*safari/i.test(navigator.userAgent)\n\t\t} else {\n\t\t\tthis.isSafari = false\n\t\t\tthis.isIos = false\n\t\t\tthis.isChromeForIos = false\n\t\t}\n\n\t\tthis.store.onBeforeDelete = (record) => {\n\t\t\tif (record.typeName === 'shape') {\n\t\t\t\tthis._shapeWillBeDeleted(record)\n\t\t\t} else if (record.typeName === 'page') {\n\t\t\t\tthis._pageWillBeDeleted(record)\n\t\t\t}\n\t\t}\n\n\t\tthis.store.onAfterChange = (prev, next) => {\n\t\t\tthis._updateDepth++\n\t\t\tif (this._updateDepth > 1000) {\n\t\t\t\tconsole.error('[onAfterChange] Maximum update depth exceeded, bailing out.')\n\t\t\t}\n\t\t\tif (prev.typeName === 'shape' && next.typeName === 'shape') {\n\t\t\t\tthis._shapeDidChange(prev, next)\n\t\t\t} else if (\n\t\t\t\tprev.typeName === 'instance_page_state' &&\n\t\t\t\tnext.typeName === 'instance_page_state'\n\t\t\t) {\n\t\t\t\tthis._pageStateDidChange(prev, next)\n\t\t\t}\n\n\t\t\tthis._updateDepth--\n\t\t}\n\t\tthis.store.onAfterCreate = (record) => {\n\t\t\tif (record.typeName === 'shape' && this.isShapeOfType(record, ArrowShapeUtil)) {\n\t\t\t\tthis._arrowDidUpdate(record)\n\t\t\t}\n\t\t\tif (record.typeName === 'page') {\n\t\t\t\tconst cameraId = CameraRecordType.createId(record.id)\n\t\t\t\tconst pageStateId = InstancePageStateRecordType.createId(record.id)\n\t\t\t\tif (!this.store.has(cameraId)) {\n\t\t\t\t\tthis.store.put([CameraRecordType.create({ id: cameraId })])\n\t\t\t\t}\n\t\t\t\tif (!this.store.has(pageStateId)) {\n\t\t\t\t\tthis.store.put([\n\t\t\t\t\t\tInstancePageStateRecordType.create({ id: pageStateId, pageId: record.id }),\n\t\t\t\t\t])\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis._currentPageShapeIds = deriveShapeIdsInCurrentPage(this.store, () => this.currentPageId)\n\t\tthis._parentIdsToChildIds = parentsToChildrenWithIndexes(this.store)\n\n\t\tthis.disposables.add(\n\t\t\tthis.store.listen((changes) => {\n\t\t\t\tthis.emit('change', changes)\n\t\t\t})\n\t\t)\n\n\t\tconst container = this.getContainer()\n\t\tconst focusin = () => {\n\t\t\tthis._isFocused.set(true)\n\t\t}\n\t\tconst focusout = () => {\n\t\t\tthis._isFocused.set(false)\n\t\t}\n\n\t\tcontainer.addEventListener('focusin', focusin)\n\t\tcontainer.addEventListener('focus', focusin)\n\t\tcontainer.addEventListener('focusout', focusout)\n\t\tcontainer.addEventListener('blur', focusout)\n\n\t\tthis.disposables.add(() => {\n\t\t\tcontainer.removeEventListener('focusin', focusin)\n\t\t\tcontainer.removeEventListener('focus', focusin)\n\t\t\tcontainer.removeEventListener('focusout', focusout)\n\t\t\tcontainer.removeEventListener('blur', focusout)\n\t\t})\n\n\t\tthis.store.ensureStoreIsUsable()\n\n\t\t// clear ephemeral state\n\t\tthis.setInstancePageState(\n\t\t\t{\n\t\t\t\teditingId: null,\n\t\t\t\thoveredId: null,\n\t\t\t\terasingIds: [],\n\t\t\t},\n\t\t\ttrue\n\t\t)\n\n\t\tthis.root.enter(undefined, 'initial')\n\n\t\tif (this.instanceState.followingUserId) {\n\t\t\tthis.stopFollowingUser()\n\t\t}\n\n\t\tthis.updateRenderingBounds()\n\n\t\trequestAnimationFrame(() => {\n\t\t\tthis._tickManager.start()\n\t\t})\n\t}\n\n\t/**\n\t * The editor's store\n\t *\n\t * @public\n\t */\n\treadonly store: TLStore\n\n\t/**\n\t * The root state of the statechart.\n\t *\n\t * @public\n\t */\n\treadonly root: RootState\n\n\t/**\n\t * A set of functions to call when the app is disposed.\n\t *\n\t * @public\n\t */\n\treadonly disposables = new Set<() => void>()\n\n\t/** @internal */\n\tprivate _dprManager = new DprManager(this)\n\n\t/** @internal */\n\tprivate _activeAreaManager = new ActiveAreaManager(this)\n\n\t/** @internal */\n\tprivate _tickManager = new TickManager(this)\n\n\t/** @internal */\n\tprivate _updateDepth = 0\n\n\t/** @public */\n\texternalContentManager = new ExternalContentManager(this)\n\n\t/**\n\t * A manager for the app's snapping feature.\n\t *\n\t * @public\n\t */\n\treadonly snaps = new SnapManager(this)\n\n\t/**\n\t * A manager for the user and their preferences.\n\t *\n\t * @public\n\t */\n\treadonly user: UserPreferencesManager\n\n\t/**\n\t * Whether the editor is running in Safari.\n\t *\n\t * @public\n\t */\n\treadonly isSafari: boolean\n\n\t/**\n\t * Whether the editor is running on iOS.\n\t *\n\t * @public\n\t */\n\treadonly isIos: boolean\n\n\t/**\n\t * Whether the editor is running on iOS.\n\t *\n\t * @public\n\t */\n\treadonly isChromeForIos: boolean\n\n\t/**\n\t * The current HTML element containing the editor.\n\t *\n\t * @example\n\t * ```ts\n\t * const container = editor.getContainer()\n\t * ```\n\t *\n\t * @public\n\t */\n\tgetContainer: () => HTMLElement\n\n\t/**\n\t * A cache of page transforms.\n\t *\n\t * @internal\n\t */\n\t@computed private get _pageTransformCache(): ComputedCache<Matrix2d, TLShape> {\n\t\treturn this.store.createComputedCache<Matrix2d, TLShape>('pageTransformCache', (shape) => {\n\t\t\tif (isPageId(shape.parentId)) {\n\t\t\t\treturn this.getTransform(shape)\n\t\t\t}\n\n\t\t\t// If the shape's parent doesn't exist yet (e.g. when merging in changes from remote in the wrong order)\n\t\t\t// then we can't compute the transform yet, so just return the identity matrix.\n\t\t\t// In the future we should look at creating a store update mechanism that understands and preserves\n\t\t\t// ordering.\n\t\t\tconst parent = this._pageTransformCache.get(shape.parentId) ?? Matrix2d.Identity()\n\n\t\t\treturn Matrix2d.Compose(parent, this.getTransform(shape))\n\t\t})\n\t}\n\n\t/**\n\t * A cache of axis aligned page bounding boxes.\n\t *\n\t * @internal\n\t */\n\t@computed private get _pageBoundsCache(): ComputedCache<Box2d, TLShape> {\n\t\treturn this.store.createComputedCache<Box2d, TLShape>('pageBoundsCache', (shape) => {\n\t\t\tconst pageTransform = this._pageTransformCache.get(shape.id)\n\n\t\t\tif (!pageTransform) return new Box2d()\n\n\t\t\tconst result = Box2d.FromPoints(\n\t\t\t\tMatrix2d.applyToPoints(pageTransform, this.getShapeUtil(shape).outline(shape))\n\t\t\t)\n\n\t\t\treturn result\n\t\t})\n\t}\n\n\t/**\n\t * Dispose the editor.\n\t *\n\t * @public\n\t */\n\tdispose() {\n\t\tthis.disposables.forEach((dispose) => dispose())\n\t\tthis.disposables.clear()\n\t}\n\n\t/**\n\t * A manager for the app's history.\n\t *\n\t * @readonly\n\t */\n\treadonly history = new HistoryManager(\n\t\tthis,\n\t\t() => this._complete(),\n\t\t(error) => {\n\t\t\tthis.annotateError(error, { origin: 'history.batch', willCrashApp: true })\n\t\t\tthis.crash(error)\n\t\t}\n\t)\n\n\t/**\n\t * Undo to the last mark.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.undo()\n\t * ```\n\t *\n\t * @public\n\t */\n\tundo() {\n\t\treturn this.history.undo()\n\t}\n\n\t/**\n\t * Whether the app can undo.\n\t *\n\t * @public\n\t */\n\t@computed get canUndo() {\n\t\treturn this.history.numUndos > 0\n\t}\n\n\t/**\n\t * Redo to the next mark.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.redo()\n\t * ```\n\t *\n\t * @public\n\t */\n\tredo() {\n\t\tthis.history.redo()\n\t\treturn this\n\t}\n\n\t/**\n\t * Whether the app can redo.\n\t *\n\t * @public\n\t */\n\t@computed get canRedo() {\n\t\treturn this.history.numRedos > 0\n\t}\n\n\t/**\n\t * Create a new \"mark\", or stopping point, in the undo redo history. Creating a mark will clear\n\t * any redos.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.mark()\n\t * editor.mark('flip shapes')\n\t * ```\n\t *\n\t * @param reason - The reason for the mark.\n\t * @param onUndo - Whether to stop at the mark when undoing.\n\t * @param onRedo - Whether to stop at the mark when redoing.\n\t *\n\t * @public\n\t */\n\tmark(reason?: string, onUndo?: boolean, onRedo?: boolean) {\n\t\treturn this.history.mark(reason, onUndo, onRedo)\n\t}\n\n\t/**\n\t * Clear all marks in the undo stack back to the next mark.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.bail()\n\t * ```\n\t *\n\t * @public\n\t */\n\tbail() {\n\t\tthis.history.bail()\n\t\treturn this\n\t}\n\n\t/**\n\t * Clear all marks in the undo stack back to the mark with the provided mark id.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.bailToMark('creating')\n\t * ```\n\t *\n\t * @public\n\t */\n\tbailToMark(id: string) {\n\t\tthis.history.bailToMark(id)\n\t\treturn this\n\t}\n\n\t/**\n\t * Run a function in a batch, which will be undone/redone as a single action.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.batch(() => {\n\t * \teditor.selectAll()\n\t * \teditor.deleteShapes()\n\t * \teditor.createShapes(myShapes)\n\t * \teditor.selectNone()\n\t * })\n\t *\n\t * editor.undo() // will undo all of the above\n\t * ```\n\t *\n\t * @public\n\t */\n\tbatch(fn: () => void) {\n\t\tthis.history.batch(fn)\n\t\treturn this\n\t}\n\n\t/**\n\t * A map of shape utility classes (TLShapeUtils) by shape type.\n\t *\n\t * @public\n\t */\n\tshapeUtils: { readonly [K in string]?: ShapeUtil<TLUnknownShape> }\n\n\t/**\n\t * Get a shape util by its definition.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.getShapeUtil(ArrowShapeUtil)\n\t * ```\n\t *\n\t * @param util - The shape util.\n\t *\n\t * @public\n\t */\n\tgetShapeUtil<C extends { new (...args: any[]): ShapeUtil<any>; type: string }>(\n\t\tutil: C\n\t): InstanceType<C>\n\t/**\n\t * Get a shape util from a shape itself.\n\t *\n\t * @example\n\t * ```ts\n\t * const util = editor.getShapeUtil(myShape)\n\t * const util = editor.getShapeUtil<ArrowShapeUtil>(myShape)\n\t * const util = editor.getShapeUtil(ArrowShapeUtil)\n\t * ```\n\t *\n\t * @param shape - A shape or shape partial.\n\t *\n\t * @public\n\t */\n\tgetShapeUtil<S extends TLUnknownShape>(shape: S | TLShapePartial<S>): ShapeUtil<S>\n\tgetShapeUtil<T extends ShapeUtil>(shapeUtilConstructor: {\n\t\ttype: T extends ShapeUtil<infer R> ? R['type'] : string\n\t}): T {\n\t\tconst shapeUtil = getOwnProperty(this.shapeUtils, shapeUtilConstructor.type) as T | undefined\n\t\tassert(shapeUtil, `No shape util found for type \"${shapeUtilConstructor.type}\"`)\n\n\t\t// does shapeUtilConstructor extends ShapeUtil?\n\t\tif (\n\t\t\t'prototype' in shapeUtilConstructor &&\n\t\t\tshapeUtilConstructor.prototype instanceof ShapeUtil\n\t\t) {\n\t\t\tassert(\n\t\t\t\tshapeUtil instanceof (shapeUtilConstructor as any),\n\t\t\t\t`Shape util found for type \"${shapeUtilConstructor.type}\" is not an instance of the provided constructor`\n\t\t\t)\n\t\t}\n\n\t\treturn shapeUtil as T\n\t}\n\n\t/* ---------------------- Props --------------------- */\n\n\t/**\n\t * Get all the current styles among the users selected shapes\n\t *\n\t * @internal\n\t */\n\tprivate _extractSharedStyles(shape: TLShape, sharedStyleMap: SharedStyleMap) {\n\t\tif (this.isShapeOfType(shape, GroupShapeUtil)) {\n\t\t\t// For groups, ignore the styles of the group shape and instead include the styles of the\n\t\t\t// group's children. These are the shapes that would have their styles changed if the\n\t\t\t// user called `setStyle` on the current selection.\n\t\t\tconst childIds = this._parentIdsToChildIds.value[shape.id]\n\t\t\tif (!childIds) return\n\n\t\t\tfor (let i = 0, n = childIds.length; i < n; i++) {\n\t\t\t\tthis._extractSharedStyles(this.getShapeById(childIds[i][0])!, sharedStyleMap)\n\t\t\t}\n\t\t} else {\n\t\t\tconst util = this.getShapeUtil(shape)\n\t\t\tfor (const [style, value] of util.iterateStyles(shape)) {\n\t\t\t\tsharedStyleMap.applyValue(style, value)\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * A derived map containing all current styles among the user's selected shapes.\n\t *\n\t * @internal\n\t */\n\tprivate _selectionSharedStyles = computed<ReadonlySharedStyleMap>(\n\t\t'_selectionSharedStyles',\n\t\t() => {\n\t\t\tconst { selectedShapes } = this\n\n\t\t\tconst sharedStyles = new SharedStyleMap()\n\t\t\tfor (const selectedShape of selectedShapes) {\n\t\t\t\tthis._extractSharedStyles(selectedShape, sharedStyles)\n\t\t\t}\n\n\t\t\treturn sharedStyles\n\t\t}\n\t)\n\n\t@computed private get _stylesForNextShape() {\n\t\treturn this.instanceState.stylesForNextShape\n\t}\n\n\t/** @internal */\n\tgetStyleForNextShape<T>(style: StyleProp<T>): T {\n\t\tconst value = this._stylesForNextShape[style.id]\n\t\treturn value === undefined ? style.defaultValue : (value as T)\n\t}\n\n\t/**\n\t * A derived object containing either all current styles among the user's selected shapes, or\n\t * else the user's most recent style choices that correspond to the current active state (i.e.\n\t * the selected tool).\n\t *\n\t * @public\n\t */\n\t@computed<ReadonlySharedStyleMap>({ isEqual: (a, b) => a.equals(b) })\n\tget sharedStyles(): ReadonlySharedStyleMap {\n\t\t// If we're in selecting and if we have a selection, return the shared styles from the\n\t\t// current selection\n\t\tif (this.isIn('select') && this.selectedIds.length > 0) {\n\t\t\treturn this._selectionSharedStyles.value\n\t\t}\n\n\t\t// If the current tool is associated with a shape, return the styles for that shape.\n\t\t// Otherwise, just return an empty map.\n\t\tconst currentTool = this.root.current.value!\n\t\tconst styles = new SharedStyleMap()\n\t\tif (currentTool.shapeType) {\n\t\t\tfor (const style of this.getShapeUtil(currentTool.shapeType).styleProps.keys()) {\n\t\t\t\tstyles.applyValue(style, this.getStyleForNextShape(style))\n\t\t\t}\n\t\t}\n\n\t\treturn styles\n\t}\n\n\t/**\n\t * Get the currently selected shared opacity.\n\t * If any shapes are selected, this returns the shared opacity of the selected shapes.\n\t * Otherwise, this returns the chosen opacity for the next shape.\n\t *\n\t * @public\n\t */\n\t@computed get sharedOpacity(): SharedStyle<number> {\n\t\tif (this.isIn('select') && this.selectedIds.length > 0) {\n\t\t\tconst shapesToCheck: TLShape[] = []\n\t\t\tconst addShape = (shapeId: TLShapeId) => {\n\t\t\t\tconst shape = this.getShapeById(shapeId)\n\t\t\t\tif (!shape) return\n\t\t\t\t// For groups, ignore the opacity of the group shape and instead include\n\t\t\t\t// the opacity of the group's children. These are the shapes that would have\n\t\t\t\t// their opacity changed if the user called `setOpacity` on the current selection.\n\t\t\t\tif (this.isShapeOfType(shape, GroupShapeUtil)) {\n\t\t\t\t\tfor (const childId of this.getSortedChildIds(shape.id)) {\n\t\t\t\t\t\taddShape(childId)\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tshapesToCheck.push(shape)\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (const shapeId of this.selectedIds) {\n\t\t\t\taddShape(shapeId)\n\t\t\t}\n\n\t\t\tlet opacity: number | null = null\n\t\t\tfor (const shape of shapesToCheck) {\n\t\t\t\tif (opacity === null) {\n\t\t\t\t\topacity = shape.opacity\n\t\t\t\t} else if (opacity !== shape.opacity) {\n\t\t\t\t\treturn { type: 'mixed' }\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (opacity !== null) return { type: 'shared', value: opacity }\n\t\t}\n\t\treturn { type: 'shared', value: this.instanceState.opacityForNextShape }\n\t}\n\n\t/** @internal */\n\t@computed\n\tprivate get _arrowBindingsIndex() {\n\t\treturn arrowBindingsIndex(this)\n\t}\n\n\t/**\n\t * Get all arrows bound to a shape.\n\t *\n\t * @param shapeId - The id of the shape.\n\t *\n\t * @public\n\t */\n\tgetArrowsBoundTo(shapeId: TLShapeId) {\n\t\treturn this._arrowBindingsIndex.value[shapeId] || EMPTY_ARRAY\n\t}\n\n\t/** @internal */\n\tprivate _reparentArrow(arrowId: TLShapeId) {\n\t\tconst arrow = this.getShapeById<TLArrowShape>(arrowId)\n\t\tif (!arrow) return\n\t\tconst { start, end } = arrow.props\n\t\tconst startShape = start.type === 'binding' ? this.getShapeById(start.boundShapeId) : undefined\n\t\tconst endShape = end.type === 'binding' ? this.getShapeById(end.boundShapeId) : undefined\n\n\t\tconst parentPageId = this.getAncestorPageId(arrow)\n\t\tif (!parentPageId) return\n\n\t\tlet nextParentId: TLParentId\n\t\tif (startShape && endShape) {\n\t\t\t// if arrow has two bindings, always parent arrow to closest common ancestor of the bindings\n\t\t\tnextParentId = this.findCommonAncestor([startShape, endShape]) ?? parentPageId\n\t\t} else if (startShape || endShape) {\n\t\t\t// if arrow has one binding, keep arrow on its own page\n\t\t\tnextParentId = parentPageId\n\t\t} else {\n\t\t\treturn\n\t\t}\n\n\t\tif (nextParentId && nextParentId !== arrow.parentId) {\n\t\t\tthis.reparentShapesById([arrowId], nextParentId)\n\t\t}\n\n\t\tconst reparentedArrow = this.getShapeById<TLArrowShape>(arrowId)\n\t\tif (!reparentedArrow) throw Error('no reparented arrow')\n\n\t\tconst startSibling = this.getShapeNearestSibling(reparentedArrow, startShape)\n\t\tconst endSibling = this.getShapeNearestSibling(reparentedArrow, endShape)\n\n\t\tlet highestSibling: TLShape | undefined\n\n\t\tif (startSibling && endSibling) {\n\t\t\thighestSibling = startSibling.index > endSibling.index ? startSibling : endSibling\n\t\t} else if (startSibling && !endSibling) {\n\t\t\thighestSibling = startSibling\n\t\t} else if (endSibling && !startSibling) {\n\t\t\thighestSibling = endSibling\n\t\t} else {\n\t\t\treturn\n\t\t}\n\n\t\tlet finalIndex: string\n\n\t\tconst higherSiblings = this.getSortedChildIds(highestSibling.parentId)\n\t\t\t.map((id) => this.getShapeById(id)!)\n\t\t\t.filter((sibling) => sibling.index > highestSibling!.index)\n\n\t\tif (higherSiblings.length) {\n\t\t\t// there are siblings above the highest bound sibling, we need to\n\t\t\t// insert between them.\n\n\t\t\t// if the next sibling is also a bound arrow though, we can end up\n\t\t\t// all fighting for the same indexes. so lets find the next\n\t\t\t// non-arrow sibling...\n\t\t\tconst nextHighestNonArrowSibling = higherSiblings.find((sibling) => sibling.type !== 'arrow')\n\n\t\t\tif (\n\t\t\t\t// ...then, if we're above the last shape we want to be above...\n\t\t\t\treparentedArrow.index > highestSibling.index &&\n\t\t\t\t// ...but below the next non-arrow sibling...\n\t\t\t\t(!nextHighestNonArrowSibling || reparentedArrow.index < nextHighestNonArrowSibling.index)\n\t\t\t) {\n\t\t\t\t// ...then we're already in the right place. no need to update!\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// otherwise, we need to find the index between the highest sibling\n\t\t\t// we want to be above, and the next highest sibling we want to be\n\t\t\t// below:\n\t\t\tfinalIndex = getIndexBetween(highestSibling.index, higherSiblings[0].index)\n\t\t} else {\n\t\t\t// if there are no siblings above us, we can just get the next index:\n\t\t\tfinalIndex = getIndexAbove(highestSibling.index)\n\t\t}\n\n\t\tif (finalIndex !== reparentedArrow.index) {\n\t\t\tthis.updateShapes<TLArrowShape>([{ id: arrowId, type: 'arrow', index: finalIndex }])\n\t\t}\n\t}\n\n\t/** @internal */\n\tprivate _unbindArrowTerminal(arrow: TLArrowShape, handleId: 'start' | 'end') {\n\t\tconst { x, y } = getArrowTerminalsInArrowSpace(this, arrow)[handleId]\n\t\tthis.store.put([{ ...arrow, props: { ...arrow.props, [handleId]: { type: 'point', x, y } } }])\n\t}\n\n\t// private _shapeWillUpdate = (prev: TLShape, next: TLShape) => {\n\t// \tconst update = this.getShapeUtil(next).onUpdate?.(prev, next)\n\t// \treturn update ?? next\n\t// }\n\n\t@computed\n\tprivate get _allPageStates() {\n\t\treturn this.store.query.records('instance_page_state')\n\t}\n\n\t/** @internal */\n\tprivate _shapeWillBeDeleted(deletedShape: TLShape) {\n\t\t// if the deleted shape has a parent shape make sure we call it's onChildrenChange callback\n\t\tif (deletedShape.parentId && isShapeId(deletedShape.parentId)) {\n\t\t\tthis._invalidParents.add(deletedShape.parentId)\n\t\t}\n\t\t// clean up any arrows bound to this shape\n\t\tconst bindings = this._arrowBindingsIndex.value[deletedShape.id]\n\t\tif (bindings?.length) {\n\t\t\tfor (const { arrowId, handleId } of bindings) {\n\t\t\t\tconst arrow = this.getShapeById<TLArrowShape>(arrowId)\n\t\t\t\tif (!arrow) continue\n\t\t\t\tthis._unbindArrowTerminal(arrow, handleId)\n\t\t\t}\n\t\t}\n\t\tconst pageStates = this._allPageStates.value\n\n\t\tconst deletedIds = new Set([deletedShape.id])\n\t\tconst updates = compact(\n\t\t\tpageStates.map((pageState) => {\n\t\t\t\treturn this._cleanupInstancePageState(pageState, deletedIds)\n\t\t\t})\n\t\t)\n\n\t\tif (updates.length) {\n\t\t\tthis.store.put(updates)\n\t\t}\n\t}\n\n\t/** @internal */\n\tprivate _arrowDidUpdate(arrow: TLArrowShape) {\n\t\t// if the shape is an arrow and its bound shape is on another page\n\t\t// or was deleted, unbind it\n\t\tfor (const handle of ['start', 'end'] as const) {\n\t\t\tconst terminal = arrow.props[handle]\n\t\t\tif (terminal.type !== 'binding') continue\n\t\t\tconst boundShape = this.getShapeById(terminal.boundShapeId)\n\t\t\tconst isShapeInSamePageAsArrow =\n\t\t\t\tthis.getAncestorPageId(arrow) === this.getAncestorPageId(boundShape)\n\t\t\tif (!boundShape || !isShapeInSamePageAsArrow) {\n\t\t\t\tthis._unbindArrowTerminal(arrow, handle)\n\t\t\t}\n\t\t}\n\n\t\t// always check the arrow parents\n\t\tthis._reparentArrow(arrow.id)\n\t}\n\n\t/**\n\t * _invalidParents is used to trigger the 'onChildrenChange' callback that shapes can have.\n\t *\n\t * @internal\n\t */\n\tprivate readonly _invalidParents = new Set<TLShapeId>()\n\n\t/** @internal */\n\tprivate _complete() {\n\t\tfor (const parentId of this._invalidParents) {\n\t\t\tthis._invalidParents.delete(parentId)\n\t\t\tconst parent = this.getShapeById(parentId)\n\t\t\tif (!parent) continue\n\n\t\t\tconst util = this.getShapeUtil(parent)\n\t\t\tconst changes = util.onChildrenChange?.(parent)\n\n\t\t\tif (changes?.length) {\n\t\t\t\tthis.updateShapes(changes, true)\n\t\t\t}\n\t\t}\n\n\t\tthis.emit('update')\n\t}\n\n\t/** @internal */\n\tprivate _cleanupInstancePageState(\n\t\tprevPageState: TLInstancePageState,\n\t\tshapesNoLongerInPage: Set<TLShapeId>\n\t) {\n\t\tlet nextPageState = null as null | TLInstancePageState\n\n\t\tconst selectedIds = prevPageState.selectedIds.filter((id) => !shapesNoLongerInPage.has(id))\n\t\tif (selectedIds.length !== prevPageState.selectedIds.length) {\n\t\t\tif (!nextPageState) nextPageState = { ...prevPageState }\n\t\t\tnextPageState.selectedIds = selectedIds\n\t\t}\n\n\t\tconst erasingIds = prevPageState.erasingIds.filter((id) => !shapesNoLongerInPage.has(id))\n\t\tif (erasingIds.length !== prevPageState.erasingIds.length) {\n\t\t\tif (!nextPageState) nextPageState = { ...prevPageState }\n\t\t\tnextPageState.erasingIds = erasingIds\n\t\t}\n\n\t\tif (prevPageState.hoveredId && shapesNoLongerInPage.has(prevPageState.hoveredId)) {\n\t\t\tif (!nextPageState) nextPageState = { ...prevPageState }\n\t\t\tnextPageState.hoveredId = null\n\t\t}\n\n\t\tif (prevPageState.editingId && shapesNoLongerInPage.has(prevPageState.editingId)) {\n\t\t\tif (!nextPageState) nextPageState = { ...prevPageState }\n\t\t\tnextPageState.editingId = null\n\t\t}\n\n\t\tconst hintingIds = prevPageState.hintingIds.filter((id) => !shapesNoLongerInPage.has(id))\n\t\tif (hintingIds.length !== prevPageState.hintingIds.length) {\n\t\t\tif (!nextPageState) nextPageState = { ...prevPageState }\n\t\t\tnextPageState.hintingIds = hintingIds\n\t\t}\n\n\t\tif (prevPageState.focusLayerId && shapesNoLongerInPage.has(prevPageState.focusLayerId)) {\n\t\t\tif (!nextPageState) nextPageState = { ...prevPageState }\n\t\t\tnextPageState.focusLayerId = null\n\t\t}\n\t\treturn nextPageState\n\t}\n\n\t/** @internal */\n\tprivate _shapeDidChange(prev: TLShape, next: TLShape) {\n\t\tif (this.isShapeOfType(next, ArrowShapeUtil)) {\n\t\t\tthis._arrowDidUpdate(next)\n\t\t}\n\n\t\t// if the shape's parent changed and it is bound to an arrow, update the arrow's parent\n\t\tif (prev.parentId !== next.parentId) {\n\t\t\tconst reparentBoundArrows = (id: TLShapeId) => {\n\t\t\t\tconst boundArrows = this._arrowBindingsIndex.value[id]\n\t\t\t\tif (boundArrows?.length) {\n\t\t\t\t\tfor (const arrow of boundArrows) {\n\t\t\t\t\t\tthis._reparentArrow(arrow.arrowId)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treparentBoundArrows(next.id)\n\t\t\tthis.visitDescendants(next.id, reparentBoundArrows)\n\t\t}\n\n\t\t// if this shape moved to a new page, clean up any previous page's instance state\n\t\tif (prev.parentId !== next.parentId && isPageId(next.parentId)) {\n\t\t\tconst allMovingIds = new Set([prev.id])\n\t\t\tthis.visitDescendants(prev.id, (id) => {\n\t\t\t\tallMovingIds.add(id)\n\t\t\t})\n\n\t\t\tfor (const instancePageState of this._allPageStates.value) {\n\t\t\t\tif (instancePageState.pageId === next.parentId) continue\n\t\t\t\tconst nextPageState = this._cleanupInstancePageState(instancePageState, allMovingIds)\n\n\t\t\t\tif (nextPageState) {\n\t\t\t\t\tthis.store.put([nextPageState])\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (prev.parentId && isShapeId(prev.parentId)) {\n\t\t\tthis._invalidParents.add(prev.parentId)\n\t\t}\n\n\t\tif (next.parentId !== prev.parentId && isShapeId(next.parentId)) {\n\t\t\tthis._invalidParents.add(next.parentId)\n\t\t}\n\t}\n\n\t/** @internal */\n\tprivate _pageStateDidChange(prev: TLInstancePageState, next: TLInstancePageState) {\n\t\tif (prev?.selectedIds !== next?.selectedIds) {\n\t\t\t// ensure that descendants and ancestors are not selected at the same time\n\t\t\tconst filtered = next.selectedIds.filter((id) => {\n\t\t\t\tlet parentId = this.getShapeById(id)?.parentId\n\t\t\t\twhile (isShapeId(parentId)) {\n\t\t\t\t\tif (next.selectedIds.includes(parentId)) {\n\t\t\t\t\t\treturn false\n\t\t\t\t\t}\n\t\t\t\t\tparentId = this.getShapeById(parentId)?.parentId\n\t\t\t\t}\n\t\t\t\treturn true\n\t\t\t})\n\n\t\t\tconst nextFocusLayerId =\n\t\t\t\tfiltered.length === 0\n\t\t\t\t\t? next?.focusLayerId\n\t\t\t\t\t: this.findCommonAncestor(compact(filtered.map((id) => this.getShapeById(id))), (shape) =>\n\t\t\t\t\t\t\tthis.isShapeOfType(shape, GroupShapeUtil)\n\t\t\t\t\t  )\n\n\t\t\tif (filtered.length !== next.selectedIds.length || nextFocusLayerId != next.focusLayerId) {\n\t\t\t\tthis.store.put([{ ...next, selectedIds: filtered, focusLayerId: nextFocusLayerId ?? null }])\n\t\t\t}\n\t\t}\n\t}\n\n\t/** @internal */\n\tprivate _pageWillBeDeleted(page: TLPage) {\n\t\t// page was deleted, need to check whether it's the current page and select another one if so\n\t\tif (this.instanceState.currentPageId !== page.id) return\n\n\t\tconst backupPageId = this.pages.find((p) => p.id !== page.id)?.id\n\t\tif (!backupPageId) return\n\t\tthis.store.put([{ ...this.instanceState, currentPageId: backupPageId }])\n\n\t\t// delete the camera and state for the page if necessary\n\t\tconst cameraId = CameraRecordType.createId(page.id)\n\t\tconst instancePageStateId = InstancePageStateRecordType.createId(page.id)\n\t\tthis.store.remove([cameraId, instancePageStateId])\n\t}\n\n\t/* --------------------- Errors --------------------- */\n\n\t/** @internal */\n\tannotateError(\n\t\terror: unknown,\n\t\t{\n\t\t\torigin,\n\t\t\twillCrashApp,\n\t\t\ttags,\n\t\t\textras,\n\t\t}: {\n\t\t\torigin: string\n\t\t\twillCrashApp: boolean\n\t\t\ttags?: Record<string, string | boolean | number>\n\t\t\textras?: Record<string, unknown>\n\t\t}\n\t) {\n\t\tconst defaultAnnotations = this.createErrorAnnotations(origin, willCrashApp)\n\t\tannotateError(error, {\n\t\t\ttags: { ...defaultAnnotations.tags, ...tags },\n\t\t\textras: { ...defaultAnnotations.extras, ...extras },\n\t\t})\n\t\tif (willCrashApp) {\n\t\t\tthis.store.markAsPossiblyCorrupted()\n\t\t}\n\t}\n\n\t/** @internal */\n\tcreateErrorAnnotations(\n\t\torigin: string,\n\t\twillCrashApp: boolean | 'unknown'\n\t): {\n\t\ttags: { origin: string; willCrashApp: boolean | 'unknown' }\n\t\textras: {\n\t\t\tactiveStateNode?: string\n\t\t\tselectedShapes?: TLUnknownShape[]\n\t\t\teditingShape?: TLUnknownShape\n\t\t\tinputs?: Record<string, unknown>\n\t\t}\n\t} {\n\t\ttry {\n\t\t\treturn {\n\t\t\t\ttags: {\n\t\t\t\t\torigin: origin,\n\t\t\t\t\twillCrashApp,\n\t\t\t\t},\n\t\t\t\textras: {\n\t\t\t\t\tactiveStateNode: this.root.path.value,\n\t\t\t\t\tselectedShapes: this.selectedShapes,\n\t\t\t\t\teditingShape: this.editingId ? this.getShapeById(this.editingId) : undefined,\n\t\t\t\t\tinputs: this.inputs,\n\t\t\t\t},\n\t\t\t}\n\t\t} catch {\n\t\t\treturn {\n\t\t\t\ttags: {\n\t\t\t\t\torigin: origin,\n\t\t\t\t\twillCrashApp,\n\t\t\t\t},\n\t\t\t\textras: {},\n\t\t\t}\n\t\t}\n\t}\n\n\t/** @internal */\n\tprivate _crashingError: unknown | null = null\n\n\t/**\n\t * We can't use an `atom` here because there's a chance that when `crashAndReportError` is called,\n\t * we're in a transaction that's about to be rolled back due to the same error we're currently\n\t * reporting.\n\t *\n\t * Instead, to listen to changes to this value, you need to listen to app's `crash` event.\n\t *\n\t * @internal\n\t */\n\tget crashingError() {\n\t\treturn this._crashingError\n\t}\n\n\t/** @internal */\n\tcrash(error: unknown) {\n\t\tthis._crashingError = error\n\t\tthis.store.markAsPossiblyCorrupted()\n\t\tthis.emit('crash', { error })\n\t}\n\n\t/* ----------------- Internal State ----------------- */\n\n\tprivate _canMoveCamera = atom('can move camera', true)\n\n\t/**\n\t * Whether the editor's camera can move.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.canMoveCamera = false\n\t * ```\n\t *\n\t * @param canMove - Whether the camera can move.\n\t *\n\t * @public\n\t */\n\tget canMoveCamera() {\n\t\treturn this._canMoveCamera.value\n\t}\n\n\tset canMoveCamera(canMove: boolean) {\n\t\tthis._canMoveCamera.set(canMove)\n\t}\n\n\tprivate _isFocused = atom('_isFocused', false)\n\n\t/**\n\t * Whether or not the editor is focused.\n\t *\n\t * @public\n\t */\n\tget isFocused() {\n\t\treturn this._isFocused.value\n\t}\n\n\t/**\n\t * The window's device pixel ratio.\n\t *\n\t * @public\n\t */\n\tget devicePixelRatio() {\n\t\treturn this._dprManager.dpr.value\n\t}\n\n\t// Coarse Pointer\n\n\t/** @internal */\n\tprivate _isCoarsePointer = atom<boolean>('isCoarsePointer', false as any)\n\n\t/**\n\t * Whether the user is using a \"coarse\" pointer, such as on a touch screen. This is automatically set by the canvas.\n\t *\n\t * @public\n\t **/\n\tget isCoarsePointer() {\n\t\treturn this._isCoarsePointer.value\n\t}\n\n\tset isCoarsePointer(v) {\n\t\tthis._isCoarsePointer.set(v)\n\t}\n\n\t// Menus\n\n\tprivate _openMenus = atom('open-menus', [] as string[])\n\n\t/**\n\t * A set of strings representing any open menus. When menus are open,\n\t * certain interactions will behave differently; for example, when a\n\t * draw tool is selected and a menu is open, a pointer-down will not\n\t * create a dot (because the user is probably trying to close the menu)\n\t * however a pointer-down event followed by a drag will begin drawing\n\t * a line (because the user is BOTH trying to close the menu AND start\n\t * drawing a line).\n\t *\n\t * @public\n\t */\n\t@computed get openMenus(): string[] {\n\t\treturn this._openMenus.value\n\t}\n\n\t/**\n\t * Add an open menu.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.addOpenMenu('menu-id')\n\t * ```\n\t *\n\t * @public\n\t */\n\taddOpenMenu(id: string) {\n\t\tconst menus = new Set(this.openMenus)\n\t\tif (!menus.has(id)) {\n\t\t\tmenus.add(id)\n\t\t\tthis._openMenus.set([...menus])\n\t\t}\n\t\treturn this\n\t}\n\n\t/**\n\t * Delete an open menu.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.deleteOpenMenu('menu-id')\n\t * ```\n\t *\n\t * @public\n\t */\n\tdeleteOpenMenu(id: string) {\n\t\tconst menus = new Set(this.openMenus)\n\t\tif (menus.has(id)) {\n\t\t\tmenus.delete(id)\n\t\t\tthis._openMenus.set([...menus])\n\t\t}\n\t\treturn this\n\t}\n\n\t/**\n\t * Get whether any menus are open.\n\t *\n\t * @public\n\t */\n\t@computed get isMenuOpen() {\n\t\treturn this.openMenus.length > 0\n\t}\n\n\t// Changing style\n\n\t/** @internal */\n\tprivate _isChangingStyle = atom<boolean>('isChangingStyle', false as any)\n\n\t/** @internal */\n\tprivate _isChangingStyleTimeout = -1 as any\n\n\t/**\n\t * Whether the user is currently changing the style of a shape. This may cause the UI to change.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.isChangingStyle = true\n\t * ```\n\t *\n\t * @public\n\t */\n\tget isChangingStyle() {\n\t\treturn this._isChangingStyle.value\n\t}\n\n\tset isChangingStyle(v) {\n\t\tthis._isChangingStyle.set(v)\n\t\t// Clear any reset timeout\n\t\tclearTimeout(this._isChangingStyleTimeout)\n\t\tif (v) {\n\t\t\t// If we've set to true, set a new reset timeout to change the value back to false after 2 seconds\n\t\t\tthis._isChangingStyleTimeout = setTimeout(() => (this.isChangingStyle = false), 2000)\n\t\t}\n\t}\n\n\t// Pen Mode\n\n\t/** @internal */\n\tprivate _isPenMode = atom<boolean>('isPenMode', false as any)\n\n\t/** @internal */\n\tprivate _touchEventsRemainingBeforeExitingPenMode = 0\n\n\t/**\n\t * Whether the editor is in pen mode or not.\n\t *\n\t * @public\n\t **/\n\tget isPenMode() {\n\t\treturn this._isPenMode.value\n\t}\n\n\t/**\n\t * Set whether the editor is in pen mode or not.\n\t *\n\t * @public\n\t **/\n\tsetPenMode(isPenMode: boolean): this {\n\t\tif (isPenMode) this._touchEventsRemainingBeforeExitingPenMode = 3\n\t\tif (isPenMode !== this.isPenMode) {\n\t\t\tthis._isPenMode.set(isPenMode)\n\t\t}\n\t\treturn this\n\t}\n\n\t// Read only\n\n\tprivate _isReadOnly = atom<boolean>('isReadOnly', false as any)\n\n\t/**\n\t * Set whether the editor is in read-only mode or not.\n\t *\n\t * @public\n\t **/\n\tsetReadOnly(isReadOnly: boolean): this {\n\t\tthis._isReadOnly.set(isReadOnly)\n\t\tif (isReadOnly) {\n\t\t\tthis.setSelectedTool('hand')\n\t\t}\n\t\treturn this\n\t}\n\n\t/**\n\t * Whether the editor is in read-only mode or not.\n\t *\n\t * @public\n\t **/\n\tget isReadOnly() {\n\t\treturn this._isReadOnly.value\n\t}\n\n\t/* ---------------- Document Settings --------------- */\n\n\t/**\n\t * The global document settings that apply to all users.\n\t *\n\t * @public\n\t **/\n\t@computed get documentSettings() {\n\t\treturn this.store.get(TLDOCUMENT_ID)!\n\t}\n\n\t/**\n\t * Update the global document settings that apply to all users.\n\t *\n\t * @public\n\t **/\n\tupdateDocumentSettings(settings: Partial<TLDocument>) {\n\t\tthis.store.put([{ ...this.documentSettings, ...settings }])\n\t}\n\n\t/**\n\t * The document's grid size.\n\t *\n\t * @public\n\t **/\n\tget gridSize() {\n\t\treturn this.documentSettings.gridSize\n\t}\n\n\t/** @internal */\n\tget projectName() {\n\t\treturn this.documentSettings.name\n\t}\n\n\t/** @internal */\n\tsetProjectName(name: string) {\n\t\tthis.updateDocumentSettings({ name })\n\t}\n\n\t/* ---------------------- User ---------------------- */\n\n\t/**\n\t * Whether the user has \"always snap\" mode enabled.\n\t *\n\t * @public\n\t **/\n\tget isSnapMode() {\n\t\treturn this.user.isSnapMode\n\t}\n\n\t/**\n\t * Set whether the user has \"always snap\" mode enabled.\n\t *\n\t * @public\n\t **/\n\tsetSnapMode(isSnapMode: boolean) {\n\t\tif (isSnapMode !== this.isSnapMode) {\n\t\t\tthis.user.updateUserPreferences({ isSnapMode })\n\t\t}\n\t\treturn this\n\t}\n\n\t/**\n\t * Whether the user has dark mode enabled.\n\t *\n\t * @public\n\t **/\n\tget isDarkMode() {\n\t\treturn this.user.isDarkMode\n\t}\n\n\t/**\n\t * Set whether the user has dark mode enabled.\n\t *\n\t * @public\n\t **/\n\tsetDarkMode(isDarkMode: boolean) {\n\t\tif (isDarkMode !== this.isDarkMode) {\n\t\t\tthis.user.updateUserPreferences({ isDarkMode })\n\t\t}\n\t\treturn this\n\t}\n\n\t/**\n\t * The user's chosen animation speed.\n\t *\n\t * @public\n\t */\n\tget animationSpeed() {\n\t\treturn this.user.animationSpeed\n\t}\n\n\t/**\n\t * Set the user's chosen animation speed.\n\t * Set to 0.0 to disable animations.\n\t * Set to 1.0 for full speed.\n\t *\n\t * @public\n\t */\n\tsetAnimationSpeed(animationSpeed: number): this {\n\t\tif (animationSpeed !== this.animationSpeed) {\n\t\t\tthis.user.updateUserPreferences({ animationSpeed })\n\t\t}\n\t\treturn this\n\t}\n\n\t/* ----------------- Instance State ----------------- */\n\n\t/**\n\t * The current instance's state.\n\t *\n\t * @public\n\t */\n\tget instanceState(): TLInstance {\n\t\treturn this.store.get(TLINSTANCE_ID)!\n\t}\n\n\t/**\n\t * The instance's cursor state.\n\t *\n\t * @public\n\t **/\n\tget cursor() {\n\t\treturn this.instanceState.cursor\n\t}\n\n\t/**\n\t * The instance's brush state.\n\t *\n\t * @public\n\t **/\n\tget brush() {\n\t\treturn this.instanceState.brush\n\t}\n\n\t/**\n\t * The instance's zoom brush state.\n\t *\n\t * @public\n\t **/\n\tget zoomBrush() {\n\t\treturn this.instanceState.zoomBrush\n\t}\n\n\t/**\n\t * The instance's scribble state.\n\t *\n\t * @public\n\t **/\n\tget scribble() {\n\t\treturn this.instanceState.scribble\n\t}\n\n\t// Focus Mode\n\n\t/**\n\t * Whether the instance is in focus mode or not.\n\t *\n\t * @public\n\t **/\n\tget isFocusMode() {\n\t\treturn this.instanceState.isFocusMode\n\t}\n\n\t/**\n\t * Set whether the instance is in focus mode or not.\n\t *\n\t * @public\n\t **/\n\tsetFocusMode(isFocusMode: boolean): this {\n\t\tif (isFocusMode !== this.isFocusMode) {\n\t\t\tthis.updateInstanceState({ isFocusMode }, true)\n\t\t}\n\t\treturn this\n\t}\n\n\t// Tool Locked\n\n\t/**\n\t * Whether the instance has \"tool lock\" mode enabled.\n\t *\n\t * @public\n\t **/\n\tget isToolLocked() {\n\t\treturn this.instanceState.isToolLocked\n\t}\n\n\t/**\n\t * Set whether the instance has \"tool lock\" mode enabled.\n\t *\n\t * @public\n\t **/\n\tsetToolLocked(isToolLocked: boolean): this {\n\t\tif (isToolLocked !== this.isToolLocked) {\n\t\t\tthis.updateInstanceState({ isToolLocked }, true)\n\t\t}\n\t\treturn this\n\t}\n\n\t// Grid Mode\n\n\t/**\n\t * Whether the instance's grid is enabled.\n\t *\n\t * @public\n\t **/\n\tget isGridMode() {\n\t\treturn this.instanceState.isGridMode\n\t}\n\n\t/**\n\t * Set whether the instance's grid is enabled.\n\t *\n\t * @public\n\t **/\n\tsetGridMode(isGridMode: boolean): this {\n\t\tif (isGridMode !== this.isGridMode) {\n\t\t\tthis.updateInstanceState({ isGridMode }, true)\n\t\t}\n\t\treturn this\n\t}\n\n\t/* ---------------------- Pages --------------------- */\n\n\t/** @internal */\n\t@computed private get _pages() {\n\t\treturn this.store.query.records('page')\n\t}\n\n\t/**\n\t * Info about the project's current pages.\n\t *\n\t * @public\n\t */\n\t@computed get pages(): TLPage[] {\n\t\treturn this._pages.value.sort(sortByIndex)\n\t}\n\n\t/**\n\t * The current page.\n\t *\n\t * @public\n\t */\n\tget currentPage(): TLPage {\n\t\tconst page = this.getPageById(this.currentPageId)\n\t\tif (!page)\n\t\t\tthrow Error(`No current page (id ${this.currentPageId}, ${this.pages.length} pages))`)\n\t\treturn page\n\t}\n\n\t/**\n\t * The current page id.\n\t *\n\t * @public\n\t */\n\tget currentPageId(): TLPageId {\n\t\treturn this.instanceState.currentPageId\n\t}\n\n\t/**\n\t * Get a page by its ID.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.getPageById(myPage.id)\n\t * ```\n\t *\n\t * @public\n\t */\n\tgetPageById(id: TLPageId): TLPage | undefined {\n\t\treturn this.store.get(id)\n\t}\n\n\t/**\n\t * Get a page by its ID.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.getPageById(myPage.id)\n\t * ```\n\t *\n\t * @public\n\t */\n\tgetPageInfoById(id: TLPage['id']) {\n\t\treturn this.store.get(id)\n\t}\n\n\t/**\n\t * A cache of shape ids in the current page.\n\t *\n\t * @internal\n\t */\n\tprivate readonly _currentPageShapeIds: ReturnType<typeof deriveShapeIdsInCurrentPage>\n\n\t/**\n\t * An array of all of the shapes on the current page.\n\t *\n\t * @public\n\t */\n\tget currentPageShapeIds() {\n\t\treturn this._currentPageShapeIds.value\n\t}\n\n\t/**\n\t * Get the ids of shapes on a page.\n\t *\n\t * @example\n\t * ```ts\n\t * const idsOnPage1 = editor.getShapeIdsInPage('page1')\n\t * const idsOnPage2 = editor.getShapeIdsInPage('page2')\n\t * ```\n\t *\n\t * @param pageId - The id of the page.\n\t *\n\t * @public\n\t **/\n\tgetShapeIdsInPage(pageId: TLPageId): Set<TLShapeId> {\n\t\tconst result = this.store.query.exec('shape', { parentId: { eq: pageId } })\n\t\treturn this.getShapeAndDescendantIds(result.map((s) => s.id))\n\t}\n\n\t/* ------------------- Page State ------------------- */\n\n\t/** @internal */\n\t@computed private get _pageStates() {\n\t\treturn this.store.query.records('instance_page_state')\n\t}\n\n\t/**\n\t * Get a page state by its id.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.getPageStateByPageId('page1')\n\t * ```\n\t *\n\t * @public\n\t */\n\tgetPageStateByPageId(id: TLPageId) {\n\t\treturn this._pageStates.value.find((p) => p.pageId === id)\n\t}\n\n\t/** @internal */\n\t@computed private get pageStateId() {\n\t\treturn InstancePageStateRecordType.createId(this.currentPageId)\n\t}\n\n\t/**\n\t * The current page state.\n\t *\n\t * @public\n\t */\n\t@computed get pageState(): TLInstancePageState {\n\t\treturn this.store.get(this.pageStateId)!\n\t}\n\n\t/**\n\t * Update a page state.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.setInstancePageState({ id: 'page1', editingId: 'shape:123' })\n\t * editor.setInstancePageState({ id: 'page1', editingId: 'shape:123' }, true)\n\t * ```\n\t *\n\t * @param partial - The partial of the page state object containing the changes.\n\t * @param ephemeral - Whether the command is ephemeral.\n\t *\n\t * @public\n\t */\n\tsetInstancePageState(partial: Partial<TLInstancePageState>, ephemeral = false) {\n\t\tthis._setInstancePageState(partial, ephemeral)\n\t}\n\n\t// Selected Ids\n\n\t/**\n\t * The current selected ids.\n\t *\n\t * @public\n\t */\n\t@computed get selectedIds() {\n\t\treturn this.pageState.selectedIds\n\t}\n\n\t/**\n\t * The current selected ids as a set\n\t *\n\t * @public\n\t */\n\t@computed get selectedIdsSet(): ReadonlySet<TLShapeId> {\n\t\treturn new Set(this.selectedIds)\n\t}\n\n\t/**\n\t * Select one or more shapes.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.setSelectedIds(['id1'])\n\t * editor.setSelectedIds(['id1', 'id2'])\n\t * ```\n\t *\n\t * @param ids - The ids to select.\n\t * @param squashing - Whether the change should create a new history entry or combine with the\n\t *   previous (if the previous is the same type).\n\t *\n\t * @public\n\t */\n\tsetSelectedIds(ids: TLShapeId[], squashing = false) {\n\t\tthis._setSelectedIds(ids, squashing)\n\t\treturn this\n\t}\n\n\t/** @internal */\n\tprivate _setSelectedIds = this.history.createCommand(\n\t\t'setSelectedIds',\n\t\t(ids: TLShapeId[], squashing = false) => {\n\t\t\tconst prevSelectedIds = this.pageState.selectedIds\n\n\t\t\tconst prevSet = new Set(this.pageState.selectedIds)\n\n\t\t\tif (ids.length === prevSet.size && ids.every((id) => prevSet.has(id))) return null\n\n\t\t\treturn { data: { ids, prevSelectedIds }, squashing, preservesRedoStack: true }\n\t\t},\n\t\t{\n\t\t\tdo: ({ ids }) => {\n\t\t\t\tthis.store.update(this.pageState.id, (state) => ({ ...state, selectedIds: ids }))\n\t\t\t},\n\t\t\tundo: ({ prevSelectedIds }) => {\n\t\t\t\tthis.store.update(this.pageState.id, () => ({\n\t\t\t\t\t...this.pageState,\n\t\t\t\t\tselectedIds: prevSelectedIds,\n\t\t\t\t}))\n\t\t\t},\n\t\t\tsquash(prev, next) {\n\t\t\t\treturn { ids: next.ids, prevSelectedIds: prev.prevSelectedIds }\n\t\t\t},\n\t\t}\n\t)\n\n\t/**\n\t * Determine whether or not a shape is selected\n\t *\n\t * @example\n\t * ```ts\n\t * editor.isSelected('id1')\n\t * ```\n\t *\n\t * @param id - The id of the shape to check.\n\t *\n\t * @public\n\t */\n\tisSelected(id: TLShapeId) {\n\t\treturn this.selectedIdsSet.has(id)\n\t}\n\n\t/**\n\t * Determine whether a not a shape is within the current selection. A shape is within the\n\t * selection if it or any of its parents is selected.\n\t *\n\t * @param id - The id of the shape to check.\n\t *\n\t * @public\n\t */\n\tisWithinSelection(id: TLShapeId) {\n\t\tconst shape = this.getShapeById(id)\n\t\tif (!shape) return false\n\n\t\tif (this.isSelected(id)) return true\n\n\t\treturn !!this.findAncestor(shape, (parent) => this.isSelected(parent.id))\n\t}\n\n\t/**\n\t * Select one or more shapes.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.select('id1')\n\t * editor.select('id1', 'id2')\n\t * ```\n\t *\n\t * @param ids - The ids to select.\n\t *\n\t * @public\n\t */\n\tselect(...ids: TLShapeId[]) {\n\t\tthis.setSelectedIds(ids)\n\t\treturn this\n\t}\n\n\t/**\n\t * Remove a shape from the existing set of selected shapes.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.deselect(shape.id)\n\t * ```\n\t *\n\t * @public\n\t */\n\tdeselect(...ids: TLShapeId[]) {\n\t\tconst { selectedIds } = this\n\t\tif (selectedIds.length > 0 && ids.length > 0) {\n\t\t\tthis.setSelectedIds(selectedIds.filter((id) => !ids.includes(id)))\n\t\t}\n\t\treturn this\n\t}\n\n\t/**\n\t * Select all direct children of the current page.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.selectAll()\n\t * ```\n\t *\n\t * @public\n\t */\n\tselectAll() {\n\t\tconst ids = this.getSortedChildIds(this.currentPageId)\n\t\t// page might have no shapes\n\t\tif (ids.length <= 0) return this\n\t\tthis.setSelectedIds(this._getUnlockedShapeIds(ids))\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Clear the selection.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.selectNone()\n\t * ```\n\t *\n\t * @public\n\t */\n\tselectNone(): this {\n\t\tif (this.selectedIds.length > 0) {\n\t\t\tthis.setSelectedIds([])\n\t\t}\n\n\t\treturn this\n\t}\n\n\t// Focus Layer Id\n\n\t/**\n\t * The shape id of the current focus layer.\n\t *\n\t * @public\n\t */\n\tget focusLayerId() {\n\t\treturn this.pageState.focusLayerId ?? this.currentPageId\n\t}\n\n\t/**\n\t * The shape of the current focus layer.\n\t *\n\t * @public\n\t */\n\tget focusLayerShape(): TLShape | undefined {\n\t\tconst id = this.pageState.focusLayerId\n\t\tif (!id) {\n\t\t\treturn\n\t\t}\n\t\treturn this.getShapeById(id)\n\t}\n\n\t/**\n\t * Exit the current focus layer, moving up to the next group if there is one.\n\t *\n\t * @public\n\t */\n\tpopFocusLayer() {\n\t\tconst current = this.pageState.focusLayerId\n\t\tconst focusedShape = current && this.getShapeById(current)\n\n\t\tif (focusedShape) {\n\t\t\t// If we have a focused layer, look for an ancestor of the focused shape that is a group\n\t\t\tconst match = this.findAncestor(focusedShape, (shape) =>\n\t\t\t\tthis.isShapeOfType(shape, GroupShapeUtil)\n\t\t\t)\n\t\t\t// If we have an ancestor that can become a focused layer, set it as the focused layer\n\t\t\tthis.setFocusLayer(match?.id ?? null)\n\t\t\tthis.select(focusedShape.id)\n\t\t} else {\n\t\t\t// If there's no focused shape, then clear the focus layer and clear selection\n\t\t\tthis.setFocusLayer(null)\n\t\t\tthis.selectNone()\n\t\t}\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Set the focus layer to the given shape id.\n\t *\n\t * @param next - The next focus layer id or null to reset the focus layer to the page\n\t *\n\t * @public\n\t */\n\tsetFocusLayer(next: null | TLShapeId) {\n\t\tthis._setFocusLayer(next)\n\t\treturn this\n\t}\n\n\t/** @internal */\n\tprivate _setFocusLayer = this.history.createCommand(\n\t\t'setFocusLayer',\n\t\t(next: null | TLShapeId) => {\n\t\t\t// When we first click an empty canvas we don't want this to show up in the undo stack\n\t\t\tif (next === null && !this.canUndo) {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tconst prev = this.pageState.focusLayerId\n\t\t\treturn { data: { prev, next }, preservesRedoStack: true, squashing: true }\n\t\t},\n\t\t{\n\t\t\tdo: ({ next }) => {\n\t\t\t\tthis.store.update(this.pageState.id, (s) => ({ ...s, focusLayerId: next }))\n\t\t\t},\n\t\t\tundo: ({ prev }) => {\n\t\t\t\tthis.store.update(this.pageState.id, (s) => ({ ...s, focusLayerId: prev }))\n\t\t\t},\n\t\t\tsquash({ prev }, { next }) {\n\t\t\t\treturn { prev, next }\n\t\t\t},\n\t\t}\n\t)\n\n\t// Editing Id\n\n\t/**\n\t * The current editing shape's id.\n\t *\n\t * @public\n\t */\n\tget editingId() {\n\t\treturn this.pageState.editingId\n\t}\n\n\t/**\n\t * Set the current editing id.\n\t *\n\t * @param id - The id of the shape to edit or null to clear the editing id.\n\t *\n\t * @public\n\t */\n\tsetEditingId(id: TLShapeId | null): this {\n\t\tif (!id) {\n\t\t\tthis.setInstancePageState({ editingId: null })\n\t\t} else {\n\t\t\tif (id !== this.editingId) {\n\t\t\t\tconst shape = this.getShapeById(id)!\n\t\t\t\tconst util = this.getShapeUtil(shape)\n\t\t\t\tif (shape && util.canEdit(shape)) {\n\t\t\t\t\tthis.setInstancePageState({ editingId: id, hoveredId: null }, false)\n\n\t\t\t\t\t// todo: remove this camera move\n\n\t\t\t\t\tconst { viewportPageBounds } = this\n\t\t\t\t\tconst localEditingBounds = util.getEditingBounds(shape)!\n\t\t\t\t\tconst pageTransform = this.getPageTransformById(id)!\n\t\t\t\t\tconst pageEditingBounds = Box2d.FromPoints(\n\t\t\t\t\t\tMatrix2d.applyToPoints(pageTransform, localEditingBounds.corners)\n\t\t\t\t\t)\n\n\t\t\t\t\tif (!viewportPageBounds.contains(pageEditingBounds)) {\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tpageEditingBounds.width > viewportPageBounds.width ||\n\t\t\t\t\t\t\tpageEditingBounds.height > viewportPageBounds.height\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tthis.zoomToBounds(\n\t\t\t\t\t\t\t\tpageEditingBounds.minX,\n\t\t\t\t\t\t\t\tpageEditingBounds.minY,\n\t\t\t\t\t\t\t\tpageEditingBounds.width,\n\t\t\t\t\t\t\t\tpageEditingBounds.height\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis.centerOnPoint(pageEditingBounds.midX, pageEditingBounds.midY)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this\n\t}\n\n\t@computed get editingShape() {\n\t\tif (!this.editingId) return null\n\t\treturn this.getShapeById(this.editingId) ?? null\n\t}\n\n\t// Hovered Id\n\n\t/**\n\t * The current hovered shape id.\n\t *\n\t * @readonly\n\t * @public\n\t */\n\t@computed get hoveredId() {\n\t\treturn this.pageState.hoveredId\n\t}\n\n\t/**\n\t * Set the current hovered shape.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.setHoveredId('box1')\n\t * editor.setHoveredId() // Clears the hovered shape.\n\t * ```\n\t *\n\t * @param id - The id of the page to set as the current page\n\t *\n\t * @public\n\t */\n\tsetHoveredId(id: TLShapeId | null = null): this {\n\t\tif (id === this.pageState.hoveredId) return this\n\n\t\tthis.setInstancePageState({ hoveredId: id }, true)\n\t\treturn this\n\t}\n\n\t/**\n\t * The current hovered shape.\n\t *\n\t * @readonly\n\t * @public\n\t */\n\t@computed get hoveredShape() {\n\t\tif (!this.hoveredId) return null\n\t\treturn this.getShapeById(this.hoveredId) ?? null\n\t}\n\n\t// Hinting ids\n\n\t/**\n\t * The editor's current hinting ids.\n\t *\n\t * @public\n\t */\n\t@computed get hintingIds() {\n\t\treturn this.pageState.hintingIds\n\t}\n\n\t/**\n\t * Set the hinted shape ids.\n\t *\n\t * @param ids - The ids to set as hinted.\n\t *\n\t * @public\n\t */\n\tsetHintingIds(ids: TLShapeId[]): this {\n\t\t// always ephemeral\n\t\tthis.store.update(this.pageState.id, (s) => ({ ...s, hintingIds: dedupe(ids) }))\n\t\treturn this\n\t}\n\n\t// Erasing Ids\n\n\t/**\n\t * The editor's current erasing ids.\n\t *\n\t * @public\n\t */\n\t@computed get erasingIds() {\n\t\treturn this.pageState.erasingIds\n\t}\n\n\t/**\n\t * A derived set containing the current erasing ids.\n\t *\n\t * @public\n\t */\n\t@computed get erasingIdsSet() {\n\t\t// todo: Make incremental derivation, so that this only gets updated when erasingIds changes: we're creating this too often!\n\t\treturn new Set<TLShapeId>(this.erasingIds)\n\t}\n\n\t/**\n\t * Set the current erasing shapes.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.setErasingIds(['box1', 'box2'])\n\t * editor.setErasingIds() // Clears the erasing set\n\t * ```\n\t *\n\t * @param ids - The ids of shapes to set as erasing.\n\t *\n\t * @public\n\t */\n\tsetErasingIds(ids: TLShapeId[] = []): this {\n\t\tconst erasingIds = this.erasingIdsSet\n\t\tif (ids.length === erasingIds.size && ids.every((id) => erasingIds.has(id))) return this\n\n\t\tthis.setInstancePageState({ erasingIds: ids }, true)\n\t\treturn this\n\t}\n\n\t// Cropping Id\n\n\t/**\n\t * The current cropping shape's id.\n\t *\n\t * @public\n\t */\n\tget croppingId() {\n\t\treturn this.pageState.croppingId\n\t}\n\n\t/**\n\t * Set the current cropping shape's id.\n\t *\n\t * @param id - The id of the shape to crop or null to clear the cropping id.\n\t *\n\t * @public\n\t */\n\tsetCroppingId(id: TLShapeId | null): this {\n\t\tif (id !== this.croppingId) {\n\t\t\tif (!id) {\n\t\t\t\tthis.setInstancePageState({ croppingId: null })\n\t\t\t\tif (this.isInAny('select.crop', 'select.pointing_crop_handle', 'select.cropping')) {\n\t\t\t\t\tthis.setSelectedTool('select.idle')\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst shape = this.getShapeById(id)!\n\t\t\t\tconst util = this.getShapeUtil(shape)\n\t\t\t\tif (shape && util.canCrop(shape)) {\n\t\t\t\t\tthis.setInstancePageState({ croppingId: id, hoveredId: null })\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn this\n\t}\n\n\t/* --------------------- Camera --------------------- */\n\n\t/** @internal */\n\t@computed\n\tprivate get cameraId() {\n\t\treturn CameraRecordType.createId(this.currentPageId)\n\t}\n\n\t/**\n\t * The current camera.\n\t *\n\t * @public\n\t */\n\t@computed get camera() {\n\t\treturn this.store.get(this.cameraId)!\n\t}\n\n\t/**\n\t * The current camera zoom level.\n\t *\n\t * @public\n\t */\n\t@computed get zoomLevel() {\n\t\treturn this.camera.z\n\t}\n\n\t/* -------------------- Viewport -------------------- */\n\n\t/**\n\t * Update the viewport. The viewport will measure the size and screen position of its container\n\t * element. This should be done whenever the container's position on the screen changes.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.updateViewportScreenBounds()\n\t * editor.updateViewportScreenBounds(true)\n\t * ```\n\t *\n\t * @param center - (optional) Whether to preserve the viewport page center as the viewport changes.\n\t *\n\t * @public\n\t */\n\tupdateViewportScreenBounds(center = false) {\n\t\tconst container = this.getContainer()\n\n\t\tif (!container) return this\n\t\tconst rect = container.getBoundingClientRect()\n\t\tconst screenBounds = new Box2d(0, 0, Math.max(rect.width, 1), Math.max(rect.height, 1))\n\n\t\tconst boundsAreEqual = screenBounds.equals(this.viewportScreenBounds)\n\n\t\t// Get the current value\n\t\tconst { _willSetInitialBounds } = this\n\n\t\tif (boundsAreEqual) {\n\t\t\tthis._willSetInitialBounds = false\n\t\t} else {\n\t\t\tif (_willSetInitialBounds) {\n\t\t\t\t// If we have just received the initial bounds, don't center the camera.\n\t\t\t\tthis._willSetInitialBounds = false\n\t\t\t\tthis.updateInstanceState({ screenBounds: screenBounds.toJson() }, true, true)\n\t\t\t} else {\n\t\t\t\tconst { zoomLevel } = this\n\t\t\t\tif (center) {\n\t\t\t\t\tconst before = this.viewportPageCenter\n\t\t\t\t\tthis.updateInstanceState({ screenBounds: screenBounds.toJson() }, true, true)\n\t\t\t\t\tconst after = this.viewportPageCenter\n\t\t\t\t\tif (!this.instanceState.followingUserId) {\n\t\t\t\t\t\tthis.pan((after.x - before.x) * zoomLevel, (after.y - before.y) * zoomLevel)\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tconst before = this.screenToPage(0, 0)\n\t\t\t\t\tthis.updateInstanceState({ screenBounds: screenBounds.toJson() }, true, true)\n\t\t\t\t\tconst after = this.screenToPage(0, 0)\n\t\t\t\t\tif (!this.instanceState.followingUserId) {\n\t\t\t\t\t\tthis.pan((after.x - before.x) * zoomLevel, (after.y - before.y) * zoomLevel)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis._tickCameraState()\n\t\tthis.updateRenderingBounds()\n\n\t\tconst { editingId } = this\n\n\t\tif (editingId) {\n\t\t\tthis.panZoomIntoView([editingId])\n\t\t}\n\n\t\treturn this\n\t}\n\n\t/**\n\t * The bounds of the editor's viewport in screen space.\n\t *\n\t * @public\n\t */\n\t@computed get viewportScreenBounds() {\n\t\tconst { x, y, w, h } = this.instanceState.screenBounds\n\t\treturn new Box2d(x, y, w, h)\n\t}\n\n\t/**\n\t * The center of the editor's viewport in screen space.\n\t *\n\t * @public\n\t */\n\t@computed get viewportScreenCenter() {\n\t\treturn this.viewportScreenBounds.center\n\t}\n\n\t/**\n\t * The current viewport in page space.\n\t *\n\t * @public\n\t */\n\t@computed get viewportPageBounds() {\n\t\tconst { x, y, w, h } = this.viewportScreenBounds\n\t\tconst tl = this.screenToPage(x, y)\n\t\tconst br = this.screenToPage(x + w, y + h)\n\t\treturn new Box2d(tl.x, tl.y, br.x - tl.x, br.y - tl.y)\n\t}\n\n\t/**\n\t * The center of the viewport in page space.\n\t *\n\t * @public\n\t */\n\t@computed get viewportPageCenter() {\n\t\treturn this.viewportPageBounds.center\n\t}\n\n\t/**\n\t * Convert a point in screen space to a point in page space.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.screenToPage(100, 100)\n\t * ```\n\t *\n\t * @param x - The x coordinate of the point in screen space.\n\t * @param y - The y coordinate of the point in screen space.\n\t * @param camera - The camera to use. Defaults to the current camera.\n\t *\n\t * @public\n\t */\n\tscreenToPage(x: number, y: number, z = 0.5, camera: Vec2dModel = this.camera) {\n\t\tconst { screenBounds } = this.store.unsafeGetWithoutCapture(TLINSTANCE_ID)!\n\t\tconst { x: cx, y: cy, z: cz = 1 } = camera\n\t\treturn {\n\t\t\tx: (x - screenBounds.x) / cz - cx,\n\t\t\ty: (y - screenBounds.y) / cz - cy,\n\t\t\tz,\n\t\t}\n\t}\n\n\t/**\n\t * Convert a point in page space to a point in screen space.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.pageToScreen(100, 100)\n\t * ```\n\t *\n\t * @param x - The x coordinate of the point in screen space.\n\t * @param y - The y coordinate of the point in screen space.\n\t * @param camera - The camera to use. Defaults to the current camera.\n\t *\n\t * @public\n\t */\n\tpageToScreen(x: number, y: number, z = 0.5, camera: Vec2dModel = this.camera) {\n\t\tconst { x: cx, y: cy, z: cz = 1 } = camera\n\t\treturn {\n\t\t\tx: x + cx * cz,\n\t\t\ty: y + cy * cz,\n\t\t\tz,\n\t\t}\n\t}\n\n\t/* -------- Rendering Shapes / rendering Bounds ------- */\n\n\tprivate _cameraState = atom('camera state', 'idle' as 'idle' | 'moving')\n\n\t/**\n\t * Whether the camera is moving or idle.\n\t *\n\t * @public\n\t */\n\t@computed get cameraState() {\n\t\treturn this._cameraState.value\n\t}\n\n\t// Camera state does two things: first, it allows us to subscribe to whether\n\t// the camera is moving or not; and second, it allows us to update the rendering\n\t// shapes on the canvas. Changing the rendering shapes may cause shapes to\n\t// unmount / remount in the DOM, which is expensive; and computing visibility is\n\t// also expensive in large projects. For this reason, we use a second bounding\n\t// box just for rendering, and we only update after the camera stops moving.\n\n\tprivate _cameraStateTimeoutRemaining = 0\n\tprivate _lastUpdateRenderingBoundsTimestamp = Date.now()\n\n\tprivate _decayCameraStateTimeout = (elapsed: number) => {\n\t\tthis._cameraStateTimeoutRemaining -= elapsed\n\n\t\tif (this._cameraStateTimeoutRemaining <= 0) {\n\t\t\tthis.off('tick', this._decayCameraStateTimeout)\n\t\t\tthis._cameraState.set('idle')\n\t\t\tthis.updateRenderingBounds()\n\t\t}\n\t}\n\n\tprivate _tickCameraState = () => {\n\t\t// always reset the timeout\n\t\tthis._cameraStateTimeoutRemaining = CAMERA_MOVING_TIMEOUT\n\n\t\tconst now = Date.now()\n\n\t\t// If the state is idle, then start the tick\n\t\tif (this._cameraState.__unsafe__getWithoutCapture() === 'idle') {\n\t\t\tthis._lastUpdateRenderingBoundsTimestamp = now // don't render right away\n\t\t\tthis._cameraState.set('moving')\n\t\t\tthis.on('tick', this._decayCameraStateTimeout)\n\t\t} else {\n\t\t\tif (now - this._lastUpdateRenderingBoundsTimestamp > CAMERA_MAX_RENDERING_INTERVAL) {\n\t\t\t\tthis.updateRenderingBounds()\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate computeUnorderedRenderingShapes(\n\t\tids: TLParentId[],\n\t\t{\n\t\t\trenderingBounds,\n\t\t\trenderingBoundsExpanded,\n\t\t\terasingIdsSet,\n\t\t\teditingId,\n\t\t}: {\n\t\t\trenderingBounds?: Box2d\n\t\t\trenderingBoundsExpanded?: Box2d\n\t\t\terasingIdsSet?: Set<TLShapeId>\n\t\t\teditingId?: TLShapeId | null\n\t\t} = {}\n\t) {\n\t\t// Here we get the shape as well as any of its children, as well as their\n\t\t// opacities. If the shape is being erased, and none of its ancestors are\n\t\t// being erased, then we reduce the opacity of the shape and all of its\n\t\t// ancestors; but we don't apply this effect more than once among a set\n\t\t// of descendants so that it does not compound.\n\n\t\t// This is designed to keep all the shapes in a single list which\n\t\t// allows the DOM nodes to be reused even when they become children\n\t\t// of other nodes.\n\n\t\tconst renderingShapes: {\n\t\t\tid: TLShapeId\n\t\t\tindex: number\n\t\t\tbackgroundIndex: number\n\t\t\topacity: number\n\t\t\tisCulled: boolean\n\t\t\tisInViewport: boolean\n\t\t\tmaskedPageBounds: Box2d | undefined\n\t\t}[] = []\n\n\t\tlet nextIndex = MAX_SHAPES_PER_PAGE\n\t\tlet nextBackgroundIndex = 0\n\n\t\tconst addShapeById = (id: TLParentId, parentOpacity: number, isAncestorErasing: boolean) => {\n\t\t\tif (PageRecordType.isId(id)) {\n\t\t\t\tfor (const childId of this.getSortedChildIds(id)) {\n\t\t\t\t\taddShapeById(childId, parentOpacity, isAncestorErasing)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tconst shape = this.getShapeById(id)\n\t\t\tif (!shape) return\n\n\t\t\tlet opacity = shape.opacity * parentOpacity\n\t\t\tlet isShapeErasing = false\n\n\t\t\tif (!isAncestorErasing && erasingIdsSet?.has(id)) {\n\t\t\t\tisShapeErasing = true\n\t\t\t\topacity *= 0.32\n\t\t\t}\n\n\t\t\t// If a child is outside of its parent's clipping bounds, then bounds will be undefined.\n\t\t\tconst maskedPageBounds = this.getMaskedPageBoundsById(id)\n\n\t\t\t// Whether the shape is on screen. Use the \"strict\" viewport here.\n\t\t\tconst isInViewport = maskedPageBounds\n\t\t\t\t? renderingBounds?.includes(maskedPageBounds) ?? true\n\t\t\t\t: false\n\n\t\t\t// Whether the shape should actually be culled / unmounted.\n\t\t\t// - Use the \"expanded\" rendering viewport to include shapes that are just off-screen.\n\t\t\t// - Editing shapes should never be culled.\n\t\t\tconst isCulled = maskedPageBounds\n\t\t\t\t? (editingId !== id && !renderingBoundsExpanded?.includes(maskedPageBounds)) ?? true\n\t\t\t\t: true\n\n\t\t\trenderingShapes.push({\n\t\t\t\tid,\n\t\t\t\tindex: nextIndex,\n\t\t\t\tbackgroundIndex: nextBackgroundIndex,\n\t\t\t\topacity,\n\t\t\t\tisCulled,\n\t\t\t\tisInViewport,\n\t\t\t\tmaskedPageBounds,\n\t\t\t})\n\n\t\t\tnextIndex += 1\n\t\t\tnextBackgroundIndex += 1\n\n\t\t\tconst childIds = this.getSortedChildIds(id)\n\t\t\tif (!childIds.length) return\n\n\t\t\tlet backgroundIndexToRestore = null\n\t\t\tif (this.getShapeUtil(shape).providesBackgroundForChildren(shape)) {\n\t\t\t\tbackgroundIndexToRestore = nextBackgroundIndex\n\t\t\t\tnextBackgroundIndex = nextIndex\n\t\t\t\tnextIndex += MAX_SHAPES_PER_PAGE\n\t\t\t}\n\n\t\t\tfor (const childId of childIds) {\n\t\t\t\taddShapeById(childId, opacity, isAncestorErasing || isShapeErasing)\n\t\t\t}\n\n\t\t\tif (backgroundIndexToRestore !== null) {\n\t\t\t\tnextBackgroundIndex = backgroundIndexToRestore\n\t\t\t}\n\t\t}\n\n\t\tfor (const id of ids) {\n\t\t\taddShapeById(id, 1, false)\n\t\t}\n\n\t\treturn renderingShapes\n\t}\n\n\t/**\n\t * Get the shapes that should be displayed in the current viewport.\n\t *\n\t * @public\n\t */\n\t@computed get renderingShapes() {\n\t\tconst renderingShapes = this.computeUnorderedRenderingShapes([this.currentPageId], {\n\t\t\trenderingBounds: this.renderingBounds,\n\t\t\trenderingBoundsExpanded: this.renderingBoundsExpanded,\n\t\t\terasingIdsSet: this.erasingIdsSet,\n\t\t\teditingId: this.editingId,\n\t\t})\n\n\t\t// Its IMPORTANT that the result be sorted by id AND include the index\n\t\t// that the shape should be displayed at. Steve, this is the past you\n\t\t// telling the present you not to change this.\n\n\t\t// We want to sort by id because moving elements about in the DOM will\n\t\t// cause the element to get removed by react as it moves the DOM node. This\n\t\t// causes <iframes/> to re-render which is hella annoying and a perf\n\t\t// drain. By always sorting by 'id' we keep the shapes always in the\n\t\t// same order; but we later use index to set the element's 'z-index'\n\t\t// to change the \"rendered\" position in z-space.\n\t\treturn renderingShapes.sort(sortById)\n\t}\n\n\t/**\n\t * The current rendering bounds in page space, used for checking which shapes are \"on screen\".\n\t *\n\t * @public\n\t */\n\t@computed get renderingBounds() {\n\t\treturn this._renderingBounds.value\n\t}\n\n\t/** @internal */\n\treadonly _renderingBounds = atom('rendering viewport', new Box2d())\n\n\t/**\n\t * The current rendering bounds in page space, expanded slightly. Used for determining which shapes\n\t * to render and which to \"cull\".\n\t *\n\t * @public\n\t */\n\t@computed get renderingBoundsExpanded() {\n\t\treturn this._renderingBoundsExpanded.value\n\t}\n\n\t/** @internal */\n\treadonly _renderingBoundsExpanded = atom('rendering viewport expanded', new Box2d())\n\n\t/**\n\t * Update the rendering bounds. This should be called when the viewport has stopped changing, such\n\t * as at the end of a pan, zoom, or animation.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.updateRenderingBounds()\n\t * ```\n\t *\n\t *\n\t * @internal\n\t */\n\tupdateRenderingBounds(): this {\n\t\tconst { viewportPageBounds } = this\n\t\tif (viewportPageBounds.equals(this._renderingBounds.__unsafe__getWithoutCapture())) return this\n\t\tthis._renderingBounds.set(viewportPageBounds.clone())\n\t\tthis._renderingBoundsExpanded.set(viewportPageBounds.clone().expandBy(100 / this.zoomLevel))\n\t\treturn this\n\t}\n\n\t/* --------------------- Shapes --------------------- */\n\n\t/**\n\t * Get the local transform for a shape as a matrix model. This transform reflects both its\n\t * translation (x, y) from from either its parent's top left corner, if the shape's parent is\n\t * another shape, or else from the 0,0 of the page, if the shape's parent is the page; and the\n\t * shape's rotation.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.getTransform(myShape)\n\t * ```\n\t *\n\t * @param shape - The shape to get the local transform for.\n\t *\n\t * @public\n\t */\n\tgetTransform(shape: TLShape) {\n\t\treturn Matrix2d.Compose(Matrix2d.Translate(shape.x, shape.y), Matrix2d.Rotate(shape.rotation))\n\t}\n\n\t/**\n\t * Get the local transform of a shape's parent as a matrix model.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.getParentTransform(myShape)\n\t * ```\n\t *\n\t * @param shape - The shape to get the parent transform for.\n\t *\n\t * @public\n\t */\n\tgetParentTransform(shape: TLShape) {\n\t\tif (isPageId(shape.parentId)) {\n\t\t\treturn Matrix2d.Identity()\n\t\t}\n\t\treturn this._pageTransformCache.get(shape.parentId) ?? Matrix2d.Identity()\n\t}\n\n\t/**\n\t * Get the page transform (or absolute transform) of a shape.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.getPageTransform(myShape)\n\t * ```\n\t *\n\t * @param shape - The shape to get the page transform for.\n\t *\n\t * @public\n\t */\n\tgetPageTransform(shape: TLShape) {\n\t\treturn this.getPageTransformById(shape.id)\n\t}\n\n\t/**\n\t * Get the page transform (or absolute transform) of a shape by its id.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.getPageTransformById(myShape)\n\t * ```\n\t *\n\t * @param id - The if of the shape to get the page transform for.\n\t *\n\t * @public\n\t */\n\tgetPageTransformById(id: TLShapeId) {\n\t\treturn this._pageTransformCache.get(id)\n\t}\n\n\t/**\n\t * Get the page point (or absolute point) of a shape.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.getPagePoint(myShape)\n\t * ```\n\t *\n\t * @param shape - The shape to get the page point for.\n\t *\n\t * @public\n\t */\n\tgetPagePointById(id: TLShapeId) {\n\t\tconst pageTransform = this.getPageTransformById(id)\n\t\tif (!pageTransform) return\n\t\treturn Matrix2d.applyToPoint(pageTransform, new Vec2d())\n\t}\n\n\t/**\n\t * Get the page point (or absolute point) of a shape.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.getPagePoint(myShape)\n\t * ```\n\t *\n\t * @param shape - The shape to get the page point for.\n\t *\n\t * @public\n\t */\n\tgetPageCenter(shape: TLShape) {\n\t\tconst pageTransform = this.getPageTransformById(shape.id)\n\t\tif (!pageTransform) return null\n\t\tconst util = this.getShapeUtil(shape)\n\t\tconst center = util.center(shape)\n\t\treturn Matrix2d.applyToPoint(pageTransform, center)\n\t}\n\n\t/**\n\t * Get the page point (or absolute point) of a shape by its id.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.getPagePoint(myShape)\n\t * ```\n\t *\n\t * @param id - The shape id to get the page point for.\n\t *\n\t * @public\n\t */\n\tgetPageCenterById(id: TLShapeId) {\n\t\tconst shape = this.getShapeById(id)!\n\t\treturn this.getPageCenter(shape)\n\t}\n\n\t/**\n\t * Get the page rotation (or absolute rotation) of a shape.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.getPageRotation(myShape)\n\t * ```\n\t *\n\t * @param shape - The shape to get the page rotation for.\n\t *\n\t * @public\n\t */\n\tgetPageRotation(shape: TLShape): number {\n\t\treturn this.getPageRotationById(shape.id)\n\t}\n\n\t/**\n\t * Get the page rotation (or absolute rotation) of a shape by its id.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.getPageRotationById(myShapeId)\n\t * ```\n\t *\n\t * @param id - The id of the shape to get the page rotation for.\n\t */\n\tgetPageRotationById(id: TLShapeId): number {\n\t\tconst pageTransform = this.getPageTransformById(id)\n\t\tif (pageTransform) {\n\t\t\treturn Matrix2d.Decompose(pageTransform).rotation\n\t\t}\n\t\treturn 0\n\t}\n\n\t/**\n\t * Get the local bounds of a shape.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.getBounds(myShape)\n\t * ```\n\t *\n\t * @param shape - The shape to get the bounds for.\n\t *\n\t * @public\n\t */\n\tgetBounds(shape: TLShape): Box2d {\n\t\treturn this.getShapeUtil(shape).bounds(shape)\n\t}\n\n\t/**\n\t * Get the local bounds of a shape by its id.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.getBoundsById(myShape)\n\t * ```\n\t *\n\t * @param id - The id of the shape to get the bounds for.\n\t *\n\t * @public\n\t */\n\tgetBoundsById(id: TLShapeId): Box2d | undefined {\n\t\tconst shape = this.getShapeById(id)\n\t\tif (!shape) return undefined\n\t\treturn this.getBounds(shape)\n\t}\n\n\t/**\n\t * Get the page (or absolute) bounds of a shape.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.getPageBounds(myShape)\n\t * ```\n\t *\n\t * @param shape - The shape to get the bounds for.\n\t *\n\t * @public\n\t */\n\tgetPageBounds(shape: TLShape): Box2d | undefined {\n\t\treturn this.getPageBoundsById(shape.id)\n\t}\n\n\t/**\n\t * Get the page (or absolute) bounds of a shape by its id.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.getPageBoundsById(myShape)\n\t * ```\n\t *\n\t * @param id - The id of the shape to get the page bounds for.\n\t *\n\t * @public\n\t */\n\tgetPageBoundsById(id: TLShapeId): Box2d | undefined {\n\t\treturn this._pageBoundsCache.get(id)\n\t}\n\n\t/**\n\t * A cache of clip paths used for clipping.\n\t *\n\t * @internal\n\t */\n\t@computed private get _clipPathCache(): ComputedCache<string, TLShape> {\n\t\treturn this.store.createComputedCache<string, TLShape>('clipPathCache', (shape) => {\n\t\t\tconst pageMask = this._pageMaskCache.get(shape.id)\n\t\t\tif (!pageMask) return undefined\n\t\t\tconst pageTransform = this._pageTransformCache.get(shape.id)\n\t\t\tif (!pageTransform) return undefined\n\n\t\t\tif (pageMask.length === 0) {\n\t\t\t\treturn `polygon(0px 0px, 0px 0px, 0px 0px)`\n\t\t\t}\n\n\t\t\tconst localMask = Matrix2d.applyToPoints(Matrix2d.Inverse(pageTransform), pageMask)\n\n\t\t\treturn `polygon(${localMask.map((p) => `${p.x}px ${p.y}px`).join(',')})`\n\t\t})\n\t}\n\n\t/**\n\t * Get the clip path for a shape.\n\t *\n\t * @example\n\t * ```ts\n\t * const clipPath = editor.getClipPathById(shape.id)\n\t * ```\n\t *\n\t * @param id - The shape id.\n\t *\n\t * @returns The clip path or undefined.\n\t *\n\t * @public\n\t */\n\tgetClipPathById(id: TLShapeId) {\n\t\treturn this._clipPathCache.get(id)\n\t}\n\n\t/**\n\t * A cache of page masks used for clipping.\n\t *\n\t * @internal\n\t */\n\t@computed private get _pageMaskCache(): ComputedCache<VecLike[], TLShape> {\n\t\treturn this.store.createComputedCache<VecLike[], TLShape>('pageMaskCache', (shape) => {\n\t\t\tif (isPageId(shape.parentId)) {\n\t\t\t\treturn undefined\n\t\t\t}\n\n\t\t\tconst frameAncestors = this.getAncestorsById(shape.id).filter((shape) =>\n\t\t\t\tthis.isShapeOfType(shape, FrameShapeUtil)\n\t\t\t)\n\n\t\t\tif (frameAncestors.length === 0) return undefined\n\n\t\t\tconst pageMask = frameAncestors\n\t\t\t\t.map<VecLike[] | undefined>((s) =>\n\t\t\t\t\t// Apply the frame transform to the frame outline to get the frame outline in page space\n\t\t\t\t\tMatrix2d.applyToPoints(this._pageTransformCache.get(s.id)!, this.getOutline(s))\n\t\t\t\t)\n\t\t\t\t.reduce((acc, b) => (b && acc ? intersectPolygonPolygon(acc, b) ?? undefined : undefined))\n\n\t\t\treturn pageMask\n\t\t})\n\t}\n\n\t/**\n\t * Get the page mask for a shape.\n\t *\n\t * @example\n\t * ```ts\n\t * const pageMask = editor.getPageMaskById(shape.id)\n\t * ```\n\t *\n\t * @param id - The id of the shape to get the page mask for.\n\t *\n\t * @returns The page mask for the shape.\n\t *\n\t * @public\n\t */\n\tgetPageMaskById(id: TLShapeId) {\n\t\treturn this._pageMaskCache.get(id)\n\t}\n\n\t/**\n\t * Get the page (or absolute) bounds of a shape, incorporating any masks. For example, if the\n\t * shape were the child of a frame and was half way out of the frame, the bounds would be the half\n\t * of the shape that was in the frame.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.getMaskedPageBounds(myShape)\n\t * ```\n\t *\n\t * @param shape - The shape to get the masked bounds for.\n\t *\n\t * @public\n\t */\n\tgetMaskedPageBounds(shape: TLShape): Box2d | undefined {\n\t\treturn this.getMaskedPageBoundsById(shape.id)\n\t}\n\n\t/**\n\t * Get the page (or absolute) bounds of a shape by its id, incorporating any masks. For example,\n\t * if the shape were the child of a frame and was half way out of the frame, the bounds would be\n\t * the half of the shape that was in the frame.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.getMaskedPageBoundsById(myShape)\n\t * ```\n\t *\n\t * @param id - The id of the shape to get the masked page bounds for.\n\t *\n\t * @public\n\t */\n\tgetMaskedPageBoundsById(id: TLShapeId): Box2d | undefined {\n\t\tconst pageBounds = this._pageBoundsCache.get(id)\n\t\tif (!pageBounds) return\n\t\tconst pageMask = this._pageMaskCache.get(id)\n\t\tif (pageMask) {\n\t\t\tconst intersection = intersectPolygonPolygon(pageMask, pageBounds.corners)\n\t\t\tif (!intersection) return\n\t\t\treturn Box2d.FromPoints(intersection)\n\t\t}\n\t\treturn pageBounds\n\t}\n\n\t/**\n\t * Get the local outline of a shape.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.getOutline(myShape)\n\t * ```\n\t *\n\t * @param shape - The shape to get the outline for.\n\t *\n\t * @public\n\t */\n\tgetOutline(shape: TLShape) {\n\t\treturn this.getShapeUtil(shape).outline(shape)\n\t}\n\n\t/**\n\t * Get the local outline of a shape.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.getOutlineById(myShape)\n\t * ```\n\t *\n\t * @param id - The shape id to get the outline for.\n\t *\n\t * @public\n\t */\n\tgetOutlineById(id: TLShapeId) {\n\t\treturn this.getOutline(this.getShapeById(id)!)\n\t}\n\n\t/**\n\t * Get the ancestors of a shape.\n\t *\n\t * @example\n\t * ```ts\n\t * const ancestors = editor.getAncestors(myShape)\n\t * ```\n\t *\n\t * @param shape - The shape to get the ancestors for.\n\t *\n\t * @public\n\t */\n\tgetAncestors(shape: TLShape, acc: TLShape[] = []): TLShape[] {\n\t\tconst parentId = shape.parentId\n\t\tif (isPageId(parentId)) {\n\t\t\tacc.reverse()\n\t\t\treturn acc\n\t\t}\n\n\t\tconst parent = this.store.get(parentId)\n\t\tif (!parent) return acc\n\t\tacc.push(parent)\n\t\treturn this.getAncestors(parent, acc)\n\t}\n\n\t/**\n\t * Get the ancestors of a shape by its id.\n\t *\n\t * @example\n\t * ```ts\n\t * const ancestors = editor.getAncestorsById(myShape)\n\t * ```\n\t *\n\t * @param id - The id of the shape to get the ancestors for.\n\t *\n\t * @public\n\t */\n\tgetAncestorsById(id: TLShapeId, acc: TLShape[] = []): TLShape[] {\n\t\tconst shape = this.getShapeById(id)\n\t\tif (!shape) return acc\n\t\treturn this.getAncestors(shape, acc)\n\t}\n\n\t/**\n\t * Find the first ancestor matching the given predicate\n\t *\n\t * @example\n\t * ```ts\n\t * const ancestor = editor.findAncestor(myShape)\n\t * ```\n\t *\n\t * @param shape - The shape to check the ancestors for.\n\t *\n\t * @public\n\t */\n\tfindAncestor(shape: TLShape, predicate: (parent: TLShape) => boolean): TLShape | undefined {\n\t\tconst parentId = shape.parentId\n\n\t\tif (isPageId(parentId)) {\n\t\t\treturn undefined\n\t\t}\n\n\t\tconst parent = this.getShapeById(parentId)\n\n\t\tif (parent) {\n\t\t\tif (predicate(parent)) {\n\t\t\t\treturn parent\n\t\t\t}\n\t\t\treturn this.findAncestor(parent, predicate)\n\t\t}\n\n\t\treturn undefined\n\t}\n\n\t/**\n\t * Returns true if the the given shape has the given ancestor.\n\t *\n\t * @param shape - The shape.\n\t * @param ancestorId - The id of the ancestor.\n\t *\n\t * @public\n\t */\n\thasAncestor(shape: TLShape | undefined, ancestorId: TLShapeId): boolean {\n\t\tif (!shape) return false\n\t\tif (shape.parentId === ancestorId) return true\n\t\treturn this.hasAncestor(this.getParentShape(shape), ancestorId)\n\t}\n\n\t/**\n\t * Get the common ancestor of two or more shapes that matches a predicate.\n\t *\n\t * @param shapes - The shapes to check.\n\t * @param predicate - The predicate to match.\n\t */\n\tfindCommonAncestor(\n\t\tshapes: TLShape[],\n\t\tpredicate?: (shape: TLShape) => boolean\n\t): TLShapeId | undefined {\n\t\tif (shapes.length === 0) {\n\t\t\treturn\n\t\t}\n\t\tif (shapes.length === 1) {\n\t\t\tconst parentId = shapes[0].parentId\n\t\t\tif (isPageId(parentId)) {\n\t\t\t\treturn\n\t\t\t}\n\t\t\treturn predicate ? this.findAncestor(shapes[0], predicate)?.id : parentId\n\t\t}\n\n\t\tconst [nodeA, ...others] = shapes\n\t\tlet ancestor = this.getParentShape(nodeA)\n\t\twhile (ancestor) {\n\t\t\t// TODO: this is not ideal, optimize\n\t\t\tif (predicate && !predicate(ancestor)) {\n\t\t\t\tancestor = this.getParentShape(ancestor)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif (others.every((shape) => this.hasAncestor(shape, ancestor!.id))) {\n\t\t\t\treturn ancestor!.id\n\t\t\t}\n\t\t\tancestor = this.getParentShape(ancestor)\n\t\t}\n\t\treturn undefined\n\t}\n\n\t/**\n\t * Check whether a shape or its parent is locked.\n\t *\n\t * @param id - The id of the shape to check.\n\t *\n\t * @public\n\t */\n\tisShapeOrAncestorLocked(shape?: TLShape): boolean {\n\t\tif (shape === undefined) return false\n\t\tif (shape.isLocked) return true\n\t\treturn this.isShapeOrAncestorLocked(this.getParentShape(shape))\n\t}\n\n\t/**\n\t * The common bounds of all of the shapes on the page.\n\t *\n\t * @public\n\t */\n\t@computed get allShapesCommonBounds(): Box2d | null {\n\t\tlet commonBounds = null as Box2d | null\n\n\t\tthis.currentPageShapeIds.forEach((shapeId) => {\n\t\t\tconst bounds = this.getMaskedPageBoundsById(shapeId)\n\t\t\tif (bounds) {\n\t\t\t\tif (commonBounds) {\n\t\t\t\t\tcommonBounds.expand(bounds)\n\t\t\t\t} else {\n\t\t\t\t\tcommonBounds = bounds.clone()\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\n\t\treturn commonBounds\n\t}\n\n\t/**\n\t * Get the corners of a shape in page space.\n\t *\n\t * @example\n\t * ```ts\n\t * const corners = editor.getPageCorners(myShape)\n\t * ```\n\t *\n\t * @param shape - The shape to get the corners for.\n\t *\n\t * @public\n\t */\n\tgetPageCorners(shape: TLShape): Vec2d[] {\n\t\tconst ancestors = this.getAncestors(shape)\n\t\tconst corners = this.getBounds(shape).corners\n\n\t\tconst transform = Matrix2d.Compose(\n\t\t\t...ancestors.flatMap((s) => [Matrix2d.Translate(s.x, s.y), Matrix2d.Rotate(s.rotation)]),\n\t\t\tMatrix2d.Translate(shape.x, shape.y),\n\t\t\tMatrix2d.Rotate(shape.rotation, 0, 0)\n\t\t)\n\n\t\treturn Matrix2d.applyToPoints(transform, corners)\n\t}\n\n\t/**\n\t * Test whether a point (in page space) will will a shape. This method takes into account masks,\n\t * such as when a shape is the child of a frame and is partially clipped by the frame.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.isPointInShape({ x: 100, y: 100 }, myShape)\n\t * ```\n\t *\n\t * @param point - The page point to test.\n\t * @param shape - The shape to test against.\n\t *\n\t * @public\n\t */\n\tisPointInShape(point: VecLike, shape: TLShape): boolean {\n\t\tconst util = this.getShapeUtil(shape)\n\n\t\tconst pageMask = this._pageMaskCache.get(shape.id)\n\n\t\tif (pageMask) {\n\t\t\tconst hit = pointInPolygon(point, pageMask)\n\t\t\tif (!hit) return false\n\t\t}\n\n\t\treturn util.hitTestPoint(shape, this.getPointInShapeSpace(shape, point))\n\t}\n\n\t/**\n\t * Get the shapes, if any, at a given page point.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.getShapesAtPoint({ x: 100, y: 100 })\n\t * ```\n\t *\n\t * @param point - The page point to test.\n\t *\n\t * @public\n\t */\n\tgetShapesAtPoint(point: VecLike): TLShape[] {\n\t\treturn this.shapesArray.filter((shape) => {\n\t\t\t// Check the page mask too\n\t\t\tconst pageMask = this._pageMaskCache.get(shape.id)\n\t\t\tif (pageMask) {\n\t\t\t\treturn pointInPolygon(point, pageMask)\n\t\t\t}\n\n\t\t\t// Otherwise, use the shape's own hit test method\n\t\t\treturn this.getShapeUtil(shape).hitTestPoint(shape, this.getPointInShapeSpace(shape, point))\n\t\t})\n\t}\n\n\t/**\n\t * Convert a point in page space to a point in the local space of a shape. For example, if a\n\t * shape's page point were `{ x: 100, y: 100 }`, a page point at `{ x: 110, y: 110 }` would be at\n\t * `{ x: 10, y: 10 }` in the shape's local space.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.getPointInShapeSpace(myShape, { x: 100, y: 100 })\n\t * ```\n\t *\n\t * @param shape - The shape to get the point in the local space of.\n\t * @param point - The page point to get in the local space of the shape.\n\t *\n\t * @public\n\t */\n\tgetPointInShapeSpace(shape: TLShape, point: VecLike): Vec2d {\n\t\treturn Matrix2d.applyToPoint(Matrix2d.Inverse(this.getPageTransform(shape)!), point)\n\t}\n\n\t/**\n\t * Convert a delta in page space to a point in the local space of a shape. For example, if a\n\t * shape's page point were `{ x: 100, y: 100 }`, a page point at `{ x: 110, y: 110 }` would be at\n\t * `{ x: 10, y: 10 }` in the shape's local space.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.getPointInShapeSpace(myShape.id, { x: 100, y: 100 })\n\t * ```\n\t *\n\t * @param shape - The shape to get the point in the local space of.\n\t * @param point - The page point to get in the local space of the shape.\n\t *\n\t * @public\n\t */\n\tgetPointInParentSpace(shapeId: TLShapeId, point: VecLike): Vec2d {\n\t\tconst shape = this.getShapeById(shapeId)!\n\t\tif (!shape) {\n\t\t\treturn new Vec2d(0, 0)\n\t\t}\n\t\tif (isPageId(shape.parentId)) return Vec2d.From(point)\n\n\t\tconst parentTransform = this.getPageTransformById(shape.parentId)\n\t\tif (!parentTransform) return Vec2d.From(point)\n\n\t\treturn Matrix2d.applyToPoint(Matrix2d.Inverse(parentTransform), point)\n\t}\n\n\t/**\n\t * Convert a delta in page space to a delta in the local space of a shape.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.getDeltaInShapeSpace(myShape, { x: 100, y: 100 })\n\t * ```\n\t *\n\t * @param shape - The shape to get the delta in the local space of.\n\t * @param delta - The page delta to convert.\n\t *\n\t * @public\n\t */\n\tgetDeltaInShapeSpace(shape: TLShape, delta: VecLike): Vec2d {\n\t\tconst pageTransform = this.getPageTransform(shape)\n\t\tif (!pageTransform) return Vec2d.From(delta)\n\t\treturn Vec2d.Rot(delta, -Matrix2d.Decompose(pageTransform).rotation)\n\t}\n\n\t/**\n\t * Convert a delta in page space to a delta in the parent space of a shape.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.getDeltaInParentSpace(myShape, { x: 100, y: 100 })\n\t * ```\n\t *\n\t * @param shape - The shape to get the delta in the parent space of.\n\t * @param delta - The page delta to convert.\n\t *\n\t * @public\n\t */\n\tgetDeltaInParentSpace(shape: TLShape, delta: VecLike): Vec2d {\n\t\tif (isPageId(shape.parentId)) return Vec2d.From(delta)\n\n\t\tconst parent = this.getShapeById(shape.parentId)\n\t\tif (!parent) return Vec2d.From(delta)\n\n\t\treturn this.getDeltaInShapeSpace(parent, delta)\n\t}\n\n\t/**\n\t * For a given set of ids, get a map containing the ids of their parents and the children of those\n\t * parents.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.getParentsMappedToChildren(['id1', 'id2', 'id3'])\n\t * ```\n\t *\n\t * @param ids - The ids to get the parents and children of.\n\t *\n\t * @public\n\t */\n\tgetParentsMappedToChildren(ids: TLShapeId[]) {\n\t\tconst shapes = ids.map((id) => this.store.get(id)!)\n\t\tconst parents = new Map<TLParentId, Set<TLShape>>()\n\t\tshapes.forEach((shape) => {\n\t\t\tif (!parents.has(shape.parentId)) {\n\t\t\t\tparents.set(shape.parentId, new Set())\n\t\t\t}\n\t\t\tparents.get(shape.parentId)?.add(shape)\n\t\t})\n\t\treturn parents\n\t}\n\n\t/**\n\t * The current page bounds of all the selected shapes (Not the same thing as the page bounds of\n\t * the selection bounding box when the selection has been rotated)\n\t *\n\t * @readonly\n\t *\n\t * @public\n\t */\n\t@computed get selectedPageBounds(): Box2d | null {\n\t\tconst {\n\t\t\tpageState: { selectedIds },\n\t\t} = this\n\n\t\tif (selectedIds.length === 0) return null\n\n\t\treturn Box2d.Common(compact(selectedIds.map((id) => this.getPageBoundsById(id))))\n\t}\n\n\t/**\n\t * The rotation of the selection bounding box.\n\t *\n\t * @readonly\n\t * @public\n\t */\n\t@computed get selectionRotation(): number {\n\t\tconst { selectedIds } = this\n\t\tif (selectedIds.length === 0) {\n\t\t\treturn 0\n\t\t}\n\t\tif (selectedIds.length === 1) {\n\t\t\treturn this.getPageRotationById(this.selectedIds[0])\n\t\t}\n\n\t\tconst allRotations = selectedIds.map((id) => this.getPageRotationById(id) % (Math.PI / 2))\n\t\t// if the rotations are all compatible with each other, return the rotation of any one of them\n\t\tif (allRotations.every((rotation) => Math.abs(rotation - allRotations[0]) < Math.PI / 180)) {\n\t\t\treturn this.getPageRotationById(selectedIds[0])\n\t\t}\n\t\treturn 0\n\t}\n\n\t/**\n\t * The bounds of the selection bounding box.\n\t *\n\t * @readonly\n\t * @public\n\t */\n\t@computed get selectionBounds(): Box2d | undefined {\n\t\tconst { selectedIds } = this\n\n\t\tif (selectedIds.length === 0) {\n\t\t\treturn undefined\n\t\t}\n\n\t\tconst { selectionRotation } = this\n\t\tif (selectionRotation === 0) {\n\t\t\treturn this.selectedPageBounds!\n\t\t}\n\n\t\tif (selectedIds.length === 1) {\n\t\t\tconst bounds = this.getBounds(this.getShapeById(selectedIds[0])!).clone()\n\t\t\tbounds.point = Matrix2d.applyToPoint(this.getPageTransformById(selectedIds[0])!, bounds.point)\n\t\t\treturn bounds\n\t\t}\n\n\t\t// need to 'un-rotate' all the outlines of the existing nodes so we can fit them inside a box\n\t\tconst allPoints = this.selectedIds\n\t\t\t.flatMap((id) => {\n\t\t\t\tconst pageTransform = this.getPageTransformById(id)\n\t\t\t\tif (!pageTransform) return []\n\t\t\t\treturn this.getOutlineById(id).map((point) => Matrix2d.applyToPoint(pageTransform, point))\n\t\t\t})\n\t\t\t.map((p) => Vec2d.Rot(p, -selectionRotation))\n\t\tconst box = Box2d.FromPoints(allPoints)\n\t\t// now position box so that it's top-left corner is in the right place\n\t\tbox.point = box.point.rot(selectionRotation)\n\t\treturn box\n\t}\n\n\t/**\n\t * The center of the selection bounding box.\n\t *\n\t * @readonly\n\t * @public\n\t */\n\t@computed get selectionPageCenter() {\n\t\tconst { selectionBounds, selectionRotation } = this\n\t\tif (!selectionBounds) return null\n\t\treturn Vec2d.RotWith(selectionBounds.center, selectionBounds.point, selectionRotation)\n\t}\n\n\t/* ------------------- Statechart ------------------- */\n\n\t/**\n\t * The id of the current selected tool.\n\t *\n\t * @public\n\t */\n\tget currentToolId(): string {\n\t\tconst activeTool = this.root.current.value\n\t\tlet activeToolId = activeTool?.id\n\n\t\t// Often a tool will transition into one of the following select states after the initial pointerdown: 'translating', 'resizing', 'dragging_handle'\n\t\t// It should then supply the tool id to the `onInteractionEnd` property to tell us which tool initially triggered the interaction.\n\t\t// If tool lock mode is on then tldraw will switch to the given tool id.\n\t\t// If tool lock mode is off then tldraw will switch back to the select tool when the interaction ends.\n\n\t\tif (activeToolId === 'select' || activeToolId === 'zoom') {\n\t\t\tconst currentChildState = activeTool?.current.value as any\n\t\t\tactiveToolId = currentChildState?.info?.onInteractionEnd ?? 'select'\n\t\t}\n\n\t\treturn activeToolId ?? 'select'\n\t}\n\n\t/**\n\t * Set the selected tool.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.setSelectedTool('hand')\n\t * editor.setSelectedTool('hand', { date: Date.now() })\n\t * ```\n\t *\n\t * @param id - The id of the tool to select.\n\t * @param info - Arbitrary data to pass along into the transition.\n\t *\n\t * @public\n\t */\n\tsetSelectedTool(id: string, info = {}) {\n\t\tthis.root.transition(id, info)\n\t\treturn this\n\t}\n\n\t/**\n\t * Get a descendant by its path.\n\t *\n\t * @example\n\t * ```ts\n\t * state.getStateDescendant('select')\n\t * state.getStateDescendant('select.brushing')\n\t * ```\n\t *\n\t * @param path - The descendant's path of state ids, separated by periods.\n\t *\n\t * @public\n\t */\n\tgetStateDescendant(path: string): StateNode | undefined {\n\t\tconst ids = path.split('.').reverse()\n\t\tlet state = this.root as StateNode\n\t\twhile (ids.length > 0) {\n\t\t\tconst id = ids.pop()\n\t\t\tif (!id) return state\n\t\t\tconst childState = state.children?.[id]\n\t\t\tif (!childState) return undefined\n\t\t\tstate = childState\n\t\t}\n\t\treturn state\n\t}\n\n\t/**\n\t * Get whether a certain tool (or other state node) is currently active.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.isIn('select')\n\t * editor.isIn('select.brushing')\n\t * ```\n\t *\n\t * @param path - The path of active states, separated by periods.\n\t *\n\t * @public\n\t */\n\tisIn(path: string): boolean {\n\t\tconst ids = path.split('.').reverse()\n\t\tlet state = this.root as StateNode\n\t\twhile (ids.length > 0) {\n\t\t\tconst id = ids.pop()\n\t\t\tif (!id) return true\n\t\t\tconst current = state.current.value\n\t\t\tif (current?.id === id) {\n\t\t\t\tif (ids.length === 0) return true\n\t\t\t\tstate = current\n\t\t\t\tcontinue\n\t\t\t} else return false\n\t\t}\n\t\treturn false\n\t}\n\n\t/**\n\t * Get whether the state node is in any of the given active paths.\n\t *\n\t * @example\n\t * ```ts\n\t * state.isInAny('select', 'erase')\n\t * state.isInAny('select.brushing', 'erase.idle')\n\t * ```\n\t *\n\t * @public\n\t */\n\tisInAny(...paths: string[]): boolean {\n\t\treturn paths.some((path) => this.isIn(path))\n\t}\n\n\t/* --------------------- Inputs --------------------- */\n\n\t/**\n\t * The app's current input state.\n\t *\n\t * @public\n\t */\n\tinputs = {\n\t\t/** The most recent pointer down's position in page space. */\n\t\toriginPagePoint: new Vec2d(),\n\t\t/** The most recent pointer down's position in screen space. */\n\t\toriginScreenPoint: new Vec2d(),\n\t\t/** The previous pointer position in page space. */\n\t\tpreviousPagePoint: new Vec2d(),\n\t\t/** The previous pointer position in screen space. */\n\t\tpreviousScreenPoint: new Vec2d(),\n\t\t/** The most recent pointer position in page space. */\n\t\tcurrentPagePoint: new Vec2d(),\n\t\t/** The most recent pointer position in screen space. */\n\t\tcurrentScreenPoint: new Vec2d(),\n\t\t/** A set containing the currently pressed keys. */\n\t\tkeys: new Set<string>(),\n\t\t/** A set containing the currently pressed buttons. */\n\t\tbuttons: new Set<number>(),\n\t\t/** Whether the input is from a pe. */\n\t\tisPen: false,\n\t\t/** Whether the shift key is currently pressed. */\n\t\tshiftKey: false,\n\t\t/** Whether the control or command key is currently pressed. */\n\t\tctrlKey: false,\n\t\t/** Whether the alt or option key is currently pressed. */\n\t\taltKey: false,\n\t\t/** Whether the user is dragging. */\n\t\tisDragging: false,\n\t\t/** Whether the user is pointing. */\n\t\tisPointing: false,\n\t\t/** Whether the user is pinching. */\n\t\tisPinching: false,\n\t\t/** Whether the user is editing. */\n\t\tisEditing: false,\n\t\t/** Whether the user is panning. */\n\t\tisPanning: false,\n\t\t/** Velocity of mouse pointer, in pixels per millisecond */\n\t\tpointerVelocity: new Vec2d(),\n\t}\n\n\t/**\n\t * Update the input points from a pointer or pinch event.\n\t *\n\t * @param info - The event info.\n\t */\n\tprivate _updateInputsFromEvent(info: TLPointerEventInfo | TLPinchEventInfo) {\n\t\tconst { previousScreenPoint, previousPagePoint, currentScreenPoint, currentPagePoint } =\n\t\t\tthis.inputs\n\n\t\tconst { screenBounds } = this.store.unsafeGetWithoutCapture(TLINSTANCE_ID)!\n\t\tconst { x: sx, y: sy, z: sz } = info.point\n\t\tconst { x: cx, y: cy, z: cz } = this.camera\n\n\t\tpreviousScreenPoint.setTo(currentScreenPoint)\n\t\tpreviousPagePoint.setTo(currentPagePoint)\n\n\t\tcurrentScreenPoint.set(sx, sy)\n\t\tcurrentPagePoint.set(\n\t\t\t(sx - screenBounds.x) / cz - cx,\n\t\t\t(sy - screenBounds.y) / cz - cy,\n\t\t\tsz ?? 0.5\n\t\t)\n\n\t\tthis.inputs.isPen = info.type === 'pointer' && info.isPen\n\n\t\t// Reset velocity on pointer down\n\t\tif (info.name === 'pointer_down') {\n\t\t\tthis.inputs.pointerVelocity.set(0, 0)\n\t\t}\n\n\t\t// todo: We only have to do this if there are multiple users in the document\n\t\tthis.store.put([\n\t\t\t{\n\t\t\t\tid: TLPOINTER_ID,\n\t\t\t\ttypeName: 'pointer',\n\t\t\t\tx: currentPagePoint.x,\n\t\t\t\ty: currentPagePoint.y,\n\t\t\t\tlastActivityTimestamp:\n\t\t\t\t\t// If our pointer moved only because we're following some other user, then don't\n\t\t\t\t\t// update our last activity timestamp; otherwise, update it to the current timestamp.\n\t\t\t\t\tinfo.type === 'pointer' && info.pointerId === INTERNAL_POINTER_IDS.CAMERA_MOVE\n\t\t\t\t\t\t? this.store.get(TLPOINTER_ID)?.lastActivityTimestamp ?? Date.now()\n\t\t\t\t\t\t: Date.now(),\n\t\t\t},\n\t\t])\n\t}\n\n\t/* --------------------- Events --------------------- */\n\n\t/**\n\t * A manager for recording multiple click events.\n\t *\n\t * @internal\n\t */\n\tprotected _clickManager = new ClickManager(this)\n\n\t/**\n\t * Prevent a double click event from firing the next time the user clicks\n\t *\n\t * @public\n\t */\n\tcancelDoubleClick() {\n\t\tthis._clickManager.cancelDoubleClickTimeout()\n\t}\n\n\t/**\n\t * The previous cursor. Used for restoring the cursor after pan events.\n\t *\n\t * @internal\n\t */\n\tprivate _prevCursor: TLCursorType = 'default'\n\n\t/** @internal */\n\tprivate _shiftKeyTimeout = -1 as any\n\n\t/** @internal */\n\tprivate _setShiftKeyTimeout = () => {\n\t\tthis.inputs.shiftKey = false\n\t\tthis.dispatch({\n\t\t\ttype: 'keyboard',\n\t\t\tname: 'key_up',\n\t\t\tkey: 'Shift',\n\t\t\tshiftKey: this.inputs.shiftKey,\n\t\t\tctrlKey: this.inputs.ctrlKey,\n\t\t\taltKey: this.inputs.altKey,\n\t\t\tcode: 'ShiftLeft',\n\t\t})\n\t}\n\n\t/** @internal */\n\tprivate _altKeyTimeout = -1 as any\n\n\t/** @internal */\n\tprivate _setAltKeyTimeout = () => {\n\t\tthis.inputs.altKey = false\n\t\tthis.dispatch({\n\t\t\ttype: 'keyboard',\n\t\t\tname: 'key_up',\n\t\t\tkey: 'Alt',\n\t\t\tshiftKey: this.inputs.shiftKey,\n\t\t\tctrlKey: this.inputs.ctrlKey,\n\t\t\taltKey: this.inputs.altKey,\n\t\t\tcode: 'AltLeft',\n\t\t})\n\t}\n\n\t/** @internal */\n\tprivate _ctrlKeyTimeout = -1 as any\n\n\t/** @internal */\n\tprivate _setCtrlKeyTimeout = () => {\n\t\tthis.inputs.ctrlKey = false\n\t\tthis.dispatch({\n\t\t\ttype: 'keyboard',\n\t\t\tname: 'key_up',\n\t\t\tkey: 'Ctrl',\n\t\t\tshiftKey: this.inputs.shiftKey,\n\t\t\tctrlKey: this.inputs.ctrlKey,\n\t\t\taltKey: this.inputs.altKey,\n\t\t\tcode: 'ControlLeft',\n\t\t})\n\t}\n\n\t/** @internal */\n\tprivate _restoreToolId = 'select'\n\n\t/** @internal */\n\tprivate _pinchStart = 1\n\n\t/** @internal */\n\tprivate _didPinch = false\n\n\t/** @internal */\n\tprivate _selectedIdsAtPointerDown: TLShapeId[] = []\n\n\t/** @internal */\n\tcapturedPointerId: number | null = null\n\n\t/**\n\t * Dispatch an event to the editor.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.dispatch(myPointerEvent)\n\t * ```\n\t *\n\t * @param info - The event info.\n\t *\n\t * @public\n\t */\n\tdispatch(info: TLEventInfo): this {\n\t\t// prevent us from spamming similar event errors if we're crashed.\n\t\t// todo: replace with new readonly mode?\n\t\tif (this.crashingError) return this\n\n\t\tconst { inputs } = this\n\t\tconst { type } = info\n\n\t\tthis.batch(() => {\n\t\t\tif (info.type === 'misc') {\n\t\t\t\t// stop panning if the interaction is cancelled or completed\n\t\t\t\tif (info.name === 'cancel' || info.name === 'complete') {\n\t\t\t\t\tthis.inputs.isDragging = false\n\n\t\t\t\t\tif (this.inputs.isPanning) {\n\t\t\t\t\t\tthis.inputs.isPanning = false\n\t\t\t\t\t\tthis.setCursor({\n\t\t\t\t\t\t\ttype: this._prevCursor,\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis.root.handleEvent(info)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif (info.shiftKey) {\n\t\t\t\tclearInterval(this._shiftKeyTimeout)\n\t\t\t\tthis._shiftKeyTimeout = -1\n\t\t\t\tinputs.shiftKey = true\n\t\t\t} else if (!info.shiftKey && inputs.shiftKey && this._shiftKeyTimeout === -1) {\n\t\t\t\tthis._shiftKeyTimeout = setTimeout(this._setShiftKeyTimeout, 150)\n\t\t\t}\n\n\t\t\tif (info.altKey) {\n\t\t\t\tclearInterval(this._altKeyTimeout)\n\t\t\t\tthis._altKeyTimeout = -1\n\t\t\t\tinputs.altKey = true\n\t\t\t} else if (!info.altKey && inputs.altKey && this._altKeyTimeout === -1) {\n\t\t\t\tthis._altKeyTimeout = setTimeout(this._setAltKeyTimeout, 150)\n\t\t\t}\n\n\t\t\tif (info.ctrlKey) {\n\t\t\t\tclearInterval(this._ctrlKeyTimeout)\n\t\t\t\tthis._ctrlKeyTimeout = -1\n\t\t\t\tinputs.ctrlKey = true /** @internal */ /** @internal */ /** @internal */\n\t\t\t} else if (!info.ctrlKey && inputs.ctrlKey && this._ctrlKeyTimeout === -1) {\n\t\t\t\tthis._ctrlKeyTimeout = setTimeout(this._setCtrlKeyTimeout, 150)\n\t\t\t}\n\n\t\t\tconst { originPagePoint, originScreenPoint, currentPagePoint, currentScreenPoint } = inputs\n\n\t\t\tif (!inputs.isPointing) {\n\t\t\t\tinputs.isDragging = false\n\t\t\t}\n\n\t\t\tswitch (type) {\n\t\t\t\tcase 'pinch': {\n\t\t\t\t\tif (!this.canMoveCamera) return\n\t\t\t\t\tthis._updateInputsFromEvent(info)\n\n\t\t\t\t\tswitch (info.name) {\n\t\t\t\t\t\tcase 'pinch_start': {\n\t\t\t\t\t\t\tif (inputs.isPinching) return\n\n\t\t\t\t\t\t\tif (!inputs.isEditing) {\n\t\t\t\t\t\t\t\tthis._pinchStart = this.camera.z\n\t\t\t\t\t\t\t\tif (!this._selectedIdsAtPointerDown.length) {\n\t\t\t\t\t\t\t\t\tthis._selectedIdsAtPointerDown = this.selectedIds.slice()\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tthis._didPinch = true\n\n\t\t\t\t\t\t\t\tinputs.isPinching = true\n\n\t\t\t\t\t\t\t\tthis.interrupt()\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn // Stop here!\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 'pinch': {\n\t\t\t\t\t\t\tif (!inputs.isPinching) return\n\n\t\t\t\t\t\t\tconst {\n\t\t\t\t\t\t\t\tpoint: { x, y, z = 1 },\n\t\t\t\t\t\t\t\tdelta: { x: dx, y: dy },\n\t\t\t\t\t\t\t} = info\n\n\t\t\t\t\t\t\tconst {\n\t\t\t\t\t\t\t\tcamera: { x: cx, y: cy, z: cz },\n\t\t\t\t\t\t\t} = this\n\n\t\t\t\t\t\t\tconst zoom = Math.min(MAX_ZOOM, Math.max(MIN_ZOOM, z))\n\n\t\t\t\t\t\t\tthis.setCamera(\n\t\t\t\t\t\t\t\tcx + dx / cz - x / cz + x / zoom,\n\t\t\t\t\t\t\t\tcy + dy / cz - y / cz + y / zoom,\n\t\t\t\t\t\t\t\tzoom\n\t\t\t\t\t\t\t)\n\n\t\t\t\t\t\t\treturn // Stop here!\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 'pinch_end': {\n\t\t\t\t\t\t\tif (!inputs.isPinching) return this\n\n\t\t\t\t\t\t\tinputs.isPinching = false\n\t\t\t\t\t\t\tconst { _selectedIdsAtPointerDown } = this\n\t\t\t\t\t\t\tthis.setSelectedIds(this._selectedIdsAtPointerDown, true)\n\t\t\t\t\t\t\tthis._selectedIdsAtPointerDown = []\n\n\t\t\t\t\t\t\tconst {\n\t\t\t\t\t\t\t\tcamera: { x: cx, y: cy, z: cz },\n\t\t\t\t\t\t\t} = this\n\n\t\t\t\t\t\t\tlet zoom: number | undefined\n\n\t\t\t\t\t\t\tif (cz > 0.9 && cz < 1.05) {\n\t\t\t\t\t\t\t\tzoom = 1\n\t\t\t\t\t\t\t} else if (cz > 0.49 && cz < 0.505) {\n\t\t\t\t\t\t\t\tzoom = 0.5\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (cz > this._pinchStart - 0.1 && cz < this._pinchStart + 0.05) {\n\t\t\t\t\t\t\t\tzoom = this._pinchStart\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (zoom !== undefined) {\n\t\t\t\t\t\t\t\tconst { x, y } = this.viewportScreenCenter\n\t\t\t\t\t\t\t\tthis.animateCamera(\n\t\t\t\t\t\t\t\t\tcx + (x / zoom - x) - (x / cz - x),\n\t\t\t\t\t\t\t\t\tcy + (y / zoom - y) - (y / cz - y),\n\t\t\t\t\t\t\t\t\tzoom,\n\t\t\t\t\t\t\t\t\t{ duration: 100 }\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (this._didPinch) {\n\t\t\t\t\t\t\t\tthis._didPinch = false\n\t\t\t\t\t\t\t\trequestAnimationFrame(() => {\n\t\t\t\t\t\t\t\t\tif (!this._didPinch) {\n\t\t\t\t\t\t\t\t\t\tthis.setSelectedIds(_selectedIdsAtPointerDown, true)\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn // Stop here!\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcase 'wheel': {\n\t\t\t\t\tif (!this.canMoveCamera) return\n\n\t\t\t\t\tif (this.isMenuOpen) {\n\t\t\t\t\t\t// noop\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (inputs.ctrlKey) {\n\t\t\t\t\t\t\t// todo: Start or update the zoom end interval\n\n\t\t\t\t\t\t\t// If the alt or ctrl keys are pressed,\n\t\t\t\t\t\t\t// zoom or pan the camera and then return.\n\t\t\t\t\t\t\tconst { x, y } = this.inputs.currentScreenPoint\n\t\t\t\t\t\t\tconst { x: cx, y: cy, z: cz } = this.camera\n\n\t\t\t\t\t\t\tconst zoom = Math.min(MAX_ZOOM, Math.max(MIN_ZOOM, cz + (info.delta.z ?? 0) * cz))\n\n\t\t\t\t\t\t\tthis.setCamera(\n\t\t\t\t\t\t\t\tcx + (x / zoom - x) - (x / cz - x),\n\t\t\t\t\t\t\t\tcy + (y / zoom - y) - (y / cz - y),\n\t\t\t\t\t\t\t\tzoom\n\t\t\t\t\t\t\t)\n\n\t\t\t\t\t\t\t// We want to return here because none of the states in our\n\t\t\t\t\t\t\t// statechart should respond to this event (a camera zoom)\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Update the camera here, which will dispatch a pointer move...\n\t\t\t\t\t\t// this will also update the pointer position, etc\n\t\t\t\t\t\tthis.pan(info.delta.x, info.delta.y)\n\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t!inputs.isDragging &&\n\t\t\t\t\t\t\tinputs.isPointing &&\n\t\t\t\t\t\t\toriginPagePoint.dist(currentPagePoint) >\n\t\t\t\t\t\t\t\t(this.isCoarsePointer ? COARSE_DRAG_DISTANCE : DRAG_DISTANCE) / this.zoomLevel\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tinputs.isDragging = true\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tcase 'pointer': {\n\t\t\t\t\t// If we're pinching, return\n\t\t\t\t\tif (inputs.isPinching) return\n\n\t\t\t\t\tthis._updateInputsFromEvent(info)\n\n\t\t\t\t\tconst { isPen } = info\n\n\t\t\t\t\tswitch (info.name) {\n\t\t\t\t\t\tcase 'pointer_down': {\n\t\t\t\t\t\t\tthis._selectedIdsAtPointerDown = this.selectedIds.slice()\n\n\t\t\t\t\t\t\t// Firefox bug fix...\n\t\t\t\t\t\t\t// If it's a left-mouse-click, we store the pointer id for later user\n\t\t\t\t\t\t\tif (info.button === 0) {\n\t\t\t\t\t\t\t\tthis.capturedPointerId = info.pointerId\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Add the button from the buttons set\n\t\t\t\t\t\t\tinputs.buttons.add(info.button)\n\n\t\t\t\t\t\t\tinputs.isPointing = true\n\t\t\t\t\t\t\tinputs.isDragging = false\n\n\t\t\t\t\t\t\tif (this.isPenMode) {\n\t\t\t\t\t\t\t\tif (!isPen) {\n\t\t\t\t\t\t\t\t\t// decrement the remaining taps before exiting pen mode\n\t\t\t\t\t\t\t\t\tthis._touchEventsRemainingBeforeExitingPenMode--\n\t\t\t\t\t\t\t\t\tif (this._touchEventsRemainingBeforeExitingPenMode === 0) {\n\t\t\t\t\t\t\t\t\t\tthis.setPenMode(false)\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t// reset the remaining taps before exiting pen mode\n\t\t\t\t\t\t\t\t\tthis._touchEventsRemainingBeforeExitingPenMode = 3\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (isPen) {\n\t\t\t\t\t\t\t\t\tthis.setPenMode(true)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (info.button === 5) {\n\t\t\t\t\t\t\t\t// Eraser button activates eraser\n\t\t\t\t\t\t\t\tthis._restoreToolId = this.currentToolId\n\t\t\t\t\t\t\t\tthis.complete()\n\t\t\t\t\t\t\t\tthis.setSelectedTool('eraser')\n\t\t\t\t\t\t\t} else if (info.button === 1) {\n\t\t\t\t\t\t\t\t// Middle mouse pan activates panning\n\t\t\t\t\t\t\t\tif (!this.inputs.isPanning) {\n\t\t\t\t\t\t\t\t\tthis._prevCursor = this.instanceState.cursor.type\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tthis.inputs.isPanning = true\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (this.inputs.isPanning) {\n\t\t\t\t\t\t\t\tthis.stopCameraAnimation()\n\t\t\t\t\t\t\t\tthis.setCursor({\n\t\t\t\t\t\t\t\t\ttype: 'grabbing',\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\treturn this\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\toriginScreenPoint.setTo(currentScreenPoint)\n\t\t\t\t\t\t\toriginPagePoint.setTo(currentPagePoint)\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 'pointer_move': {\n\t\t\t\t\t\t\t// If the user is in pen mode, but the pointer is not a pen, stop here.\n\t\t\t\t\t\t\tif (!isPen && this.isPenMode) {\n\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (this.inputs.isPanning && this.inputs.isPointing) {\n\t\t\t\t\t\t\t\t// Handle panning\n\t\t\t\t\t\t\t\tconst { currentScreenPoint, previousScreenPoint } = this.inputs\n\t\t\t\t\t\t\t\tconst delta = Vec2d.Sub(currentScreenPoint, previousScreenPoint)\n\t\t\t\t\t\t\t\tthis.pan(delta.x, delta.y)\n\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t!inputs.isDragging &&\n\t\t\t\t\t\t\t\tinputs.isPointing &&\n\t\t\t\t\t\t\t\toriginPagePoint.dist(currentPagePoint) >\n\t\t\t\t\t\t\t\t\t(this.isCoarsePointer ? COARSE_DRAG_DISTANCE : DRAG_DISTANCE) / this.zoomLevel\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tinputs.isDragging = true\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 'pointer_up': {\n\t\t\t\t\t\t\t// Remove the button from the buttons set\n\t\t\t\t\t\t\tinputs.buttons.delete(info.button)\n\n\t\t\t\t\t\t\tinputs.isPointing = false\n\t\t\t\t\t\t\tinputs.isDragging = false\n\n\t\t\t\t\t\t\tif (this.isMenuOpen) {\n\t\t\t\t\t\t\t\t// Suppressing pointerup here as <ContextMenu/> doesn't seem to do what we what here.\n\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (!isPen && this.isPenMode) {\n\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Firefox bug fix...\n\t\t\t\t\t\t\t// If it's the same pointer that we stored earlier...\n\t\t\t\t\t\t\t// ... then it's probably still a left-mouse-click!\n\t\t\t\t\t\t\tif (this.capturedPointerId === info.pointerId) {\n\t\t\t\t\t\t\t\tthis.capturedPointerId = null\n\t\t\t\t\t\t\t\tinfo.button = 0\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (inputs.isPanning) {\n\t\t\t\t\t\t\t\tif (info.button === 1) {\n\t\t\t\t\t\t\t\t\tif (!this.inputs.keys.has(' ')) {\n\t\t\t\t\t\t\t\t\t\tinputs.isPanning = false\n\n\t\t\t\t\t\t\t\t\t\tthis.slideCamera({\n\t\t\t\t\t\t\t\t\t\t\tspeed: Math.min(2, this.inputs.pointerVelocity.len()),\n\t\t\t\t\t\t\t\t\t\t\tdirection: this.inputs.pointerVelocity,\n\t\t\t\t\t\t\t\t\t\t\tfriction: HAND_TOOL_FRICTION,\n\t\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t\t\tthis.setCursor({\n\t\t\t\t\t\t\t\t\t\t\ttype: this._prevCursor,\n\t\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tthis.slideCamera({\n\t\t\t\t\t\t\t\t\t\t\tspeed: Math.min(2, this.inputs.pointerVelocity.len()),\n\t\t\t\t\t\t\t\t\t\t\tdirection: this.inputs.pointerVelocity,\n\t\t\t\t\t\t\t\t\t\t\tfriction: HAND_TOOL_FRICTION,\n\t\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t\t\tthis.setCursor({\n\t\t\t\t\t\t\t\t\t\t\ttype: 'grab',\n\t\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else if (info.button === 0) {\n\t\t\t\t\t\t\t\t\tthis.slideCamera({\n\t\t\t\t\t\t\t\t\t\tspeed: Math.min(2, this.inputs.pointerVelocity.len()),\n\t\t\t\t\t\t\t\t\t\tdirection: this.inputs.pointerVelocity,\n\t\t\t\t\t\t\t\t\t\tfriction: HAND_TOOL_FRICTION,\n\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t\tthis.setCursor({\n\t\t\t\t\t\t\t\t\t\ttype: 'grab',\n\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (info.button === 5) {\n\t\t\t\t\t\t\t\t\t// Eraser button activates eraser\n\t\t\t\t\t\t\t\t\tthis.complete()\n\t\t\t\t\t\t\t\t\tthis.setSelectedTool(this._restoreToolId)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tcase 'keyboard': {\n\t\t\t\t\t// please, please\n\t\t\t\t\tif (info.key === 'ShiftRight') info.key = 'ShiftLeft'\n\t\t\t\t\tif (info.key === 'AltRight') info.key = 'AltLeft'\n\t\t\t\t\tif (info.code === 'ControlRight') info.code = 'ControlLeft'\n\n\t\t\t\t\tswitch (info.name) {\n\t\t\t\t\t\tcase 'key_down': {\n\t\t\t\t\t\t\t// Add the key from the keys set\n\t\t\t\t\t\t\tinputs.keys.add(info.code)\n\n\t\t\t\t\t\t\t// If the space key is pressed (but meta / control isn't!) activate panning\n\t\t\t\t\t\t\tif (!info.ctrlKey && info.code === 'Space') {\n\t\t\t\t\t\t\t\tif (!this.inputs.isPanning) {\n\t\t\t\t\t\t\t\t\tthis._prevCursor = this.instanceState.cursor.type\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tthis.inputs.isPanning = true\n\t\t\t\t\t\t\t\tthis.setCursor({\n\t\t\t\t\t\t\t\t\ttype: this.inputs.isPointing ? 'grabbing' : 'grab',\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 'key_up': {\n\t\t\t\t\t\t\t// Remove the key from the keys set\n\t\t\t\t\t\t\tinputs.keys.delete(info.code)\n\n\t\t\t\t\t\t\tif (info.code === 'Space' && !this.inputs.buttons.has(1)) {\n\t\t\t\t\t\t\t\tthis.inputs.isPanning = false\n\t\t\t\t\t\t\t\tthis.setCursor({\n\t\t\t\t\t\t\t\t\ttype: this._prevCursor,\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 'key_repeat': {\n\t\t\t\t\t\t\t// noop\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Correct the info name for right / middle clicks\n\t\t\tif (info.type === 'pointer') {\n\t\t\t\tif (info.button === 1) {\n\t\t\t\t\tinfo.name = 'middle_click'\n\t\t\t\t} else if (info.button === 2) {\n\t\t\t\t\tinfo.name = 'right_click'\n\t\t\t\t}\n\n\t\t\t\t// If a pointer event, send the event to the click manager.\n\t\t\t\tif (info.isPen === this.isPenMode) {\n\t\t\t\t\tswitch (info.name) {\n\t\t\t\t\t\tcase 'pointer_down': {\n\t\t\t\t\t\t\tconst otherEvent = this._clickManager.transformPointerDownEvent(info)\n\t\t\t\t\t\t\tif (info.name !== otherEvent.name) {\n\t\t\t\t\t\t\t\tthis.root.handleEvent(info)\n\t\t\t\t\t\t\t\tthis.emit('event', info)\n\t\t\t\t\t\t\t\tthis.root.handleEvent(otherEvent)\n\t\t\t\t\t\t\t\tthis.emit('event', otherEvent)\n\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 'pointer_up': {\n\t\t\t\t\t\t\tconst otherEvent = this._clickManager.transformPointerUpEvent(info)\n\t\t\t\t\t\t\tif (info.name !== otherEvent.name) {\n\t\t\t\t\t\t\t\tthis.root.handleEvent(info)\n\t\t\t\t\t\t\t\tthis.emit('event', info)\n\t\t\t\t\t\t\t\tthis.root.handleEvent(otherEvent)\n\t\t\t\t\t\t\t\tthis.emit('event', otherEvent)\n\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 'pointer_move': {\n\t\t\t\t\t\t\tthis._clickManager.handleMove()\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Send the event to the statechart. It will be handled by all\n\t\t\t// active states, starting at the root.\n\t\t\tthis.root.handleEvent(info)\n\t\t\tthis.emit('event', info)\n\t\t})\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Replace the store's contents with the given records.\n\t *\n\t * @param records - The records to replace the store's contents with.\n\t */\n\treplaceStoreContentsWithRecordsForOtherDocument(records: TLRecord[]) {\n\t\ttransact(() => {\n\t\t\tthis.store.clear()\n\t\t\tconst [shapes, nonShapes] = partition(records, (record) => record.typeName === 'shape')\n\t\t\tthis.store.put(nonShapes, 'initialize')\n\t\t\tthis.store.ensureStoreIsUsable()\n\t\t\tthis.store.put(shapes, 'initialize')\n\t\t\tthis.history.clear()\n\t\t\tthis.updateViewportScreenBounds()\n\t\t\tthis.updateRenderingBounds()\n\n\t\t\tconst bounds = this.allShapesCommonBounds\n\t\t\tif (bounds) {\n\t\t\t\tthis.zoomToBounds(bounds.minX, bounds.minY, bounds.width, bounds.height, 1)\n\t\t\t}\n\t\t})\n\t}\n\n\t/**\n\t * Get content that can be exported for the given shape ids.\n\t *\n\t * @param ids - The ids of the shapes to get content for. Defaults to the selected shape ids.\n\t *\n\t * @returns The exported content.\n\t *\n\t * @public\n\t */\n\tgetContent(ids: TLShapeId[] = this.selectedIds): TLContent | undefined {\n\t\tif (!ids) return\n\t\tif (ids.length === 0) return\n\n\t\tconst pageTransforms: Record<string, Matrix2dModel> = {}\n\n\t\tlet shapes = dedupe(\n\t\t\tids\n\t\t\t\t.map((id) => this.getShapeById(id)!)\n\t\t\t\t.sort(sortByIndex)\n\t\t\t\t.flatMap((shape) => {\n\t\t\t\t\tconst allShapes = [shape]\n\t\t\t\t\tthis.visitDescendants(shape.id, (descendant) => {\n\t\t\t\t\t\tallShapes.push(this.getShapeById(descendant)!)\n\t\t\t\t\t})\n\t\t\t\t\treturn allShapes\n\t\t\t\t})\n\t\t)\n\n\t\tshapes = shapes.map((shape) => {\n\t\t\tpageTransforms[shape.id] = this.getPageTransformById(shape.id)!\n\n\t\t\tshape = structuredClone(shape) as typeof shape\n\n\t\t\tif (this.isShapeOfType(shape, ArrowShapeUtil)) {\n\t\t\t\tconst startBindingId =\n\t\t\t\t\tshape.props.start.type === 'binding' ? shape.props.start.boundShapeId : undefined\n\n\t\t\t\tconst endBindingId =\n\t\t\t\t\tshape.props.end.type === 'binding' ? shape.props.end.boundShapeId : undefined\n\n\t\t\t\tconst info = this.getShapeUtil(ArrowShapeUtil).getArrowInfo(shape)\n\n\t\t\t\tif (shape.props.start.type === 'binding') {\n\t\t\t\t\tif (!shapes.some((s) => s.id === startBindingId)) {\n\t\t\t\t\t\t// Uh oh, the arrow's bound-to shape isn't among the shapes\n\t\t\t\t\t\t// that we're getting the content for. We should try to adjust\n\t\t\t\t\t\t// the arrow so that it appears in the place it would be\n\t\t\t\t\t\tif (info?.isValid) {\n\t\t\t\t\t\t\tconst { x, y } = info.start.point\n\t\t\t\t\t\t\tshape.props.start = {\n\t\t\t\t\t\t\t\ttype: 'point',\n\t\t\t\t\t\t\t\tx,\n\t\t\t\t\t\t\t\ty,\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst { start } = getArrowTerminalsInArrowSpace(this, shape)\n\t\t\t\t\t\t\tshape.props.start = {\n\t\t\t\t\t\t\t\ttype: 'point',\n\t\t\t\t\t\t\t\tx: start.x,\n\t\t\t\t\t\t\t\ty: start.y,\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (shape.props.end.type === 'binding') {\n\t\t\t\t\tif (!shapes.some((s) => s.id === endBindingId)) {\n\t\t\t\t\t\tif (info?.isValid) {\n\t\t\t\t\t\t\tconst { x, y } = info.end.point\n\t\t\t\t\t\t\tshape.props.end = {\n\t\t\t\t\t\t\t\ttype: 'point',\n\t\t\t\t\t\t\t\tx,\n\t\t\t\t\t\t\t\ty,\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst { end } = getArrowTerminalsInArrowSpace(this, shape)\n\t\t\t\t\t\t\tshape.props.end = {\n\t\t\t\t\t\t\t\ttype: 'point',\n\t\t\t\t\t\t\t\tx: end.x,\n\t\t\t\t\t\t\t\ty: end.y,\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst infoAfter = getIsArrowStraight(shape)\n\t\t\t\t\t? getStraightArrowInfo(this, shape)\n\t\t\t\t\t: getCurvedArrowInfo(this, shape)\n\n\t\t\t\tif (info?.isValid && infoAfter?.isValid && !getIsArrowStraight(shape)) {\n\t\t\t\t\tconst mpA = Vec2d.Med(info.start.handle, info.end.handle)\n\t\t\t\t\tconst distA = Vec2d.Dist(info.middle, mpA)\n\t\t\t\t\tconst distB = Vec2d.Dist(infoAfter.middle, mpA)\n\t\t\t\t\tif (shape.props.bend < 0) {\n\t\t\t\t\t\tshape.props.bend += distB - distA\n\t\t\t\t\t} else {\n\t\t\t\t\t\tshape.props.bend -= distB - distA\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn shape\n\t\t\t}\n\n\t\t\treturn shape\n\t\t})\n\n\t\tconst rootShapeIds: TLShapeId[] = []\n\n\t\tshapes.forEach((shape) => {\n\t\t\tif (shapes.find((s) => s.id === shape.parentId) === undefined) {\n\t\t\t\t// Need to get page point and rotation of the shape because shapes in\n\t\t\t\t// groups use local position/rotation\n\n\t\t\t\tconst pagePoint = this.getPagePointById(shape.id)!\n\t\t\t\tconst pageRotation = this.getPageRotationById(shape.id)!\n\t\t\t\tshape.x = pagePoint.x\n\t\t\t\tshape.y = pagePoint.y\n\t\t\t\tshape.rotation = pageRotation\n\t\t\t\tshape.parentId = this.currentPageId\n\n\t\t\t\trootShapeIds.push(shape.id)\n\t\t\t}\n\t\t})\n\n\t\tconst assetsSet = new Set<TLAssetId>()\n\n\t\tshapes.forEach((shape) => {\n\t\t\tif ('assetId' in shape.props) {\n\t\t\t\tif (shape.props.assetId !== null) {\n\t\t\t\t\tassetsSet.add(shape.props.assetId)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\n\t\treturn {\n\t\t\tshapes,\n\t\t\trootShapeIds,\n\t\t\tschema: this.store.schema.serialize(),\n\t\t\tassets: compact(Array.from(assetsSet).map((id) => this.getAssetById(id))),\n\t\t}\n\t}\n\n\t/* --------------------- Commands --------------------- */\n\n\t/**\n\t * Place content into the editor.\n\t *\n\t * @param content - The content.\n\t * @param options - Options for placing the content.\n\t *\n\t * @public\n\t */\n\tputContent(\n\t\tcontent: TLContent,\n\t\toptions: {\n\t\t\tpoint?: VecLike\n\t\t\tselect?: boolean\n\t\t\tpreservePosition?: boolean\n\t\t\tpreserveIds?: boolean\n\t\t} = {}\n\t): this {\n\t\tif (this.isReadOnly) return this\n\n\t\tif (!content.schema) {\n\t\t\tthrow Error('Could not put content: content is missing a schema.')\n\t\t}\n\n\t\tconst { select = false, preserveIds = false, preservePosition = false } = options\n\t\tlet { point = undefined } = options\n\n\t\t// decide on a parent for the put shapes; if the parent is among the put shapes(?) then use its parent\n\n\t\tconst { currentPageId } = this\n\t\tconst { assets, shapes, rootShapeIds } = content\n\n\t\tconst idMap = new Map<any, TLShapeId>(shapes.map((shape) => [shape.id, createShapeId()]))\n\n\t\t// By default, the paste parent will be the current page.\n\t\tlet pasteParentId = this.currentPageId as TLPageId | TLShapeId\n\t\tlet lowestDepth = Infinity\n\t\tlet lowestAncestors: TLShape[] = []\n\n\t\t// Among the selected shapes, find the shape with the fewest ancestors and use its first ancestor.\n\t\tfor (const shape of this.selectedShapes) {\n\t\t\tif (lowestDepth === 0) break\n\n\t\t\tconst isFrame = this.isShapeOfType(shape, FrameShapeUtil)\n\t\t\tconst ancestors = this.getAncestors(shape)\n\t\t\tif (isFrame) ancestors.push(shape)\n\n\t\t\tconst depth = isFrame ? ancestors.length + 1 : ancestors.length\n\n\t\t\tif (depth < lowestDepth) {\n\t\t\t\tlowestDepth = depth\n\t\t\t\tlowestAncestors = ancestors\n\t\t\t\tpasteParentId = isFrame ? shape.id : shape.parentId\n\t\t\t} else if (depth === lowestDepth) {\n\t\t\t\tif (lowestAncestors.length !== ancestors.length) {\n\t\t\t\t\tthrow Error(`Ancestors: ${lowestAncestors.length} !== ${ancestors.length}`)\n\t\t\t\t}\n\n\t\t\t\tif (lowestAncestors.length === 0) {\n\t\t\t\t\tpasteParentId = currentPageId\n\t\t\t\t\tbreak\n\t\t\t\t} else {\n\t\t\t\t\tpasteParentId = currentPageId\n\t\t\t\t\tfor (let i = 0; i < lowestAncestors.length; i++) {\n\t\t\t\t\t\tif (ancestors[i] !== lowestAncestors[i]) break\n\t\t\t\t\t\tpasteParentId = ancestors[i].id\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlet isDuplicating = false\n\n\t\tif (!isPageId(pasteParentId)) {\n\t\t\tconst parent = this.getShapeById(pasteParentId)\n\t\t\tif (parent) {\n\t\t\t\tif (!this.viewportPageBounds.includes(this.getPageBounds(parent)!)) {\n\t\t\t\t\tpasteParentId = currentPageId\n\t\t\t\t} else {\n\t\t\t\t\tif (rootShapeIds.length === 1) {\n\t\t\t\t\t\tconst rootShape = shapes.find((s) => s.id === rootShapeIds[0])!\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tthis.isShapeOfType(parent, FrameShapeUtil) &&\n\t\t\t\t\t\t\tthis.isShapeOfType(rootShape, FrameShapeUtil) &&\n\t\t\t\t\t\t\trootShape.props.w === parent?.props.w &&\n\t\t\t\t\t\t\trootShape.props.h === parent?.props.h\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tisDuplicating = true\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpasteParentId = currentPageId\n\t\t\t}\n\t\t}\n\n\t\tif (!isDuplicating) {\n\t\t\tisDuplicating = idMap.has(pasteParentId)\n\t\t}\n\n\t\tif (isDuplicating) {\n\t\t\tpasteParentId = this.getShapeById(pasteParentId)!.parentId\n\t\t}\n\n\t\tlet index = this.getHighestIndexForParent(pasteParentId)\n\n\t\tconst rootShapes: TLShape[] = []\n\n\t\tconst newShapes: TLShape[] = shapes.map((shape): TLShape => {\n\t\t\tlet newShape: TLShape\n\n\t\t\tif (preserveIds) {\n\t\t\t\tnewShape = deepCopy(shape)\n\t\t\t\tidMap.set(shape.id, shape.id)\n\t\t\t} else {\n\t\t\t\tconst id = idMap.get(shape.id)!\n\n\t\t\t\t// Create the new shape (new except for the id)\n\t\t\t\tnewShape = deepCopy({ ...shape, id })\n\t\t\t}\n\n\t\t\tif (rootShapeIds.includes(shape.id)) {\n\t\t\t\tnewShape.parentId = currentPageId\n\t\t\t\trootShapes.push(newShape)\n\t\t\t}\n\n\t\t\t// Assign the child to its new parent.\n\n\t\t\t// If the child's parent is among the putting shapes, then assign\n\t\t\t// it to the new parent's id.\n\t\t\tif (idMap.has(newShape.parentId)) {\n\t\t\t\tnewShape.parentId = idMap.get(shape.parentId)!\n\t\t\t} else {\n\t\t\t\trootShapeIds.push(newShape.id)\n\t\t\t\t// newShape.parentId = pasteParentId\n\t\t\t\tnewShape.index = index\n\t\t\t\tindex = getIndexAbove(index)\n\t\t\t}\n\n\t\t\tif (this.isShapeOfType(newShape, ArrowShapeUtil)) {\n\t\t\t\tif (newShape.props.start.type === 'binding') {\n\t\t\t\t\tconst mappedId = idMap.get(newShape.props.start.boundShapeId)\n\t\t\t\t\tnewShape.props.start = mappedId\n\t\t\t\t\t\t? { ...newShape.props.start, boundShapeId: mappedId }\n\t\t\t\t\t\t: // this shouldn't happen, if you copy an arrow but not it's bound shape it should\n\t\t\t\t\t\t  // convert the binding to a point at the time of copying\n\t\t\t\t\t\t  { type: 'point', x: 0, y: 0 }\n\t\t\t\t}\n\t\t\t\tif (newShape.props.end.type === 'binding') {\n\t\t\t\t\tconst mappedId = idMap.get(newShape.props.end.boundShapeId)\n\t\t\t\t\tnewShape.props.end = mappedId\n\t\t\t\t\t\t? { ...newShape.props.end, boundShapeId: mappedId }\n\t\t\t\t\t\t: // this shouldn't happen, if you copy an arrow but not it's bound shape it should\n\t\t\t\t\t\t  // convert the binding to a point at the time of copying\n\t\t\t\t\t\t  { type: 'point', x: 0, y: 0 }\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn newShape\n\t\t})\n\n\t\tif (newShapes.length + this.currentPageShapeIds.size > MAX_SHAPES_PER_PAGE) {\n\t\t\t// There's some complexity here involving children\n\t\t\t// that might be created without their parents, so\n\t\t\t// if we're going over the limit then just don't paste.\n\t\t\talertMaxShapes(this)\n\t\t\treturn this\n\t\t}\n\n\t\t// Migrate the new shapes\n\n\t\tlet assetsToCreate: TLAsset[] = []\n\n\t\tif (assets) {\n\t\t\tfor (let i = 0; i < assets.length; i++) {\n\t\t\t\tconst asset = assets[i]\n\t\t\t\tconst result = this.store.schema.migratePersistedRecord(asset, content.schema)\n\t\t\t\tif (result.type === 'success') {\n\t\t\t\t\tassets[i] = result.value as TLAsset\n\t\t\t\t} else {\n\t\t\t\t\tthrow Error(\n\t\t\t\t\t\t`Could not put content: could not migrate content for asset:\\n${JSON.stringify(\n\t\t\t\t\t\t\tasset,\n\t\t\t\t\t\t\tnull,\n\t\t\t\t\t\t\t2\n\t\t\t\t\t\t)}`\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst assetsToUpdate: (TLImageAsset | TLVideoAsset)[] = []\n\n\t\t\tassetsToCreate = assets\n\t\t\t\t.filter((asset) => !this.store.has(asset.id))\n\t\t\t\t.map((asset) => {\n\t\t\t\t\tif (asset.type === 'image' || asset.type === 'video') {\n\t\t\t\t\t\tif (asset.props.src && asset.props.src?.startsWith('data:image')) {\n\t\t\t\t\t\t\tassetsToUpdate.push(structuredClone(asset))\n\t\t\t\t\t\t\tasset.props.src = null\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tassetsToUpdate.push(structuredClone(asset))\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn asset\n\t\t\t\t})\n\n\t\t\tPromise.allSettled(\n\t\t\t\tassetsToUpdate.map(async (asset) => {\n\t\t\t\t\tconst file = await dataUrlToFile(\n\t\t\t\t\t\tasset.props.src!,\n\t\t\t\t\t\tasset.props.name,\n\t\t\t\t\t\tasset.props.mimeType ?? 'image/png'\n\t\t\t\t\t)\n\n\t\t\t\t\tconst newAsset = await this.externalContentManager.createAssetFromFile(this, file)\n\n\t\t\t\t\treturn [asset, newAsset] as const\n\t\t\t\t})\n\t\t\t).then((assets) => {\n\t\t\t\tthis.updateAssets(\n\t\t\t\t\tcompact(\n\t\t\t\t\t\tassets.map((result) =>\n\t\t\t\t\t\t\tresult.status === 'fulfilled'\n\t\t\t\t\t\t\t\t? { ...result.value[1], id: result.value[0].id }\n\t\t\t\t\t\t\t\t: undefined\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t})\n\t\t}\n\n\t\tfor (let i = 0; i < newShapes.length; i++) {\n\t\t\tconst shape = newShapes[i]\n\t\t\tconst result = this.store.schema.migratePersistedRecord(shape, content.schema)\n\t\t\tif (result.type === 'success') {\n\t\t\t\tnewShapes[i] = result.value as TLShape\n\t\t\t} else {\n\t\t\t\tthrow Error(\n\t\t\t\t\t`Could not put content: could not migrate content for shape:\\n${JSON.stringify(\n\t\t\t\t\t\tshape,\n\t\t\t\t\t\tnull,\n\t\t\t\t\t\t2\n\t\t\t\t\t)}`\n\t\t\t\t)\n\t\t\t}\n\t\t}\n\n\t\tthis.batch(() => {\n\t\t\t// Create any assets that need to be created\n\t\t\tif (assetsToCreate.length > 0) {\n\t\t\t\tthis.createAssets(assetsToCreate)\n\t\t\t}\n\n\t\t\t// Create the shapes with root shapes as children of the page\n\t\t\tthis.createShapes(newShapes, select)\n\n\t\t\t// And then, if needed, reparent the root shapes to the paste parent\n\t\t\tif (pasteParentId !== currentPageId) {\n\t\t\t\tthis.reparentShapesById(\n\t\t\t\t\trootShapes.map((s) => s.id),\n\t\t\t\t\tpasteParentId\n\t\t\t\t)\n\t\t\t}\n\n\t\t\tconst newCreatedShapes = newShapes.map((s) => this.getShapeById(s.id)!)\n\t\t\tconst bounds = Box2d.Common(newCreatedShapes.map((s) => this.getPageBounds(s)!))\n\n\t\t\tif (point === undefined) {\n\t\t\t\tif (!isPageId(pasteParentId)) {\n\t\t\t\t\t// Put the shapes in the middle of the (on screen) parent\n\t\t\t\t\tconst shape = this.getShapeById(pasteParentId)!\n\t\t\t\t\tconst util = this.getShapeUtil(shape)\n\t\t\t\t\tpoint = util.center(shape)\n\t\t\t\t} else {\n\t\t\t\t\tconst { viewportPageBounds } = this\n\t\t\t\t\tif (preservePosition || viewportPageBounds.includes(Box2d.From(bounds))) {\n\t\t\t\t\t\t// Otherwise, put shapes where they used to be\n\t\t\t\t\t\tpoint = bounds.center\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// If the old bounds are outside of the viewport...\n\t\t\t\t\t\t// put the shapes in the middle of the viewport\n\t\t\t\t\t\tpoint = viewportPageBounds.center\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (rootShapes.length === 1) {\n\t\t\t\tconst onlyRoot = rootShapes[0] as TLFrameShape\n\t\t\t\t// If the old bounds are in the viewport...\n\t\t\t\tif (this.isShapeOfType(onlyRoot, FrameShapeUtil)) {\n\t\t\t\t\twhile (\n\t\t\t\t\t\tthis.getShapesAtPoint(point).some(\n\t\t\t\t\t\t\t(shape) =>\n\t\t\t\t\t\t\t\tthis.isShapeOfType(shape, FrameShapeUtil) &&\n\t\t\t\t\t\t\t\tshape.props.w === onlyRoot.props.w &&\n\t\t\t\t\t\t\t\tshape.props.h === onlyRoot.props.h\n\t\t\t\t\t\t)\n\t\t\t\t\t) {\n\t\t\t\t\t\tpoint.x += bounds.w + 16\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.updateShapes(\n\t\t\t\trootShapes.map((s) => {\n\t\t\t\t\tconst delta = {\n\t\t\t\t\t\tx: (s.x ?? 0) - (bounds.x + bounds.w / 2),\n\t\t\t\t\t\ty: (s.y ?? 0) - (bounds.y + bounds.h / 2),\n\t\t\t\t\t}\n\n\t\t\t\t\treturn { id: s.id, type: s.type, x: point!.x + delta.x, y: point!.y + delta.y }\n\t\t\t\t})\n\t\t\t)\n\t\t})\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Create shapes.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.createShapes([{ id: 'box1', type: 'text', props: { text: \"ok\" } }])\n\t * ```\n\t *\n\t * @param partials - The shape partials to create.\n\t * @param select - Whether to select the created shapes. Defaults to false.\n\t *\n\t * @public\n\t */\n\tcreateShapes<T extends TLUnknownShape>(partials: TLShapePartial<T>[], select = false) {\n\t\tthis._createShapes(partials, select)\n\t\treturn this\n\t}\n\n\t/** @internal */\n\tprivate _createShapes = this.history.createCommand(\n\t\t'createShapes',\n\t\t(partials: TLShapePartial[], select = false) => {\n\t\t\tif (this.isReadOnly) return null\n\t\t\tif (partials.length <= 0) return null\n\n\t\t\tconst { currentPageShapeIds: shapeIds, selectedIds } = this\n\n\t\t\tconst prevSelectedIds = select ? selectedIds : undefined\n\n\t\t\tconst maxShapesReached = partials.length + shapeIds.size > MAX_SHAPES_PER_PAGE\n\n\t\t\tif (maxShapesReached) {\n\t\t\t\talertMaxShapes(this)\n\t\t\t}\n\n\t\t\tconst partialsToCreate = maxShapesReached\n\t\t\t\t? partials.slice(0, MAX_SHAPES_PER_PAGE - shapeIds.size)\n\t\t\t\t: partials\n\n\t\t\tif (partialsToCreate.length === 0) return null\n\n\t\t\treturn {\n\t\t\t\tdata: {\n\t\t\t\t\tcurrentPageId: this.currentPageId,\n\t\t\t\t\tcreatedIds: partials.map((p) => p.id),\n\t\t\t\t\tprevSelectedIds,\n\t\t\t\t\tpartials: partialsToCreate,\n\t\t\t\t\tselect,\n\t\t\t\t},\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\tdo: ({ createdIds, partials, select }) => {\n\t\t\t\tconst { focusLayerId } = this\n\n\t\t\t\t// 1. Parents\n\n\t\t\t\t// Make sure that each partial will become the child of either the\n\t\t\t\t// page or another shape that exists (or that will exist) in this page.\n\n\t\t\t\tpartials = partials.map((partial) => {\n\t\t\t\t\tif (\n\t\t\t\t\t\t// No parentId provided\n\t\t\t\t\t\t!partial.parentId ||\n\t\t\t\t\t\t// A parentId is proved but the parent is neither a) in the store\n\t\t\t\t\t\t// or b) among the other creating shape partials\n\t\t\t\t\t\t(!this.store.get(partial.parentId) && !partials.find((p) => p.id === partial.parentId))\n\t\t\t\t\t) {\n\t\t\t\t\t\tpartial = { ...partial }\n\t\t\t\t\t\tconst parentId = this.getParentIdForNewShapeAtPoint(\n\t\t\t\t\t\t\t{ x: partial.x ?? 0, y: partial.y ?? 0 },\n\t\t\t\t\t\t\tpartial.type\n\t\t\t\t\t\t)\n\t\t\t\t\t\tpartial.parentId = parentId\n\t\t\t\t\t\t// If the parent is a shape (rather than a page) then insert the\n\t\t\t\t\t\t// shapes into the shape's children. Adjust the point and page rotation to be\n\t\t\t\t\t\t// preserved relative to the parent.\n\t\t\t\t\t\tif (isShapeId(parentId)) {\n\t\t\t\t\t\t\tconst point = this.getPointInShapeSpace(this.getShapeById(parentId)!, {\n\t\t\t\t\t\t\t\tx: partial.x ?? 0,\n\t\t\t\t\t\t\t\ty: partial.y ?? 0,\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\tpartial.x = point.x\n\t\t\t\t\t\t\tpartial.y = point.y\n\t\t\t\t\t\t\tpartial.rotation = -this.getPageRotationById(parentId) + (partial.rotation ?? 0)\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// a shape cannot be it's own parent. This was a rare issue with frames/groups in the syncFuzz tests.\n\t\t\t\t\t\tif (partial.parentId === partial.id) {\n\t\t\t\t\t\t\tpartial.parentId = focusLayerId\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn partial\n\t\t\t\t\t}\n\t\t\t\t\treturn partial\n\t\t\t\t})\n\n\t\t\t\t// 2. Indices\n\n\t\t\t\t// Get the highest index among the parents of each of the\n\t\t\t\t// the shapes being created; we'll increment from there.\n\n\t\t\t\tconst parentIndices = new Map<string, string>()\n\n\t\t\t\tconst shapeRecordsToCreate: TLShape[] = []\n\n\t\t\t\tfor (const partial of partials) {\n\t\t\t\t\tconst util = this.getShapeUtil(partial)\n\n\t\t\t\t\t// If an index is not explicitly provided, then add the\n\t\t\t\t\t// shapes to the top of their parents' children; using the\n\t\t\t\t\t// value in parentsMappedToIndex, get the index above, use it,\n\t\t\t\t\t// and set it back to parentsMappedToIndex for next time.\n\t\t\t\t\tlet index = partial.index\n\n\t\t\t\t\tif (!index) {\n\t\t\t\t\t\tconst parentId = partial.parentId ?? focusLayerId\n\t\t\t\t\t\tif (!parentIndices.has(parentId)) {\n\t\t\t\t\t\t\tparentIndices.set(parentId, this.getHighestIndexForParent(parentId))\n\t\t\t\t\t\t}\n\t\t\t\t\t\tindex = parentIndices.get(parentId)!\n\t\t\t\t\t\tparentIndices.set(parentId, getIndexAbove(index))\n\t\t\t\t\t}\n\n\t\t\t\t\t// The initial props starts as the shape utility's default props\n\t\t\t\t\tconst initialProps = util.defaultProps()\n\n\t\t\t\t\t// We then look up each key in the tab state's styles; and if it's there,\n\t\t\t\t\t// we use the value from the tab state's styles instead of the default.\n\t\t\t\t\tfor (const [style, propKey] of util.styleProps) {\n\t\t\t\t\t\t;(initialProps as any)[propKey] = this.getStyleForNextShape(style)\n\t\t\t\t\t}\n\n\t\t\t\t\t// When we create the shape, take in the partial (the props coming into the\n\t\t\t\t\t// function) and merge it with the default props.\n\t\t\t\t\tlet shapeRecordToCreate = (\n\t\t\t\t\t\tthis.store.schema.types.shape as RecordType<\n\t\t\t\t\t\t\tTLShape,\n\t\t\t\t\t\t\t'type' | 'props' | 'index' | 'parentId'\n\t\t\t\t\t\t>\n\t\t\t\t\t).create({\n\t\t\t\t\t\t...partial,\n\t\t\t\t\t\tindex,\n\t\t\t\t\t\topacity: partial.opacity ?? this.instanceState.opacityForNextShape,\n\t\t\t\t\t\tparentId: partial.parentId ?? focusLayerId,\n\t\t\t\t\t\tprops: 'props' in partial ? { ...initialProps, ...partial.props } : initialProps,\n\t\t\t\t\t})\n\n\t\t\t\t\tif (shapeRecordToCreate.index === undefined) {\n\t\t\t\t\t\tthrow Error('no index!')\n\t\t\t\t\t}\n\n\t\t\t\t\tconst next = this.getShapeUtil(shapeRecordToCreate).onBeforeCreate?.(shapeRecordToCreate)\n\n\t\t\t\t\tif (next) {\n\t\t\t\t\t\tshapeRecordToCreate = next\n\t\t\t\t\t}\n\n\t\t\t\t\tshapeRecordsToCreate.push(shapeRecordToCreate)\n\t\t\t\t}\n\n\t\t\t\tthis.store.put(shapeRecordsToCreate)\n\n\t\t\t\t// If we're also selecting the newly created shapes, attempt to select all of them;\n\n\t\t\t\t// the engine will filter out any shapes that are descendants of other new shapes.\n\t\t\t\tif (select) {\n\t\t\t\t\tthis.store.update(this.pageState.id, (state) => ({\n\t\t\t\t\t\t...state,\n\t\t\t\t\t\tselectedIds: createdIds,\n\t\t\t\t\t}))\n\t\t\t\t}\n\t\t\t},\n\t\t\tundo: ({ createdIds, prevSelectedIds }) => {\n\t\t\t\tthis.store.remove(createdIds)\n\n\t\t\t\tif (prevSelectedIds) {\n\t\t\t\t\tthis.store.update(this.pageState.id, (state) => ({\n\t\t\t\t\t\t...state,\n\t\t\t\t\t\tselectedIds: prevSelectedIds,\n\t\t\t\t\t}))\n\t\t\t\t}\n\t\t\t},\n\t\t}\n\t)\n\n\tprivate animatingShapes = new Map<TLShapeId, string>()\n\n\t/**\n\t * Animate shapes.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.animateShapes([{ id: 'box1', type: 'box', x: 100, y: 100 }])\n\t * ```\n\t *\n\t * @param partials - The shape partials to update.\n\t *\n\t * @public\n\t */\n\tanimateShapes(\n\t\tpartials: (TLShapePartial | null | undefined)[],\n\t\toptions: {\n\t\t\t/** The animation's duration in milliseconds. */\n\t\t\tduration?: number\n\t\t\t/** The animation's easing function. */\n\t\t\tease?: (t: number) => number\n\t\t} = {}\n\t) {\n\t\tconst { duration = 500, ease = EASINGS.linear } = options\n\n\t\tconst animationId = uniqueId()\n\n\t\tlet remaining = duration\n\t\tlet t: number\n\n\t\ttype FromTo = { prop: string; from: number; to: number }\n\t\ttype ShapeAnimation = { partial: TLShapePartial; values: FromTo[] }\n\n\t\tconst animations: ShapeAnimation[] = []\n\n\t\tpartials.forEach((partial) => {\n\t\t\tif (!partial) return\n\n\t\t\tconst result: ShapeAnimation = {\n\t\t\t\tpartial,\n\t\t\t\tvalues: [],\n\t\t\t}\n\n\t\t\tconst shape = this.getShapeById(partial.id)!\n\n\t\t\tif (!shape) return\n\n\t\t\tfor (const key of ['x', 'y', 'rotation'] as const) {\n\t\t\t\tif (partial[key] !== undefined && shape[key] !== partial[key]) {\n\t\t\t\t\tresult.values.push({ prop: key, from: shape[key], to: partial[key] as number })\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tanimations.push(result)\n\t\t\tthis.animatingShapes.set(shape.id, animationId)\n\t\t})\n\n\t\tlet value: ShapeAnimation\n\n\t\tconst handleTick = (elapsed: number) => {\n\t\t\tremaining -= elapsed\n\n\t\t\tif (remaining < 0) {\n\t\t\t\tconst { animatingShapes } = this\n\t\t\t\tconst partialsToUpdate = partials.filter(\n\t\t\t\t\t(p) => p && animatingShapes.get(p.id) === animationId\n\t\t\t\t)\n\t\t\t\tif (partialsToUpdate.length) {\n\t\t\t\t\tthis.updateShapes(partialsToUpdate, false)\n\t\t\t\t\t// update shapes also removes the shape from animating shapes\n\t\t\t\t}\n\n\t\t\t\tthis.removeListener('tick', handleTick)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tt = ease(1 - remaining / duration)\n\n\t\t\tconst { animatingShapes } = this\n\n\t\t\ttry {\n\t\t\t\tconst tPartials: TLShapePartial[] = []\n\n\t\t\t\tfor (let i = 0; i < animations.length; i++) {\n\t\t\t\t\tvalue = animations[i]\n\n\t\t\t\t\tif (animatingShapes.get(value.partial.id) === animationId) {\n\t\t\t\t\t\ttPartials.push({\n\t\t\t\t\t\t\tid: value.partial.id,\n\t\t\t\t\t\t\ttype: value.partial.type,\n\t\t\t\t\t\t\t...value.values.reduce((acc, { prop, from, to }) => {\n\t\t\t\t\t\t\t\tacc[prop] = from + (to - from) * t\n\t\t\t\t\t\t\t\treturn acc\n\t\t\t\t\t\t\t}, {} as any),\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis._updateShapes(tPartials, true)\n\t\t\t} catch (e) {\n\t\t\t\t// noop\n\t\t\t}\n\t\t}\n\n\t\tthis.addListener('tick', handleTick)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Update shapes using partials of each shape.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.updateShapes([{ id: 'box1', type: 'geo', props: { w: 100, h: 100 } }])\n\t * ```\n\t *\n\t * @param partials - The shape partials to update.\n\t * @param squashing - Whether the change is ephemeral.\n\t *\n\t * @public\n\t */\n\tupdateShapes<T extends TLUnknownShape>(\n\t\tpartials: (TLShapePartial<T> | null | undefined)[],\n\t\tsquashing = false\n\t) {\n\t\tlet compactedPartials = compact(partials)\n\t\tif (this.animatingShapes.size > 0) {\n\t\t\tcompactedPartials.forEach((p) => this.animatingShapes.delete(p.id))\n\t\t}\n\n\t\tcompactedPartials = compactedPartials.filter((p) => {\n\t\t\tconst shape = this.getShapeById(p.id)\n\t\t\tif (!shape) return false\n\n\t\t\t// Only allow changes to unlocked shapes or changes to the isLocked property (otherwise we cannot unlock a shape)\n\t\t\tif (this.isShapeOrAncestorLocked(shape) && !Object.hasOwn(p, 'isLocked')) return false\n\t\t\treturn true\n\t\t})\n\n\t\tthis._updateShapes(compactedPartials, squashing)\n\t\treturn this\n\t}\n\n\t/** @internal */\n\tprivate _updateShapes = this.history.createCommand(\n\t\t'updateShapes',\n\t\t(_partials: (TLShapePartial | null | undefined)[], squashing = false) => {\n\t\t\tif (this.isReadOnly) return null\n\n\t\t\tconst partials = compact(_partials)\n\n\t\t\tconst snapshots = Object.fromEntries(\n\t\t\t\tcompact(partials.map(({ id }) => this.getShapeById(id))).map((shape) => {\n\t\t\t\t\treturn [shape.id, shape]\n\t\t\t\t})\n\t\t\t)\n\n\t\t\tif (partials.length <= 0) return null\n\n\t\t\tconst updated = compact(\n\t\t\t\tpartials.map((partial) => {\n\t\t\t\t\tconst prev = snapshots[partial.id]\n\t\t\t\t\tif (!prev) return null\n\t\t\t\t\tlet newRecord = null as null | TLShape\n\t\t\t\t\tfor (const [k, v] of Object.entries(partial)) {\n\t\t\t\t\t\tif (v === undefined) continue\n\t\t\t\t\t\tswitch (k) {\n\t\t\t\t\t\t\tcase 'id':\n\t\t\t\t\t\t\tcase 'type':\n\t\t\t\t\t\t\tcase 'typeName': {\n\t\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdefault: {\n\t\t\t\t\t\t\t\tif (v !== (prev as any)[k]) {\n\t\t\t\t\t\t\t\t\tif (!newRecord) {\n\t\t\t\t\t\t\t\t\t\tnewRecord = { ...prev }\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (k === 'props') {\n\t\t\t\t\t\t\t\t\t\tconst nextProps = { ...prev.props } as Record<string, unknown>\n\t\t\t\t\t\t\t\t\t\tfor (const [propKey, propValue] of Object.entries(v as object)) {\n\t\t\t\t\t\t\t\t\t\t\tif (propValue === undefined) continue\n\t\t\t\t\t\t\t\t\t\t\tnextProps[propKey] = propValue\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tnewRecord!.props = nextProps\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t;(newRecord as any)[k] = v\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn newRecord ?? prev\n\t\t\t\t})\n\t\t\t)\n\n\t\t\tconst updates = Object.fromEntries(updated.map((shape) => [shape.id, shape]))\n\n\t\t\treturn { data: { snapshots, updates }, squashing }\n\t\t},\n\t\t{\n\t\t\tdo: ({ updates }) => {\n\t\t\t\t// Iterate through array; if any shape has an onUpdate handler, call it\n\t\t\t\t// and, if the handler returns a new shape, replace the old shape with\n\t\t\t\t// the new one. This is used for example when repositioning a text shape\n\t\t\t\t// based on its new text content.\n\t\t\t\tconst result = Object.values(updates)\n\t\t\t\tfor (let i = 0; i < result.length; i++) {\n\t\t\t\t\tconst shape = result[i]\n\t\t\t\t\tconst current = this.store.get(shape.id)\n\t\t\t\t\tif (!current) continue\n\t\t\t\t\tconst next = this.getShapeUtil(shape).onBeforeUpdate?.(current, shape)\n\t\t\t\t\tif (next) {\n\t\t\t\t\t\tresult[i] = next\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.store.put(result)\n\t\t\t},\n\t\t\tundo: ({ snapshots }) => {\n\t\t\t\tthis.store.put(Object.values(snapshots))\n\t\t\t},\n\t\t\tsquash(prevData, nextData) {\n\t\t\t\treturn {\n\t\t\t\t\t// keep the oldest snapshots\n\t\t\t\t\tsnapshots: { ...nextData.snapshots, ...prevData.snapshots },\n\t\t\t\t\t// keep the newest updates\n\t\t\t\t\tupdates: { ...prevData.updates, ...nextData.updates },\n\t\t\t\t}\n\t\t\t},\n\t\t}\n\t)\n\n\t/** @internal */\n\tprivate _getUnlockedShapeIds(ids: TLShapeId[]): TLShapeId[] {\n\t\treturn ids.filter((id) => !this.getShapeById(id)?.isLocked)\n\t}\n\n\t/**\n\t * Delete shapes.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.deleteShapes()\n\t * editor.deleteShapes(['box1', 'box2'])\n\t * ```\n\t *\n\t * @param ids - The ids of the shapes to delete. Defaults to the selected shapes.\n\t *\n\t * @public\n\t */\n\tdeleteShapes(ids: TLShapeId[] = this.selectedIds) {\n\t\tthis._deleteShapes(this._getUnlockedShapeIds(ids))\n\t\treturn this\n\t}\n\n\t/** @internal */\n\tprivate _deleteShapes = this.history.createCommand(\n\t\t'delete_shapes',\n\t\t(ids: TLShapeId[]) => {\n\t\t\tif (this.isReadOnly) return null\n\t\t\tif (ids.length === 0) return null\n\t\t\tconst prevSelectedIds = [...this.pageState.selectedIds]\n\n\t\t\tconst allIds = new Set(ids)\n\n\t\t\tfor (const id of ids) {\n\t\t\t\tthis.visitDescendants(id, (childId) => {\n\t\t\t\t\tallIds.add(childId)\n\t\t\t\t})\n\t\t\t}\n\n\t\t\tconst deletedIds = [...allIds]\n\t\t\tconst arrowBindings = this._arrowBindingsIndex.value\n\t\t\tconst snapshots = compact(\n\t\t\t\tdeletedIds.flatMap((id) => {\n\t\t\t\t\tconst shape = this.getShapeById(id)\n\n\t\t\t\t\t// Add any bound arrows to the snapshots, so that we can restore the bindings on undo\n\t\t\t\t\tconst bindings = arrowBindings[id]\n\t\t\t\t\tif (bindings && bindings.length > 0) {\n\t\t\t\t\t\treturn bindings.map(({ arrowId }) => this.getShapeById(arrowId)).concat(shape)\n\t\t\t\t\t}\n\t\t\t\t\treturn shape\n\t\t\t\t})\n\t\t\t)\n\n\t\t\tconst postSelectedIds = prevSelectedIds.filter((id) => !allIds.has(id))\n\n\t\t\treturn { data: { deletedIds, snapshots, prevSelectedIds, postSelectedIds } }\n\t\t},\n\t\t{\n\t\t\tdo: ({ deletedIds, postSelectedIds }) => {\n\t\t\t\tthis.store.remove(deletedIds)\n\t\t\t\tthis.store.update(this.pageState.id, (state) => ({\n\t\t\t\t\t...state,\n\t\t\t\t\tselectedIds: postSelectedIds,\n\t\t\t\t}))\n\t\t\t},\n\t\t\tundo: ({ snapshots, prevSelectedIds }) => {\n\t\t\t\tthis.store.put(snapshots)\n\t\t\t\tthis.store.update(this.pageState.id, (state) => ({\n\t\t\t\t\t...state,\n\t\t\t\t\tselectedIds: prevSelectedIds,\n\t\t\t\t}))\n\t\t\t},\n\t\t}\n\t)\n\n\t/**\n\t * Get the user's locale.\n\t *\n\t * @public\n\t */\n\tget locale() {\n\t\treturn this.user.locale\n\t}\n\n\t/**\n\t * Update the user's locale. This affects which translations are used when rendering UI elements.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.setLocale('fr')\n\t * ```\n\t *\n\t * @public\n\t */\n\tsetLocale(locale: string) {\n\t\tthis.user.updateUserPreferences({ locale })\n\t}\n\n\t/**\n\t * Update a page.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.updatePage({ id: 'page2', name: 'Page 2' })\n\t * ```\n\t *\n\t * @param partial - The partial of the shape to update.\n\t *\n\t * @public\n\t */\n\tupdatePage(partial: RequiredKeys<TLPage, 'id'>, squashing = false) {\n\t\tthis._updatePage(partial, squashing)\n\t\treturn this\n\t}\n\n\t/** @internal */\n\tprivate _updatePage = this.history.createCommand(\n\t\t'updatePage',\n\t\t(partial: RequiredKeys<TLPage, 'id'>, squashing = false) => {\n\t\t\tif (this.isReadOnly) return null\n\n\t\t\tconst prev = this.getPageById(partial.id)\n\n\t\t\tif (!prev) return null\n\n\t\t\treturn { data: { prev, partial }, squashing }\n\t\t},\n\t\t{\n\t\t\tdo: ({ partial }) => {\n\t\t\t\tthis.store.update(partial.id, (page) => ({ ...page, ...partial }))\n\t\t\t},\n\t\t\tundo: ({ prev, partial }) => {\n\t\t\t\tthis.store.update(partial.id, () => prev)\n\t\t\t},\n\t\t\tsquash(prevData, nextData) {\n\t\t\t\treturn {\n\t\t\t\t\tprev: { ...prevData.prev, ...nextData.prev },\n\t\t\t\t\tpartial: nextData.partial,\n\t\t\t\t}\n\t\t\t},\n\t\t}\n\t)\n\n\t/**\n\t * Create a page.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.createPage('New Page')\n\t * editor.createPage('New Page', 'page1')\n\t * ```\n\t *\n\t * @param id - The new page's id.\n\t * @param title - The new page's title.\n\t *\n\t * @public\n\t */\n\tcreatePage(title: string, id: TLPageId = PageRecordType.createId(), belowPageIndex?: string) {\n\t\tthis._createPage(title, id, belowPageIndex)\n\t\treturn this\n\t}\n\n\t/** @internal */\n\tprivate _createPage = this.history.createCommand(\n\t\t'createPage',\n\t\t(title: string, id: TLPageId = PageRecordType.createId(), belowPageIndex?: string) => {\n\t\t\tif (this.isReadOnly) return null\n\t\t\tif (this.pages.length >= MAX_PAGES) return null\n\t\t\tconst pageInfo = this.pages\n\t\t\tconst topIndex = belowPageIndex ?? pageInfo[pageInfo.length - 1]?.index ?? 'a1'\n\t\t\tconst bottomIndex = pageInfo[pageInfo.findIndex((p) => p.index === topIndex) + 1]?.index\n\n\t\t\ttitle = getIncrementedName(\n\t\t\t\ttitle,\n\t\t\t\tpageInfo.map((p) => p.name)\n\t\t\t)\n\n\t\t\tconst newPage = PageRecordType.create({\n\t\t\t\tid,\n\t\t\t\tname: title,\n\t\t\t\tindex:\n\t\t\t\t\tbottomIndex && topIndex !== bottomIndex\n\t\t\t\t\t\t? getIndexBetween(topIndex, bottomIndex)\n\t\t\t\t\t\t: getIndexAbove(topIndex),\n\t\t\t})\n\n\t\t\tconst newCamera = CameraRecordType.create({\n\t\t\t\tid: CameraRecordType.createId(newPage.id),\n\t\t\t})\n\n\t\t\tconst newTabPageState = InstancePageStateRecordType.create({\n\t\t\t\tid: InstancePageStateRecordType.createId(newPage.id),\n\t\t\t\tpageId: newPage.id,\n\t\t\t})\n\n\t\t\treturn {\n\t\t\t\tdata: {\n\t\t\t\t\tprevSelectedPageId: this.currentPageId,\n\t\t\t\t\tnewPage,\n\t\t\t\t\tnewTabPageState,\n\t\t\t\t\tnewCamera,\n\t\t\t\t},\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\tdo: ({ newPage, newTabPageState, newCamera }) => {\n\t\t\t\tthis.store.put([\n\t\t\t\t\tnewPage,\n\t\t\t\t\tnewCamera,\n\t\t\t\t\tnewTabPageState,\n\t\t\t\t\t{ ...this.instanceState, currentPageId: newPage.id },\n\t\t\t\t])\n\t\t\t\tthis.updateRenderingBounds()\n\t\t\t},\n\t\t\tundo: ({ newPage, prevSelectedPageId, newTabPageState, newCamera }) => {\n\t\t\t\tif (this.pages.length === 1) return\n\t\t\t\tthis.store.remove([newTabPageState.id, newPage.id, newCamera.id])\n\n\t\t\t\tif (this.store.has(prevSelectedPageId) && this.currentPageId !== prevSelectedPageId) {\n\t\t\t\t\tthis.store.put([{ ...this.instanceState, currentPageId: prevSelectedPageId }])\n\t\t\t\t}\n\n\t\t\t\tthis.updateRenderingBounds()\n\t\t\t},\n\t\t}\n\t)\n\n\t/**\n\t * Duplicate a page.\n\t *\n\t * @param id - The id of the page to duplicate. Defaults to the current page.\n\t * @param createId - The id of the new page. Defaults to a new id.\n\t *\n\t * @public\n\t */\n\tduplicatePage(id: TLPageId = this.currentPageId, createId: TLPageId = PageRecordType.createId()) {\n\t\tif (this.pages.length >= MAX_PAGES) return this\n\t\tconst page = this.getPageById(id)\n\t\tif (!page) return this\n\n\t\tconst camera = { ...this.camera }\n\t\tconst content = this.getContent(this.getSortedChildIds(page.id))\n\n\t\tthis.batch(() => {\n\t\t\tthis.createPage(page.name + ' Copy', createId, page.index)\n\t\t\tthis.setCurrentPageId(createId)\n\t\t\tthis.setCamera(camera.x, camera.y, camera.z)\n\n\t\t\t// will change page automatically\n\t\t\tif (content) {\n\t\t\t\treturn this.putContent(content)\n\t\t\t}\n\t\t})\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Delete a page.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.deletePage('page1')\n\t * ```\n\t *\n\t * @param id - The id of the page to delete.\n\t *\n\t * @public\n\t */\n\tdeletePage(id: TLPageId) {\n\t\tthis._deletePage(id)\n\t}\n\n\t/** @internal */\n\tprivate _deletePage = this.history.createCommand(\n\t\t'delete_page',\n\t\t(id: TLPageId) => {\n\t\t\tif (this.isReadOnly) return null\n\t\t\tconst { pages } = this\n\t\t\tif (pages.length === 1) return null\n\n\t\t\tconst deletedPage = this.getPageById(id)\n\t\t\tconst deletedPageStates = this._pageStates.value.filter((s) => s.pageId === id)\n\n\t\t\tif (!deletedPage) return null\n\n\t\t\tif (id === this.currentPageId) {\n\t\t\t\tconst index = pages.findIndex((page) => page.id === id)\n\t\t\t\tconst next = pages[index - 1] ?? pages[index + 1]\n\t\t\t\tthis.setCurrentPageId(next.id)\n\t\t\t}\n\n\t\t\treturn { data: { id, deletedPage, deletedPageStates } }\n\t\t},\n\t\t{\n\t\t\tdo: ({ deletedPage, deletedPageStates }) => {\n\t\t\t\tconst { pages } = this\n\t\t\t\tif (pages.length === 1) return\n\n\t\t\t\tif (deletedPage.id === this.currentPageId) {\n\t\t\t\t\tconst index = pages.findIndex((page) => page.id === deletedPage.id)\n\t\t\t\t\tconst next = pages[index - 1] ?? pages[index + 1]\n\t\t\t\t\tthis.setCurrentPageId(next.id)\n\t\t\t\t}\n\n\t\t\t\tthis.store.remove(deletedPageStates.map((s) => s.id)) // remove the page state\n\t\t\t\tthis.store.remove([deletedPage.id]) // remove the page\n\t\t\t\tthis.updateRenderingBounds()\n\t\t\t},\n\t\t\tundo: ({ deletedPage, deletedPageStates }) => {\n\t\t\t\tthis.store.put([deletedPage])\n\t\t\t\tthis.store.put(deletedPageStates)\n\t\t\t\tthis.updateRenderingBounds()\n\t\t\t},\n\t\t}\n\t)\n\n\t/** @internal */\n\tprivate _setInstancePageState = this.history.createCommand(\n\t\t'setInstancePageState',\n\t\t(partial: Partial<TLInstancePageState>, ephemeral = false) => {\n\t\t\tconst prev = this.store.get(partial.id ?? this.pageState.id)!\n\t\t\treturn { data: { prev, partial }, ephemeral }\n\t\t},\n\t\t{\n\t\t\tdo: ({ prev, partial }) => {\n\t\t\t\tthis.store.update(prev.id, (state) => ({ ...state, ...partial }))\n\t\t\t},\n\t\t\tundo: ({ prev }) => {\n\t\t\t\tthis.store.update(prev.id, () => prev)\n\t\t\t},\n\t\t}\n\t)\n\n\t/* --------------------- Assets --------------------- */\n\n\t/** @internal */\n\t@computed private get _assets() {\n\t\treturn this.store.query.records('asset')\n\t}\n\n\t/**\n\t * Get all assets in the editor.\n\t *\n\t * @public\n\t */\n\tget assets() {\n\t\treturn this._assets.value\n\t}\n\n\t/**\n\t * Create one or more assets.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.createAssets([...myAssets])\n\t * ```\n\t *\n\t * @param assets - The assets to create.\n\t *\n\t * @public\n\t */\n\tcreateAssets(assets: TLAsset[]) {\n\t\tthis._createAssets(assets)\n\t\treturn this\n\t}\n\n\t/** @internal */\n\tprivate _createAssets = this.history.createCommand(\n\t\t'createAssets',\n\t\t(assets: TLAsset[]) => {\n\t\t\tif (this.isReadOnly) return null\n\t\t\tif (assets.length <= 0) return null\n\n\t\t\treturn { data: { assets } }\n\t\t},\n\t\t{\n\t\t\tdo: ({ assets }) => {\n\t\t\t\tthis.store.put(assets)\n\t\t\t},\n\t\t\tundo: ({ assets }) => {\n\t\t\t\t// todo: should we actually remove assets here? or on cleanup elsewhere?\n\t\t\t\tthis.store.remove(assets.map((a) => a.id))\n\t\t\t},\n\t\t}\n\t)\n\n\t/**\n\t * Delete one or more assets.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.deleteAssets(['asset1', 'asset2'])\n\t * ```\n\t *\n\t * @param ids - The assets to delete.\n\t *\n\t * @public\n\t */\n\tdeleteAssets(ids: TLAssetId[]) {\n\t\tthis._deleteAssets(ids)\n\t\treturn this\n\t}\n\n\t/** @internal */\n\tprivate _deleteAssets = this.history.createCommand(\n\t\t'deleteAssets',\n\t\t(ids: TLAssetId[]) => {\n\t\t\tif (this.isReadOnly) return\n\t\t\tif (ids.length <= 0) return\n\n\t\t\tconst prev = compact(ids.map((id) => this.store.get(id)))\n\n\t\t\treturn { data: { ids, prev } }\n\t\t},\n\t\t{\n\t\t\tdo: ({ ids }) => {\n\t\t\t\tthis.store.remove(ids)\n\t\t\t},\n\t\t\tundo: ({ prev }) => {\n\t\t\t\tthis.store.put(prev)\n\t\t\t},\n\t\t}\n\t)\n\n\t/**\n\t * Update one or more assets.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.updateAssets([{ id: 'asset1', name: 'New name' }])\n\t * ```\n\t *\n\t * @param assets - The assets to update.\n\t *\n\t * @public\n\t */\n\tupdateAssets(assets: TLAssetPartial[]) {\n\t\tthis._updateAssets(assets)\n\t\treturn this\n\t}\n\n\t/** @internal */\n\tprivate _updateAssets = this.history.createCommand(\n\t\t'updateAssets',\n\t\t(assets: TLAssetPartial[]) => {\n\t\t\tif (this.isReadOnly) return\n\t\t\tif (assets.length <= 0) return\n\n\t\t\tconst snapshots: Record<string, TLAsset> = {}\n\n\t\t\treturn { data: { snapshots, assets } }\n\t\t},\n\t\t{\n\t\t\tdo: ({ assets, snapshots }) => {\n\t\t\t\tthis.store.put(\n\t\t\t\t\tassets.map((a) => {\n\t\t\t\t\t\tconst asset = this.store.get(a.id)!\n\t\t\t\t\t\tsnapshots[a.id] = asset\n\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t...asset,\n\t\t\t\t\t\t\t...a,\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t)\n\t\t\t},\n\t\t\tundo: ({ snapshots }) => {\n\t\t\t\tthis.store.put(Object.values(snapshots))\n\t\t\t},\n\t\t}\n\t)\n\n\t/**\n\t * Get an asset by its src property.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.getAssetBySource('https://example.com/image.png')\n\t * ```\n\t *\n\t * @param src - The source value of the asset.\n\t *\n\t * @public\n\t */\n\tgetAssetBySrc(src: string) {\n\t\treturn this.assets.find((a) => a.props.src === src)\n\t}\n\n\t/**\n\t * Get an asset by its id.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.getAssetById('asset1')\n\t * ```\n\t *\n\t * @param id - The id of the asset.\n\t *\n\t * @public\n\t */\n\tgetAssetById(id: TLAssetId): TLAsset | undefined {\n\t\treturn this.store.get(id) as TLAsset | undefined\n\t}\n\n\t/**\n\t * Rename a page.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.renamePage('page1', 'My Page')\n\t * ```\n\t *\n\t * @param id - The id of the page to rename.\n\t * @param name - The new name.\n\t *\n\t * @public\n\t */\n\trenamePage(id: TLPageId, name: string, squashing = false) {\n\t\tif (this.isReadOnly) return this\n\t\tthis.updatePage({ id, name }, squashing)\n\t\treturn this\n\t}\n\n\t/**\n\t * Move shapes to page.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.moveShapesToPage(['box1', 'box2'], 'page1')\n\t * ```\n\t *\n\t * @param ids - The ids of the shapes to move.\n\t * @param pageId - The id of the page where the shapes will be moved.\n\t *\n\t * @public\n\t */\n\tmoveShapesToPage(ids: TLShapeId[], pageId: TLPageId): this {\n\t\tif (ids.length === 0) return this\n\t\tif (this.isReadOnly) return this\n\n\t\tconst { currentPageId } = this\n\n\t\tif (pageId === currentPageId) return this\n\t\tif (!this.store.has(pageId)) return this\n\n\t\t// Basically copy the shapes\n\t\tconst content = this.getContent(ids)\n\n\t\t// Just to be sure\n\t\tif (!content) return this\n\n\t\t// If there is no space on pageId, or if the selected shapes\n\t\t// would take the new page above the limit, don't move the shapes\n\t\tif (this.getShapeIdsInPage(pageId).size + content.shapes.length > MAX_SHAPES_PER_PAGE) {\n\t\t\talertMaxShapes(this, pageId)\n\t\t\treturn this\n\t\t}\n\n\t\tconst fromPageZ = this.camera.z\n\n\t\tthis.history.batch(() => {\n\t\t\t// Delete the shapes on the current page\n\t\t\tthis.deleteShapes(ids)\n\n\t\t\t// Move to the next page\n\t\t\tthis.setCurrentPageId(pageId)\n\n\t\t\t// Put the shape content onto the new page; parents and indices will\n\t\t\t// be taken care of by the putContent method; make sure to pop any focus\n\t\t\t// layers so that the content will be put onto the page.\n\t\t\tthis.setFocusLayer(null)\n\t\t\tthis.selectNone()\n\t\t\tthis.putContent(content, { select: true, preserveIds: true, preservePosition: true })\n\n\t\t\t// Force the new page's camera to be at the same zoom level as the\n\t\t\t// \"from\" page's camera, then center the \"to\" page's camera on the\n\t\t\t// pasted shapes\n\t\t\tconst {\n\t\t\t\tcenter: { x, y },\n\t\t\t} = this.selectionBounds!\n\t\t\tthis.setCamera(this.camera.x, this.camera.y, fromPageZ)\n\t\t\tthis.centerOnPoint(x, y)\n\t\t})\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Toggle the lock state of one or more shapes. If there is a mix of locked and unlocked shapes, all shapes will be locked.\n\t *\n\t * @param ids - The ids of the shapes to toggle. Defaults to selected shapes.\n\t *\n\t * @public\n\t */\n\ttoggleLock(ids: TLShapeId[] = this.selectedIds): this {\n\t\tif (this.isReadOnly || ids.length === 0) return this\n\n\t\tlet allLocked = true,\n\t\t\tallUnlocked = true\n\t\tconst shapes: TLShape[] = []\n\t\tfor (const id of ids) {\n\t\t\tconst shape = this.getShapeById(id)\n\t\t\tif (shape) {\n\t\t\t\tshapes.push(shape)\n\t\t\t\tif (shape.isLocked) {\n\t\t\t\t\tallUnlocked = false\n\t\t\t\t} else {\n\t\t\t\t\tallLocked = false\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (allUnlocked) {\n\t\t\tthis.updateShapes(shapes.map((shape) => ({ id: shape.id, type: shape.type, isLocked: true })))\n\t\t\tthis.setSelectedIds([])\n\t\t} else if (allLocked) {\n\t\t\tthis.updateShapes(\n\t\t\t\tshapes.map((shape) => ({ id: shape.id, type: shape.type, isLocked: false }))\n\t\t\t)\n\t\t} else {\n\t\t\tthis.updateShapes(shapes.map((shape) => ({ id: shape.id, type: shape.type, isLocked: true })))\n\t\t}\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Reorder shapes.\n\t *\n\t * @param operation - The operation to perform.\n\t * @param ids - The ids to reorder.\n\t *\n\t * @public\n\t */\n\treorderShapes(operation: 'toBack' | 'toFront' | 'forward' | 'backward', ids: TLShapeId[]) {\n\t\tif (this.isReadOnly) return this\n\t\tif (ids.length === 0) return this\n\t\t// this.emit('reorder-shapes', { pageId: this.currentPageId, ids, operation })\n\n\t\tconst parents = this.getParentsMappedToChildren(ids)\n\n\t\tconst changes: TLShapePartial[] = []\n\n\t\tswitch (operation) {\n\t\t\tcase 'toBack': {\n\t\t\t\tparents.forEach((movingSet, parentId) => {\n\t\t\t\t\tconst siblings = compact(\n\t\t\t\t\t\tthis.getSortedChildIds(parentId).map((id) => this.getShapeById(id))\n\t\t\t\t\t)\n\n\t\t\t\t\tif (movingSet.size === siblings.length) return\n\n\t\t\t\t\tlet below: string | undefined\n\t\t\t\t\tlet above: string | undefined\n\n\t\t\t\t\tfor (const shape of siblings) {\n\t\t\t\t\t\tif (!movingSet.has(shape)) {\n\t\t\t\t\t\t\tabove = shape.index\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmovingSet.delete(shape)\n\t\t\t\t\t\tbelow = shape.index\n\t\t\t\t\t}\n\n\t\t\t\t\tif (movingSet.size === 0) return\n\n\t\t\t\t\tconst indices = getIndicesBetween(below, above, movingSet.size)\n\n\t\t\t\t\tArray.from(movingSet.values())\n\t\t\t\t\t\t.sort(sortByIndex)\n\t\t\t\t\t\t.forEach((node, i) =>\n\t\t\t\t\t\t\tchanges.push({ id: node.id as any, type: node.type, index: indices[i] })\n\t\t\t\t\t\t)\n\t\t\t\t})\n\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase 'toFront': {\n\t\t\t\tparents.forEach((movingSet, parentId) => {\n\t\t\t\t\tconst siblings = compact(\n\t\t\t\t\t\tthis.getSortedChildIds(parentId).map((id) => this.getShapeById(id))\n\t\t\t\t\t)\n\t\t\t\t\tconst len = siblings.length\n\n\t\t\t\t\tif (movingSet.size === len) return\n\n\t\t\t\t\tlet below: string | undefined\n\t\t\t\t\tlet above: string | undefined\n\n\t\t\t\t\tfor (let i = len - 1; i > -1; i--) {\n\t\t\t\t\t\tconst shape = siblings[i]\n\n\t\t\t\t\t\tif (!movingSet.has(shape)) {\n\t\t\t\t\t\t\tbelow = shape.index\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmovingSet.delete(shape)\n\t\t\t\t\t\tabove = shape.index\n\t\t\t\t\t}\n\n\t\t\t\t\tif (movingSet.size === 0) return\n\n\t\t\t\t\tconst indices = getIndicesBetween(below, above, movingSet.size)\n\n\t\t\t\t\tArray.from(movingSet.values())\n\t\t\t\t\t\t.sort(sortByIndex)\n\t\t\t\t\t\t.forEach((node, i) =>\n\t\t\t\t\t\t\tchanges.push({ id: node.id as any, type: node.type, index: indices[i] })\n\t\t\t\t\t\t)\n\t\t\t\t})\n\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase 'forward': {\n\t\t\t\tparents.forEach((movingSet, parentId) => {\n\t\t\t\t\tconst siblings = compact(\n\t\t\t\t\t\tthis.getSortedChildIds(parentId).map((id) => this.getShapeById(id))\n\t\t\t\t\t)\n\t\t\t\t\tconst len = siblings.length\n\n\t\t\t\t\tif (movingSet.size === len) return\n\n\t\t\t\t\tconst movingIndices = new Set(Array.from(movingSet).map((n) => siblings.indexOf(n)))\n\n\t\t\t\t\tlet selectIndex = -1\n\t\t\t\t\tlet isSelecting = false\n\t\t\t\t\tlet below: string | undefined\n\t\t\t\t\tlet above: string | undefined\n\t\t\t\t\tlet count: number\n\n\t\t\t\t\tfor (let i = 0; i < len; i++) {\n\t\t\t\t\t\tconst isMoving = movingIndices.has(i)\n\n\t\t\t\t\t\tif (!isSelecting && isMoving) {\n\t\t\t\t\t\t\tisSelecting = true\n\t\t\t\t\t\t\tselectIndex = i\n\t\t\t\t\t\t\tabove = undefined\n\t\t\t\t\t\t} else if (isSelecting && !isMoving) {\n\t\t\t\t\t\t\tisSelecting = false\n\t\t\t\t\t\t\tcount = i - selectIndex\n\t\t\t\t\t\t\tbelow = siblings[i].index\n\t\t\t\t\t\t\tabove = siblings[i + 1]?.index\n\n\t\t\t\t\t\t\tconst indices = getIndicesBetween(below, above, count)\n\n\t\t\t\t\t\t\tfor (let k = 0; k < count; k++) {\n\t\t\t\t\t\t\t\tconst node = siblings[selectIndex + k]\n\t\t\t\t\t\t\t\tchanges.push({ id: node.id as any, type: node.type, index: indices[k] })\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t})\n\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase 'backward': {\n\t\t\t\tparents.forEach((movingSet, parentId) => {\n\t\t\t\t\tconst siblings = compact(\n\t\t\t\t\t\tthis.getSortedChildIds(parentId).map((id) => this.getShapeById(id))\n\t\t\t\t\t)\n\t\t\t\t\tconst len = siblings.length\n\n\t\t\t\t\tif (movingSet.size === len) return\n\n\t\t\t\t\tconst movingIndices = new Set(Array.from(movingSet).map((n) => siblings.indexOf(n)))\n\n\t\t\t\t\tlet selectIndex = -1\n\t\t\t\t\tlet isSelecting = false\n\t\t\t\t\tlet count: number\n\n\t\t\t\t\tfor (let i = len - 1; i > -1; i--) {\n\t\t\t\t\t\tconst isMoving = movingIndices.has(i)\n\n\t\t\t\t\t\tif (!isSelecting && isMoving) {\n\t\t\t\t\t\t\tisSelecting = true\n\t\t\t\t\t\t\tselectIndex = i\n\t\t\t\t\t\t} else if (isSelecting && !isMoving) {\n\t\t\t\t\t\t\tisSelecting = false\n\t\t\t\t\t\t\tcount = selectIndex - i\n\n\t\t\t\t\t\t\tconst indices = getIndicesBetween(siblings[i - 1]?.index, siblings[i].index, count)\n\n\t\t\t\t\t\t\tfor (let k = 0; k < count; k++) {\n\t\t\t\t\t\t\t\tconst node = siblings[i + k + 1]\n\t\t\t\t\t\t\t\tchanges.push({ id: node.id as any, type: node.type, index: indices[k] })\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t})\n\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tthis.updateShapes(changes)\n\t\treturn this\n\t}\n\n\t/**\n\t * Send shapes to the back of the page's object list.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.sendToBack()\n\t * editor.sendToBack(['id1', 'id2'])\n\t * ```\n\t *\n\t * @param ids - The ids of the shapes to move. Defaults to the ids of the selected shapes.\n\t *\n\t * @public\n\t */\n\tsendToBack(ids = this.pageState.selectedIds) {\n\t\tthis.reorderShapes('toBack', ids)\n\t\treturn this\n\t}\n\n\t/**\n\t * Send shapes backward in the page's object list.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.sendBackward()\n\t * editor.sendBackward(['id1', 'id2'])\n\t * ```\n\t *\n\t * @param ids - The ids of the shapes to move. Defaults to the ids of the selected shapes.\n\t *\n\t * @public\n\t */\n\tsendBackward(ids = this.pageState.selectedIds) {\n\t\tthis.reorderShapes('backward', ids)\n\t\treturn this\n\t}\n\n\t/**\n\t * Bring shapes forward in the page's object list.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.bringForward()\n\t * editor.bringForward(['id1', 'id2'])\n\t * ```\n\t *\n\t * @param ids - The ids of the shapes to move. Defaults to the ids of the selected shapes.\n\t *\n\t * @public\n\t */\n\tbringForward(ids = this.pageState.selectedIds) {\n\t\tthis.reorderShapes('forward', ids)\n\t\treturn this\n\t}\n\n\t/**\n\t * Bring shapes to the front of the page's object list.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.bringToFront()\n\t * editor.bringToFront(['id1', 'id2'])\n\t * ```\n\t *\n\t * @param ids - The ids of the shapes to move. Defaults to the ids of the selected shapes.\n\t *\n\t * @public\n\t */\n\tbringToFront(ids = this.pageState.selectedIds) {\n\t\tthis.reorderShapes('toFront', ids)\n\t\treturn this\n\t}\n\n\t/**\n\t * Flip shape positions.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.flipShapes('horizontal')\n\t * editor.flipShapes('horizontal', ['box1', 'box2'])\n\t * ```\n\t *\n\t * @param operation - Whether to flip horizontally or vertically.\n\t * @param ids - The ids of the shapes to flip. Defaults to selected shapes.\n\t *\n\t * @public\n\t */\n\tflipShapes(operation: 'horizontal' | 'vertical', ids: TLShapeId[] = this.selectedIds) {\n\t\tif (this.isReadOnly) return this\n\n\t\tlet shapes = compact(ids.map((id) => this.getShapeById(id)))\n\n\t\tif (!shapes.length) return this\n\n\t\tshapes = compact(\n\t\t\tshapes\n\t\t\t\t.map((shape) => {\n\t\t\t\t\tif (this.isShapeOfType(shape, GroupShapeUtil)) {\n\t\t\t\t\t\treturn this.getSortedChildIds(shape.id).map((id) => this.getShapeById(id))\n\t\t\t\t\t}\n\n\t\t\t\t\treturn shape\n\t\t\t\t})\n\t\t\t\t.flat()\n\t\t)\n\n\t\tconst scaleOriginPage = Box2d.Common(compact(shapes.map((id) => this.getPageBounds(id)))).center\n\n\t\tthis.batch(() => {\n\t\t\tfor (const shape of shapes) {\n\t\t\t\tconst util = this.getShapeUtil(shape)\n\t\t\t\tconst bounds = util.bounds(shape)\n\t\t\t\tconst initialPageTransform = this.getPageTransformById(shape.id)\n\t\t\t\tif (!initialPageTransform) continue\n\t\t\t\tthis.resizeShape(\n\t\t\t\t\tshape.id,\n\t\t\t\t\t{ x: operation === 'horizontal' ? -1 : 1, y: operation === 'vertical' ? -1 : 1 },\n\t\t\t\t\t{\n\t\t\t\t\t\tinitialBounds: bounds,\n\t\t\t\t\t\tinitialPageTransform,\n\t\t\t\t\t\tinitialShape: shape,\n\t\t\t\t\t\tmode: 'scale_shape',\n\t\t\t\t\t\tscaleOrigin: scaleOriginPage,\n\t\t\t\t\t\tscaleAxisRotation: 0,\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t}\n\t\t})\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Stack shape.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.stackShapes('horizontal')\n\t * editor.stackShapes('horizontal', ['box1', 'box2'])\n\t * editor.stackShapes('horizontal', ['box1', 'box2'], 20)\n\t * ```\n\t *\n\t * @param operation - Whether to stack horizontally or vertically.\n\t * @param ids - The ids of the shapes to stack. Defaults to selected shapes.\n\t * @param gap - A specific gap to use when stacking.\n\t *\n\t * @public\n\t */\n\tstackShapes(\n\t\toperation: 'horizontal' | 'vertical',\n\t\tids: TLShapeId[] = this.pageState.selectedIds,\n\t\tgap?: number\n\t) {\n\t\tif (this.isReadOnly) return this\n\n\t\tconst shapes = compact(ids.map((id) => this.getShapeById(id))).filter((shape) => {\n\t\t\tif (!shape) return false\n\n\t\t\tif (this.isShapeOfType(shape, ArrowShapeUtil)) {\n\t\t\t\tif (shape.props.start.type === 'binding' || shape.props.end.type === 'binding') {\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn true\n\t\t})\n\n\t\tconst len = shapes.length\n\n\t\tif ((gap === undefined && len < 3) || len < 2) return this\n\n\t\tconst pageBounds = Object.fromEntries(\n\t\t\tshapes.map((shape) => [shape.id, this.getPageBounds(shape)!])\n\t\t)\n\n\t\tlet val: 'x' | 'y'\n\t\tlet min: 'minX' | 'minY'\n\t\tlet max: 'maxX' | 'maxY'\n\t\tlet dim: 'width' | 'height'\n\n\t\tif (operation === 'horizontal') {\n\t\t\tval = 'x'\n\t\t\tmin = 'minX'\n\t\t\tmax = 'maxX'\n\t\t\tdim = 'width'\n\t\t} else {\n\t\t\tval = 'y'\n\t\t\tmin = 'minY'\n\t\t\tmax = 'maxY'\n\t\t\tdim = 'height'\n\t\t}\n\n\t\tlet shapeGap: number\n\n\t\tif (gap === undefined) {\n\t\t\tconst gaps: { gap: number; count: number }[] = []\n\n\t\t\tshapes.sort((a, b) => pageBounds[a.id][min] - pageBounds[b.id][min])\n\n\t\t\t// Collect all of the gaps between shapes. We want to find\n\t\t\t// patterns (equal gaps between shapes) and use the most common\n\t\t\t// one as the gap for all of the shapes.\n\t\t\tfor (let i = 0; i < len - 1; i++) {\n\t\t\t\tconst shape = shapes[i]\n\t\t\t\tconst nextShape = shapes[i + 1]\n\n\t\t\t\tconst bounds = pageBounds[shape.id]\n\t\t\t\tconst nextBounds = pageBounds[nextShape.id]\n\n\t\t\t\tconst gap = nextBounds[min] - bounds[max]\n\n\t\t\t\tconst current = gaps.find((g) => g.gap === gap)\n\n\t\t\t\tif (current) {\n\t\t\t\t\tcurrent.count++\n\t\t\t\t} else {\n\t\t\t\t\tgaps.push({ gap, count: 1 })\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Which gap is the most common?\n\t\t\tlet maxCount = 0\n\t\t\tgaps.forEach((g) => {\n\t\t\t\tif (g.count > maxCount) {\n\t\t\t\t\tmaxCount = g.count\n\t\t\t\t\tshapeGap = g.gap\n\t\t\t\t}\n\t\t\t})\n\n\t\t\t// If there is no most-common gap, use the average gap.\n\t\t\tif (maxCount === 1) {\n\t\t\t\tshapeGap = Math.max(0, gaps.reduce((a, c) => a + c.gap * c.count, 0) / (len - 1))\n\t\t\t}\n\t\t} else {\n\t\t\t// If a gap was provided, then use that instead.\n\t\t\tshapeGap = gap\n\t\t}\n\n\t\tconst changes: TLShapePartial[] = []\n\n\t\tlet v = pageBounds[shapes[0].id][max]\n\n\t\tshapes.forEach((shape, i) => {\n\t\t\tif (i === 0) return\n\n\t\t\tconst delta = { x: 0, y: 0 }\n\t\t\tdelta[val] = v + shapeGap - pageBounds[shape.id][val]\n\n\t\t\tconst parent = this.getParentShape(shape)\n\t\t\tconst localDelta = parent ? Vec2d.Rot(delta, -this.getPageRotation(parent)) : delta\n\n\t\t\tconst translateStartChanges = this.getShapeUtil(shape).onTranslateStart?.(shape)\n\n\t\t\tchanges.push(\n\t\t\t\ttranslateStartChanges\n\t\t\t\t\t? {\n\t\t\t\t\t\t\t...translateStartChanges,\n\t\t\t\t\t\t\t[val]: shape[val] + localDelta[val],\n\t\t\t\t\t  }\n\t\t\t\t\t: {\n\t\t\t\t\t\t\tid: shape.id as any,\n\t\t\t\t\t\t\ttype: shape.type,\n\t\t\t\t\t\t\t[val]: shape[val] + localDelta[val],\n\t\t\t\t\t  }\n\t\t\t)\n\n\t\t\tv += pageBounds[shape.id][dim] + shapeGap\n\t\t})\n\n\t\tthis.updateShapes(changes)\n\t\treturn this\n\t}\n\n\t/**\n\t * Pack shapes into a grid centered on their current position. Based on potpack\n\t * (https://github.com/mapbox/potpack)\n\t * @param ids - The ids of the shapes to pack. Defaults to selected shapes.\n\t * @param padding - The padding to apply to the packed shapes.\n\t */\n\tpackShapes(ids: TLShapeId[] = this.pageState.selectedIds, padding = 16) {\n\t\tif (this.isReadOnly) return this\n\t\tif (ids.length < 2) return this\n\n\t\tconst shapes = compact(\n\t\t\tids\n\t\t\t\t.map((id) => this.getShapeById(id))\n\t\t\t\t.filter((shape) => {\n\t\t\t\t\tif (!shape) return false\n\n\t\t\t\t\tif (this.isShapeOfType(shape, ArrowShapeUtil)) {\n\t\t\t\t\t\tif (shape.props.start.type === 'binding' || shape.props.end.type === 'binding') {\n\t\t\t\t\t\t\treturn false\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true\n\t\t\t\t})\n\t\t)\n\t\tconst shapePageBounds: Record<string, Box2d> = {}\n\t\tconst nextShapePageBounds: Record<string, Box2d> = {}\n\n\t\tlet shape: TLShape,\n\t\t\tbounds: Box2d,\n\t\t\tarea = 0\n\n\t\tfor (let i = 0; i < shapes.length; i++) {\n\t\t\tshape = shapes[i]\n\t\t\tbounds = this.getPageBounds(shape)!\n\t\t\tshapePageBounds[shape.id] = bounds\n\t\t\tnextShapePageBounds[shape.id] = bounds.clone()\n\t\t\tarea += bounds.width * bounds.height\n\t\t}\n\n\t\tconst commonBounds = Box2d.Common(compact(Object.values(shapePageBounds)))\n\n\t\tconst maxWidth = commonBounds.width\n\n\t\t// sort the shapes by height, descending\n\t\tshapes.sort((a, b) => shapePageBounds[b.id].height - shapePageBounds[a.id].height)\n\n\t\t// Start with is (sort of) the square of the area\n\t\tconst startWidth = Math.max(Math.ceil(Math.sqrt(area / 0.95)), maxWidth)\n\n\t\t// first shape fills the width and is infinitely tall\n\t\tconst spaces: Box2d[] = [new Box2d(commonBounds.x, commonBounds.y, startWidth, Infinity)]\n\n\t\tlet width = 0\n\t\tlet height = 0\n\t\tlet space: Box2d\n\t\tlet last: Box2d\n\n\t\tfor (let i = 0; i < shapes.length; i++) {\n\t\t\tshape = shapes[i]\n\t\t\tbounds = nextShapePageBounds[shape.id]\n\n\t\t\t// starting at the back (smaller shapes)\n\t\t\tfor (let i = spaces.length - 1; i >= 0; i--) {\n\t\t\t\tspace = spaces[i]\n\n\t\t\t\t// find a space that is big enough to contain the shape\n\t\t\t\tif (bounds.width > space.width || bounds.height > space.height) continue\n\n\t\t\t\t// add the shape to its top-left corner\n\t\t\t\tbounds.x = space.x\n\t\t\t\tbounds.y = space.y\n\n\t\t\t\theight = Math.max(height, bounds.maxY)\n\t\t\t\twidth = Math.max(width, bounds.maxX)\n\n\t\t\t\tif (bounds.width === space.width && bounds.height === space.height) {\n\t\t\t\t\t// remove the space on a perfect fit\n\t\t\t\t\tlast = spaces.pop()!\n\t\t\t\t\tif (i < spaces.length) spaces[i] = last\n\t\t\t\t} else if (bounds.height === space.height) {\n\t\t\t\t\t// fit the shape into the space (width)\n\t\t\t\t\tspace.x += bounds.width + padding\n\t\t\t\t\tspace.width -= bounds.width + padding\n\t\t\t\t} else if (bounds.width === space.width) {\n\t\t\t\t\t// fit the shape into the space (height)\n\t\t\t\t\tspace.y += bounds.height + padding\n\t\t\t\t\tspace.height -= bounds.height + padding\n\t\t\t\t} else {\n\t\t\t\t\t// split the space into two spaces\n\t\t\t\t\tspaces.push(\n\t\t\t\t\t\tnew Box2d(\n\t\t\t\t\t\t\tspace.x + (bounds.width + padding),\n\t\t\t\t\t\t\tspace.y,\n\t\t\t\t\t\t\tspace.width - (bounds.width + padding),\n\t\t\t\t\t\t\tbounds.height\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t\tspace.y += bounds.height + padding\n\t\t\t\t\tspace.height -= bounds.height + padding\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tconst commonAfter = Box2d.Common(Object.values(nextShapePageBounds))\n\t\tconst centerDelta = Vec2d.Sub(commonBounds.center, commonAfter.center)\n\n\t\tlet nextBounds: Box2d\n\n\t\tconst changes: TLShapePartial<any>[] = []\n\n\t\tfor (let i = 0; i < shapes.length; i++) {\n\t\t\tshape = shapes[i]\n\t\t\tbounds = shapePageBounds[shape.id]\n\t\t\tnextBounds = nextShapePageBounds[shape.id]\n\n\t\t\tconst delta = this.getDeltaInParentSpace(\n\t\t\t\tshape,\n\t\t\t\tVec2d.Sub(nextBounds.point, bounds.point).add(centerDelta)\n\t\t\t)\n\n\t\t\tconst change: TLShapePartial = {\n\t\t\t\tid: shape.id,\n\t\t\t\ttype: shape.type,\n\t\t\t\tx: shape.x + delta.x,\n\t\t\t\ty: shape.y + delta.y,\n\t\t\t}\n\n\t\t\tconst translateStartChange = this.getShapeUtil(shape).onTranslateStart?.({\n\t\t\t\t...shape,\n\t\t\t\t...change,\n\t\t\t})\n\n\t\t\tif (translateStartChange) {\n\t\t\t\tchanges.push({ ...change, ...translateStartChange })\n\t\t\t} else {\n\t\t\t\tchanges.push(change)\n\t\t\t}\n\t\t}\n\n\t\tif (changes.length) {\n\t\t\tthis.updateShapes(changes)\n\t\t}\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Align shape positions.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.alignShapes('left')\n\t * editor.alignShapes('left', ['box1', 'box2'])\n\t * ```\n\t *\n\t * @param operation - The align operation to apply.\n\t * @param ids - The ids of the shapes to align. Defaults to selected shapes.\n\t *\n\t * @public\n\t */\n\talignShapes(\n\t\toperation: 'left' | 'center-horizontal' | 'right' | 'top' | 'center-vertical' | 'bottom',\n\t\tids: TLShapeId[] = this.pageState.selectedIds\n\t) {\n\t\tif (this.isReadOnly) return this\n\t\tif (ids.length < 2) return this\n\n\t\tconst shapes = compact(ids.map((id) => this.getShapeById(id)))\n\t\tconst shapePageBounds = Object.fromEntries(\n\t\t\tshapes.map((shape) => [shape.id, this.getPageBounds(shape)])\n\t\t)\n\t\tconst commonBounds = Box2d.Common(compact(Object.values(shapePageBounds)))\n\n\t\tconst changes: TLShapePartial[] = []\n\n\t\tshapes.forEach((shape) => {\n\t\t\tconst pageBounds = shapePageBounds[shape.id]\n\t\t\tif (!pageBounds) return\n\n\t\t\tconst delta = { x: 0, y: 0 }\n\n\t\t\tswitch (operation) {\n\t\t\t\tcase 'top': {\n\t\t\t\t\tdelta.y = commonBounds.minY - pageBounds.minY\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tcase 'center-vertical': {\n\t\t\t\t\tdelta.y = commonBounds.midY - pageBounds.minY - pageBounds.height / 2\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tcase 'bottom': {\n\t\t\t\t\tdelta.y = commonBounds.maxY - pageBounds.minY - pageBounds.height\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tcase 'left': {\n\t\t\t\t\tdelta.x = commonBounds.minX - pageBounds.minX\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tcase 'center-horizontal': {\n\t\t\t\t\tdelta.x = commonBounds.midX - pageBounds.minX - pageBounds.width / 2\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tcase 'right': {\n\t\t\t\t\tdelta.x = commonBounds.maxX - pageBounds.minX - pageBounds.width\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst parent = this.getParentShape(shape)\n\t\t\tconst localDelta = parent ? Vec2d.Rot(delta, -this.getPageRotation(parent)) : delta\n\n\t\t\tconst translateChanges = this.getShapeUtil(shape).onTranslateStart?.(shape)\n\n\t\t\tchanges.push(\n\t\t\t\ttranslateChanges\n\t\t\t\t\t? {\n\t\t\t\t\t\t\t...translateChanges,\n\t\t\t\t\t\t\tx: shape.x + localDelta.x,\n\t\t\t\t\t\t\ty: shape.y + localDelta.y,\n\t\t\t\t\t  }\n\t\t\t\t\t: {\n\t\t\t\t\t\t\tid: shape.id,\n\t\t\t\t\t\t\ttype: shape.type,\n\t\t\t\t\t\t\tx: shape.x + localDelta.x,\n\t\t\t\t\t\t\ty: shape.y + localDelta.y,\n\t\t\t\t\t  }\n\t\t\t)\n\t\t})\n\n\t\tthis.updateShapes(changes)\n\t\treturn this\n\t}\n\n\t/**\n\t * Distribute shape positions.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.distributeShapes('left')\n\t * editor.distributeShapes('left', ['box1', 'box2'])\n\t * ```\n\t *\n\t * @param operation - Whether to distribute shapes horizontally or vertically.\n\t * @param ids - The ids of the shapes to distribute. Defaults to selected shapes.\n\t *\n\t * @public\n\t */\n\tdistributeShapes(\n\t\toperation: 'horizontal' | 'vertical',\n\t\tids: TLShapeId[] = this.pageState.selectedIds\n\t) {\n\t\tif (this.isReadOnly) return this\n\t\tif (ids.length < 3) return this\n\n\t\tconst len = ids.length\n\t\tconst shapes = compact(ids.map((id) => this.getShapeById(id)))\n\t\tconst pageBounds = Object.fromEntries(\n\t\t\tshapes.map((shape) => [shape.id, this.getPageBounds(shape)!])\n\t\t)\n\n\t\tlet val: 'x' | 'y'\n\t\tlet min: 'minX' | 'minY'\n\t\tlet max: 'maxX' | 'maxY'\n\t\tlet mid: 'midX' | 'midY'\n\t\tlet dim: 'width' | 'height'\n\n\t\tif (operation === 'horizontal') {\n\t\t\tval = 'x'\n\t\t\tmin = 'minX'\n\t\t\tmax = 'maxX'\n\t\t\tmid = 'midX'\n\t\t\tdim = 'width'\n\t\t} else {\n\t\t\tval = 'y'\n\t\t\tmin = 'minY'\n\t\t\tmax = 'maxY'\n\t\t\tmid = 'midY'\n\t\t\tdim = 'height'\n\t\t}\n\t\tconst changes: TLShapePartial[] = []\n\n\t\t// Clustered\n\t\tconst first = shapes.sort((a, b) => pageBounds[a.id][min] - pageBounds[b.id][min])[0]\n\t\tconst last = shapes.sort((a, b) => pageBounds[b.id][max] - pageBounds[a.id][max])[0]\n\n\t\tconst midFirst = pageBounds[first.id][mid]\n\t\tconst step = (pageBounds[last.id][mid] - midFirst) / (len - 1)\n\t\tconst v = midFirst + step\n\n\t\tshapes\n\t\t\t.filter((shape) => shape !== first && shape !== last)\n\t\t\t.sort((a, b) => pageBounds[a.id][mid] - pageBounds[b.id][mid])\n\t\t\t.forEach((shape, i) => {\n\t\t\t\tconst delta = { x: 0, y: 0 }\n\t\t\t\tdelta[val] = v + step * i - pageBounds[shape.id][dim] / 2 - pageBounds[shape.id][val]\n\n\t\t\t\tconst parent = this.getParentShape(shape)\n\t\t\t\tconst localDelta = parent ? Vec2d.Rot(delta, -this.getPageRotation(parent)) : delta\n\t\t\t\tconst translateStartChanges = this.getShapeUtil(shape).onTranslateStart?.(shape)\n\n\t\t\t\tchanges.push(\n\t\t\t\t\ttranslateStartChanges\n\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t...translateStartChanges,\n\t\t\t\t\t\t\t\t[val]: shape[val] + localDelta[val],\n\t\t\t\t\t\t  }\n\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\tid: shape.id,\n\t\t\t\t\t\t\t\ttype: shape.type,\n\t\t\t\t\t\t\t\t[val]: shape[val] + localDelta[val],\n\t\t\t\t\t\t  }\n\t\t\t\t)\n\t\t\t})\n\n\t\tthis.updateShapes(changes)\n\t\treturn this\n\t}\n\n\t/** @internal */\n\tprivate _resizeUnalignedShape(\n\t\tid: TLShapeId,\n\t\tscale: VecLike,\n\t\toptions: {\n\t\t\tinitialBounds: Box2d\n\t\t\tscaleOrigin: VecLike\n\t\t\tscaleAxisRotation: number\n\t\t\tinitialShape: TLShape\n\t\t\tinitialPageTransform: MatLike\n\t\t}\n\t) {\n\t\tconst { type } = options.initialShape\n\t\t// If a shape is not aligned with the scale axis we need to treat it differently to avoid skewing.\n\t\t// Instead of skewing we normalize the scale aspect ratio (i.e. keep the same scale magnitude in both axes)\n\t\t// and then after applying the scale to the shape we also rotate it if required and translate it so that it's center\n\t\t// point ends up in the right place.\n\n\t\tconst shapeScale = new Vec2d(scale.x, scale.y)\n\n\t\t// // make sure we are constraining aspect ratio, and using the smallest scale axis to avoid shapes getting bigger\n\t\t// // than the selection bounding box\n\t\tif (Math.abs(scale.x) > Math.abs(scale.y)) {\n\t\t\tshapeScale.x = Math.sign(scale.x) * Math.abs(scale.y)\n\t\t} else {\n\t\t\tshapeScale.y = Math.sign(scale.y) * Math.abs(scale.x)\n\t\t}\n\n\t\t// first we can scale the shape about its center point\n\t\tthis.resizeShape(id, shapeScale, {\n\t\t\tinitialShape: options.initialShape,\n\t\t\tinitialBounds: options.initialBounds,\n\t\t})\n\n\t\t// then if the shape is flipped in one axis only, we need to apply an extra rotation\n\t\t// to make sure the shape is mirrored correctly\n\t\tif (Math.sign(scale.x) * Math.sign(scale.y) < 0) {\n\t\t\tlet { rotation } = Matrix2d.Decompose(options.initialPageTransform)\n\t\t\trotation -= 2 * rotation\n\t\t\tthis.updateShapes([{ id, type, rotation }], true)\n\t\t}\n\n\t\t// Next we need to translate the shape so that it's center point ends up in the right place.\n\t\t// To do that we first need to calculate the center point of the shape in page space before the scale was applied.\n\t\tconst preScaleShapePageCenter = Matrix2d.applyToPoint(\n\t\t\toptions.initialPageTransform,\n\t\t\toptions.initialBounds.center\n\t\t)\n\n\t\t// And now we scale the center point by the original scale factor\n\t\tconst postScaleShapePageCenter = this._scalePagePoint(\n\t\t\tpreScaleShapePageCenter,\n\t\t\toptions.scaleOrigin,\n\t\t\tscale,\n\t\t\toptions.scaleAxisRotation\n\t\t)\n\n\t\t// now calculate how far away the shape is from where it needs to be\n\t\tconst currentPageCenter = this.getPageCenterById(id)\n\t\tconst currentPagePoint = this.getPagePointById(id)\n\t\tif (!currentPageCenter || !currentPagePoint) return this\n\t\tconst pageDelta = Vec2d.Sub(postScaleShapePageCenter, currentPageCenter)\n\n\t\t// and finally figure out what the shape's new position should be\n\t\tconst postScaleShapePagePoint = Vec2d.Add(currentPagePoint, pageDelta)\n\t\tconst { x, y } = this.getPointInParentSpace(id, postScaleShapePagePoint)\n\n\t\tthis.updateShapes([{ id, type, x, y }], true)\n\n\t\treturn this\n\t}\n\n\t/** @internal */\n\tprivate _scalePagePoint(\n\t\tpoint: VecLike,\n\t\tscaleOrigin: VecLike,\n\t\tscale: VecLike,\n\t\tscaleAxisRotation: number\n\t) {\n\t\tconst relativePoint = Vec2d.RotWith(point, scaleOrigin, -scaleAxisRotation).sub(scaleOrigin)\n\n\t\t// calculate the new point position relative to the scale origin\n\t\tconst newRelativePagePoint = Vec2d.MulV(relativePoint, scale)\n\n\t\t// and rotate it back to page coords to get the new page point of the resized shape\n\t\tconst destination = Vec2d.Add(newRelativePagePoint, scaleOrigin).rotWith(\n\t\t\tscaleOrigin,\n\t\t\tscaleAxisRotation\n\t\t)\n\n\t\treturn destination\n\t}\n\n\t/**\n\t * Resize a shape.\n\t *\n\t * @param id - The id of the shape to resize.\n\t * @param scale - The scale factor to apply to the shape.\n\t * @param options - Additional options.\n\t *\n\t * @public\n\t */\n\tresizeShape(\n\t\tid: TLShapeId,\n\t\tscale: VecLike,\n\t\toptions: {\n\t\t\tinitialBounds?: Box2d\n\t\t\tscaleOrigin?: VecLike\n\t\t\tscaleAxisRotation?: number\n\t\t\tinitialShape?: TLShape\n\t\t\tinitialPageTransform?: MatLike\n\t\t\tdragHandle?: TLResizeHandle\n\t\t\tmode?: TLResizeMode\n\t\t} = {}\n\t) {\n\t\tif (this.isReadOnly) return this\n\n\t\tif (!Number.isFinite(scale.x)) scale = new Vec2d(1, scale.y)\n\t\tif (!Number.isFinite(scale.y)) scale = new Vec2d(scale.x, 1)\n\n\t\tconst initialShape = options.initialShape ?? this.getShapeById(id)\n\t\tif (!initialShape) return this\n\n\t\tconst scaleOrigin = options.scaleOrigin ?? this.getPageBoundsById(id)?.center\n\t\tif (!scaleOrigin) return this\n\n\t\tconst pageRotation = this.getPageRotationById(id)\n\n\t\tif (pageRotation == null) return this\n\n\t\tconst scaleAxisRotation = options.scaleAxisRotation ?? pageRotation\n\n\t\tconst pageTransform = options.initialPageTransform ?? this.getPageTransformById(id)\n\t\tif (!pageTransform) return this\n\n\t\tconst initialBounds = options.initialBounds ?? this.getBoundsById(id)\n\n\t\tif (!initialBounds) return this\n\n\t\tif (!areAnglesCompatible(pageRotation, scaleAxisRotation)) {\n\t\t\t// shape is awkwardly rotated, keep the aspect ratio locked and adopt the scale factor\n\t\t\t// from whichever axis is being scaled the least, to avoid the shape getting bigger\n\t\t\t// than the bounds of the selection\n\t\t\t// const minScale = Math.min(Math.abs(scale.x), Math.abs(scale.y))\n\t\t\treturn this._resizeUnalignedShape(id, scale, {\n\t\t\t\t...options,\n\t\t\t\tinitialBounds,\n\t\t\t\tscaleOrigin,\n\t\t\t\tscaleAxisRotation,\n\t\t\t\tinitialPageTransform: pageTransform,\n\t\t\t\tinitialShape,\n\t\t\t})\n\t\t}\n\n\t\tconst util = this.getShapeUtil(initialShape)\n\n\t\tif (util.isAspectRatioLocked(initialShape)) {\n\t\t\tif (Math.abs(scale.x) > Math.abs(scale.y)) {\n\t\t\t\tscale = new Vec2d(scale.x, Math.sign(scale.y) * Math.abs(scale.x))\n\t\t\t} else {\n\t\t\t\tscale = new Vec2d(Math.sign(scale.x) * Math.abs(scale.y), scale.y)\n\t\t\t}\n\t\t}\n\n\t\tif (util.onResize && util.canResize(initialShape)) {\n\t\t\t// get the model changes from the shape util\n\t\t\tconst newPagePoint = this._scalePagePoint(\n\t\t\t\tMatrix2d.applyToPoint(pageTransform, new Vec2d(0, 0)),\n\t\t\t\tscaleOrigin,\n\t\t\t\tscale,\n\t\t\t\tscaleAxisRotation\n\t\t\t)\n\n\t\t\tconst newLocalPoint = this.getPointInParentSpace(initialShape.id, newPagePoint)\n\n\t\t\t// resize the shape's local bounding box\n\t\t\tconst myScale = new Vec2d(scale.x, scale.y)\n\t\t\t// the shape is aligned with the rest of the shapes in the selection, but may be\n\t\t\t// 90deg offset from the main rotation of the selection, in which case\n\t\t\t// we need to flip the width and height scale factors\n\t\t\tconst areWidthAndHeightAlignedWithCorrectAxis = approximately(\n\t\t\t\t(pageRotation - scaleAxisRotation) % Math.PI,\n\t\t\t\t0\n\t\t\t)\n\t\t\tmyScale.x = areWidthAndHeightAlignedWithCorrectAxis ? scale.x : scale.y\n\t\t\tmyScale.y = areWidthAndHeightAlignedWithCorrectAxis ? scale.y : scale.x\n\n\t\t\t// adjust initial model for situations where the parent has moved during the resize\n\t\t\t// e.g. groups\n\t\t\tconst initialPagePoint = Matrix2d.applyToPoint(pageTransform, new Vec2d())\n\n\t\t\t// need to adjust the shape's x and y points in case the parent has moved since start of resizing\n\t\t\tconst { x, y } = this.getPointInParentSpace(initialShape.id, initialPagePoint)\n\n\t\t\tthis.updateShapes(\n\t\t\t\t[\n\t\t\t\t\t{\n\t\t\t\t\t\tid,\n\t\t\t\t\t\ttype: initialShape.type as any,\n\t\t\t\t\t\tx: newLocalPoint.x,\n\t\t\t\t\t\ty: newLocalPoint.y,\n\t\t\t\t\t\t...util.onResize(\n\t\t\t\t\t\t\t{ ...initialShape, x, y },\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tnewPoint: newLocalPoint,\n\t\t\t\t\t\t\t\thandle: options.dragHandle ?? 'bottom_right',\n\t\t\t\t\t\t\t\t// don't set isSingle to true for children\n\t\t\t\t\t\t\t\tmode: options.mode ?? 'scale_shape',\n\t\t\t\t\t\t\t\tscaleX: myScale.x,\n\t\t\t\t\t\t\t\tscaleY: myScale.y,\n\t\t\t\t\t\t\t\tinitialBounds,\n\t\t\t\t\t\t\t\tinitialShape,\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t),\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\ttrue\n\t\t\t)\n\t\t} else {\n\t\t\tconst initialPageCenter = Matrix2d.applyToPoint(pageTransform, initialBounds.center)\n\t\t\t// get the model changes from the shape util\n\t\t\tconst newPageCenter = this._scalePagePoint(\n\t\t\t\tinitialPageCenter,\n\t\t\t\tscaleOrigin,\n\t\t\t\tscale,\n\t\t\t\tscaleAxisRotation\n\t\t\t)\n\n\t\t\tconst initialPageCenterInParentSpace = this.getPointInParentSpace(\n\t\t\t\tinitialShape.id,\n\t\t\t\tinitialPageCenter\n\t\t\t)\n\t\t\tconst newPageCenterInParentSpace = this.getPointInParentSpace(initialShape.id, newPageCenter)\n\n\t\t\tconst delta = Vec2d.Sub(newPageCenterInParentSpace, initialPageCenterInParentSpace)\n\t\t\t// apply the changes to the model\n\t\t\tthis.updateShapes(\n\t\t\t\t[\n\t\t\t\t\t{\n\t\t\t\t\t\tid,\n\t\t\t\t\t\ttype: initialShape.type as any,\n\t\t\t\t\t\tx: initialShape.x + delta.x,\n\t\t\t\t\t\ty: initialShape.y + delta.y,\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\ttrue\n\t\t\t)\n\t\t}\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Stretch shape sizes and positions to fill their common bounding box.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.stretchShapes('horizontal')\n\t * editor.stretchShapes('horizontal', ['box1', 'box2'])\n\t * ```\n\t *\n\t * @param operation - Whether to stretch shapes horizontally or vertically.\n\t * @param ids - The ids of the shapes to stretch. Defaults to selected shapes.\n\t *\n\t * @public\n\t */\n\tstretchShapes(\n\t\toperation: 'horizontal' | 'vertical',\n\t\tids: TLShapeId[] = this.pageState.selectedIds\n\t) {\n\t\tif (this.isReadOnly) return this\n\t\tif (ids.length < 2) return this\n\n\t\tconst shapes = compact(ids.map((id) => this.getShapeById(id)))\n\t\tconst shapeBounds = Object.fromEntries(shapes.map((shape) => [shape.id, this.getBounds(shape)]))\n\t\tconst shapePageBounds = Object.fromEntries(\n\t\t\tshapes.map((shape) => [shape.id, this.getPageBounds(shape)!])\n\t\t)\n\t\tconst commonBounds = Box2d.Common(compact(Object.values(shapePageBounds)))\n\n\t\tconst changes: TLShapePartial[] = []\n\n\t\tswitch (operation) {\n\t\t\tcase 'vertical': {\n\t\t\t\tthis.batch(() => {\n\t\t\t\t\tfor (const shape of shapes) {\n\t\t\t\t\t\tconst pageRotation = this.getPageRotation(shape)\n\t\t\t\t\t\tif (pageRotation % PI2) continue\n\t\t\t\t\t\tconst bounds = shapeBounds[shape.id]\n\t\t\t\t\t\tconst pageBounds = shapePageBounds[shape.id]\n\t\t\t\t\t\tconst localOffset = this.getDeltaInParentSpace(\n\t\t\t\t\t\t\tshape,\n\t\t\t\t\t\t\tnew Vec2d(0, commonBounds.minY - pageBounds.minY)\n\t\t\t\t\t\t)\n\t\t\t\t\t\tconst { x, y } = Vec2d.Add(localOffset, shape)\n\t\t\t\t\t\tthis.updateShapes([{ id: shape.id, type: shape.type, x, y }], true)\n\t\t\t\t\t\tconst scale = new Vec2d(1, commonBounds.height / pageBounds.height)\n\t\t\t\t\t\tthis.resizeShape(shape.id, scale, {\n\t\t\t\t\t\t\tinitialBounds: bounds,\n\t\t\t\t\t\t\tscaleOrigin: new Vec2d(pageBounds.center.x, commonBounds.minY),\n\t\t\t\t\t\t\tscaleAxisRotation: 0,\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase 'horizontal': {\n\t\t\t\tthis.batch(() => {\n\t\t\t\t\tfor (const shape of shapes) {\n\t\t\t\t\t\tconst bounds = shapeBounds[shape.id]\n\t\t\t\t\t\tconst pageBounds = shapePageBounds[shape.id]\n\t\t\t\t\t\tconst pageRotation = this.getPageRotation(shape)\n\t\t\t\t\t\tif (pageRotation % PI2) continue\n\t\t\t\t\t\tconst localOffset = this.getDeltaInParentSpace(\n\t\t\t\t\t\t\tshape,\n\t\t\t\t\t\t\tnew Vec2d(commonBounds.minX - pageBounds.minX, 0)\n\t\t\t\t\t\t)\n\t\t\t\t\t\tconst { x, y } = Vec2d.Add(localOffset, shape)\n\t\t\t\t\t\tthis.updateShapes([{ id: shape.id, type: shape.type, x, y }], true)\n\t\t\t\t\t\tconst scale = new Vec2d(commonBounds.width / pageBounds.width, 1)\n\t\t\t\t\t\tthis.resizeShape(shape.id, scale, {\n\t\t\t\t\t\t\tinitialBounds: bounds,\n\t\t\t\t\t\t\tscaleOrigin: new Vec2d(commonBounds.minX, pageBounds.center.y),\n\t\t\t\t\t\t\tscaleAxisRotation: 0,\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t})\n\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tthis.updateShapes(changes)\n\t\treturn this\n\t}\n\n\t/**\n\t * An array containing all of the shapes in the current page.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.shapesArray\n\t * ```\n\t *\n\t * @readonly\n\t *\n\t * @public\n\t */\n\t@computed get shapesArray() {\n\t\treturn Array.from(this.currentPageShapeIds, (id) => this.store.get(id)! as TLShape)\n\t}\n\n\t/**\n\t * An array containing all of the shapes in the current page, sorted in z-index order (accounting\n\t * for nested shapes): e.g. A, B, BA, BB, C.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.sortedShapesArray\n\t * ```\n\t *\n\t * @readonly\n\t *\n\t * @public\n\t */\n\t@computed get sortedShapesArray(): TLShape[] {\n\t\tconst shapes = new Set(this.shapesArray.sort(sortByIndex))\n\n\t\tconst results: TLShape[] = []\n\n\t\tfunction pushShapeWithDescendants(shape: TLShape): void {\n\t\t\tresults.push(shape)\n\t\t\tshapes.delete(shape)\n\n\t\t\tshapes.forEach((otherShape) => {\n\t\t\t\tif (otherShape.parentId === shape.id) {\n\t\t\t\t\tpushShapeWithDescendants(otherShape)\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\n\t\tshapes.forEach((shape) => {\n\t\t\tconst parent = this.getShapeById(shape.parentId)\n\t\t\tif (!isShape(parent)) {\n\t\t\t\tpushShapeWithDescendants(shape)\n\t\t\t}\n\t\t})\n\n\t\treturn results\n\t}\n\n\t/**\n\t * An array containing all of the currently selected shapes.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.selectedShapes\n\t * ```\n\t *\n\t * @public\n\t * @readonly\n\t */\n\t@computed get selectedShapes(): TLShape[] {\n\t\tconst { selectedIds } = this.pageState\n\t\treturn compact(selectedIds.map((id) => this.store.get(id)))\n\t}\n\n\t/**\n\t * The app's only selected shape.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.onlySelectedShape\n\t * ```\n\t *\n\t * @returns Null if there is no shape or more than one selected shape, otherwise the selected\n\t *   shape.\n\t *\n\t * @public\n\t * @readonly\n\t */\n\t@computed get onlySelectedShape(): TLShape | null {\n\t\tconst { selectedShapes } = this\n\t\treturn selectedShapes.length === 1 ? selectedShapes[0] : null\n\t}\n\n\t/**\n\t * Get whether a shape matches the type of a TLShapeUtil.\n\t *\n\t * @example\n\t * ```ts\n\t * const isArrowShape = isShapeOfType(someShape, ArrowShapeUtil)\n\t * ```\n\t *\n\t * @param util - the TLShapeUtil constructor to test against\n\t * @param shape - the shape to test\n\t *\n\t * @public\n\t */\n\tisShapeOfType<T extends TLUnknownShape>(\n\t\tshape: TLUnknownShape,\n\t\tutil: { new (...args: any): ShapeUtil<T>; type: string }\n\t): shape is T {\n\t\treturn shape.type === util.type\n\t}\n\n\t/**\n\t * Get a shape by its id.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.getShapeById('box1')\n\t * ```\n\t *\n\t * @param id - The id of the shape to get.\n\t *\n\t * @public\n\t */\n\tgetShapeById<T extends TLShape = TLShape>(id: TLParentId): T | undefined {\n\t\tif (!isShapeId(id)) return undefined\n\t\treturn this.store.get(id) as T\n\t}\n\n\t/**\n\t * Get the parent shape for a given shape. Returns undefined if the shape is the direct child of\n\t * the page.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.getParentShape(myShape)\n\t * ```\n\t *\n\t * @public\n\t */\n\tgetParentShape(shape?: TLShape): TLShape | undefined {\n\t\tif (shape === undefined || !isShapeId(shape.parentId)) return undefined\n\t\treturn this.store.get(shape.parentId)\n\t}\n\n\t/**\n\t * If siblingShape and targetShape are siblings, this returns targetShape. If targetShape has an\n\t * ancestor who is a sibling of siblingShape, this returns that ancestor. Otherwise, this returns\n\t * undefined.\n\t *\n\t * @internal\n\t */\n\tprivate getShapeNearestSibling(\n\t\tsiblingShape: TLShape,\n\t\ttargetShape: TLShape | undefined\n\t): TLShape | undefined {\n\t\tif (!targetShape) {\n\t\t\treturn undefined\n\t\t}\n\t\tif (targetShape.parentId === siblingShape.parentId) {\n\t\t\treturn targetShape\n\t\t}\n\n\t\tconst ancestor = this.findAncestor(\n\t\t\ttargetShape,\n\t\t\t(ancestor) => ancestor.parentId === siblingShape.parentId\n\t\t)\n\n\t\treturn ancestor\n\t}\n\n\t/**\n\t * Get whether the given shape is the descendant of the given page.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.isShapeInPage(myShape)\n\t * editor.isShapeInPage(myShape, 'page1')\n\t * ```\n\t *\n\t * @param shape - The shape to check.\n\t * @param pageId - The id of the page to check against. Defaults to the current page.\n\t *\n\t * @public\n\t */\n\tisShapeInPage(shape: TLShape, pageId = this.currentPageId): boolean {\n\t\tlet shapeIsInPage = false\n\n\t\tif (shape.parentId === pageId) {\n\t\t\tshapeIsInPage = true\n\t\t} else {\n\t\t\tlet parent = this.getShapeById(shape.parentId)\n\t\t\tisInPageSearch: while (parent) {\n\t\t\t\tif (parent.parentId === pageId) {\n\t\t\t\t\tshapeIsInPage = true\n\t\t\t\t\tbreak isInPageSearch\n\t\t\t\t}\n\t\t\t\tparent = this.getShapeById(parent.parentId)\n\t\t\t}\n\t\t}\n\n\t\treturn shapeIsInPage\n\t}\n\n\t/**\n\t * Get the id of the containing page for a given shape.\n\t *\n\t * @param shape - The shape to get the page id for.\n\t *\n\t * @returns The id of the page that contains the shape, or undefined if the shape is undefined.\n\t *\n\t * @public\n\t */\n\tgetAncestorPageId(shape?: TLShape): TLPageId | undefined {\n\t\tif (shape === undefined) return undefined\n\t\tif (isPageId(shape.parentId)) {\n\t\t\treturn shape.parentId\n\t\t} else {\n\t\t\treturn this.getAncestorPageId(this.getShapeById(shape.parentId))\n\t\t}\n\t}\n\n\t// Parents and children\n\n\t/**\n\t * A cache of parents to children.\n\t *\n\t * @internal\n\t */\n\tprivate readonly _parentIdsToChildIds: ReturnType<typeof parentsToChildrenWithIndexes>\n\n\t/**\n\t * Reparent shapes to a new parent. This operation preserves the shape's current page positions /\n\t * rotations.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.reparentShapesById(['box1', 'box2'], 'frame1')\n\t * ```\n\t *\n\t * @param ids - The ids of the shapes to reparent.\n\t * @param parentId - The id of the new parent shape.\n\t * @param insertIndex - The index to insert the children.\n\t *\n\t * @public\n\t */\n\treparentShapesById(ids: TLShapeId[], parentId: TLParentId, insertIndex?: string) {\n\t\tconst changes: TLShapePartial[] = []\n\n\t\tconst parentTransform = isPageId(parentId)\n\t\t\t? Matrix2d.Identity()\n\t\t\t: this.getPageTransformById(parentId)!\n\n\t\tconst parentPageRotation = parentTransform.decompose().rotation\n\n\t\tlet indices: string[] = []\n\n\t\tconst sibs = compact(this.getSortedChildIds(parentId).map((id) => this.getShapeById(id)))\n\n\t\tif (insertIndex) {\n\t\t\tconst sibWithInsertIndex = sibs.find((s) => s.index === insertIndex)\n\t\t\tif (sibWithInsertIndex) {\n\t\t\t\t// If there's a sibling with the same index as the insert index...\n\t\t\t\tconst sibAbove = sibs[sibs.indexOf(sibWithInsertIndex) + 1]\n\t\t\t\tif (sibAbove) {\n\t\t\t\t\t// If the sibling has a sibling above it, insert the shapes\n\t\t\t\t\t// between the sibling and its sibling above it.\n\t\t\t\t\tindices = getIndicesBetween(insertIndex, sibAbove.index, ids.length)\n\t\t\t\t} else {\n\t\t\t\t\t// Or if the sibling is the top sibling, insert the shapes\n\t\t\t\t\t// above the sibling\n\t\t\t\t\tindices = getIndicesAbove(insertIndex, ids.length)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// If there's no collision, then we can start at the insert index\n\t\t\t\tconst sibAbove = sibs.sort(sortByIndex).find((s) => s.index > insertIndex)\n\n\t\t\t\tif (sibAbove) {\n\t\t\t\t\t// If the siblings include a sibling with a higher index, insert the shapes\n\t\t\t\t\t// between the insert index and the sibling with the higher index.\n\t\t\t\t\tindices = getIndicesBetween(insertIndex, sibAbove.index, ids.length)\n\t\t\t\t} else {\n\t\t\t\t\t// Otherwise, we're at the top of the order, so insert the shapes above\n\t\t\t\t\t// the insert index.\n\t\t\t\t\tindices = getIndicesAbove(insertIndex, ids.length)\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// If insert index is not specified, start the index at the top.\n\t\t\tconst sib = sibs.length && sibs[sibs.length - 1]\n\t\t\tindices = sib ? getIndicesAbove(sib.index, ids.length) : getIndices(ids.length)\n\t\t}\n\n\t\tlet id: TLShapeId\n\t\tfor (let i = 0; i < ids.length; i++) {\n\t\t\tid = ids[i]\n\t\t\tconst shape = this.getShapeById(id)\n\t\t\tconst pagePoint = this.getPagePointById(id)\n\n\t\t\tif (!shape || !pagePoint) continue\n\n\t\t\tconst newPoint = Matrix2d.applyToPoint(Matrix2d.Inverse(parentTransform), pagePoint)\n\t\t\tconst newRotation = this.getPageRotation(shape) - parentPageRotation\n\n\t\t\tchanges.push({\n\t\t\t\tid: shape.id,\n\t\t\t\ttype: shape.type,\n\t\t\t\tparentId: parentId,\n\t\t\t\tx: newPoint.x,\n\t\t\t\ty: newPoint.y,\n\t\t\t\trotation: newRotation,\n\t\t\t\tindex: indices[i],\n\t\t\t})\n\t\t}\n\n\t\tthis.updateShapes(changes)\n\t\treturn this\n\t}\n\n\t/**\n\t * Get the index above the highest child of a given parent.\n\t *\n\t * @param parentId - The id of the parent.\n\t *\n\t * @returns The index.\n\t *\n\t * @public\n\t */\n\tgetHighestIndexForParent(parentId: TLShapeId | TLPageId) {\n\t\tconst children = this._parentIdsToChildIds.value[parentId]\n\n\t\tif (!children || children.length === 0) {\n\t\t\treturn 'a1'\n\t\t}\n\t\treturn getIndexAbove(children[children.length - 1][1])\n\t}\n\n\t/**\n\t * A cache of children for each parent.\n\t *\n\t * @internal\n\t */\n\tprivate _childIdsCache = new WeakMapCache<any[], TLShapeId[]>()\n\n\t/**\n\t * Get an array of all the children of a shape.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.getSortedChildIds('frame1')\n\t * ```\n\t *\n\t * @param parentId - The id of the parent shape.\n\t *\n\t * @public\n\t */\n\tgetSortedChildIds(parentId: TLParentId): TLShapeId[] {\n\t\tconst withIndices = this._parentIdsToChildIds.value[parentId]\n\t\tif (!withIndices) return EMPTY_ARRAY\n\t\treturn this._childIdsCache.get(withIndices, () => withIndices.map(([id]) => id))\n\t}\n\n\t/**\n\t * Run a visitor function for all descendants of a shape.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.visitDescendants('frame1', myCallback)\n\t * ```\n\t *\n\t * @param parentId - The id of the parent shape.\n\t * @param visitor - The visitor function.\n\t *\n\t * @public\n\t */\n\tvisitDescendants(parentId: TLParentId, visitor: (id: TLShapeId) => void | false) {\n\t\tconst children = this.getSortedChildIds(parentId)\n\t\tfor (const id of children) {\n\t\t\tif (visitor(id) === false) continue\n\t\t\tthis.visitDescendants(id, visitor)\n\t\t}\n\t}\n\n\t/**\n\t * Get the shape ids of all descendants of the given shapes (including the shapes themselves).\n\t *\n\t * @param ids - The ids of the shapes to get descendants of.\n\t *\n\t * @returns The decscendant ids.\n\t *\n\t * @public\n\t */\n\tgetShapeAndDescendantIds(ids: TLShapeId[]): Set<TLShapeId> {\n\t\tconst idsToInclude = new Set<TLShapeId>()\n\n\t\tconst idsToCheck = [...ids]\n\n\t\twhile (idsToCheck.length > 0) {\n\t\t\tconst id = idsToCheck.pop()\n\t\t\tif (!id) break\n\t\t\tif (idsToInclude.has(id)) continue\n\t\t\tidsToInclude.add(id)\n\t\t\tthis.getSortedChildIds(id).forEach((id) => {\n\t\t\t\tidsToCheck.push(id)\n\t\t\t})\n\t\t}\n\n\t\treturn idsToInclude\n\t}\n\n\t/**\n\t * Get the id of what should be the parent of a new shape at a given point. The parent can be a page or shape.\n\t *\n\t * @param point - The point to find the parent for.\n\t * @param shapeType - The type of shape that will be created.\n\t *\n\t * @returns The id of the parent.\n\t *\n\t * @public\n\t */\n\tgetParentIdForNewShapeAtPoint(point: VecLike, shapeType: TLShape['type']) {\n\t\tconst shapes = this.sortedShapesArray\n\n\t\tfor (let i = shapes.length - 1; i >= 0; i--) {\n\t\t\tconst shape = shapes[i]\n\t\t\tconst util = this.getShapeUtil(shape)\n\t\t\tif (!util.canReceiveNewChildrenOfType(shape, shapeType)) continue\n\t\t\tconst maskedPageBounds = this.getMaskedPageBoundsById(shape.id)\n\t\t\tif (\n\t\t\t\tmaskedPageBounds &&\n\t\t\t\tmaskedPageBounds.containsPoint(point) &&\n\t\t\t\tutil.hitTestPoint(shape, this.getPointInShapeSpace(shape, point))\n\t\t\t) {\n\t\t\t\treturn shape.id\n\t\t\t}\n\t\t}\n\n\t\treturn this.focusLayerId\n\t}\n\n\t/**\n\t * Get the shape that some shapes should be dropped on at a given point.\n\t *\n\t * @param point - The point to find the parent for.\n\t * @param droppingShapes - The shapes that are being dropped.\n\t *\n\t * @returns The shape to drop on.\n\t *\n\t * @public\n\t */\n\tgetDroppingShape(point: VecLike, droppingShapes: TLShape[] = []) {\n\t\tconst shapes = this.sortedShapesArray\n\n\t\tfor (let i = shapes.length - 1; i >= 0; i--) {\n\t\t\tconst shape = shapes[i]\n\t\t\t// don't allow dropping a shape on itself or one of it's children\n\t\t\tif (droppingShapes.find((s) => s.id === shape.id || this.hasAncestor(shape, s.id))) continue\n\t\t\tconst util = this.getShapeUtil(shape)\n\t\t\tif (!util.canDropShapes(shape, droppingShapes)) continue\n\t\t\tconst maskedPageBounds = this.getMaskedPageBoundsById(shape.id)\n\t\t\tif (\n\t\t\t\tmaskedPageBounds &&\n\t\t\t\tmaskedPageBounds.containsPoint(point) &&\n\t\t\t\tutil.hitTestPoint(shape, this.getPointInShapeSpace(shape, point))\n\t\t\t) {\n\t\t\t\treturn shape\n\t\t\t}\n\t\t}\n\n\t\treturn undefined\n\t}\n\n\t/**\n\t * Get the shape that should be selected when you click on a given shape, assuming there is\n\t * nothing already selected. It will not return anything higher than or including the current\n\t * focus layer.\n\t *\n\t * @param shape - The shape to get the outermost selectable shape for.\n\t * @param filter - A function to filter the selectable shapes.\n\t *\n\t * @returns The outermost selectable shape.\n\t *\n\t * @public\n\t */\n\tgetOutermostSelectableShape(shape: TLShape, filter?: (shape: TLShape) => boolean): TLShape {\n\t\tlet match = shape\n\t\tlet node = shape as TLShape | undefined\n\t\twhile (node) {\n\t\t\tif (\n\t\t\t\tthis.isShapeOfType(node, GroupShapeUtil) &&\n\t\t\t\tthis.focusLayerId !== node.id &&\n\t\t\t\t!this.hasAncestor(this.focusLayerShape, node.id) &&\n\t\t\t\t(filter?.(node) ?? true)\n\t\t\t) {\n\t\t\t\tmatch = node\n\t\t\t} else if (this.focusLayerId === node.id) {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tnode = this.getParentShape(node)\n\t\t}\n\n\t\treturn match\n\t}\n\n\t/* -------------------- Commands -------------------- */\n\n\t/**\n\t * Set the current page.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.setCurrentPageId('page1')\n\t * ```\n\t *\n\t * @param pageId - The id of the page to set as the current page.\n\t * @param options - Options for setting the current page.\n\t *\n\t * @public\n\t */\n\tsetCurrentPageId(pageId: TLPageId, { stopFollowing = true }: TLViewportOptions = {}): this {\n\t\tthis._setCurrentPageId(pageId, { stopFollowing })\n\t\treturn this\n\t}\n\n\t/** @internal */\n\tprivate _setCurrentPageId = this.history.createCommand(\n\t\t'setCurrentPage',\n\t\t(pageId: TLPageId, { stopFollowing = true }: TLViewportOptions = {}) => {\n\t\t\tif (!this.store.has(pageId)) {\n\t\t\t\tconsole.error(\"Tried to set the current page id to a page that doesn't exist.\")\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif (stopFollowing && this.instanceState.followingUserId) {\n\t\t\t\tthis.stopFollowingUser()\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tdata: { toId: pageId, fromId: this.currentPageId },\n\t\t\t\tsquashing: true,\n\t\t\t\tpreservesRedoStack: true,\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\tdo: ({ toId }) => {\n\t\t\t\tif (!this.store.has(toId)) {\n\t\t\t\t\t// in multiplayer contexts this page might have been deleted\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif (!this.getPageStateByPageId(toId)) {\n\t\t\t\t\tconst camera = CameraRecordType.create({\n\t\t\t\t\t\tid: CameraRecordType.createId(toId),\n\t\t\t\t\t})\n\t\t\t\t\tthis.store.put([\n\t\t\t\t\t\tcamera,\n\t\t\t\t\t\tInstancePageStateRecordType.create({\n\t\t\t\t\t\t\tid: InstancePageStateRecordType.createId(toId),\n\t\t\t\t\t\t\tpageId: toId,\n\t\t\t\t\t\t}),\n\t\t\t\t\t])\n\t\t\t\t}\n\n\t\t\t\tthis.store.put([{ ...this.instanceState, currentPageId: toId }])\n\n\t\t\t\tthis.updateRenderingBounds()\n\t\t\t},\n\t\t\tundo: ({ fromId }) => {\n\t\t\t\tif (!this.store.has(fromId)) {\n\t\t\t\t\t// in multiplayer contexts this page might have been deleted\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tthis.store.put([{ ...this.instanceState, currentPageId: fromId }])\n\n\t\t\t\tthis.updateRenderingBounds()\n\t\t\t},\n\t\t\tsquash: ({ fromId }, { toId }) => {\n\t\t\t\treturn { toId, fromId }\n\t\t\t},\n\t\t}\n\t)\n\n\t/**\n\t * Update the instance's state.\n\t *\n\t * @param partial - A partial object to update the instance state with.\n\t * @param ephemeral - Whether the change is ephemeral. Ephemeral changes don't get added to the undo/redo stack. Defaults to false.\n\t * @param squashing - Whether the change will be squashed into the existing history entry rather than creating a new one. Defaults to false.\n\t *\n\t * @public\n\t */\n\tupdateInstanceState(\n\t\tpartial: Partial<Omit<TLInstance, 'currentPageId'>>,\n\t\tephemeral = false,\n\t\tsquashing = false\n\t) {\n\t\tthis._updateInstanceState(partial, ephemeral, squashing)\n\t\treturn this\n\t}\n\n\t/** @internal */\n\tprivate _updateInstanceState = this.history.createCommand(\n\t\t'updateTabState',\n\t\t(partial: Partial<Omit<TLInstance, 'currentPageId'>>, ephemeral = false, squashing = false) => {\n\t\t\tconst prev = this.instanceState\n\t\t\tconst next = { ...prev, ...partial }\n\n\t\t\treturn {\n\t\t\t\tdata: { prev, next },\n\t\t\t\tsquashing,\n\t\t\t\tephemeral,\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\tdo: ({ next }) => {\n\t\t\t\tthis.store.put([next])\n\t\t\t},\n\t\t\tundo: ({ prev }) => {\n\t\t\t\tthis.store.put([prev])\n\t\t\t},\n\t\t\tsquash({ prev }, { next }) {\n\t\t\t\treturn { prev, next }\n\t\t\t},\n\t\t}\n\t)\n\n\t/**\n\t * Set the current cursor.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.setCursor({ type: 'default' })\n\t * editor.setCursor({ type: 'default', rotation: Math.PI / 2, color: 'red' })\n\t * ```\n\t *\n\t * @param cursor - A partial of the cursor object.\n\t *\n\t * @public\n\t */\n\tsetCursor(cursor: Partial<TLCursor>): this {\n\t\tconst current = this.cursor\n\t\tconst next = {\n\t\t\t...current,\n\t\t\trotation: 0,\n\t\t\t...cursor,\n\t\t}\n\n\t\tif (\n\t\t\t!(\n\t\t\t\tcurrent.type === next.type &&\n\t\t\t\tcurrent.rotation === next.rotation &&\n\t\t\t\tcurrent.color === next.color\n\t\t\t)\n\t\t) {\n\t\t\tthis.updateInstanceState({ cursor: next }, true)\n\t\t}\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Set the current scribble.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.setScribble(nextScribble)\n\t * editor.setScribble() // clears the scribble\n\t * ```\n\t *\n\t * @param scribble - The new scribble object.\n\t *\n\t * @public\n\t */\n\tsetScribble(scribble: TLScribble | null = null): this {\n\t\tthis.updateInstanceState({ scribble }, true)\n\t\treturn this\n\t}\n\n\t/**\n\t * Set the current brush.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.setBrush({ x: 0, y: 0, w: 100, h: 100 })\n\t * editor.setBrush() // Clears the brush\n\t * ```\n\t *\n\t * @param brush - The brush box model to set, or null for no brush model.\n\t *\n\t * @public\n\t */\n\tsetBrush(brush: Box2dModel | null = null): this {\n\t\tif (!brush && !this.brush) return this\n\t\tthis.updateInstanceState({ brush }, true)\n\t\treturn this\n\t}\n\n\t/**\n\t * Set the current zoom brush.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.setZoomBrush({ x: 0, y: 0, w: 100, h: 100 })\n\t * editor.setZoomBrush() // Clears the zoom\n\t * ```\n\t *\n\t * @param zoomBrush - The zoom box model to set, or null for no zoom model.\n\t *\n\t * @public\n\t */\n\tsetZoomBrush(zoomBrush: Box2dModel | null = null): this {\n\t\tif (!zoomBrush && !this.zoomBrush) return this\n\t\tthis.updateInstanceState({ zoomBrush }, true)\n\t\treturn this\n\t}\n\n\t/**\n\t * Rotate shapes by a delta in radians.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.rotateShapesBy(['box1', 'box2'], Math.PI)\n\t * editor.rotateShapesBy(['box1', 'box2'], Math.PI / 2)\n\t * ```\n\t *\n\t * @param ids - The ids of the shapes to move.\n\t * @param delta - The delta in radians to apply to the selection rotation.\n\t */\n\trotateShapesBy(ids: TLShapeId[], delta: number): this {\n\t\tif (ids.length <= 0) return this\n\n\t\tconst snapshot = getRotationSnapshot({ editor: this })\n\t\tapplyRotationToSnapshotShapes({ delta, snapshot, editor: this, stage: 'one-off' })\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Move shapes by a delta.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.nudgeShapes(['box1', 'box2'], { x: 0, y: 1 })\n\t * editor.nudgeShapes(['box1', 'box2'], { x: 0, y: 1 }, true)\n\t * ```\n\t *\n\t * @param ids - The ids of the shapes to move.\n\t * @param direction - The direction in which to move the shapes.\n\t * @param major - Whether this is a major nudge, e.g. a shift + arrow nudge.\n\t */\n\tnudgeShapes(ids: TLShapeId[], direction: Vec2dModel, major = false, ephemeral = false): this {\n\t\tif (ids.length <= 0) return this\n\n\t\tconst step = this.isGridMode\n\t\t\t? major\n\t\t\t\t? this.gridSize * GRID_INCREMENT\n\t\t\t\t: this.gridSize\n\t\t\t: major\n\t\t\t? MAJOR_NUDGE_FACTOR\n\t\t\t: MINOR_NUDGE_FACTOR\n\n\t\tconst steppedDelta = Vec2d.Mul(direction, step)\n\t\tconst changes: TLShapePartial[] = []\n\n\t\tfor (const id of ids) {\n\t\t\tconst shape = this.getShapeById(id)\n\n\t\t\tif (!shape) {\n\t\t\t\tthrow Error(`Could not find a shape with the id ${id}.`)\n\t\t\t}\n\n\t\t\tconst localDelta = this.getDeltaInParentSpace(shape, steppedDelta)\n\t\t\tconst translateStartChanges = this.getShapeUtil(shape).onTranslateStart?.(shape)\n\n\t\t\tchanges.push(\n\t\t\t\ttranslateStartChanges\n\t\t\t\t\t? {\n\t\t\t\t\t\t\t...translateStartChanges,\n\t\t\t\t\t\t\tx: shape.x + localDelta.x,\n\t\t\t\t\t\t\ty: shape.y + localDelta.y,\n\t\t\t\t\t  }\n\t\t\t\t\t: {\n\t\t\t\t\t\t\tid,\n\t\t\t\t\t\t\tx: shape.x + localDelta.x,\n\t\t\t\t\t\t\ty: shape.y + localDelta.y,\n\t\t\t\t\t\t\ttype: shape.type,\n\t\t\t\t\t  }\n\t\t\t)\n\t\t}\n\n\t\tthis.updateShapes(changes, ephemeral)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Duplicate shapes.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.duplicateShapes()\n\t * editor.duplicateShapes(['id1', 'id2'])\n\t * editor.duplicateShapes(['id1', 'id2'], { x: 8, y: 8 })\n\t * ```\n\t *\n\t * @param ids - The ids of the shapes to duplicate. Defaults to the ids of the selected shapes.\n\t * @param offset - The offset (in pixels) to apply to the duplicated shapes.\n\t *\n\t * @public\n\t */\n\tduplicateShapes(ids: TLShapeId[] = this.selectedIds, offset?: VecLike): this {\n\t\tif (ids.length <= 0) return this\n\n\t\tconst initialIds = new Set(ids)\n\t\tconst idsToCreate: TLShapeId[] = []\n\t\tconst idsToCheck = [...ids]\n\n\t\twhile (idsToCheck.length > 0) {\n\t\t\tconst id = idsToCheck.pop()\n\t\t\tif (!id) break\n\t\t\tidsToCreate.push(id)\n\t\t\tthis.getSortedChildIds(id).forEach((childId) => idsToCheck.push(childId))\n\t\t}\n\n\t\tidsToCreate.reverse()\n\n\t\tconst idsMap = new Map<any, TLShapeId>(idsToCreate.map((id) => [id, createShapeId()]))\n\n\t\tconst shapesToCreate = compact(\n\t\t\tidsToCreate.map((id) => {\n\t\t\t\tconst shape = this.getShapeById(id)\n\n\t\t\t\tif (!shape) {\n\t\t\t\t\treturn null\n\t\t\t\t}\n\n\t\t\t\tconst createId = idsMap.get(id)!\n\n\t\t\t\tlet ox = 0\n\t\t\t\tlet oy = 0\n\n\t\t\t\tif (offset && initialIds.has(id)) {\n\t\t\t\t\tconst parentTransform = this.getParentTransform(shape)\n\t\t\t\t\tconst vec = new Vec2d(offset.x, offset.y).rot(\n\t\t\t\t\t\t-Matrix2d.Decompose(parentTransform).rotation\n\t\t\t\t\t)\n\t\t\t\t\tox = vec.x\n\t\t\t\t\toy = vec.y\n\t\t\t\t}\n\n\t\t\t\tconst parentId = shape.parentId ?? this.currentPageId\n\t\t\t\tconst siblings = this.getSortedChildIds(parentId)\n\t\t\t\tconst currentIndex = siblings.indexOf(shape.id)\n\t\t\t\tconst siblingAboveId = siblings[currentIndex + 1]\n\t\t\t\tconst siblingAbove = siblingAboveId ? this.getShapeById(siblingAboveId) : null\n\n\t\t\t\tconst index = siblingAbove\n\t\t\t\t\t? getIndexBetween(shape.index, siblingAbove.index)\n\t\t\t\t\t: getIndexAbove(shape.index)\n\n\t\t\t\tlet newShape: TLShape = deepCopy(shape)\n\n\t\t\t\tif (\n\t\t\t\t\tthis.isShapeOfType(shape, ArrowShapeUtil) &&\n\t\t\t\t\tthis.isShapeOfType(newShape, ArrowShapeUtil)\n\t\t\t\t) {\n\t\t\t\t\tconst info = this.getShapeUtil(ArrowShapeUtil).getArrowInfo(shape)\n\t\t\t\t\tlet newStartShapeId: TLShapeId | undefined = undefined\n\t\t\t\t\tlet newEndShapeId: TLShapeId | undefined = undefined\n\n\t\t\t\t\tif (shape.props.start.type === 'binding') {\n\t\t\t\t\t\tnewStartShapeId = idsMap.get(shape.props.start.boundShapeId)\n\n\t\t\t\t\t\tif (!newStartShapeId) {\n\t\t\t\t\t\t\tif (info?.isValid) {\n\t\t\t\t\t\t\t\tconst { x, y } = info.start.point\n\t\t\t\t\t\t\t\tnewShape.props.start = {\n\t\t\t\t\t\t\t\t\ttype: 'point',\n\t\t\t\t\t\t\t\t\tx,\n\t\t\t\t\t\t\t\t\ty,\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tconst { start } = getArrowTerminalsInArrowSpace(this, shape)\n\t\t\t\t\t\t\t\tnewShape.props.start = {\n\t\t\t\t\t\t\t\t\ttype: 'point',\n\t\t\t\t\t\t\t\t\tx: start.x,\n\t\t\t\t\t\t\t\t\ty: start.y,\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (shape.props.end.type === 'binding') {\n\t\t\t\t\t\tnewEndShapeId = idsMap.get(shape.props.end.boundShapeId)\n\t\t\t\t\t\tif (!newEndShapeId) {\n\t\t\t\t\t\t\tif (info?.isValid) {\n\t\t\t\t\t\t\t\tconst { x, y } = info.end.point\n\t\t\t\t\t\t\t\tnewShape.props.end = {\n\t\t\t\t\t\t\t\t\ttype: 'point',\n\t\t\t\t\t\t\t\t\tx,\n\t\t\t\t\t\t\t\t\ty,\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tconst { end } = getArrowTerminalsInArrowSpace(this, shape)\n\t\t\t\t\t\t\t\tnewShape.props.start = {\n\t\t\t\t\t\t\t\t\ttype: 'point',\n\t\t\t\t\t\t\t\t\tx: end.x,\n\t\t\t\t\t\t\t\t\ty: end.y,\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tconst infoAfter = getIsArrowStraight(newShape)\n\t\t\t\t\t\t? getStraightArrowInfo(this, newShape)\n\t\t\t\t\t\t: getCurvedArrowInfo(this, newShape)\n\n\t\t\t\t\tif (info?.isValid && infoAfter?.isValid && !getIsArrowStraight(shape)) {\n\t\t\t\t\t\tconst mpA = Vec2d.Med(info.start.handle, info.end.handle)\n\t\t\t\t\t\tconst distA = Vec2d.Dist(info.middle, mpA)\n\t\t\t\t\t\tconst distB = Vec2d.Dist(infoAfter.middle, mpA)\n\t\t\t\t\t\tif (newShape.props.bend < 0) {\n\t\t\t\t\t\t\tnewShape.props.bend += distB - distA\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnewShape.props.bend -= distB - distA\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (newShape.props.start.type === 'binding' && newStartShapeId) {\n\t\t\t\t\t\tnewShape.props.start.boundShapeId = newStartShapeId\n\t\t\t\t\t}\n\n\t\t\t\t\tif (newShape.props.end.type === 'binding' && newEndShapeId) {\n\t\t\t\t\t\tnewShape.props.end.boundShapeId = newEndShapeId\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tnewShape = { ...newShape, id: createId, x: shape.x + ox, y: shape.y + oy, index }\n\n\t\t\t\treturn newShape\n\t\t\t})\n\t\t)\n\n\t\tshapesToCreate.forEach((shape) => {\n\t\t\tif (isShapeId(shape.parentId)) {\n\t\t\t\tif (idsMap.has(shape.parentId)) {\n\t\t\t\t\tshape.parentId = idsMap.get(shape.parentId)!\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\n\t\tthis.history.batch(() => {\n\t\t\tconst maxShapesReached =\n\t\t\t\tshapesToCreate.length + this.currentPageShapeIds.size > MAX_SHAPES_PER_PAGE\n\n\t\t\tif (maxShapesReached) {\n\t\t\t\talertMaxShapes(this)\n\t\t\t}\n\n\t\t\tconst newShapes = maxShapesReached\n\t\t\t\t? shapesToCreate.slice(0, MAX_SHAPES_PER_PAGE - this.currentPageShapeIds.size)\n\t\t\t\t: shapesToCreate\n\n\t\t\tconst ids = newShapes.map((s) => s.id)\n\n\t\t\tthis.createShapes(newShapes)\n\t\t\tthis.setSelectedIds(ids)\n\n\t\t\tif (offset !== undefined) {\n\t\t\t\t// If we've offset the duplicated shapes, check to see whether their new bounds is entirely\n\t\t\t\t// contained in the current viewport. If not, then animate the camera to be centered on the\n\t\t\t\t// new shapes.\n\t\t\t\tconst { viewportPageBounds, selectedPageBounds } = this\n\t\t\t\tif (selectedPageBounds && !viewportPageBounds.contains(selectedPageBounds)) {\n\t\t\t\t\tthis.centerOnPoint(selectedPageBounds.center.x, selectedPageBounds.center.y, {\n\t\t\t\t\t\tduration: ANIMATION_MEDIUM_MS,\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Set the current opacity. This will effect any selected shapes, or the\n\t * next-created shape.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.setOpacity(0.5)\n\t * editor.setOpacity(0.5, true)\n\t * ```\n\t *\n\t * @param opacity - The opacity to set. Must be a number between 0 and 1 inclusive.\n\t * @param ephemeral - Whether the opacity change is ephemeral. Ephemeral changes don't get added to the undo/redo stack. Defaults to false.\n\t * @param squashing - Whether the opacity change will be squashed into the existing history entry rather than creating a new one. Defaults to false.\n\t */\n\tsetOpacity(opacity: number, ephemeral = false, squashing = false): this {\n\t\tthis.history.batch(() => {\n\t\t\tif (this.isIn('select')) {\n\t\t\t\tconst {\n\t\t\t\t\tpageState: { selectedIds },\n\t\t\t\t} = this\n\n\t\t\t\tconst shapesToUpdate: TLShape[] = []\n\n\t\t\t\t// We can have many deep levels of grouped shape\n\t\t\t\t// Making a recursive function to look through all the levels\n\t\t\t\tconst addShapeById = (id: TLShape['id']) => {\n\t\t\t\t\tconst shape = this.getShapeById(id)\n\t\t\t\t\tif (!shape) return\n\t\t\t\t\tif (this.isShapeOfType(shape, GroupShapeUtil)) {\n\t\t\t\t\t\tconst childIds = this.getSortedChildIds(id)\n\t\t\t\t\t\tfor (const childId of childIds) {\n\t\t\t\t\t\t\taddShapeById(childId)\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tshapesToUpdate.push(shape)\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (selectedIds.length > 0) {\n\t\t\t\t\tfor (const id of selectedIds) {\n\t\t\t\t\t\taddShapeById(id)\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.updateShapes(\n\t\t\t\t\t\tshapesToUpdate.map((shape) => {\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tid: shape.id,\n\t\t\t\t\t\t\t\ttype: shape.type,\n\t\t\t\t\t\t\t\topacity,\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tephemeral\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.updateInstanceState({ opacityForNextShape: opacity }, ephemeral, squashing)\n\t\t})\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Set the current styles\n\t *\n\t * @example\n\t * ```ts\n\t * editor.setProp(DefaultColorStyle, 'red')\n\t * editor.setProp(DefaultColorStyle, 'red', true)\n\t * ```\n\t *\n\t * @param style - The style to set.\n\t * @param value - The value to set.\n\t * @param ephemeral - Whether the style change is ephemeral. Ephemeral changes don't get added to the undo/redo stack. Defaults to false.\n\t * @param squashing - Whether the style change will be squashed into the existing history entry rather than creating a new one. Defaults to false.\n\t *\n\t * @public\n\t */\n\tsetStyle<T>(style: StyleProp<T>, value: T, ephemeral = false, squashing = false): this {\n\t\tthis.history.batch(() => {\n\t\t\tif (this.isIn('select')) {\n\t\t\t\tconst {\n\t\t\t\t\tpageState: { selectedIds },\n\t\t\t\t} = this\n\n\t\t\t\tif (selectedIds.length > 0) {\n\t\t\t\t\tconst updates: { originalShape: TLShape; updatePartial: TLShapePartial }[] = []\n\n\t\t\t\t\t// We can have many deep levels of grouped shape\n\t\t\t\t\t// Making a recursive function to look through all the levels\n\t\t\t\t\tconst addShapeById = (id: TLShape['id']) => {\n\t\t\t\t\t\tconst shape = this.getShapeById(id)\n\t\t\t\t\t\tif (!shape) return\n\t\t\t\t\t\tif (this.isShapeOfType(shape, GroupShapeUtil)) {\n\t\t\t\t\t\t\tconst childIds = this.getSortedChildIds(id)\n\t\t\t\t\t\t\tfor (const childId of childIds) {\n\t\t\t\t\t\t\t\taddShapeById(childId)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst util = this.getShapeUtil(shape)\n\t\t\t\t\t\t\tif (util.hasStyle(style)) {\n\t\t\t\t\t\t\t\tconst shapePartial: TLShapePartial = {\n\t\t\t\t\t\t\t\t\tid: shape.id,\n\t\t\t\t\t\t\t\t\ttype: shape.type,\n\t\t\t\t\t\t\t\t\tprops: {},\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tupdates.push({\n\t\t\t\t\t\t\t\t\toriginalShape: shape,\n\t\t\t\t\t\t\t\t\tupdatePartial: util.setStyleInPartial(style, shapePartial, value),\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (const id of selectedIds) {\n\t\t\t\t\t\taddShapeById(id)\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.updateShapes(\n\t\t\t\t\t\tupdates.map(({ updatePartial }) => updatePartial),\n\t\t\t\t\t\tephemeral\n\t\t\t\t\t)\n\n\t\t\t\t\t// TODO: find a way to sink this stuff into shape utils directly?\n\t\t\t\t\tconst changes: TLShapePartial[] = []\n\t\t\t\t\tfor (const { originalShape: originalShape } of updates) {\n\t\t\t\t\t\tconst currentShape = this.getShapeById(originalShape.id)\n\t\t\t\t\t\tif (!currentShape) continue\n\t\t\t\t\t\tconst util = this.getShapeUtil(currentShape)\n\n\t\t\t\t\t\tconst boundsA = util.bounds(originalShape)\n\t\t\t\t\t\tconst boundsB = util.bounds(currentShape)\n\n\t\t\t\t\t\tconst change: TLShapePartial = { id: originalShape.id, type: originalShape.type }\n\n\t\t\t\t\t\tlet didChange = false\n\n\t\t\t\t\t\tif (boundsA.width !== boundsB.width) {\n\t\t\t\t\t\t\tdidChange = true\n\n\t\t\t\t\t\t\tif (this.isShapeOfType(originalShape, TextShapeUtil)) {\n\t\t\t\t\t\t\t\tswitch (originalShape.props.align) {\n\t\t\t\t\t\t\t\t\tcase 'middle': {\n\t\t\t\t\t\t\t\t\t\tchange.x = currentShape.x + (boundsA.width - boundsB.width) / 2\n\t\t\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tcase 'end': {\n\t\t\t\t\t\t\t\t\t\tchange.x = currentShape.x + boundsA.width - boundsB.width\n\t\t\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tchange.x = currentShape.x + (boundsA.width - boundsB.width) / 2\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (boundsA.height !== boundsB.height) {\n\t\t\t\t\t\t\tdidChange = true\n\t\t\t\t\t\t\tchange.y = currentShape.y + (boundsA.height - boundsB.height) / 2\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (didChange) {\n\t\t\t\t\t\t\tchanges.push(change)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (changes.length) {\n\t\t\t\t\t\tthis.updateShapes(changes, ephemeral)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.updateInstanceState(\n\t\t\t\t{\n\t\t\t\t\tstylesForNextShape: { ...this._stylesForNextShape, [style.id]: value },\n\t\t\t\t},\n\t\t\t\tephemeral,\n\t\t\t\tsquashing\n\t\t\t)\n\t\t})\n\n\t\treturn this\n\t}\n\n\t/** @internal */\n\tprivate _willSetInitialBounds = true\n\n\t/** @internal */\n\tprivate _setCamera(x: number, y: number, z = this.camera.z): this {\n\t\tconst currentCamera = this.camera\n\t\tif (currentCamera.x === x && currentCamera.y === y && currentCamera.z === z) return this\n\t\tconst nextCamera = { ...currentCamera, x, y, z }\n\n\t\tthis.batch(() => {\n\t\t\tthis.store.put([nextCamera])\n\n\t\t\tconst { currentScreenPoint } = this.inputs\n\n\t\t\tthis.dispatch({\n\t\t\t\ttype: 'pointer',\n\t\t\t\ttarget: 'canvas',\n\t\t\t\tname: 'pointer_move',\n\t\t\t\tpoint: currentScreenPoint,\n\t\t\t\tpointerId: INTERNAL_POINTER_IDS.CAMERA_MOVE,\n\t\t\t\tctrlKey: this.inputs.ctrlKey,\n\t\t\t\taltKey: this.inputs.altKey,\n\t\t\t\tshiftKey: this.inputs.shiftKey,\n\t\t\t\tbutton: 0,\n\t\t\t\tisPen: this.isPenMode ?? false,\n\t\t\t})\n\n\t\t\tthis._tickCameraState()\n\t\t})\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Set the current camera.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.setCamera(0, 0)\n\t * editor.setCamera(0, 0, 1)\n\t * ```\n\t *\n\t * @param x - The camera's x position.\n\t * @param y - The camera's y position.\n\t * @param z - The camera's z position. Defaults to the current zoom.\n\t * @param options - Options for the camera change.\n\t *\n\t * @public\n\t */\n\tsetCamera(\n\t\tx: number,\n\t\ty: number,\n\t\tz = this.camera.z,\n\t\t{ stopFollowing = true }: TLViewportOptions = {}\n\t): this {\n\t\tthis.stopCameraAnimation()\n\t\tif (stopFollowing && this.instanceState.followingUserId) {\n\t\t\tthis.stopFollowingUser()\n\t\t}\n\t\tx = Number.isNaN(x) ? 0 : x\n\t\ty = Number.isNaN(y) ? 0 : y\n\t\tz = Number.isNaN(z) ? 1 : z\n\t\tthis._setCamera(x, y, z)\n\t\treturn this\n\t}\n\n\t/**\n\t * Animate the camera.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.animateCamera(0, 0)\n\t * editor.animateCamera(0, 0, 1)\n\t * editor.animateCamera(0, 0, 1, { duration: 1000, easing: (t) => t * t })\n\t * ```\n\t *\n\t * @param x - The camera's x position.\n\t * @param y - The camera's y position.\n\t * @param z - The camera's z position. Defaults to the current zoom.\n\t * @param opts - Options for the animation.\n\t *\n\t * @public\n\t */\n\tanimateCamera(\n\t\tx: number,\n\t\ty: number,\n\t\tz = this.camera.z,\n\t\topts: TLAnimationOptions = DEFAULT_ANIMATION_OPTIONS\n\t): this {\n\t\tx = Number.isNaN(x) ? 0 : x\n\t\ty = Number.isNaN(y) ? 0 : y\n\t\tz = Number.isNaN(z) ? 1 : z\n\t\tconst { width, height } = this.viewportScreenBounds\n\t\tconst w = width / z\n\t\tconst h = height / z\n\n\t\tconst targetViewport = new Box2d(-x, -y, w, h)\n\n\t\treturn this._animateToViewport(targetViewport, opts)\n\t}\n\n\t/**\n\t * Center the camera on a point (in page space).\n\t *\n\t * @example\n\t * ```ts\n\t * editor.centerOnPoint(100, 100)\n\t * ```\n\t *\n\t * @param x - The x position of the point.\n\t * @param y - The y position of the point.\n\t * @param opts - The options for an animation.\n\t *\n\t * @public\n\t */\n\tcenterOnPoint(x: number, y: number, opts?: TLAnimationOptions): this {\n\t\tif (!this.canMoveCamera) return this\n\n\t\tconst {\n\t\t\tviewportPageBounds: { width: pw, height: ph },\n\t\t\tcamera,\n\t\t} = this\n\n\t\tif (opts?.duration) {\n\t\t\tthis.animateCamera(-(x - pw / 2), -(y - ph / 2), camera.z, opts)\n\t\t} else {\n\t\t\tthis.setCamera(-(x - pw / 2), -(y - ph / 2), camera.z)\n\t\t}\n\t\treturn this\n\t}\n\n\t/**\n\t * Move the camera to the nearest content.\n\t *\n\t * @public\n\t */\n\tzoomToContent() {\n\t\tconst bounds = this.selectedPageBounds ?? this.allShapesCommonBounds\n\n\t\tif (bounds) {\n\t\t\tthis.zoomToBounds(\n\t\t\t\tbounds.minX,\n\t\t\t\tbounds.minY,\n\t\t\t\tbounds.width,\n\t\t\t\tbounds.height,\n\t\t\t\tMath.min(1, this.zoomLevel),\n\t\t\t\t{ duration: 220 }\n\t\t\t)\n\t\t}\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Zoom the camera to fit the current page's content in the viewport.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.zoomToFit()\n\t * ```\n\t *\n\t * @public\n\t */\n\tzoomToFit(opts?: TLAnimationOptions): this {\n\t\tif (!this.canMoveCamera) return this\n\n\t\tconst ids = [...this.currentPageShapeIds]\n\t\tif (ids.length <= 0) return this\n\n\t\tconst pageBounds = Box2d.Common(compact(ids.map((id) => this.getPageBoundsById(id))))\n\t\tthis.zoomToBounds(\n\t\t\tpageBounds.minX,\n\t\t\tpageBounds.minY,\n\t\t\tpageBounds.width,\n\t\t\tpageBounds.height,\n\t\t\tundefined,\n\t\t\topts\n\t\t)\n\t\treturn this\n\t}\n\n\t/**\n\t * Set the zoom back to 100%.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.resetZoom()\n\t * ```\n\t *\n\t * @param opts - The options for an animation.\n\t *\n\t * @public\n\t */\n\tresetZoom(point = this.viewportScreenCenter, opts?: TLAnimationOptions): this {\n\t\tif (!this.canMoveCamera) return this\n\n\t\tconst { x: cx, y: cy, z: cz } = this.camera\n\t\tconst { x, y } = point\n\t\tif (opts?.duration) {\n\t\t\tthis.animateCamera(cx + (x / 1 - x) - (x / cz - x), cy + (y / 1 - y) - (y / cz - y), 1, opts)\n\t\t} else {\n\t\t\tthis.setCamera(cx + (x / 1 - x) - (x / cz - x), cy + (y / 1 - y) - (y / cz - y), 1)\n\t\t}\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Zoom the camera in.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.zoomIn()\n\t * editor.zoomIn(editor.viewportScreenCenter, { duration: 120 })\n\t * editor.zoomIn(editor.inputs.currentScreenPoint, { duration: 120 })\n\t * ```\n\t *\n\t * @param opts - The options for an animation.\n\t *\n\t * @public\n\t */\n\tzoomIn(point = this.viewportScreenCenter, opts?: TLAnimationOptions): this {\n\t\tif (!this.canMoveCamera) return this\n\n\t\tconst { x: cx, y: cy, z: cz } = this.camera\n\n\t\tlet zoom = MAX_ZOOM\n\n\t\tfor (let i = 1; i < ZOOMS.length; i++) {\n\t\t\tconst z1 = ZOOMS[i - 1]\n\t\t\tconst z2 = ZOOMS[i]\n\t\t\tif (z2 - cz <= (z2 - z1) / 2) continue\n\t\t\tzoom = z2\n\t\t\tbreak\n\t\t}\n\n\t\tconst { x, y } = point\n\t\tif (opts?.duration) {\n\t\t\tthis.animateCamera(\n\t\t\t\tcx + (x / zoom - x) - (x / cz - x),\n\t\t\t\tcy + (y / zoom - y) - (y / cz - y),\n\t\t\t\tzoom,\n\t\t\t\topts\n\t\t\t)\n\t\t} else {\n\t\t\tthis.setCamera(cx + (x / zoom - x) - (x / cz - x), cy + (y / zoom - y) - (y / cz - y), zoom)\n\t\t}\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Zoom the camera out.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.zoomOut()\n\t * editor.zoomOut(editor.viewportScreenCenter, { duration: 120 })\n\t * editor.zoomOut(editor.inputs.currentScreenPoint, { duration: 120 })\n\t * ```\n\t *\n\t * @param opts - The options for an animation.\n\t *\n\t * @public\n\t */\n\tzoomOut(point = this.viewportScreenCenter, opts?: TLAnimationOptions): this {\n\t\tif (!this.canMoveCamera) return this\n\n\t\tconst { x: cx, y: cy, z: cz } = this.camera\n\n\t\tlet zoom = MIN_ZOOM\n\n\t\tfor (let i = ZOOMS.length - 1; i > 0; i--) {\n\t\t\tconst z1 = ZOOMS[i - 1]\n\t\t\tconst z2 = ZOOMS[i]\n\t\t\tif (z2 - cz >= (z2 - z1) / 2) continue\n\t\t\tzoom = z1\n\t\t\tbreak\n\t\t}\n\n\t\tconst { x, y } = point\n\n\t\tif (opts?.duration) {\n\t\t\tthis.animateCamera(\n\t\t\t\tcx + (x / zoom - x) - (x / cz - x),\n\t\t\t\tcy + (y / zoom - y) - (y / cz - y),\n\t\t\t\tzoom,\n\t\t\t\topts\n\t\t\t)\n\t\t} else {\n\t\t\tthis.setCamera(cx + (x / zoom - x) - (x / cz - x), cy + (y / zoom - y) - (y / cz - y), zoom)\n\t\t}\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Zoom the camera to fit the current selection in the viewport.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.zoomToSelection()\n\t * ```\n\t *\n\t * @param opts - The options for an animation.\n\t *\n\t * @public\n\t */\n\tzoomToSelection(opts?: TLAnimationOptions): this {\n\t\tif (!this.canMoveCamera) return this\n\n\t\tconst ids = this.selectedIds\n\t\tif (ids.length <= 0) return this\n\n\t\tconst selectedBounds = Box2d.Common(compact(ids.map((id) => this.getPageBoundsById(id))))\n\n\t\tthis.zoomToBounds(\n\t\t\tselectedBounds.minX,\n\t\t\tselectedBounds.minY,\n\t\t\tselectedBounds.width,\n\t\t\tselectedBounds.height,\n\t\t\tMath.max(1, this.camera.z),\n\t\t\topts\n\t\t)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Pan or pan/zoom the selected ids into view. This method tries to not change the zoom if possible.\n\t *\n\t * @param ids - The ids of the shapes to pan and zoom into view.\n\t * @param opts - The options for an animation.\n\t *\n\t * @public\n\t */\n\tpanZoomIntoView(ids: TLShapeId[], opts?: TLAnimationOptions): this {\n\t\tif (!this.canMoveCamera) return this\n\n\t\tif (ids.length <= 0) return this\n\t\tconst selectedBounds = Box2d.Common(compact(ids.map((id) => this.getPageBoundsById(id))))\n\n\t\tconst { viewportPageBounds } = this\n\n\t\tif (viewportPageBounds.h < selectedBounds.h || viewportPageBounds.w < selectedBounds.w) {\n\t\t\tthis.zoomToBounds(\n\t\t\t\tselectedBounds.minX,\n\t\t\t\tselectedBounds.minY,\n\t\t\t\tselectedBounds.width,\n\t\t\t\tselectedBounds.height,\n\t\t\t\tthis.camera.z,\n\t\t\t\topts\n\t\t\t)\n\n\t\t\treturn this\n\t\t} else {\n\t\t\t// TODO: This buffer should calculate the 'active area' of the UI\n\t\t\tconst bufferOffsets = this._activeAreaManager.offsets.value\n\n\t\t\tconst pageTop = viewportPageBounds.y + bufferOffsets.top\n\t\t\tconst pageRight = viewportPageBounds.maxY - bufferOffsets.right\n\t\t\tconst pageBottom = viewportPageBounds.maxY - bufferOffsets.bottom\n\t\t\tconst pageLeft = viewportPageBounds.x + bufferOffsets.left\n\n\t\t\tconst selectedTop = selectedBounds.y\n\t\t\tconst selectedRight = selectedBounds.maxX\n\t\t\tconst selectedBottom = selectedBounds.maxY\n\t\t\tconst selectedLeft = selectedBounds.x\n\n\t\t\tlet offsetX = 0\n\t\t\tlet offsetY = 0\n\t\t\tif (pageBottom < selectedBottom) {\n\t\t\t\t// off bottom\n\t\t\t\toffsetY = pageBottom - selectedBottom\n\t\t\t} else if (pageTop > selectedTop) {\n\t\t\t\t// off top\n\t\t\t\toffsetY = pageTop - selectedTop\n\t\t\t} else {\n\t\t\t\t// inside y-bounds\n\t\t\t}\n\n\t\t\tif (pageRight < selectedRight) {\n\t\t\t\t// off right\n\t\t\t\toffsetX = pageRight - selectedRight\n\t\t\t} else if (pageLeft > selectedLeft) {\n\t\t\t\t// off left\n\t\t\t\toffsetX = pageLeft - selectedLeft\n\t\t\t} else {\n\t\t\t\t// inside x-bounds\n\t\t\t}\n\n\t\t\tconst { camera } = this\n\n\t\t\tif (opts?.duration) {\n\t\t\t\tthis.animateCamera(camera.x + offsetX, camera.y + offsetY, camera.z, opts)\n\t\t\t} else {\n\t\t\t\tthis.setCamera(camera.x + offsetX, camera.y + offsetY, camera.z)\n\t\t\t}\n\t\t}\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Zoom the camera to fit a bounding box (in page space).\n\t *\n\t * @example\n\t * ```ts\n\t * editor.zoomToBounds(0, 0, 100, 100)\n\t * ```\n\t *\n\t * @param x - The bounding box's x position.\n\t * @param y - The bounding box's y position.\n\t * @param width - The bounding box's width.\n\t * @param height - The bounding box's height.\n\t * @param targetZoom - The desired zoom level. Defaults to 0.1.\n\t *\n\t * @public\n\t */\n\tzoomToBounds(\n\t\tx: number,\n\t\ty: number,\n\t\twidth: number,\n\t\theight: number,\n\t\ttargetZoom?: number,\n\t\topts?: TLAnimationOptions\n\t): this {\n\t\tif (!this.canMoveCamera) return this\n\n\t\tconst { viewportScreenBounds } = this\n\n\t\tconst inset = Math.min(256, viewportScreenBounds.width * 0.28)\n\n\t\tlet zoom = clamp(\n\t\t\tMath.min(\n\t\t\t\t(viewportScreenBounds.width - inset) / width,\n\t\t\t\t(viewportScreenBounds.height - inset) / height\n\t\t\t),\n\t\t\tMIN_ZOOM,\n\t\t\tMAX_ZOOM\n\t\t)\n\n\t\tif (targetZoom !== undefined) {\n\t\t\tzoom = Math.min(targetZoom, zoom)\n\t\t}\n\n\t\tif (opts?.duration) {\n\t\t\tthis.animateCamera(\n\t\t\t\t-x + (viewportScreenBounds.width - width * zoom) / 2 / zoom,\n\t\t\t\t-y + (viewportScreenBounds.height - height * zoom) / 2 / zoom,\n\t\t\t\tzoom,\n\t\t\t\topts\n\t\t\t)\n\t\t} else {\n\t\t\tthis.setCamera(\n\t\t\t\t-x + (viewportScreenBounds.width - width * zoom) / 2 / zoom,\n\t\t\t\t-y + (viewportScreenBounds.height - height * zoom) / 2 / zoom,\n\t\t\t\tzoom\n\t\t\t)\n\t\t}\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Pan the camera.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.pan(100, 100)\n\t * editor.pan(100, 100, { duration: 1000 })\n\t * ```\n\t *\n\t * @param dx - The amount to pan on the x axis.\n\t * @param dy - The amount to pan on the y axis.\n\t * @param opts - The animation options\n\t */\n\tpan(dx: number, dy: number, opts?: TLAnimationOptions): this {\n\t\tif (!this.canMoveCamera) return this\n\n\t\tconst { camera } = this\n\t\tconst { x: cx, y: cy, z: cz } = camera\n\t\tconst d = new Vec2d(dx, dy).div(cz)\n\n\t\tif (opts?.duration ?? 0 > 0) {\n\t\t\treturn this.animateCamera(cx + d.x, cy + d.y, cz, opts)\n\t\t} else {\n\t\t\tthis.setCamera(cx + d.x, cy + d.y, cz)\n\t\t}\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Stop the current camera animation, if any.\n\t *\n\t * @public\n\t */\n\tstopCameraAnimation() {\n\t\tthis.emit('stop-camera-animation')\n\n\t\treturn this\n\t}\n\n\t/** @internal */\n\tprivate _viewportAnimation = null as null | {\n\t\telapsed: number\n\t\tduration: number\n\t\teasing: (t: number) => number\n\t\tstart: Box2d\n\t\tend: Box2d\n\t}\n\n\t/** @internal */\n\tprivate _animateViewport(ms: number) {\n\t\tif (!this._viewportAnimation) return\n\n\t\tconst cancel = () => {\n\t\t\tthis.removeListener('tick', this._animateViewport)\n\t\t\tthis.removeListener('stop-camera-animation', cancel)\n\t\t\tthis._viewportAnimation = null\n\t\t}\n\n\t\tthis.once('stop-camera-animation', cancel)\n\n\t\tthis._viewportAnimation.elapsed += ms\n\n\t\tconst { elapsed, easing, duration, start, end } = this._viewportAnimation\n\n\t\tif (elapsed > duration) {\n\t\t\tconst z = this.viewportScreenBounds.width / end.width\n\t\t\tconst x = -end.x\n\t\t\tconst y = -end.y\n\n\t\t\tthis._setCamera(x, y, z)\n\t\t\tcancel()\n\t\t\treturn\n\t\t}\n\n\t\tconst remaining = duration - elapsed\n\t\tconst t = easing(1 - remaining / duration)\n\n\t\tconst left = start.minX + (end.minX - start.minX) * t\n\t\tconst top = start.minY + (end.minY - start.minY) * t\n\t\tconst right = start.maxX + (end.maxX - start.maxX) * t\n\t\tconst bottom = start.maxY + (end.maxY - start.maxY) * t\n\n\t\tconst easedViewport = new Box2d(left, top, right - left, bottom - top)\n\n\t\tconst z = this.viewportScreenBounds.width / easedViewport.width\n\t\tconst x = -easedViewport.x\n\t\tconst y = -easedViewport.y\n\n\t\tthis._setCamera(x, y, z)\n\t}\n\n\t/** @internal */\n\tprivate _animateToViewport(targetViewportPage: Box2d, opts = {} as TLAnimationOptions) {\n\t\tconst { duration = 0, easing = EASINGS.easeInOutCubic } = opts\n\t\tconst { animationSpeed, viewportPageBounds } = this\n\n\t\t// If we have an existing animation, then stop it; also stop following any user\n\t\tthis.stopCameraAnimation()\n\t\tif (this.instanceState.followingUserId) {\n\t\t\tthis.stopFollowingUser()\n\t\t}\n\n\t\tif (duration === 0 || animationSpeed === 0) {\n\t\t\t// If we have no animation, then skip the animation and just set the camera\n\t\t\treturn this._setCamera(\n\t\t\t\t-targetViewportPage.x,\n\t\t\t\t-targetViewportPage.y,\n\t\t\t\tthis.viewportScreenBounds.width / targetViewportPage.width\n\t\t\t)\n\t\t}\n\n\t\t// Set our viewport animation\n\t\tthis._viewportAnimation = {\n\t\t\telapsed: 0,\n\t\t\tduration: duration / animationSpeed,\n\t\t\teasing,\n\t\t\tstart: viewportPageBounds.clone(),\n\t\t\tend: targetViewportPage,\n\t\t}\n\n\t\t// On each tick, animate the viewport\n\t\tthis.addListener('tick', this._animateViewport)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Slide the camera in a certain direction.\n\t *\n\t * @param opts - Options for the slide\n\t * @public\n\t */\n\tslideCamera(\n\t\topts = {} as {\n\t\t\tspeed: number\n\t\t\tdirection: Vec2d\n\t\t\tfriction: number\n\t\t\tspeedThreshold?: number\n\t\t}\n\t) {\n\t\tif (!this.canMoveCamera) return this\n\n\t\tthis.stopCameraAnimation()\n\n\t\tconst { animationSpeed } = this\n\n\t\tif (animationSpeed === 0) return\n\n\t\tconst { speed, friction, direction, speedThreshold = 0.01 } = opts\n\t\tlet currentSpeed = Math.min(speed, 1)\n\n\t\tconst cancel = () => {\n\t\t\tthis.removeListener('tick', moveCamera)\n\t\t\tthis.removeListener('stop-camera-animation', cancel)\n\t\t}\n\n\t\tthis.once('stop-camera-animation', cancel)\n\n\t\tconst moveCamera = (elapsed: number) => {\n\t\t\tconst { x: cx, y: cy, z: cz } = this.camera\n\t\t\tconst movementVec = direction.clone().mul((currentSpeed * elapsed) / cz)\n\n\t\t\t// Apply friction\n\t\t\tcurrentSpeed *= 1 - friction\n\t\t\tif (currentSpeed < speedThreshold) {\n\t\t\t\tcancel()\n\t\t\t} else {\n\t\t\t\tthis._setCamera(cx + movementVec.x, cy + movementVec.y, cz)\n\t\t\t}\n\t\t}\n\n\t\tthis.addListener('tick', moveCamera)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Animate the camera to a user's cursor position.\n\t * This also briefly show the user's cursor if it's not currently visible.\n\t *\n\t * @param userId - The id of the user to aniamte to.\n\t * @public\n\t */\n\tanimateToUser(userId: string) {\n\t\tconst presences = this.store.query.records('instance_presence', () => ({\n\t\t\tuserId: { eq: userId },\n\t\t}))\n\n\t\tconst presence = [...presences.value]\n\t\t\t.sort((a, b) => {\n\t\t\t\treturn a.lastActivityTimestamp - b.lastActivityTimestamp\n\t\t\t})\n\t\t\t.pop()\n\n\t\tif (!presence) return\n\n\t\tthis.batch(() => {\n\t\t\t// If we're following someone, stop following them\n\t\t\tif (this.instanceState.followingUserId !== null) {\n\t\t\t\tthis.stopFollowingUser()\n\t\t\t}\n\n\t\t\t// If we're not on the same page, move to the page they're on\n\t\t\tconst isOnSamePage = presence.currentPageId === this.currentPageId\n\t\t\tif (!isOnSamePage) {\n\t\t\t\tthis.setCurrentPageId(presence.currentPageId)\n\t\t\t}\n\n\t\t\t// Only animate the camera if the user is on the same page as us\n\t\t\tconst options = isOnSamePage ? { duration: 500 } : undefined\n\n\t\t\tconst position = presence.cursor\n\n\t\t\tthis.centerOnPoint(position.x, position.y, options)\n\n\t\t\t// Highlight the user's cursor\n\t\t\tconst { highlightedUserIds } = this.instanceState\n\t\t\tthis.updateInstanceState({ highlightedUserIds: [...highlightedUserIds, userId] })\n\n\t\t\t// Unhighlight the user's cursor after a few seconds\n\t\t\tsetTimeout(() => {\n\t\t\t\tconst highlightedUserIds = [...this.instanceState.highlightedUserIds]\n\t\t\t\tconst index = highlightedUserIds.indexOf(userId)\n\t\t\t\tif (index < 0) return\n\t\t\t\thighlightedUserIds.splice(index, 1)\n\t\t\t\tthis.updateInstanceState({ highlightedUserIds })\n\t\t\t}, COLLABORATOR_TIMEOUT)\n\t\t})\n\t}\n\n\t/**\n\t * Start viewport-following a user.\n\t *\n\t * @param userId - The id of the user to follow.\n\t *\n\t * @public\n\t */\n\tstartFollowingUser(userId: string) {\n\t\tconst leaderPresences = this.store.query.records('instance_presence', () => ({\n\t\t\tuserId: { eq: userId },\n\t\t}))\n\n\t\tconst thisUserId = this.user.id\n\n\t\tif (!thisUserId) {\n\t\t\tconsole.warn('You should set the userId for the current instance before following a user')\n\t\t}\n\n\t\t// If the leader is following us, then we can't follow them\n\t\tif (leaderPresences.value.some((p) => p.followingUserId === thisUserId)) {\n\t\t\treturn\n\t\t}\n\n\t\ttransact(() => {\n\t\t\tthis.stopFollowingUser()\n\n\t\t\tthis.updateInstanceState({ followingUserId: userId }, true)\n\t\t})\n\n\t\tconst cancel = () => {\n\t\t\tthis.removeListener('frame', moveTowardsUser)\n\t\t\tthis.removeListener('stop-following', cancel)\n\t\t}\n\n\t\tlet isCaughtUp = false\n\n\t\tconst moveTowardsUser = () => {\n\t\t\t// Stop following if we can't find the user\n\t\t\tconst leaderPresence = [...leaderPresences.value]\n\t\t\t\t.sort((a, b) => {\n\t\t\t\t\treturn a.lastActivityTimestamp - b.lastActivityTimestamp\n\t\t\t\t})\n\t\t\t\t.pop()\n\t\t\tif (!leaderPresence) {\n\t\t\t\tthis.stopFollowingUser()\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// Change page if leader is on a different page\n\t\t\tconst isOnSamePage = leaderPresence.currentPageId === this.currentPageId\n\t\t\tconst chaseProportion = isOnSamePage ? FOLLOW_CHASE_PROPORTION : 1\n\t\t\tif (!isOnSamePage) {\n\t\t\t\tthis.setCurrentPageId(leaderPresence.currentPageId, { stopFollowing: false })\n\t\t\t}\n\n\t\t\t// Get the bounds of the follower (me) and the leader (them)\n\t\t\tconst { center, width, height } = this.viewportPageBounds\n\t\t\tconst leaderScreen = Box2d.From(leaderPresence.screenBounds)\n\t\t\tconst leaderWidth = leaderScreen.width / leaderPresence.camera.z\n\t\t\tconst leaderHeight = leaderScreen.height / leaderPresence.camera.z\n\t\t\tconst leaderCenter = new Vec2d(\n\t\t\t\tleaderWidth / 2 - leaderPresence.camera.x,\n\t\t\t\tleaderHeight / 2 - leaderPresence.camera.y\n\t\t\t)\n\n\t\t\t// At this point, let's check if we're following someone who's following us.\n\t\t\t// If so, we can't try to contain their entire viewport\n\t\t\t// because that would become a feedback loop where we zoom, they zoom, etc.\n\t\t\tconst isFollowingFollower = leaderPresence.followingUserId === thisUserId\n\n\t\t\t// Figure out how much to zoom\n\t\t\tconst desiredWidth = width + (leaderWidth - width) * chaseProportion\n\t\t\tconst desiredHeight = height + (leaderHeight - height) * chaseProportion\n\t\t\tconst ratio = !isFollowingFollower\n\t\t\t\t? Math.min(width / desiredWidth, height / desiredHeight)\n\t\t\t\t: height / desiredHeight\n\n\t\t\tconst targetZoom = clamp(this.camera.z * ratio, MIN_ZOOM, MAX_ZOOM)\n\t\t\tconst targetWidth = this.viewportScreenBounds.w / targetZoom\n\t\t\tconst targetHeight = this.viewportScreenBounds.h / targetZoom\n\n\t\t\t// Figure out where to move the camera\n\t\t\tconst displacement = leaderCenter.sub(center)\n\t\t\tconst targetCenter = Vec2d.Add(center, Vec2d.Mul(displacement, chaseProportion))\n\n\t\t\t// Now let's assess whether we've caught up to the leader or not\n\t\t\tconst distance = Vec2d.Sub(targetCenter, center).len()\n\t\t\tconst zoomChange = Math.abs(targetZoom - this.camera.z)\n\n\t\t\t// If we're chasing the leader...\n\t\t\t// Stop chasing if we're close enough\n\t\t\tif (distance < FOLLOW_CHASE_PAN_SNAP && zoomChange < FOLLOW_CHASE_ZOOM_SNAP) {\n\t\t\t\tisCaughtUp = true\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// If we're already caught up with the leader...\n\t\t\t// Only start moving again if we're far enough away\n\t\t\tif (\n\t\t\t\tisCaughtUp &&\n\t\t\t\tdistance < FOLLOW_CHASE_PAN_UNSNAP &&\n\t\t\t\tzoomChange < FOLLOW_CHASE_ZOOM_UNSNAP\n\t\t\t) {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// Update the camera!\n\t\t\tisCaughtUp = false\n\t\t\tthis.stopCameraAnimation()\n\t\t\tthis.setCamera(\n\t\t\t\t-(targetCenter.x - targetWidth / 2),\n\t\t\t\t-(targetCenter.y - targetHeight / 2),\n\t\t\t\ttargetZoom,\n\t\t\t\t{ stopFollowing: false }\n\t\t\t)\n\t\t}\n\n\t\tthis.once('stop-following', cancel)\n\t\tthis.addListener('frame', moveTowardsUser)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Stop viewport-following a user.\n\t *\n\t * @public\n\t */\n\tstopFollowingUser() {\n\t\tthis.updateInstanceState({ followingUserId: null }, true)\n\t\tthis.emit('stop-following')\n\t\treturn this\n\t}\n\n\t/**\n\t * Animate the camera to a shape.\n\t *\n\t * @public\n\t */\n\tanimateToShape(shapeId: TLShapeId, opts: TLAnimationOptions = DEFAULT_ANIMATION_OPTIONS): this {\n\t\tif (!this.canMoveCamera) return this\n\n\t\tconst activeArea = getActiveAreaScreenSpace(this)\n\t\tconst viewportAspectRatio = activeArea.width / activeArea.height\n\n\t\tconst shapePageBounds = this.getPageBoundsById(shapeId)\n\n\t\tif (!shapePageBounds) return this\n\n\t\tconst shapeAspectRatio = shapePageBounds.width / shapePageBounds.height\n\n\t\tconst targetViewportPage = shapePageBounds.clone()\n\n\t\tconst z = shapePageBounds.width / activeArea.width\n\t\ttargetViewportPage.width += (activeArea.left + activeArea.right) * z\n\t\ttargetViewportPage.height += (activeArea.top + activeArea.bottom) * z\n\t\ttargetViewportPage.x -= activeArea.left * z\n\t\ttargetViewportPage.y -= activeArea.top * z\n\n\t\tif (shapeAspectRatio > viewportAspectRatio) {\n\t\t\ttargetViewportPage.height = shapePageBounds.width / viewportAspectRatio\n\t\t\ttargetViewportPage.y -= (targetViewportPage.height - shapePageBounds.height) / 2\n\t\t} else {\n\t\t\ttargetViewportPage.width = shapePageBounds.height * viewportAspectRatio\n\t\t\ttargetViewportPage.x -= (targetViewportPage.width - shapePageBounds.width) / 2\n\t\t}\n\n\t\treturn this._animateToViewport(targetViewportPage, opts)\n\t}\n\n\t/**\n\t * Blur the app, cancelling any interaction state.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.blur()\n\t * ```\n\t *\n\t * @public\n\t */\n\tblur() {\n\t\tthis.complete()\n\t\tthis.getContainer().blur()\n\t\tthis._isFocused.set(false)\n\t\treturn this\n\t}\n\n\t/**\n\t * Focus the editor.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.focus()\n\t * ```\n\t *\n\t * @public\n\t */\n\tfocus() {\n\t\tthis.getContainer().focus()\n\t\tthis._isFocused.set(true)\n\t\treturn this\n\t}\n\n\t/**\n\t * Dispatch a cancel event.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.cancel()\n\t * ```\n\t *\n\t * @public\n\t */\n\tcancel() {\n\t\tthis.dispatch({ type: 'misc', name: 'cancel' })\n\t\treturn this\n\t}\n\n\t/**\n\t * Dispatch an interrupt event.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.interrupt()\n\t * ```\n\t *\n\t * @public\n\t */\n\tinterrupt() {\n\t\tthis.dispatch({ type: 'misc', name: 'interrupt' })\n\t\treturn this\n\t}\n\n\t/**\n\t * Dispatch a complete event.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.complete()\n\t * ```\n\t *\n\t * @public\n\t */\n\tcomplete() {\n\t\tthis.dispatch({ type: 'misc', name: 'complete' })\n\t\treturn this\n\t}\n\n\t/* -------------------- Callbacks ------------------- */\n\n\t/**\n\t * Handle external content, such as files, urls, embeds, or plain text which has been put into the app, for example by pasting external text or dropping external images onto canvas.\n\t *\n\t * @param info - Info about the external content.\n\t */\n\tasync putExternalContent(info: TLExternalContent): Promise<void> {\n\t\tthis.externalContentManager.handleContent(info)\n\t}\n\n\t/* ---------------- Text Measurement ---------------- */\n\n\t/**\n\t * A helper for measuring text.\n\t *\n\t * @public\n\t */\n\ttextMeasure: TextManager\n\n\t/* --------------------- Groups --------------------- */\n\n\t/**\n\t * Group some shapes together.\n\t *\n\t * @param ids - Ids of the shapes to group. Defaults to the selected shapes.\n\t * @param groupId - Id of the group to create. Defaults to a new shape id.\n\t *\n\t * @public\n\t */\n\tgroupShapes(ids: TLShapeId[] = this.selectedIds, groupId = createShapeId()) {\n\t\tif (this.isReadOnly) return this\n\n\t\tif (ids.length <= 1) return this\n\n\t\tconst shapes = compact(this._getUnlockedShapeIds(ids).map((id) => this.getShapeById(id)))\n\t\tconst sortedShapeIds = shapes.sort(sortByIndex).map((s) => s.id)\n\t\tconst pageBounds = Box2d.Common(compact(shapes.map((id) => this.getPageBounds(id))))\n\n\t\tconst { x, y } = pageBounds.point\n\n\t\tconst parentId = this.findCommonAncestor(shapes) ?? this.currentPageId\n\n\t\t// Only group when the select tool is active\n\t\tif (this.currentToolId !== 'select') return this\n\n\t\t// If not already in idle, cancel the current interaction (get back to idle)\n\t\tif (!this.isIn('select.idle')) {\n\t\t\tthis.cancel()\n\t\t}\n\n\t\t// Find all the shapes that have the same parentId, and use the highest index.\n\t\tconst shapesWithRootParent = shapes\n\t\t\t.filter((shape) => shape.parentId === parentId)\n\t\t\t.sort(sortByIndex)\n\n\t\tconst highestIndex = shapesWithRootParent[shapesWithRootParent.length - 1]?.index\n\n\t\tthis.batch(() => {\n\t\t\tthis.createShapes<TLGroupShape>([\n\t\t\t\t{\n\t\t\t\t\tid: groupId,\n\t\t\t\t\ttype: 'group',\n\t\t\t\t\tparentId,\n\t\t\t\t\tindex: highestIndex,\n\t\t\t\t\tx,\n\t\t\t\t\ty,\n\t\t\t\t\topacity: 1,\n\t\t\t\t\tprops: {},\n\t\t\t\t},\n\t\t\t])\n\t\t\tthis.reparentShapesById(sortedShapeIds, groupId)\n\t\t\tthis.select(groupId)\n\t\t})\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Ungroup some shapes.\n\t *\n\t * @param ids - Ids of the shapes to ungroup. Defaults to the selected shapes.\n\t *\n\t * @public\n\t */\n\tungroupShapes(ids: TLShapeId[] = this.selectedIds) {\n\t\tif (this.isReadOnly) return this\n\t\tif (ids.length === 0) return this\n\n\t\t// Only ungroup when the select tool is active\n\t\tif (this.currentToolId !== 'select') return this\n\n\t\t// If not already in idle, cancel the current interaction (get back to idle)\n\t\tif (!this.isIn('select.idle')) {\n\t\t\tthis.cancel()\n\t\t}\n\n\t\t// The ids of the selected shapes after ungrouping;\n\t\t// these include all of the grouped shapes children,\n\t\t// plus any shapes that were selected apart from the groups.\n\t\tconst idsToSelect = new Set<TLShapeId>()\n\n\t\t// Get all groups in the selection\n\t\tconst shapes = compact(ids.map((id) => this.getShapeById(id)))\n\n\t\tconst groups: TLGroupShape[] = []\n\n\t\tshapes.forEach((shape) => {\n\t\t\tif (this.isShapeOfType(shape, GroupShapeUtil)) {\n\t\t\t\tgroups.push(shape)\n\t\t\t} else {\n\t\t\t\tidsToSelect.add(shape.id)\n\t\t\t}\n\t\t})\n\n\t\tif (groups.length === 0) return this\n\n\t\tthis.batch(() => {\n\t\t\tlet group: TLGroupShape\n\n\t\t\tfor (let i = 0, n = groups.length; i < n; i++) {\n\t\t\t\tgroup = groups[i]\n\t\t\t\tconst childIds = this.getSortedChildIds(group.id)\n\n\t\t\t\tfor (let j = 0, n = childIds.length; j < n; j++) {\n\t\t\t\t\tidsToSelect.add(childIds[j])\n\t\t\t\t}\n\n\t\t\t\tthis.reparentShapesById(childIds, group.parentId, group.index)\n\t\t\t}\n\n\t\t\tthis.deleteShapes(groups.map((group) => group.id))\n\t\t\tthis.select(...idsToSelect)\n\t\t})\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Get an exported SVG of the given shapes.\n\t *\n\t * @param ids - The ids of the shapes to export. Defaults to selected shapes.\n\t * @param opts - Options for the export.\n\t *\n\t * @returns The SVG element.\n\t *\n\t * @public\n\t */\n\tasync getSvg(\n\t\tids: TLShapeId[] = this.selectedIds.length\n\t\t\t? this.selectedIds\n\t\t\t: (Object.keys(this.currentPageShapeIds) as TLShapeId[]),\n\t\topts = {} as Partial<{\n\t\t\tscale: number\n\t\t\tbackground: boolean\n\t\t\tpadding: number\n\t\t\tdarkMode?: boolean\n\t\t\tpreserveAspectRatio: React.SVGAttributes<SVGSVGElement>['preserveAspectRatio']\n\t\t}>\n\t) {\n\t\tif (ids.length === 0) return\n\t\tif (!window.document) throw Error('No document')\n\n\t\tconst {\n\t\t\tscale = 1,\n\t\t\tbackground = false,\n\t\t\tpadding = SVG_PADDING,\n\t\t\tdarkMode = this.isDarkMode,\n\t\t\tpreserveAspectRatio = false,\n\t\t} = opts\n\n\t\tconst realContainerEl = this.getContainer()\n\t\tconst realContainerStyle = getComputedStyle(realContainerEl)\n\n\t\t// Get the styles from the container. We'll use these to pull out colors etc.\n\t\t// NOTE: We can force force a light theme here because we don't want export\n\t\tconst fakeContainerEl = document.createElement('div')\n\t\tfakeContainerEl.className = `tl-container tl-theme__${\n\t\t\tdarkMode ? 'dark' : 'light'\n\t\t} tl-theme__force-sRGB`\n\t\tdocument.body.appendChild(fakeContainerEl)\n\n\t\tconst containerStyle = getComputedStyle(fakeContainerEl)\n\t\tconst fontsUsedInExport = new Map<string, string>()\n\n\t\tconst colors: TLExportColors = {\n\t\t\tfill: objectMapFromEntries(\n\t\t\t\tDefaultColorStyle.values.map((color) => [\n\t\t\t\t\tcolor,\n\t\t\t\t\tcontainerStyle.getPropertyValue(`--palette-${color}`),\n\t\t\t\t])\n\t\t\t),\n\t\t\tpattern: objectMapFromEntries(\n\t\t\t\tDefaultColorStyle.values.map((color) => [\n\t\t\t\t\tcolor,\n\t\t\t\t\tcontainerStyle.getPropertyValue(`--palette-${color}-pattern`),\n\t\t\t\t])\n\t\t\t),\n\t\t\tsemi: objectMapFromEntries(\n\t\t\t\tDefaultColorStyle.values.map((color) => [\n\t\t\t\t\tcolor,\n\t\t\t\t\tcontainerStyle.getPropertyValue(`--palette-${color}-semi`),\n\t\t\t\t])\n\t\t\t),\n\t\t\thighlight: objectMapFromEntries(\n\t\t\t\tDefaultColorStyle.values.map((color) => [\n\t\t\t\t\tcolor,\n\t\t\t\t\tcontainerStyle.getPropertyValue(`--palette-${color}-highlight`),\n\t\t\t\t])\n\t\t\t),\n\t\t\ttext: containerStyle.getPropertyValue(`--color-text`),\n\t\t\tbackground: containerStyle.getPropertyValue(`--color-background`),\n\t\t\tsolid: containerStyle.getPropertyValue(`--palette-solid`),\n\t\t}\n\n\t\t// Remove containerEl from DOM (temp DOM node)\n\t\tdocument.body.removeChild(fakeContainerEl)\n\n\t\t// ---Figure out which shapes we need to include\n\t\tconst shapeIdsToInclude = this.getShapeAndDescendantIds(ids)\n\t\tconst renderingShapes = this.computeUnorderedRenderingShapes([this.currentPageId]).filter(\n\t\t\t({ id }) => shapeIdsToInclude.has(id)\n\t\t)\n\n\t\t// --- Common bounding box of all shapes\n\t\tlet bbox = null\n\t\tfor (const { maskedPageBounds } of renderingShapes) {\n\t\t\tif (!maskedPageBounds) continue\n\t\t\tif (bbox) {\n\t\t\t\tbbox.union(maskedPageBounds)\n\t\t\t} else {\n\t\t\t\tbbox = maskedPageBounds.clone()\n\t\t\t}\n\t\t}\n\n\t\t// no unmasked shapes to export\n\t\tif (!bbox) return\n\n\t\tconst singleFrameShapeId =\n\t\t\tids.length === 1 && this.isShapeOfType(this.getShapeById(ids[0])!, FrameShapeUtil)\n\t\t\t\t? ids[0]\n\t\t\t\t: null\n\t\tif (!singleFrameShapeId) {\n\t\t\t// Expand by an extra 32 pixels\n\t\t\tbbox.expandBy(padding)\n\t\t}\n\n\t\t// We want the svg image to be BIGGER THAN USUAL to account for image quality\n\t\tconst w = bbox.width * scale\n\t\tconst h = bbox.height * scale\n\n\t\t// --- Create the SVG\n\n\t\t// Embed our custom fonts\n\t\tconst svg = window.document.createElementNS('http://www.w3.org/2000/svg', 'svg')\n\n\t\tif (preserveAspectRatio) {\n\t\t\tsvg.setAttribute('preserveAspectRatio', preserveAspectRatio)\n\t\t}\n\n\t\tsvg.setAttribute('direction', 'ltr')\n\t\tsvg.setAttribute('width', w + '')\n\t\tsvg.setAttribute('height', h + '')\n\t\tsvg.setAttribute('viewBox', `${bbox.minX} ${bbox.minY} ${bbox.width} ${bbox.height}`)\n\t\tsvg.setAttribute('stroke-linecap', 'round')\n\t\tsvg.setAttribute('stroke-linejoin', 'round')\n\t\t// Add current background color, or else background will be transparent\n\n\t\tif (background) {\n\t\t\tif (singleFrameShapeId) {\n\t\t\t\tsvg.style.setProperty('background', colors.solid)\n\t\t\t} else {\n\t\t\t\tsvg.style.setProperty('background-color', colors.background)\n\t\t\t}\n\t\t} else {\n\t\t\tsvg.style.setProperty('background-color', 'transparent')\n\t\t}\n\n\t\t// Add the defs to the svg\n\t\tconst defs = window.document.createElementNS('http://www.w3.org/2000/svg', 'defs')\n\n\t\tfor (const element of Array.from(exportPatternSvgDefs(colors.solid))) {\n\t\t\tdefs.appendChild(element)\n\t\t}\n\n\t\ttry {\n\t\t\tdocument.body.focus?.() // weird but necessary\n\t\t} catch (e) {\n\t\t\t// not implemented\n\t\t}\n\n\t\tsvg.append(defs)\n\n\t\tconst unorderedShapeElements = (\n\t\t\tawait Promise.all(\n\t\t\t\trenderingShapes.map(async ({ id, opacity, index, backgroundIndex }) => {\n\t\t\t\t\t// Don't render the frame if we're only exporting a single frame\n\t\t\t\t\tif (id === singleFrameShapeId) return []\n\n\t\t\t\t\tconst shape = this.getShapeById(id)!\n\n\t\t\t\t\tif (this.isShapeOfType(shape, GroupShapeUtil)) return []\n\n\t\t\t\t\tconst util = this.getShapeUtil(shape)\n\n\t\t\t\t\tlet font: string | undefined\n\t\t\t\t\t// TODO: `Editor` shouldn't know about `DefaultFontStyle`. We need another way\n\t\t\t\t\t// for shapes to register fonts for export.\n\t\t\t\t\tconst fontFromShape = util.getStyleIfExists(DefaultFontStyle, shape)\n\t\t\t\t\tif (fontFromShape) {\n\t\t\t\t\t\tif (fontsUsedInExport.has(fontFromShape)) {\n\t\t\t\t\t\t\tfont = fontsUsedInExport.get(fontFromShape)!\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// For some reason these styles aren't present in the fake element\n\t\t\t\t\t\t\t// so we need to get them from the real element\n\t\t\t\t\t\t\tfont = realContainerStyle.getPropertyValue(`--tl-font-${fontFromShape}`)\n\t\t\t\t\t\t\tfontsUsedInExport.set(fontFromShape, font)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tlet shapeSvgElement = await util.toSvg?.(shape, font, colors)\n\t\t\t\t\tlet backgroundSvgElement = await util.toBackgroundSvg?.(shape, font, colors)\n\n\t\t\t\t\t// wrap the shapes in groups so we can apply properties without overwriting ones from the shape util\n\t\t\t\t\tif (shapeSvgElement) {\n\t\t\t\t\t\tconst outerElement = document.createElementNS('http://www.w3.org/2000/svg', 'g')\n\t\t\t\t\t\touterElement.appendChild(shapeSvgElement)\n\t\t\t\t\t\tshapeSvgElement = outerElement\n\t\t\t\t\t}\n\n\t\t\t\t\tif (backgroundSvgElement) {\n\t\t\t\t\t\tconst outerElement = document.createElementNS('http://www.w3.org/2000/svg', 'g')\n\t\t\t\t\t\touterElement.appendChild(backgroundSvgElement)\n\t\t\t\t\t\tbackgroundSvgElement = outerElement\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!shapeSvgElement && !backgroundSvgElement) {\n\t\t\t\t\t\tconst bounds = this.getPageBounds(shape)!\n\t\t\t\t\t\tconst elm = window.document.createElementNS('http://www.w3.org/2000/svg', 'rect')\n\t\t\t\t\t\telm.setAttribute('width', bounds.width + '')\n\t\t\t\t\t\telm.setAttribute('height', bounds.height + '')\n\t\t\t\t\t\telm.setAttribute('fill', colors.solid)\n\t\t\t\t\t\telm.setAttribute('stroke', colors.pattern.grey)\n\t\t\t\t\t\telm.setAttribute('stroke-width', '1')\n\t\t\t\t\t\tshapeSvgElement = elm\n\t\t\t\t\t}\n\n\t\t\t\t\tlet pageTransform = this.getPageTransform(shape)!.toCssString()\n\t\t\t\t\tif ('scale' in shape.props) {\n\t\t\t\t\t\tif (shape.props.scale !== 1) {\n\t\t\t\t\t\t\tpageTransform = `${pageTransform} scale(${shape.props.scale}, ${shape.props.scale})`\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tshapeSvgElement?.setAttribute('transform', pageTransform)\n\t\t\t\t\tbackgroundSvgElement?.setAttribute('transform', pageTransform)\n\t\t\t\t\tshapeSvgElement?.setAttribute('opacity', opacity + '')\n\t\t\t\t\tbackgroundSvgElement?.setAttribute('opacity', opacity + '')\n\n\t\t\t\t\t// Create svg mask if shape has a frame as parent\n\t\t\t\t\tconst pageMask = this.getPageMaskById(shape.id)\n\t\t\t\t\tif (pageMask) {\n\t\t\t\t\t\t// Create a clip path and add it to defs\n\t\t\t\t\t\tconst clipPathEl = document.createElementNS('http://www.w3.org/2000/svg', 'clipPath')\n\t\t\t\t\t\tdefs.appendChild(clipPathEl)\n\t\t\t\t\t\tconst id = nanoid()\n\t\t\t\t\t\tclipPathEl.id = id\n\n\t\t\t\t\t\t// Create a polyline mask that does the clipping\n\t\t\t\t\t\tconst mask = document.createElementNS('http://www.w3.org/2000/svg', 'path')\n\t\t\t\t\t\tmask.setAttribute('d', `M${pageMask.map(({ x, y }) => `${x},${y}`).join('L')}Z`)\n\t\t\t\t\t\tclipPathEl.appendChild(mask)\n\n\t\t\t\t\t\t// Create group that uses the clip path and wraps the shape elements\n\t\t\t\t\t\tif (shapeSvgElement) {\n\t\t\t\t\t\t\tconst outerElement = document.createElementNS('http://www.w3.org/2000/svg', 'g')\n\t\t\t\t\t\t\touterElement.setAttribute('clip-path', `url(#${id})`)\n\t\t\t\t\t\t\touterElement.appendChild(shapeSvgElement)\n\t\t\t\t\t\t\tshapeSvgElement = outerElement\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (backgroundSvgElement) {\n\t\t\t\t\t\t\tconst outerElement = document.createElementNS('http://www.w3.org/2000/svg', 'g')\n\t\t\t\t\t\t\touterElement.setAttribute('clip-path', `url(#${id})`)\n\t\t\t\t\t\t\touterElement.appendChild(backgroundSvgElement)\n\t\t\t\t\t\t\tbackgroundSvgElement = outerElement\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tconst elements = []\n\t\t\t\t\tif (shapeSvgElement) {\n\t\t\t\t\t\telements.push({ zIndex: index, element: shapeSvgElement })\n\t\t\t\t\t}\n\t\t\t\t\tif (backgroundSvgElement) {\n\t\t\t\t\t\telements.push({ zIndex: backgroundIndex, element: backgroundSvgElement })\n\t\t\t\t\t}\n\n\t\t\t\t\treturn elements\n\t\t\t\t})\n\t\t\t)\n\t\t).flat()\n\n\t\tfor (const { element } of unorderedShapeElements.sort((a, b) => a.zIndex - b.zIndex)) {\n\t\t\tsvg.appendChild(element)\n\t\t}\n\n\t\t// Add styles to the defs\n\t\tlet styles = ``\n\t\tconst style = window.document.createElementNS('http://www.w3.org/2000/svg', 'style')\n\n\t\t// Insert fonts into app\n\t\tconst fontInstances: FontFace[] = []\n\n\t\tif ('fonts' in document) {\n\t\t\tdocument.fonts.forEach((font) => fontInstances.push(font))\n\t\t}\n\n\t\tawait Promise.all(\n\t\t\tfontInstances.map(async (font) => {\n\t\t\t\tconst fileReader = new FileReader()\n\n\t\t\t\tlet isUsed = false\n\n\t\t\t\tfontsUsedInExport.forEach((fontName) => {\n\t\t\t\t\tif (fontName.includes(font.family)) {\n\t\t\t\t\t\tisUsed = true\n\t\t\t\t\t}\n\t\t\t\t})\n\n\t\t\t\tif (!isUsed) return\n\n\t\t\t\tconst url = (font as any).$$_url\n\n\t\t\t\tconst fontFaceRule = (font as any).$$_fontface\n\n\t\t\t\tif (url) {\n\t\t\t\t\tconst fontFile = await (await fetch(url)).blob()\n\n\t\t\t\t\tconst base64Font = await new Promise<string>((resolve, reject) => {\n\t\t\t\t\t\tfileReader.onload = () => resolve(fileReader.result as string)\n\t\t\t\t\t\tfileReader.onerror = () => reject(fileReader.error)\n\t\t\t\t\t\tfileReader.readAsDataURL(fontFile)\n\t\t\t\t\t})\n\n\t\t\t\t\tconst newFontFaceRule = '\\n' + fontFaceRule.replaceAll(url, base64Font)\n\t\t\t\t\tstyles += newFontFaceRule\n\t\t\t\t}\n\t\t\t})\n\t\t)\n\n\t\tstyle.textContent = styles\n\n\t\tdefs.append(style)\n\n\t\treturn svg\n\t}\n}\n\nfunction alertMaxShapes(editor: Editor, pageId = editor.currentPageId) {\n\tconst name = editor.getPageById(pageId)!.name\n\teditor.emit('max-shapes', { name, pageId, count: MAX_SHAPES_PER_PAGE })\n}\n"],
  "mappings": "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",
  "names": ["shape", "currentScreenPoint", "assets", "animatingShapes", "gap", "i", "ancestor", "id", "ids", "z", "x", "y", "highlightedUserIds", "n", "group"]
}
