"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp(target, key, result);
  return result;
};
var ShapeUtil_exports = {};
__export(ShapeUtil_exports, {
  ShapeUtil: () => ShapeUtil
});
module.exports = __toCommonJS(ShapeUtil_exports);
var import_primitives = require("@tldraw/primitives");
var import_signia = require("signia");
class ShapeUtil {
  constructor(editor, type, styleProps) {
    this.editor = editor;
    this.type = type;
    this.styleProps = styleProps;
  }
  hasStyle(style) {
    return this.styleProps.has(style);
  }
  getStyleIfExists(style, shape) {
    const styleKey = this.styleProps.get(style);
    if (!styleKey)
      return void 0;
    return shape.props[styleKey];
  }
  *iterateStyles(shape) {
    for (const [style, styleKey] of this.styleProps) {
      const value = shape.props[styleKey];
      yield [style, value];
    }
  }
  setStyleInPartial(style, shape, value) {
    const styleKey = this.styleProps.get(style);
    if (!styleKey)
      return shape;
    return {
      ...shape,
      props: {
        ...shape.props,
        [styleKey]: value
      }
    };
  }
  /**
   * The type of the shape util, which should match the shape's type.
   *
   * @public
   */
  static type;
  /**
   * Whether the shape can be snapped to by another shape.
   *
   * @public
   */
  canSnap = () => true;
  /**
   * Whether the shape can be scrolled while editing.
   *
   * @public
   */
  canScroll = () => false;
  /**
   * Whether the shape should unmount when not visible in the editor. Consider keeping this to false if the shape's `component` has local state.
   *
   * @public
   */
  canUnmount = () => true;
  /**
   * Whether the shape can be bound to by an arrow.
   *
   * @param _otherShape - The other shape attempting to bind to this shape.
   * @public
   */
  canBind = (_shape, _otherShape) => true;
  /**
   * Whether the shape can be double clicked to edit.
   *
   * @public
   */
  canEdit = () => false;
  /**
   * Whether the shape can be resized.
   *
   * @public
   */
  canResize = () => true;
  /**
   * Whether the shape can be cropped.
   *
   * @public
   */
  canCrop = () => false;
  /**
   * Bounds of the shape to edit.
   *
   * Note: this could be a text area within a shape for example arrow labels.
   *
   * @public
   */
  getEditingBounds = (shape) => {
    return this.bounds(shape);
  };
  /**
   * Whether the shape's outline is closed.
   *
   * @public
   */
  isClosed = () => true;
  /**
   * Whether the shape should hide its resize handles when selected.
   *
   * @public
   */
  hideResizeHandles = () => false;
  /**
   * Whether the shape should hide its resize handles when selected.
   *
   * @public
   */
  hideRotateHandle = () => false;
  /**
   * Whether the shape should hide its selection bounds background when selected.
   *
   * @public
   */
  hideSelectionBoundsBg = () => false;
  /**
   * Whether the shape should hide its selection bounds foreground when selected.
   *
   * @public
   */
  hideSelectionBoundsFg = () => false;
  /**
   * Whether the shape's aspect ratio is locked.
   *
   * @public
   */
  isAspectRatioLocked = () => false;
  get handlesCache() {
    return this.editor.store.createComputedCache("handles:" + this.type, (shape) => {
      return this.getHandles(shape);
    });
  }
  /**
   * Get the cached handles (this should not be overridden!)
   *
   * @param shape - The shape.
   * @public
   */
  handles(shape) {
    if (!this.getHandles)
      return import_signia.EMPTY_ARRAY;
    return this.handlesCache.get(shape.id) ?? import_signia.EMPTY_ARRAY;
  }
  /**
   * Get an array of outline segments for the shape. For most shapes,
   * this will be a single segment that includes the entire outline.
   * For shapes with handles, this might be segments of the outline
   * between each handle.
   *
   * @example
   *
   * ```ts
   * util.getOutlineSegments(myShape)
   * ```
   *
   * @param shape - The shape.
   * @public
   */
  getOutlineSegments(shape) {
    return [this.outline(shape)];
  }
  get outlineSegmentsCache() {
    return this.editor.store.createComputedCache("outline-segments:" + this.type, (shape) => {
      return this.getOutlineSegments(shape);
    });
  }
  /**
   * Get the cached outline segments (this should not be overridden!)
   *
   * @param shape - The shape.
   * @public
   */
  outlineSegments(shape) {
    if (!this.getOutlineSegments)
      return import_signia.EMPTY_ARRAY;
    return this.outlineSegmentsCache.get(shape.id) ?? import_signia.EMPTY_ARRAY;
  }
  get boundsCache() {
    return this.editor.store.createComputedCache("bounds:" + this.type, (shape) => {
      return this.getBounds(shape);
    });
  }
  /**
   * Get the cached bounds for the shape.
   *
   * @param shape - The shape.
   * @public
   */
  bounds(shape) {
    const result = this.boundsCache.get(shape.id) ?? new import_primitives.Box2d();
    if (result.width === 0 || result.height === 0) {
      return new import_primitives.Box2d(result.x, result.y, Math.max(result.width, 1), Math.max(result.height, 1));
    }
    return result;
  }
  get outlineCache() {
    return this.editor.store.createComputedCache("outline:" + this.type, (shape) => {
      return this.getOutline(shape);
    });
  }
  /**
   * Get the shape's outline. Do not override this method!
   *
   * @param shape - The shape.
   * @public
   */
  outline(shape) {
    return this.outlineCache.get(shape.id) ?? import_signia.EMPTY_ARRAY;
  }
  /**
   * Get the shape's snap points.
   *
   * @param shape - The shape.
   * @public
   */
  snapPoints(shape) {
    return this.bounds(shape).snapPoints;
  }
  /**
   * Get the shape's cached center.
   *
   * @param shape - The shape.
   * @public
   */
  center(shape) {
    return this.getCenter(shape);
  }
  /**
   * Get whether the shape can receive children of a given type.
   *
   * @param type - The shape type.
   * @public
   */
  canReceiveNewChildrenOfType(shape, type) {
    return false;
  }
  /**
   * Get whether the shape can receive children of a given type.
   *
   * @param shape - The shape type.
   * @param shapes - The shapes that are being dropped.
   * @public
   */
  canDropShapes(shape, shapes) {
    return false;
  }
  /**
   * Get whether a point intersects the shape.
   *
   * @param shape - The shape.
   * @param point - The point to test.
   * @returns Whether the point intersects the shape.
   * @public
   */
  hitTestPoint(shape, point) {
    return this.bounds(shape).containsPoint(point);
  }
  /**
   * Get whether a point intersects the shape.
   *
   * @param shape - The shape.
   * @param A - The line segment's first point.
   * @param B - The line segment's second point.
   * @returns Whether the line segment intersects the shape.
   * @public
   */
  hitTestLineSegment(shape, A, B) {
    const outline = this.outline(shape);
    for (let i = 0; i < outline.length; i++) {
      const C = outline[i];
      const D = outline[(i + 1) % outline.length];
      if ((0, import_primitives.linesIntersect)(A, B, C, D))
        return true;
    }
    return false;
  }
  /** @internal */
  expandSelectionOutlinePx(shape) {
    return 0;
  }
  /**
   * Does this shape provide a background for its children? If this is true,
   * then any children with a `renderBackground` method will have their
   * backgrounds rendered _above_ this shape. Otherwise, the children's
   * backgrounds will be rendered above either the next ancestor that provides
   * a background, or the canvas background.
   *
   * @internal
   */
  providesBackgroundForChildren(shape) {
    return false;
  }
  //  Events
  /**
   * A callback called just before a shape is created. This method provides a last chance to modify
   * the created shape.
   *
   * @example
   *
   * ```ts
   * onBeforeCreate = (next) => {
   * 	return { ...next, x: next.x + 1 }
   * }
   * ```
   *
   * @param next - The next shape.
   * @returns The next shape or void.
   * @public
   */
  onBeforeCreate;
  /**
   * A callback called just before a shape is updated. This method provides a last chance to modify
   * the updated shape.
   *
   * @example
   *
   * ```ts
   * onBeforeUpdate = (prev, next) => {
   * 	if (prev.x === next.x) {
   * 		return { ...next, x: next.x + 1 }
   * 	}
   * }
   * ```
   *
   * @param prev - The previous shape.
   * @param next - The next shape.
   * @returns The next shape or void.
   * @public
   */
  onBeforeUpdate;
  /**
   * A callback called when some other shapes are dragged over this one.
   *
   * @example
   *
   * ```ts
   * onDragShapesOver = (shape, shapes) => {
   * 	return { shouldHint: true }
   * }
   * ```
   *
   * @param shape - The shape.
   * @param shapes - The shapes that are being dragged over this one.
   * @returns An object specifying whether the shape should hint that it can receive the dragged shapes.
   * @public
   */
  onDragShapesOver;
  /**
   * A callback called when some other shapes are dragged out of this one.
   *
   * @param shape - The shape.
   * @param shapes - The shapes that are being dragged out.
   * @public
   */
  onDragShapesOut;
  /**
   * A callback called when some other shapes are dropped over this one.
   *
   * @param shape - The shape.
   * @param shapes - The shapes that are being dropped over this one.
   * @public
   */
  onDropShapesOver;
  /**
   * A callback called when a shape starts being resized.
   *
   * @param shape - The shape.
   * @returns A change to apply to the shape, or void.
   * @public
   */
  onResizeStart;
  /**
   * A callback called when a shape changes from a resize.
   *
   * @param shape - The shape at the start of the resize.
   * @param info - Info about the resize.
   * @returns A change to apply to the shape, or void.
   * @public
   */
  onResize;
  /**
   * A callback called when a shape finishes resizing.
   *
   * @param initial - The shape at the start of the resize.
   * @param current - The current shape.
   * @returns A change to apply to the shape, or void.
   * @public
   */
  onResizeEnd;
  /**
   * A callback called when a shape starts being translated.
   *
   * @param shape - The shape.
   * @returns A change to apply to the shape, or void.
   * @public
   */
  onTranslateStart;
  /**
   * A callback called when a shape changes from a translation.
   *
   * @param initial - The shape at the start of the translation.
   * @param current - The current shape.
   * @returns A change to apply to the shape, or void.
   * @public
   */
  onTranslate;
  /**
   * A callback called when a shape finishes translating.
   *
   * @param initial - The shape at the start of the translation.
   * @param current - The current shape.
   * @returns A change to apply to the shape, or void.
   * @public
   */
  onTranslateEnd;
  /**
   * A callback called when a shape starts being rotated.
   *
   * @param shape - The shape.
   * @returns A change to apply to the shape, or void.
   * @public
   */
  onRotateStart;
  /**
   * A callback called when a shape changes from a rotation.
   *
   * @param initial - The shape at the start of the rotation.
   * @param current - The current shape.
   * @returns A change to apply to the shape, or void.
   * @public
   */
  onRotate;
  /**
   * A callback called when a shape finishes rotating.
   *
   * @param initial - The shape at the start of the rotation.
   * @param current - The current shape.
   * @returns A change to apply to the shape, or void.
   * @public
   */
  onRotateEnd;
  /**
   * A callback called when a shape's handle changes.
   *
   * @param shape - The shape.
   * @param info - An object containing the handle and whether the handle is 'precise' or not.
   * @returns A change to apply to the shape, or void.
   * @public
   */
  onHandleChange;
  /**
   * Not currently used.
   *
   * @internal
   */
  onBindingChange;
  /**
   * A callback called when a shape's children change.
   *
   * @param shape - The shape.
   * @returns An array of shape updates, or void.
   * @public
   */
  onChildrenChange;
  /**
   * A callback called when a shape's handle is double clicked.
   *
   * @param shape - The shape.
   * @param handle - The handle that is double-clicked.
   * @returns A change to apply to the shape, or void.
   * @public
   */
  onDoubleClickHandle;
  /**
   * A callback called when a shape's edge is double clicked.
   *
   * @param shape - The shape.
   * @returns A change to apply to the shape, or void.
   * @public
   */
  onDoubleClickEdge;
  /**
   * A callback called when a shape is double clicked.
   *
   * @param shape - The shape.
   * @returns A change to apply to the shape, or void.
   * @public
   */
  onDoubleClick;
  /**
   * A callback called when a shape is clicked.
   *
   * @param shape - The shape.
   * @returns A change to apply to the shape, or void.
   * @public
   */
  onClick;
  /**
   * A callback called when a shape finishes being editing.
   *
   * @param shape - The shape.
   * @public
   */
  onEditEnd;
}
__decorateClass([
  import_signia.computed
], ShapeUtil.prototype, "handlesCache", 1);
__decorateClass([
  import_signia.computed
], ShapeUtil.prototype, "outlineSegmentsCache", 1);
__decorateClass([
  import_signia.computed
], ShapeUtil.prototype, "boundsCache", 1);
__decorateClass([
  import_signia.computed
], ShapeUtil.prototype, "outlineCache", 1);
//# sourceMappingURL=ShapeUtil.js.map
