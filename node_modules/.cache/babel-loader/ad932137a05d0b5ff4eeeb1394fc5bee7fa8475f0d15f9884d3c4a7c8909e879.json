{"ast":null,"code":"import _classCallCheck from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _defineProperty from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\n// src/EffectScheduler.ts\nimport { startCapturingParents, stopCapturingParents } from \"./capture.mjs\";\nimport { GLOBAL_START_EPOCH } from \"./constants.mjs\";\nimport { attach as _attach, detach as _detach, haveParentsChanged } from \"./helpers.mjs\";\nimport { globalEpoch } from \"./transactions.mjs\";\nvar EffectScheduler = /*#__PURE__*/function () {\n  function EffectScheduler(name, runEffect, options) {\n    var _this = this;\n    _classCallCheck(this, EffectScheduler);\n    _defineProperty(this, \"_isActivelyListening\", false);\n    /** @internal */\n    _defineProperty(this, \"lastTraversedEpoch\", GLOBAL_START_EPOCH);\n    _defineProperty(this, \"lastReactedEpoch\", GLOBAL_START_EPOCH);\n    _defineProperty(this, \"_scheduleCount\", 0);\n    /** @internal */\n    _defineProperty(this, \"parentEpochs\", []);\n    /** @internal */\n    _defineProperty(this, \"parents\", []);\n    _defineProperty(this, \"_scheduleEffect\", void 0);\n    _defineProperty(this, \"maybeExecute\", function () {\n      if (!_this._isActivelyListening) return;\n      _this.execute();\n    });\n    this.name = name;\n    this.runEffect = runEffect;\n    this._scheduleEffect = options === null || options === void 0 ? void 0 : options.scheduleEffect;\n  }\n  _createClass(EffectScheduler, [{\n    key: \"isActivelyListening\",\n    get:\n    /**\n     * Whether this scheduler is attached and actively listening to its parents.\n     * @public\n     */\n    function get() {\n      return this._isActivelyListening;\n    }\n  }, {\n    key: \"scheduleCount\",\n    get:\n    /**\n     * The number of times this effect has been scheduled.\n     * @public\n     */\n    function get() {\n      return this._scheduleCount;\n    }\n  }, {\n    key: \"maybeScheduleEffect\",\n    value: /** @internal */\n    function maybeScheduleEffect() {\n      if (!this._isActivelyListening) return;\n      if (this.lastReactedEpoch === globalEpoch) return;\n      if (this.parents.length && !haveParentsChanged(this)) {\n        this.lastReactedEpoch = globalEpoch;\n        return;\n      }\n      this.scheduleEffect();\n    }\n    /** @internal */\n  }, {\n    key: \"scheduleEffect\",\n    value: function scheduleEffect() {\n      this._scheduleCount++;\n      if (this._scheduleEffect) {\n        this._scheduleEffect(this.maybeExecute);\n      } else {\n        this.execute();\n      }\n    }\n  }, {\n    key: \"attach\",\n    value:\n    /**\n     * Makes this scheduler become 'actively listening' to its parents.\n     * If it has been executed before it will immediately become eligible to receive 'maybeScheduleEffect' calls.\n     * If it has not executed before it will need to be manually executed once to become eligible for scheduling, i.e. by calling [[EffectScheduler.execute]].\n     * @public\n     */\n    function attach() {\n      this._isActivelyListening = true;\n      for (var i = 0, n = this.parents.length; i < n; i++) {\n        _attach(this.parents[i], this);\n      }\n    }\n    /**\n     * Makes this scheduler stop 'actively listening' to its parents.\n     * It will no longer be eligible to receive 'maybeScheduleEffect' calls until [[EffectScheduler.attach]] is called again.\n     */\n  }, {\n    key: \"detach\",\n    value: function detach() {\n      this._isActivelyListening = false;\n      for (var i = 0, n = this.parents.length; i < n; i++) {\n        _detach(this.parents[i], this);\n      }\n    }\n    /**\n     * Executes the effect immediately and returns the result.\n     * @returns The result of the effect.\n     */\n  }, {\n    key: \"execute\",\n    value: function execute() {\n      try {\n        startCapturingParents(this);\n        var result = this.runEffect(this.lastReactedEpoch);\n        this.lastReactedEpoch = globalEpoch;\n        return result;\n      } finally {\n        stopCapturingParents();\n      }\n    }\n  }]);\n  return EffectScheduler;\n}();\nfunction react(name, fn, options) {\n  var scheduler = new EffectScheduler(name, fn, options);\n  scheduler.attach();\n  scheduler.scheduleEffect();\n  return function () {\n    scheduler.detach();\n  };\n}\nfunction reactor(name, fn, options) {\n  var scheduler = new EffectScheduler(name, fn, options);\n  return {\n    scheduler: scheduler,\n    start: function start(options2) {\n      var _options2$force;\n      var force = (_options2$force = options2 === null || options2 === void 0 ? void 0 : options2.force) !== null && _options2$force !== void 0 ? _options2$force : false;\n      scheduler.attach();\n      if (force) {\n        scheduler.scheduleEffect();\n      } else {\n        scheduler.maybeScheduleEffect();\n      }\n    },\n    stop: function stop() {\n      scheduler.detach();\n    }\n  };\n}\nexport { EffectScheduler, react, reactor };","map":{"version":3,"names":["startCapturingParents","stopCapturingParents","GLOBAL_START_EPOCH","attach","detach","haveParentsChanged","globalEpoch","EffectScheduler","name","runEffect","options","_this","_classCallCheck","_defineProperty","_isActivelyListening","execute","_scheduleEffect","scheduleEffect","_createClass","key","get","_scheduleCount","value","maybeScheduleEffect","lastReactedEpoch","parents","length","maybeExecute","i","n","result","react","fn","scheduler","reactor","start","options2","_options2$force","force","stop"],"sources":["/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/signia/src/EffectScheduler.ts"],"sourcesContent":["import { startCapturingParents, stopCapturingParents } from './capture.js'\nimport { GLOBAL_START_EPOCH } from './constants.js'\nimport { attach, detach, haveParentsChanged } from './helpers.js'\nimport { globalEpoch } from './transactions.js'\nimport { Signal } from './types.js'\n\ninterface EffectSchedulerOptions {\n\t/**\n\t * scheduleEffect is a function that will be called when the effect is scheduled.\n\t *\n\t * It can be used to defer running effects until a later time, for example to batch them together with requestAnimationFrame.\n\t *\n\t *\n\t * @example\n\t * ```ts\n\t * let isRafScheduled = false\n\t * const scheduledEffects: Array<() => void> = []\n\t * const scheduleEffect = (runEffect: () => void) => {\n\t * \tscheduledEffects.push(runEffect)\n\t * \tif (!isRafScheduled) {\n\t * \t\tisRafScheduled = true\n\t * \t\trequestAnimationFrame(() => {\n\t * \t\t\tisRafScheduled = false\n\t * \t\t\tscheduledEffects.forEach((runEffect) => runEffect())\n\t * \t\t\tscheduledEffects.length = 0\n\t * \t\t})\n\t * \t}\n\t * }\n\t * const stop = react('set page title', () => {\n\t * \tdocument.title = doc.title,\n\t * }, scheduleEffect)\n\t * ```\n\t *\n\t * @param execute\n\t * @returns\n\t */\n\tscheduleEffect?: (execute: () => void) => void\n}\n\n/**\n * An EffectScheduler is responsible for executing side effects in response to changes in state.\n *\n * You probably don't need to use this directly unless you're integrating Signia with a framework of some kind.\n *\n * Instead, use the [[react]] and [[reactor]] functions.\n *\n * @example\n * ```ts\n * const render = new EffectScheduler('render', drawToCanvas)\n *\n * render.attach()\n * render.execute()\n * ```\n *\n * @public\n */\nexport class EffectScheduler<Result> {\n\tprivate _isActivelyListening = false\n\t/**\n\t * Whether this scheduler is attached and actively listening to its parents.\n\t * @public\n\t */\n\tget isActivelyListening() {\n\t\treturn this._isActivelyListening\n\t}\n\t/** @internal */\n\tlastTraversedEpoch = GLOBAL_START_EPOCH\n\n\tprivate lastReactedEpoch = GLOBAL_START_EPOCH\n\tprivate _scheduleCount = 0\n\n\t/**\n\t * The number of times this effect has been scheduled.\n\t * @public\n\t */\n\tget scheduleCount() {\n\t\treturn this._scheduleCount\n\t}\n\n\t/** @internal */\n\tparentEpochs: number[] = []\n\t/** @internal */\n\tparents: Signal<any, any>[] = []\n\tprivate readonly _scheduleEffect?: (execute: () => void) => void\n\tconstructor(\n\t\tpublic readonly name: string,\n\t\tprivate readonly runEffect: (lastReactedEpoch: number) => Result,\n\t\toptions?: EffectSchedulerOptions\n\t) {\n\t\tthis._scheduleEffect = options?.scheduleEffect\n\t}\n\n\t/** @internal */\n\tmaybeScheduleEffect() {\n\t\t// bail out if we have been cancelled by another effect\n\t\tif (!this._isActivelyListening) return\n\t\t// bail out if no atoms have changed since the last time we ran this effect\n\t\tif (this.lastReactedEpoch === globalEpoch) return\n\n\t\t// bail out if we have parents and they have not changed since last time\n\t\tif (this.parents.length && !haveParentsChanged(this)) {\n\t\t\tthis.lastReactedEpoch = globalEpoch\n\t\t\treturn\n\t\t}\n\t\t// if we don't have parents it's probably the first time this is running.\n\t\tthis.scheduleEffect()\n\t}\n\n\t/** @internal */\n\tscheduleEffect() {\n\t\tthis._scheduleCount++\n\t\tif (this._scheduleEffect) {\n\t\t\t// if the effect should be deferred (e.g. until a react render), do so\n\t\t\tthis._scheduleEffect(this.maybeExecute)\n\t\t} else {\n\t\t\t// otherwise execute right now!\n\t\t\tthis.execute()\n\t\t}\n\t}\n\n\tprivate maybeExecute = () => {\n\t\t// bail out if we have been detached before this runs\n\t\tif (!this._isActivelyListening) return\n\t\tthis.execute()\n\t}\n\n\t/**\n\t * Makes this scheduler become 'actively listening' to its parents.\n\t * If it has been executed before it will immediately become eligible to receive 'maybeScheduleEffect' calls.\n\t * If it has not executed before it will need to be manually executed once to become eligible for scheduling, i.e. by calling [[EffectScheduler.execute]].\n\t * @public\n\t */\n\tattach() {\n\t\tthis._isActivelyListening = true\n\t\tfor (let i = 0, n = this.parents.length; i < n; i++) {\n\t\t\tattach(this.parents[i], this)\n\t\t}\n\t}\n\n\t/**\n\t * Makes this scheduler stop 'actively listening' to its parents.\n\t * It will no longer be eligible to receive 'maybeScheduleEffect' calls until [[EffectScheduler.attach]] is called again.\n\t */\n\tdetach() {\n\t\tthis._isActivelyListening = false\n\t\tfor (let i = 0, n = this.parents.length; i < n; i++) {\n\t\t\tdetach(this.parents[i], this)\n\t\t}\n\t}\n\n\t/**\n\t * Executes the effect immediately and returns the result.\n\t * @returns The result of the effect.\n\t */\n\texecute(): Result {\n\t\ttry {\n\t\t\tstartCapturingParents(this)\n\t\t\tconst result = this.runEffect(this.lastReactedEpoch)\n\t\t\tthis.lastReactedEpoch = globalEpoch\n\t\t\treturn result\n\t\t} finally {\n\t\t\tstopCapturingParents()\n\t\t}\n\t}\n}\n\n/**\n * Starts a new effect scheduler, scheduling the effect immediately.\n *\n * Returns a function that can be called to stop the scheduler.\n *\n * @example\n * ```ts\n * const color = atom('color', 'red')\n * const stop = react('set style', () => {\n *   divElem.style.color = color.value\n * })\n * color.set('blue')\n * // divElem.style.color === 'blue'\n * stop()\n * color.set('green')\n * // divElem.style.color === 'blue'\n * ```\n *\n *\n * Also useful in React applications for running effects outside of the render cycle.\n *\n * @example\n * ```ts\n * useEffect(() => react('set style', () => {\n *   divRef.current.style.color = color.value\n * }), [])\n * ```\n *\n * @public\n */\nexport function react(\n\tname: string,\n\tfn: (lastReactedEpoch: number) => any,\n\toptions?: EffectSchedulerOptions\n) {\n\tconst scheduler = new EffectScheduler(name, fn, options)\n\tscheduler.attach()\n\tscheduler.scheduleEffect()\n\treturn () => {\n\t\tscheduler.detach()\n\t}\n}\n\n/**\n * The reactor is a user-friendly interface for starting and stopping an [[EffectScheduler]].\n *\n * Calling .start() will attach the scheduler and execute the effect immediately the first time it is called.\n *\n * If the reactor is stopped, calling `.start()` will re-attach the scheduler but will only execute the effect if any of its parents have changed since it was stopped.\n *\n * You can create a reactor with [[reactor]].\n * @public\n */\nexport interface Reactor<T = unknown> {\n\t/**\n\t * The underlying effect scheduler.\n\t * @public\n\t */\n\tscheduler: EffectScheduler<T>\n\t/**\n\t * Start the scheduler. The first time this is called the effect will be scheduled immediately.\n\t *\n\t * If the reactor is stopped, calling this will start the scheduler again but will only execute the effect if any of its parents have changed since it was stopped.\n\t *\n\t * If you need to force re-execution of the effect, pass `{ force: true }`.\n\t * @public\n\t */\n\tstart(options?: { force?: boolean }): void\n\t/**\n\t * Stop the scheduler.\n\t * @public\n\t */\n\tstop(): void\n}\n\n/**\n * Creates a [[Reactor]], which is a thin wrapper around an [[EffectScheduler]].\n *\n * @public\n */\nexport function reactor<Result>(\n\tname: string,\n\tfn: (lastReactedEpoch: number) => Result,\n\toptions?: EffectSchedulerOptions\n): Reactor<Result> {\n\tconst scheduler = new EffectScheduler<Result>(name, fn, options)\n\treturn {\n\t\tscheduler,\n\t\tstart: (options?: { force?: boolean }) => {\n\t\t\tconst force = options?.force ?? false\n\t\t\tscheduler.attach()\n\t\t\tif (force) {\n\t\t\t\tscheduler.scheduleEffect()\n\t\t\t} else {\n\t\t\t\tscheduler.maybeScheduleEffect()\n\t\t\t}\n\t\t},\n\t\tstop: () => {\n\t\t\tscheduler.detach()\n\t\t},\n\t}\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}