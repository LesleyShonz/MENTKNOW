{"ast":null,"code":"import _objectSpread from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _classCallCheck from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _inherits from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _defineProperty from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport { Vec2d } from \"@tldraw/primitives\";\nimport { createShapeId } from \"@tldraw/tlschema\";\nimport { debugFlags } from \"../../../../utils/debug-flags.mjs\";\nimport { GroupShapeUtil } from \"../../../shapes/group/GroupShapeUtil.mjs\";\nimport { StateNode } from \"../../StateNode.mjs\";\nvar Idle = /*#__PURE__*/function (_StateNode) {\n  _inherits(Idle, _StateNode);\n  var _super = _createSuper(Idle);\n  function Idle() {\n    var _this;\n    _classCallCheck(this, Idle);\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    _this = _super.call.apply(_super, [this].concat(args));\n    _defineProperty(_assertThisInitialized(_this), \"isDarwin\", window.navigator.userAgent.toLowerCase().indexOf(\"mac\") > -1);\n    _defineProperty(_assertThisInitialized(_this), \"onPointerEnter\", function (info) {\n      switch (info.target) {\n        case \"canvas\":\n          {\n            break;\n          }\n        case \"shape\":\n          {\n            var _this$editor = _this.editor,\n              selectedIds = _this$editor.selectedIds,\n              focusLayerId = _this$editor.focusLayerId;\n            var hoveringShape = _this.editor.getOutermostSelectableShape(info.shape, function (parent) {\n              return !selectedIds.includes(parent.id);\n            });\n            if (hoveringShape.id !== focusLayerId) {\n              _this.editor.setHoveredId(hoveringShape.id);\n            }\n            if (debugFlags.debugCursors.value) {\n              if (hoveringShape.type !== \"geo\") break;\n              var cursorType = hoveringShape.props.text;\n              try {\n                _this.editor.setCursor({\n                  type: cursorType\n                });\n              } catch (e) {\n                console.error(\"Cursor type not recognized: '\".concat(cursorType, \"'\"));\n                _this.editor.setCursor({\n                  type: \"default\"\n                });\n              }\n            }\n            break;\n          }\n      }\n    });\n    _defineProperty(_assertThisInitialized(_this), \"onPointerLeave\", function (info) {\n      switch (info.target) {\n        case \"shape\":\n          {\n            _this.editor.setHoveredId(null);\n            break;\n          }\n      }\n    });\n    _defineProperty(_assertThisInitialized(_this), \"onPointerDown\", function (info) {\n      if (_this.editor.isMenuOpen) return;\n      var shouldEnterCropMode = _this.shouldEnterCropMode(info, true);\n      if (info.ctrlKey && !shouldEnterCropMode) {\n        if (info.target === \"shape\" && _this.isDarwin && _this.editor.inputs.keys.has(\"ControlLeft\")) {\n          if (!_this.editor.isShapeOrAncestorLocked(info.shape)) {\n            _this.parent.transition(\"pointing_shape\", info);\n            return;\n          }\n        }\n        _this.parent.transition(\"brushing\", info);\n        return;\n      }\n      switch (info.target) {\n        case \"canvas\":\n          {\n            _this.parent.transition(\"pointing_canvas\", info);\n            break;\n          }\n        case \"shape\":\n          {\n            if (_this.editor.isShapeOrAncestorLocked(info.shape)) break;\n            _this.parent.transition(\"pointing_shape\", info);\n            break;\n          }\n        case \"handle\":\n          {\n            if (_this.editor.isReadOnly) break;\n            if (_this.editor.inputs.altKey) {\n              _this.parent.transition(\"pointing_shape\", info);\n            } else {\n              _this.parent.transition(\"pointing_handle\", info);\n            }\n            break;\n          }\n        case \"selection\":\n          {\n            switch (info.handle) {\n              case \"mobile_rotate\":\n              case \"top_left_rotate\":\n              case \"top_right_rotate\":\n              case \"bottom_left_rotate\":\n              case \"bottom_right_rotate\":\n                {\n                  _this.parent.transition(\"pointing_rotate_handle\", info);\n                  break;\n                }\n              case \"top\":\n              case \"right\":\n              case \"bottom\":\n              case \"left\":\n                {\n                  if (shouldEnterCropMode) {\n                    _this.parent.transition(\"pointing_crop_handle\", info);\n                  } else {\n                    _this.parent.transition(\"pointing_resize_handle\", info);\n                  }\n                  break;\n                }\n              case \"top_left\":\n              case \"top_right\":\n              case \"bottom_left\":\n              case \"bottom_right\":\n                {\n                  if (shouldEnterCropMode) {\n                    _this.parent.transition(\"pointing_crop_handle\", info);\n                  } else {\n                    _this.parent.transition(\"pointing_resize_handle\", info);\n                  }\n                  break;\n                }\n              default:\n                {\n                  _this.parent.transition(\"pointing_selection\", info);\n                }\n            }\n            break;\n          }\n      }\n    });\n    _defineProperty(_assertThisInitialized(_this), \"onDoubleClick\", function (info) {\n      if (info.phase !== \"up\") return;\n      switch (info.target) {\n        case \"canvas\":\n          {\n            if (_this.editor.isReadOnly) break;\n            _this.handleDoubleClickOnCanvas(info);\n            break;\n          }\n        case \"selection\":\n          {\n            if (_this.editor.isReadOnly) break;\n            var onlySelectedShape = _this.editor.onlySelectedShape;\n            if (onlySelectedShape) {\n              var util = _this.editor.getShapeUtil(onlySelectedShape);\n              if (info.handle === \"right\" || info.handle === \"left\" || info.handle === \"top\" || info.handle === \"bottom\") {\n                var _util$onDoubleClickEd;\n                var change = (_util$onDoubleClickEd = util.onDoubleClickEdge) === null || _util$onDoubleClickEd === void 0 ? void 0 : _util$onDoubleClickEd.call(util, onlySelectedShape);\n                if (change) {\n                  _this.editor.mark(\"double click edge\");\n                  _this.editor.updateShapes([change]);\n                  return;\n                }\n              }\n              if (util.canCrop(onlySelectedShape) && !_this.editor.isShapeOrAncestorLocked(onlySelectedShape)) {\n                _this.parent.transition(\"crop\", info);\n                return;\n              }\n              if (_this.shouldStartEditingShape(onlySelectedShape)) {\n                _this.startEditingShape(onlySelectedShape, info);\n              }\n            }\n            break;\n          }\n        case \"shape\":\n          {\n            var shape = info.shape;\n            var _util = _this.editor.getShapeUtil(shape);\n            if (shape.type !== \"video\" && shape.type !== \"embed\" && _this.editor.isReadOnly) break;\n            if (_util.onDoubleClick) {\n              var _util$onDoubleClick;\n              var _change = (_util$onDoubleClick = _util.onDoubleClick) === null || _util$onDoubleClick === void 0 ? void 0 : _util$onDoubleClick.call(_util, shape);\n              if (_change) {\n                _this.editor.updateShapes([_change]);\n                return;\n              } else if (_util.canCrop(shape) && !_this.editor.isShapeOrAncestorLocked(shape)) {\n                var _info$shape;\n                _this.editor.mark(\"select and crop\");\n                _this.editor.select((_info$shape = info.shape) === null || _info$shape === void 0 ? void 0 : _info$shape.id);\n                _this.parent.transition(\"crop\", info);\n                return;\n              }\n            }\n            if (_this.shouldStartEditingShape(shape)) {\n              _this.startEditingShape(shape, info);\n            } else {\n              _this.handleDoubleClickOnCanvas(info);\n            }\n            break;\n          }\n        case \"handle\":\n          {\n            var _util2$onDoubleClickH;\n            if (_this.editor.isReadOnly) break;\n            var _shape = info.shape,\n              handle = info.handle;\n            var _util2 = _this.editor.getShapeUtil(_shape);\n            var changes = (_util2$onDoubleClickH = _util2.onDoubleClickHandle) === null || _util2$onDoubleClickH === void 0 ? void 0 : _util2$onDoubleClickH.call(_util2, _shape, handle);\n            if (changes) {\n              _this.editor.updateShapes([changes]);\n            } else {\n              if (_this.shouldStartEditingShape(_shape)) {\n                _this.startEditingShape(_shape, info);\n              }\n            }\n          }\n      }\n    });\n    _defineProperty(_assertThisInitialized(_this), \"onRightClick\", function (info) {\n      switch (info.target) {\n        case \"canvas\":\n          {\n            _this.editor.selectNone();\n            break;\n          }\n        case \"shape\":\n          {\n            var selectedIds = _this.editor.pageState.selectedIds;\n            var shape = info.shape;\n            var targetShape = _this.editor.getOutermostSelectableShape(shape, function (parent) {\n              return !_this.editor.isSelected(parent.id);\n            });\n            if (!selectedIds.includes(targetShape.id)) {\n              _this.editor.mark(\"selecting shape\");\n              _this.editor.setSelectedIds([targetShape.id]);\n            }\n            break;\n          }\n      }\n    });\n    _defineProperty(_assertThisInitialized(_this), \"onEnter\", function () {\n      _this.editor.setHoveredId(null);\n      _this.editor.setCursor({\n        type: \"default\"\n      });\n    });\n    _defineProperty(_assertThisInitialized(_this), \"onCancel\", function () {\n      if (_this.editor.focusLayerId !== _this.editor.currentPageId && _this.editor.selectedIds.length > 0) {\n        _this.editor.popFocusLayer();\n      } else {\n        _this.editor.mark(\"clearing selection\");\n        _this.editor.selectNone();\n      }\n    });\n    _defineProperty(_assertThisInitialized(_this), \"onKeyDown\", function (info) {\n      switch (info.code) {\n        case \"ArrowLeft\":\n        case \"ArrowRight\":\n        case \"ArrowUp\":\n        case \"ArrowDown\":\n          {\n            _this.nudgeSelectedShapes(false);\n            break;\n          }\n      }\n    });\n    _defineProperty(_assertThisInitialized(_this), \"onKeyRepeat\", function (info) {\n      switch (info.code) {\n        case \"ArrowLeft\":\n        case \"ArrowRight\":\n        case \"ArrowUp\":\n        case \"ArrowDown\":\n          {\n            _this.nudgeSelectedShapes(true);\n            break;\n          }\n      }\n    });\n    _defineProperty(_assertThisInitialized(_this), \"onKeyUp\", function (info) {\n      if (_this.editor.isReadOnly) {\n        switch (info.code) {\n          case \"Enter\":\n            {\n              if (_this.shouldStartEditingShape() && _this.editor.onlySelectedShape) {\n                _this.startEditingShape(_this.editor.onlySelectedShape, _objectSpread(_objectSpread({}, info), {}, {\n                  target: \"shape\",\n                  shape: _this.editor.onlySelectedShape\n                }));\n                return;\n              }\n              break;\n            }\n        }\n      } else {\n        switch (info.code) {\n          case \"Enter\":\n            {\n              var selectedShapes = _this.editor.selectedShapes;\n              if (selectedShapes.every(function (shape) {\n                return _this.editor.isShapeOfType(shape, GroupShapeUtil);\n              })) {\n                _this.editor.setSelectedIds(selectedShapes.flatMap(function (shape) {\n                  return _this.editor.getSortedChildIds(shape.id);\n                }));\n                return;\n              }\n              if (_this.shouldStartEditingShape() && _this.editor.onlySelectedShape) {\n                _this.startEditingShape(_this.editor.onlySelectedShape, _objectSpread(_objectSpread({}, info), {}, {\n                  target: \"shape\",\n                  shape: _this.editor.onlySelectedShape\n                }));\n                return;\n              }\n              if (_this.shouldEnterCropMode(info, false)) {\n                _this.parent.transition(\"crop\", info);\n              }\n              break;\n            }\n        }\n      }\n    });\n    return _this;\n  }\n  _createClass(Idle, [{\n    key: \"shouldStartEditingShape\",\n    value: function shouldStartEditingShape() {\n      var shape = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.editor.onlySelectedShape;\n      if (!shape) return false;\n      if (this.editor.isShapeOrAncestorLocked(shape) && shape.type !== \"embed\") return false;\n      var util = this.editor.getShapeUtil(shape);\n      return util.canEdit(shape);\n    }\n  }, {\n    key: \"shouldEnterCropMode\",\n    value: function shouldEnterCropMode(info, withCtrlKey) {\n      var singleShape = this.editor.onlySelectedShape;\n      if (!singleShape) return false;\n      if (this.editor.isShapeOrAncestorLocked(singleShape)) return false;\n      var shapeUtil = this.editor.getShapeUtil(singleShape);\n      if (withCtrlKey) {\n        return shapeUtil.canCrop(singleShape) && info.ctrlKey;\n      } else {\n        return shapeUtil.canCrop(singleShape);\n      }\n    }\n  }, {\n    key: \"startEditingShape\",\n    value: function startEditingShape(shape, info) {\n      if (this.editor.isShapeOrAncestorLocked(shape) && shape.type !== \"embed\") return;\n      this.editor.mark(\"editing shape\");\n      this.editor.setEditingId(shape.id);\n      this.parent.transition(\"editing_shape\", info);\n    }\n  }, {\n    key: \"handleDoubleClickOnCanvas\",\n    value: function handleDoubleClickOnCanvas(info) {\n      this.editor.mark(\"creating text shape\");\n      var id = createShapeId();\n      var _this$editor$inputs$c = this.editor.inputs.currentPagePoint,\n        x = _this$editor$inputs$c.x,\n        y = _this$editor$inputs$c.y;\n      this.editor.createShapes([{\n        id: id,\n        type: \"text\",\n        x: x,\n        y: y,\n        props: {\n          text: \"\",\n          autoSize: true\n        }\n      }]);\n      var shape = this.editor.getShapeById(id);\n      if (!shape) return;\n      var bounds = this.editor.getBounds(shape);\n      this.editor.updateShapes([{\n        id: id,\n        type: \"text\",\n        x: shape.x - bounds.width / 2,\n        y: shape.y - bounds.height / 2\n      }]);\n      this.editor.setEditingId(id);\n      this.editor.select(id);\n      this.parent.transition(\"editing_shape\", info);\n    }\n  }, {\n    key: \"nudgeSelectedShapes\",\n    value: function nudgeSelectedShapes() {\n      var ephemeral = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var keys = this.editor.inputs.keys;\n      var shiftKey = keys.has(\"ShiftLeft\");\n      var delta = new Vec2d(0, 0);\n      if (keys.has(\"ArrowLeft\")) delta.x -= 1;\n      if (keys.has(\"ArrowRight\")) delta.x += 1;\n      if (keys.has(\"ArrowUp\")) delta.y -= 1;\n      if (keys.has(\"ArrowDown\")) delta.y += 1;\n      if (delta.equals(new Vec2d(0, 0))) return;\n      if (!ephemeral) this.editor.mark(\"nudge shapes\");\n      this.editor.nudgeShapes(this.editor.selectedIds, delta, shiftKey);\n    }\n  }]);\n  return Idle;\n}(StateNode);\n_defineProperty(Idle, \"id\", \"idle\");\nexport { Idle };","map":{"version":3,"names":["Vec2d","createShapeId","debugFlags","GroupShapeUtil","StateNode","Idle","_StateNode","_inherits","_super","_createSuper","_this","_classCallCheck","_len","arguments","length","args","Array","_key","call","apply","concat","_defineProperty","_assertThisInitialized","window","navigator","userAgent","toLowerCase","indexOf","info","target","_this$editor","editor","selectedIds","focusLayerId","hoveringShape","getOutermostSelectableShape","shape","parent","includes","id","setHoveredId","debugCursors","value","type","cursorType","props","text","setCursor","e","console","error","isMenuOpen","shouldEnterCropMode","ctrlKey","isDarwin","inputs","keys","has","isShapeOrAncestorLocked","transition","isReadOnly","altKey","handle","phase","handleDoubleClickOnCanvas","onlySelectedShape","util","getShapeUtil","_util$onDoubleClickEd","change","onDoubleClickEdge","mark","updateShapes","canCrop","shouldStartEditingShape","startEditingShape","onDoubleClick","_util$onDoubleClick","_info$shape","select","_util2$onDoubleClickH","changes","onDoubleClickHandle","selectNone","pageState","targetShape","isSelected","setSelectedIds","currentPageId","popFocusLayer","code","nudgeSelectedShapes","_objectSpread","selectedShapes","every","isShapeOfType","flatMap","getSortedChildIds","_createClass","key","undefined","canEdit","withCtrlKey","singleShape","shapeUtil","setEditingId","_this$editor$inputs$c","currentPagePoint","x","y","createShapes","autoSize","getShapeById","bounds","getBounds","width","height","ephemeral","shiftKey","delta","equals","nudgeShapes"],"sources":["/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@tldraw/editor/src/lib/editor/tools/SelectTool/children/Idle.ts"],"sourcesContent":["import { Vec2d } from '@tldraw/primitives'\nimport { TLGeoShape, TLShape, TLTextShape, createShapeId } from '@tldraw/tlschema'\nimport { debugFlags } from '../../../../utils/debug-flags'\nimport { GroupShapeUtil } from '../../../shapes/group/GroupShapeUtil'\nimport {\n\tTLClickEventInfo,\n\tTLEventHandlers,\n\tTLKeyboardEventInfo,\n\tTLPointerEventInfo,\n} from '../../../types/event-types'\nimport { StateNode } from '../../StateNode'\n\nexport class Idle extends StateNode {\n\tstatic override id = 'idle'\n\n\tisDarwin = window.navigator.userAgent.toLowerCase().indexOf('mac') > -1\n\n\tonPointerEnter: TLEventHandlers['onPointerEnter'] = (info) => {\n\t\tswitch (info.target) {\n\t\t\tcase 'canvas': {\n\t\t\t\t// noop\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase 'shape': {\n\t\t\t\tconst { selectedIds, focusLayerId } = this.editor\n\t\t\t\tconst hoveringShape = this.editor.getOutermostSelectableShape(\n\t\t\t\t\tinfo.shape,\n\t\t\t\t\t(parent) => !selectedIds.includes(parent.id)\n\t\t\t\t)\n\t\t\t\tif (hoveringShape.id !== focusLayerId) {\n\t\t\t\t\tthis.editor.setHoveredId(hoveringShape.id)\n\t\t\t\t}\n\n\t\t\t\t// Custom cursor debugging!\n\t\t\t\t// Change the cursor to the type specified by the shape's text label\n\t\t\t\tif (debugFlags.debugCursors.value) {\n\t\t\t\t\tif (hoveringShape.type !== 'geo') break\n\t\t\t\t\tconst cursorType = (hoveringShape as TLGeoShape).props.text\n\t\t\t\t\ttry {\n\t\t\t\t\t\tthis.editor.setCursor({ type: cursorType })\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tconsole.error(`Cursor type not recognized: '${cursorType}'`)\n\t\t\t\t\t\tthis.editor.setCursor({ type: 'default' })\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\tonPointerLeave: TLEventHandlers['onPointerLeave'] = (info) => {\n\t\tswitch (info.target) {\n\t\t\tcase 'shape': {\n\t\t\t\tthis.editor.setHoveredId(null)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\tonPointerDown: TLEventHandlers['onPointerDown'] = (info) => {\n\t\tif (this.editor.isMenuOpen) return\n\n\t\tconst shouldEnterCropMode = this.shouldEnterCropMode(info, true)\n\n\t\tif (info.ctrlKey && !shouldEnterCropMode) {\n\t\t\t// On Mac, you can right click using the Control keys + Click.\n\t\t\tif (info.target === 'shape' && this.isDarwin && this.editor.inputs.keys.has('ControlLeft')) {\n\t\t\t\tif (!this.editor.isShapeOrAncestorLocked(info.shape)) {\n\t\t\t\t\tthis.parent.transition('pointing_shape', info)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.parent.transition('brushing', info)\n\t\t\treturn\n\t\t}\n\n\t\tswitch (info.target) {\n\t\t\tcase 'canvas': {\n\t\t\t\tthis.parent.transition('pointing_canvas', info)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase 'shape': {\n\t\t\t\tif (this.editor.isShapeOrAncestorLocked(info.shape)) break\n\t\t\t\tthis.parent.transition('pointing_shape', info)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase 'handle': {\n\t\t\t\tif (this.editor.isReadOnly) break\n\t\t\t\tif (this.editor.inputs.altKey) {\n\t\t\t\t\tthis.parent.transition('pointing_shape', info)\n\t\t\t\t} else {\n\t\t\t\t\tthis.parent.transition('pointing_handle', info)\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase 'selection': {\n\t\t\t\tswitch (info.handle) {\n\t\t\t\t\tcase 'mobile_rotate':\n\t\t\t\t\tcase 'top_left_rotate':\n\t\t\t\t\tcase 'top_right_rotate':\n\t\t\t\t\tcase 'bottom_left_rotate':\n\t\t\t\t\tcase 'bottom_right_rotate': {\n\t\t\t\t\t\tthis.parent.transition('pointing_rotate_handle', info)\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t\tcase 'top':\n\t\t\t\t\tcase 'right':\n\t\t\t\t\tcase 'bottom':\n\t\t\t\t\tcase 'left': {\n\t\t\t\t\t\tif (shouldEnterCropMode) {\n\t\t\t\t\t\t\tthis.parent.transition('pointing_crop_handle', info)\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis.parent.transition('pointing_resize_handle', info)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t\tcase 'top_left':\n\t\t\t\t\tcase 'top_right':\n\t\t\t\t\tcase 'bottom_left':\n\t\t\t\t\tcase 'bottom_right': {\n\t\t\t\t\t\tif (shouldEnterCropMode) {\n\t\t\t\t\t\t\tthis.parent.transition('pointing_crop_handle', info)\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis.parent.transition('pointing_resize_handle', info)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t\tdefault: {\n\t\t\t\t\t\tthis.parent.transition('pointing_selection', info)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\tonDoubleClick: TLEventHandlers['onDoubleClick'] = (info) => {\n\t\tif (info.phase !== 'up') return\n\n\t\tswitch (info.target) {\n\t\t\tcase 'canvas': {\n\t\t\t\t// Create text shape and transition to editing_shape\n\t\t\t\tif (this.editor.isReadOnly) break\n\t\t\t\tthis.handleDoubleClickOnCanvas(info)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase 'selection': {\n\t\t\t\tif (this.editor.isReadOnly) break\n\n\t\t\t\tconst { onlySelectedShape } = this.editor\n\t\t\t\tif (onlySelectedShape) {\n\t\t\t\t\tconst util = this.editor.getShapeUtil(onlySelectedShape)\n\n\t\t\t\t\t// Test edges for an onDoubleClickEdge handler\n\t\t\t\t\tif (\n\t\t\t\t\t\tinfo.handle === 'right' ||\n\t\t\t\t\t\tinfo.handle === 'left' ||\n\t\t\t\t\t\tinfo.handle === 'top' ||\n\t\t\t\t\t\tinfo.handle === 'bottom'\n\t\t\t\t\t) {\n\t\t\t\t\t\tconst change = util.onDoubleClickEdge?.(onlySelectedShape)\n\t\t\t\t\t\tif (change) {\n\t\t\t\t\t\t\tthis.editor.mark('double click edge')\n\t\t\t\t\t\t\tthis.editor.updateShapes([change])\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// For corners OR edges\n\t\t\t\t\tif (\n\t\t\t\t\t\tutil.canCrop(onlySelectedShape) &&\n\t\t\t\t\t\t!this.editor.isShapeOrAncestorLocked(onlySelectedShape)\n\t\t\t\t\t) {\n\t\t\t\t\t\tthis.parent.transition('crop', info)\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\n\t\t\t\t\tif (this.shouldStartEditingShape(onlySelectedShape)) {\n\t\t\t\t\t\tthis.startEditingShape(onlySelectedShape, info)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase 'shape': {\n\t\t\t\tconst { shape } = info\n\t\t\t\tconst util = this.editor.getShapeUtil(shape)\n\n\t\t\t\t// Allow playing videos and embeds\n\t\t\t\tif (shape.type !== 'video' && shape.type !== 'embed' && this.editor.isReadOnly) break\n\n\t\t\t\tif (util.onDoubleClick) {\n\t\t\t\t\t// Call the shape's double click handler\n\t\t\t\t\tconst change = util.onDoubleClick?.(shape)\n\t\t\t\t\tif (change) {\n\t\t\t\t\t\tthis.editor.updateShapes([change])\n\t\t\t\t\t\treturn\n\t\t\t\t\t} else if (util.canCrop(shape) && !this.editor.isShapeOrAncestorLocked(shape)) {\n\t\t\t\t\t\t// crop on double click\n\t\t\t\t\t\tthis.editor.mark('select and crop')\n\t\t\t\t\t\tthis.editor.select(info.shape?.id)\n\t\t\t\t\t\tthis.parent.transition('crop', info)\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// If the shape can edit, then begin editing\n\t\t\t\tif (this.shouldStartEditingShape(shape)) {\n\t\t\t\t\tthis.startEditingShape(shape, info)\n\t\t\t\t} else {\n\t\t\t\t\t// If the shape's double click handler has not created a change,\n\t\t\t\t\t// and if the shape cannot edit, then create a text shape and\n\t\t\t\t\t// begin editing the text shape\n\t\t\t\t\tthis.handleDoubleClickOnCanvas(info)\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase 'handle': {\n\t\t\t\tif (this.editor.isReadOnly) break\n\t\t\t\tconst { shape, handle } = info\n\n\t\t\t\tconst util = this.editor.getShapeUtil(shape)\n\t\t\t\tconst changes = util.onDoubleClickHandle?.(shape, handle)\n\n\t\t\t\tif (changes) {\n\t\t\t\t\tthis.editor.updateShapes([changes])\n\t\t\t\t} else {\n\t\t\t\t\t// If the shape's double click handler has not created a change,\n\t\t\t\t\t// and if the shape can edit, then begin editing the shape.\n\t\t\t\t\tif (this.shouldStartEditingShape(shape)) {\n\t\t\t\t\t\tthis.startEditingShape(shape, info)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tonRightClick: TLEventHandlers['onRightClick'] = (info) => {\n\t\tswitch (info.target) {\n\t\t\tcase 'canvas': {\n\t\t\t\tthis.editor.selectNone()\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase 'shape': {\n\t\t\t\tconst { selectedIds } = this.editor.pageState\n\t\t\t\tconst { shape } = info\n\n\t\t\t\tconst targetShape = this.editor.getOutermostSelectableShape(\n\t\t\t\t\tshape,\n\t\t\t\t\t(parent) => !this.editor.isSelected(parent.id)\n\t\t\t\t)\n\n\t\t\t\tif (!selectedIds.includes(targetShape.id)) {\n\t\t\t\t\tthis.editor.mark('selecting shape')\n\t\t\t\t\tthis.editor.setSelectedIds([targetShape.id])\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\tonEnter = () => {\n\t\tthis.editor.setHoveredId(null)\n\t\tthis.editor.setCursor({ type: 'default' })\n\t}\n\n\tonCancel: TLEventHandlers['onCancel'] = () => {\n\t\tif (\n\t\t\tthis.editor.focusLayerId !== this.editor.currentPageId &&\n\t\t\tthis.editor.selectedIds.length > 0\n\t\t) {\n\t\t\tthis.editor.popFocusLayer()\n\t\t} else {\n\t\t\tthis.editor.mark('clearing selection')\n\t\t\tthis.editor.selectNone()\n\t\t}\n\t}\n\n\tonKeyDown: TLEventHandlers['onKeyDown'] = (info) => {\n\t\tswitch (info.code) {\n\t\t\tcase 'ArrowLeft':\n\t\t\tcase 'ArrowRight':\n\t\t\tcase 'ArrowUp':\n\t\t\tcase 'ArrowDown': {\n\t\t\t\tthis.nudgeSelectedShapes(false)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\tonKeyRepeat: TLEventHandlers['onKeyDown'] = (info) => {\n\t\tswitch (info.code) {\n\t\t\tcase 'ArrowLeft':\n\t\t\tcase 'ArrowRight':\n\t\t\tcase 'ArrowUp':\n\t\t\tcase 'ArrowDown': {\n\t\t\t\tthis.nudgeSelectedShapes(true)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\tonKeyUp = (info: TLKeyboardEventInfo) => {\n\t\tif (this.editor.isReadOnly) {\n\t\t\tswitch (info.code) {\n\t\t\t\tcase 'Enter': {\n\t\t\t\t\tif (this.shouldStartEditingShape() && this.editor.onlySelectedShape) {\n\t\t\t\t\t\tthis.startEditingShape(this.editor.onlySelectedShape, {\n\t\t\t\t\t\t\t...info,\n\t\t\t\t\t\t\ttarget: 'shape',\n\t\t\t\t\t\t\tshape: this.editor.onlySelectedShape,\n\t\t\t\t\t\t})\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tswitch (info.code) {\n\t\t\t\tcase 'Enter': {\n\t\t\t\t\tconst { selectedShapes } = this.editor\n\n\t\t\t\t\tif (selectedShapes.every((shape) => this.editor.isShapeOfType(shape, GroupShapeUtil))) {\n\t\t\t\t\t\tthis.editor.setSelectedIds(\n\t\t\t\t\t\t\tselectedShapes.flatMap((shape) => this.editor.getSortedChildIds(shape.id))\n\t\t\t\t\t\t)\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\n\t\t\t\t\tif (this.shouldStartEditingShape() && this.editor.onlySelectedShape) {\n\t\t\t\t\t\tthis.startEditingShape(this.editor.onlySelectedShape, {\n\t\t\t\t\t\t\t...info,\n\t\t\t\t\t\t\ttarget: 'shape',\n\t\t\t\t\t\t\tshape: this.editor.onlySelectedShape,\n\t\t\t\t\t\t})\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\n\t\t\t\t\tif (this.shouldEnterCropMode(info, false)) {\n\t\t\t\t\t\tthis.parent.transition('crop', info)\n\t\t\t\t\t}\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate shouldStartEditingShape(shape: TLShape | null = this.editor.onlySelectedShape): boolean {\n\t\tif (!shape) return false\n\t\tif (this.editor.isShapeOrAncestorLocked(shape) && shape.type !== 'embed') return false\n\n\t\tconst util = this.editor.getShapeUtil(shape)\n\t\treturn util.canEdit(shape)\n\t}\n\n\tprivate shouldEnterCropMode(\n\t\tinfo: TLPointerEventInfo | TLKeyboardEventInfo,\n\t\twithCtrlKey: boolean\n\t): boolean {\n\t\tconst singleShape = this.editor.onlySelectedShape\n\t\tif (!singleShape) return false\n\t\tif (this.editor.isShapeOrAncestorLocked(singleShape)) return false\n\n\t\tconst shapeUtil = this.editor.getShapeUtil(singleShape)\n\t\t// Should the Ctrl key be pressed to enter crop mode\n\t\tif (withCtrlKey) {\n\t\t\treturn shapeUtil.canCrop(singleShape) && info.ctrlKey\n\t\t} else {\n\t\t\treturn shapeUtil.canCrop(singleShape)\n\t\t}\n\t}\n\n\tprivate startEditingShape(shape: TLShape, info: TLClickEventInfo | TLKeyboardEventInfo) {\n\t\tif (this.editor.isShapeOrAncestorLocked(shape) && shape.type !== 'embed') return\n\t\tthis.editor.mark('editing shape')\n\t\tthis.editor.setEditingId(shape.id)\n\t\tthis.parent.transition('editing_shape', info)\n\t}\n\n\thandleDoubleClickOnCanvas(info: TLClickEventInfo) {\n\t\tthis.editor.mark('creating text shape')\n\n\t\tconst id = createShapeId()\n\n\t\tconst { x, y } = this.editor.inputs.currentPagePoint\n\n\t\tthis.editor.createShapes<TLTextShape>([\n\t\t\t{\n\t\t\t\tid,\n\t\t\t\ttype: 'text',\n\t\t\t\tx,\n\t\t\t\ty,\n\t\t\t\tprops: {\n\t\t\t\t\ttext: '',\n\t\t\t\t\tautoSize: true,\n\t\t\t\t},\n\t\t\t},\n\t\t])\n\n\t\tconst shape = this.editor.getShapeById(id)\n\t\tif (!shape) return\n\n\t\tconst bounds = this.editor.getBounds(shape)\n\n\t\tthis.editor.updateShapes([\n\t\t\t{\n\t\t\t\tid,\n\t\t\t\ttype: 'text',\n\t\t\t\tx: shape.x - bounds.width / 2,\n\t\t\t\ty: shape.y - bounds.height / 2,\n\t\t\t},\n\t\t])\n\n\t\tthis.editor.setEditingId(id)\n\t\tthis.editor.select(id)\n\t\tthis.parent.transition('editing_shape', info)\n\t}\n\n\tprivate nudgeSelectedShapes(ephemeral = false) {\n\t\tconst {\n\t\t\teditor: {\n\t\t\t\tinputs: { keys },\n\t\t\t},\n\t\t} = this\n\n\t\t// We want to use the \"actual\" shift key state,\n\t\t// not the one that's in the editor.inputs.shiftKey,\n\t\t// because that one uses a short timeout on release\n\t\tconst shiftKey = keys.has('ShiftLeft')\n\n\t\tconst delta = new Vec2d(0, 0)\n\n\t\tif (keys.has('ArrowLeft')) delta.x -= 1\n\t\tif (keys.has('ArrowRight')) delta.x += 1\n\t\tif (keys.has('ArrowUp')) delta.y -= 1\n\t\tif (keys.has('ArrowDown')) delta.y += 1\n\n\t\tif (delta.equals(new Vec2d(0, 0))) return\n\n\t\tif (!ephemeral) this.editor.mark('nudge shapes')\n\n\t\tthis.editor.nudgeShapes(this.editor.selectedIds, delta, shiftKey)\n\t}\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}