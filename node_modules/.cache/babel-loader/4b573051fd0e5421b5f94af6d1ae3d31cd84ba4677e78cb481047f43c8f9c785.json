{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _slicedToArray from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _objectSpread from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _classCallCheck from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _defineProperty from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport { filterEntries, objectMapEntries, objectMapFromEntries, objectMapKeys, objectMapValues, throttledRaf } from \"@tldraw/utils\";\nimport { nanoid } from \"nanoid\";\nimport { atom, computed, reactor, transact } from \"signia\";\nimport { Cache } from \"./Cache.mjs\";\nimport { StoreQueries } from \"./StoreQueries.mjs\";\nimport { devFreeze } from \"./devFreeze.mjs\";\nvar Store = /*#__PURE__*/function () {\n  function Store(config) {\n    var _this = this;\n    _classCallCheck(this, Store);\n    /**\n     * The random id of the store.\n     */\n    _defineProperty(this, \"id\", nanoid());\n    /**\n     * An atom containing the store's atoms.\n     *\n     * @internal\n     * @readonly\n     */\n    _defineProperty(this, \"atoms\", atom(\"store_atoms\", {}));\n    /**\n     * An atom containing the store's history.\n     *\n     * @public\n     * @readonly\n     */\n    _defineProperty(this, \"history\", atom(\"history\", 0, {\n      historyLength: 1e3\n    }));\n    /**\n     * A StoreQueries instance for this store.\n     *\n     * @public\n     * @readonly\n     */\n    _defineProperty(this, \"query\", new StoreQueries(this.atoms, this.history));\n    /**\n     * A set containing listeners that have been added to this store.\n     *\n     * @internal\n     */\n    _defineProperty(this, \"listeners\", /* @__PURE__ */new Set());\n    /**\n     * An array of history entries that have not yet been flushed.\n     *\n     * @internal\n     */\n    _defineProperty(this, \"historyAccumulator\", new HistoryAccumulator());\n    /**\n     * A reactor that responds to changes to the history by squashing the accumulated history and\n     * notifying listeners of the changes.\n     *\n     * @internal\n     */\n    _defineProperty(this, \"historyReactor\", void 0);\n    _defineProperty(this, \"schema\", void 0);\n    _defineProperty(this, \"props\", void 0);\n    _defineProperty(this, \"scopedTypes\", void 0);\n    /**\n     * A callback fired after a record is created. Use this to perform related updates to other\n     * records in the store.\n     *\n     * @param record - The record to be created\n     */\n    _defineProperty(this, \"onAfterCreate\", void 0);\n    /**\n     * A callback fired after each record's change.\n     *\n     * @param prev - The previous value, if any.\n     * @param next - The next value.\n     */\n    _defineProperty(this, \"onAfterChange\", void 0);\n    /**\n     * A callback fired before a record is deleted.\n     *\n     * @param prev - The record that will be deleted.\n     */\n    _defineProperty(this, \"onBeforeDelete\", void 0);\n    /**\n     * A callback fired after a record is deleted.\n     *\n     * @param prev - The record that will be deleted.\n     */\n    _defineProperty(this, \"onAfterDelete\", void 0);\n    // used to avoid running callbacks when rolling back changes in sync client\n    _defineProperty(this, \"_runCallbacks\", true);\n    /**\n     * Add some records to the store. It's an error if they already exist.\n     *\n     * @param records - The records to add.\n     * @public\n     */\n    _defineProperty(this, \"put\", function (records, phaseOverride) {\n      transact(function () {\n        var updates = {};\n        var additions = {};\n        var currentMap = _this.atoms.__unsafe__getWithoutCapture();\n        var map = null;\n        var record;\n        var didChange = false;\n        for (var i = 0, n = records.length; i < n; i++) {\n          var _map;\n          record = records[i];\n          var recordAtom = ((_map = map) !== null && _map !== void 0 ? _map : currentMap)[record.id];\n          if (recordAtom) {\n            var initialValue = recordAtom.__unsafe__getWithoutCapture();\n            record = _this.schema.validateRecord(_this, record, phaseOverride !== null && phaseOverride !== void 0 ? phaseOverride : \"updateRecord\", initialValue);\n            recordAtom.set(devFreeze(record));\n            var finalValue = recordAtom.__unsafe__getWithoutCapture();\n            if (initialValue !== finalValue) {\n              didChange = true;\n              updates[record.id] = [initialValue, finalValue];\n            }\n          } else {\n            didChange = true;\n            record = _this.schema.validateRecord(_this, record, phaseOverride !== null && phaseOverride !== void 0 ? phaseOverride : \"createRecord\", null);\n            additions[record.id] = record;\n            if (!map) {\n              map = _objectSpread({}, currentMap);\n            }\n            map[record.id] = atom(\"atom:\" + record.id, record);\n          }\n        }\n        if (map) {\n          _this.atoms.set(map);\n        }\n        if (!didChange) return;\n        _this.updateHistory({\n          added: additions,\n          updated: updates,\n          removed: {}\n        });\n        var onAfterCreate = _this.onAfterCreate,\n          onAfterChange = _this.onAfterChange;\n        if (onAfterCreate && _this._runCallbacks) {\n          Object.values(additions).forEach(function (record2) {\n            onAfterCreate(record2);\n          });\n        }\n        if (onAfterChange && _this._runCallbacks) {\n          Object.values(updates).forEach(function (_ref) {\n            var _ref2 = _slicedToArray(_ref, 2),\n              from = _ref2[0],\n              to = _ref2[1];\n            onAfterChange(from, to);\n          });\n        }\n      });\n    });\n    /**\n     * Remove some records from the store via their ids.\n     *\n     * @param ids - The ids of the records to remove.\n     * @public\n     */\n    _defineProperty(this, \"remove\", function (ids) {\n      transact(function () {\n        if (_this.onBeforeDelete && _this._runCallbacks) {\n          var _iterator = _createForOfIteratorHelper(ids),\n            _step;\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var id = _step.value;\n              var atom2 = _this.atoms.__unsafe__getWithoutCapture()[id];\n              if (!atom2) continue;\n              _this.onBeforeDelete(atom2.value);\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n        }\n        var removed = void 0;\n        _this.atoms.update(function (atoms) {\n          var _result;\n          var result = void 0;\n          var _iterator2 = _createForOfIteratorHelper(ids),\n            _step2;\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var _id = _step2.value;\n              if (!(_id in atoms)) continue;\n              if (!result) result = _objectSpread({}, atoms);\n              if (!removed) removed = {};\n              delete result[_id];\n              removed[_id] = atoms[_id].value;\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n          return (_result = result) !== null && _result !== void 0 ? _result : atoms;\n        });\n        if (!removed) return;\n        _this.updateHistory({\n          added: {},\n          updated: {},\n          removed: removed\n        });\n        if (_this.onAfterDelete && _this._runCallbacks) {\n          for (var i = 0, n = ids.length; i < n; i++) {\n            _this.onAfterDelete(removed[ids[i]]);\n          }\n        }\n      });\n    });\n    /**\n     * Get the value of a store record by its id.\n     *\n     * @param id - The id of the record to get.\n     * @public\n     */\n    _defineProperty(this, \"get\", function (id) {\n      var _this$atoms$value$id;\n      return (_this$atoms$value$id = _this.atoms.value[id]) === null || _this$atoms$value$id === void 0 ? void 0 : _this$atoms$value$id.value;\n    });\n    /**\n     * Get the value of a store record by its id without updating its epoch.\n     *\n     * @param id - The id of the record to get.\n     * @public\n     */\n    _defineProperty(this, \"unsafeGetWithoutCapture\", function (id) {\n      var _this$atoms$value$id2;\n      return (_this$atoms$value$id2 = _this.atoms.value[id]) === null || _this$atoms$value$id2 === void 0 ? void 0 : _this$atoms$value$id2.__unsafe__getWithoutCapture();\n    });\n    /**\n     * Creates a JSON payload from the record store.\n     *\n     * @param scope - The scope of records to serialize. Defaults to 'document'.\n     * @returns The record store snapshot as a JSON payload.\n     */\n    _defineProperty(this, \"serialize\", function () {\n      var scope = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"document\";\n      var result = {};\n      var _iterator3 = _createForOfIteratorHelper(objectMapEntries(_this.atoms.value)),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var _step3$value = _slicedToArray(_step3.value, 2),\n            id = _step3$value[0],\n            atom2 = _step3$value[1];\n          var record = atom2.value;\n          if (scope === \"all\" || _this.scopedTypes[scope].has(record.typeName)) {\n            result[id] = record;\n          }\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n      return result;\n    });\n    /**\n     * Get an array of all values in the store.\n     *\n     * @returns An array of all values in the store.\n     * @public\n     */\n    _defineProperty(this, \"allRecords\", function () {\n      return objectMapValues(_this.atoms.value).map(function (atom2) {\n        return atom2.value;\n      });\n    });\n    /**\n     * Removes all records from the store.\n     *\n     * @public\n     */\n    _defineProperty(this, \"clear\", function () {\n      _this.remove(objectMapKeys(_this.atoms.value));\n    });\n    /**\n     * Update a record. To update multiple records at once, use the `update` method of the\n     * `TypedStore` class.\n     *\n     * @param id - The id of the record to update.\n     * @param updater - A function that updates the record.\n     */\n    _defineProperty(this, \"update\", function (id, updater) {\n      var atom2 = _this.atoms.value[id];\n      if (!atom2) {\n        console.error(\"Record \".concat(id, \" not found. This is probably an error\"));\n        return;\n      }\n      _this.put([updater(atom2.__unsafe__getWithoutCapture())]);\n    });\n    /**\n     * Get whether the record store has a id.\n     *\n     * @param id - The id of the record to check.\n     * @public\n     */\n    _defineProperty(this, \"has\", function (id) {\n      return !!_this.atoms.value[id];\n    });\n    /**\n     * Add a new listener to the store.\n     *\n     * @param onHistory - The listener to call when the store updates.\n     * @param filters - Filters to apply to the listener.\n     * @returns A function to remove the listener.\n     */\n    _defineProperty(this, \"listen\", function (onHistory, filters) {\n      var _filters$source, _filters$scope;\n      _this._flushHistory();\n      var listener = {\n        onHistory: onHistory,\n        filters: {\n          source: (_filters$source = filters === null || filters === void 0 ? void 0 : filters.source) !== null && _filters$source !== void 0 ? _filters$source : \"all\",\n          scope: (_filters$scope = filters === null || filters === void 0 ? void 0 : filters.scope) !== null && _filters$scope !== void 0 ? _filters$scope : \"all\"\n        }\n      };\n      _this.listeners.add(listener);\n      if (!_this.historyReactor.scheduler.isActivelyListening) {\n        _this.historyReactor.start();\n      }\n      return function () {\n        _this.listeners.delete(listener);\n        if (_this.listeners.size === 0) {\n          _this.historyReactor.stop();\n        }\n      };\n    });\n    _defineProperty(this, \"isMergingRemoteChanges\", false);\n    /**\n     * Merge changes from a remote source without triggering listeners.\n     *\n     * @param fn - A function that merges the external changes.\n     * @public\n     */\n    _defineProperty(this, \"mergeRemoteChanges\", function (fn) {\n      if (_this.isMergingRemoteChanges) {\n        return fn();\n      }\n      try {\n        _this.isMergingRemoteChanges = true;\n        transact(fn);\n      } finally {\n        _this.isMergingRemoteChanges = false;\n      }\n    });\n    /**\n     * Create a computed cache.\n     *\n     * @param name - The name of the derivation cache.\n     * @param derive - A function used to derive the value of the cache.\n     * @public\n     */\n    _defineProperty(this, \"createComputedCache\", function (name, derive) {\n      var cache = new Cache();\n      return {\n        get: function get(id) {\n          var atom2 = _this.atoms.value[id];\n          if (!atom2) {\n            return void 0;\n          }\n          return cache.get(atom2, function () {\n            return computed(name + \":\" + id, function () {\n              return derive(atom2.value);\n            });\n          }).value;\n        }\n      };\n    });\n    /**\n     * Create a computed cache from a selector\n     *\n     * @param name - The name of the derivation cache.\n     * @param selector - A function that returns a subset of the original shape\n     * @param derive - A function used to derive the value of the cache.\n     * @public\n     */\n    _defineProperty(this, \"createSelectedComputedCache\", function (name, selector, derive) {\n      var cache = new Cache();\n      return {\n        get: function get(id) {\n          var atom2 = _this.atoms.value[id];\n          if (!atom2) {\n            return void 0;\n          }\n          var d = computed(name + \":\" + id + \":selector\", function () {\n            return selector(atom2.value);\n          });\n          return cache.get(atom2, function () {\n            return computed(name + \":\" + id, function () {\n              return derive(d.value);\n            });\n          }).value;\n        }\n      };\n    });\n    _defineProperty(this, \"_integrityChecker\", void 0);\n    _defineProperty(this, \"_isPossiblyCorrupted\", false);\n    var initialData = config.initialData,\n      schema = config.schema;\n    this.schema = schema;\n    this.props = config.props;\n    if (initialData) {\n      this.atoms.set(objectMapFromEntries(objectMapEntries(initialData).map(function (_ref3) {\n        var _ref4 = _slicedToArray(_ref3, 2),\n          id = _ref4[0],\n          record = _ref4[1];\n        return [id, atom(\"atom:\" + id, _this.schema.validateRecord(_this, record, \"initialize\", null))];\n      })));\n    }\n    this.historyReactor = reactor(\"Store.historyReactor\", function () {\n      _this.history.value;\n      _this._flushHistory();\n    }, {\n      scheduleEffect: function scheduleEffect(cb) {\n        return throttledRaf(cb);\n      }\n    });\n    this.scopedTypes = {\n      document: new Set(objectMapValues(this.schema.types).filter(function (t) {\n        return t.scope === \"document\";\n      }).map(function (t) {\n        return t.typeName;\n      })),\n      session: new Set(objectMapValues(this.schema.types).filter(function (t) {\n        return t.scope === \"session\";\n      }).map(function (t) {\n        return t.typeName;\n      })),\n      presence: new Set(objectMapValues(this.schema.types).filter(function (t) {\n        return t.scope === \"presence\";\n      }).map(function (t) {\n        return t.typeName;\n      }))\n    };\n  }\n  _createClass(Store, [{\n    key: \"_flushHistory\",\n    value: function _flushHistory() {\n      if (this.historyAccumulator.hasChanges()) {\n        var entries = this.historyAccumulator.flush();\n        var _iterator4 = _createForOfIteratorHelper(entries),\n          _step4;\n        try {\n          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n            var _step4$value = _step4.value,\n              changes = _step4$value.changes,\n              source = _step4$value.source;\n            var instanceChanges = null;\n            var documentChanges = null;\n            var presenceChanges = null;\n            var _iterator5 = _createForOfIteratorHelper(this.listeners),\n              _step5;\n            try {\n              for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n                var _step5$value = _step5.value,\n                  onHistory = _step5$value.onHistory,\n                  filters = _step5$value.filters;\n                if (filters.source !== \"all\" && filters.source !== source) {\n                  continue;\n                }\n                if (filters.scope !== \"all\") {\n                  if (filters.scope === \"document\") {\n                    var _documentChanges;\n                    (_documentChanges = documentChanges) !== null && _documentChanges !== void 0 ? _documentChanges : documentChanges = this.filterChangesByScope(changes, \"document\");\n                    if (!documentChanges) continue;\n                    onHistory({\n                      changes: documentChanges,\n                      source: source\n                    });\n                  } else if (filters.scope === \"session\") {\n                    var _instanceChanges;\n                    (_instanceChanges = instanceChanges) !== null && _instanceChanges !== void 0 ? _instanceChanges : instanceChanges = this.filterChangesByScope(changes, \"session\");\n                    if (!instanceChanges) continue;\n                    onHistory({\n                      changes: instanceChanges,\n                      source: source\n                    });\n                  } else {\n                    var _presenceChanges;\n                    (_presenceChanges = presenceChanges) !== null && _presenceChanges !== void 0 ? _presenceChanges : presenceChanges = this.filterChangesByScope(changes, \"presence\");\n                    if (!presenceChanges) continue;\n                    onHistory({\n                      changes: presenceChanges,\n                      source: source\n                    });\n                  }\n                } else {\n                  onHistory({\n                    changes: changes,\n                    source: source\n                  });\n                }\n              }\n            } catch (err) {\n              _iterator5.e(err);\n            } finally {\n              _iterator5.f();\n            }\n          }\n        } catch (err) {\n          _iterator4.e(err);\n        } finally {\n          _iterator4.f();\n        }\n      }\n    }\n    /**\n     * Filters out non-document changes from a diff. Returns null if there are no changes left.\n     * @param change - the records diff\n     * @returns\n     */\n  }, {\n    key: \"filterChangesByScope\",\n    value: function filterChangesByScope(change, scope) {\n      var _this2 = this;\n      var result = {\n        added: filterEntries(change.added, function (_, r) {\n          return _this2.scopedTypes[scope].has(r.typeName);\n        }),\n        updated: filterEntries(change.updated, function (_, r) {\n          return _this2.scopedTypes[scope].has(r[1].typeName);\n        }),\n        removed: filterEntries(change.removed, function (_, r) {\n          return _this2.scopedTypes[scope].has(r.typeName);\n        })\n      };\n      if (Object.keys(result.added).length === 0 && Object.keys(result.updated).length === 0 && Object.keys(result.removed).length === 0) {\n        return null;\n      }\n      return result;\n    }\n    /**\n     * Update the history with a diff of changes.\n     *\n     * @param changes - The changes to add to the history.\n     */\n  }, {\n    key: \"updateHistory\",\n    value: function updateHistory(changes) {\n      this.historyAccumulator.add({\n        changes: changes,\n        source: this.isMergingRemoteChanges ? \"remote\" : \"user\"\n      });\n      if (this.listeners.size === 0) {\n        this.historyAccumulator.clear();\n      }\n      this.history.set(this.history.value + 1, changes);\n    }\n  }, {\n    key: \"validate\",\n    value: function validate(phase) {\n      var _this3 = this;\n      this.allRecords().forEach(function (record) {\n        return _this3.schema.validateRecord(_this3, record, phase, null);\n      });\n    }\n  }, {\n    key: \"getSnapshot\",\n    value:\n    /**\n     * Get a serialized snapshot of the store and its schema.\n     *\n     * ```ts\n     * const snapshot = store.getSnapshot()\n     * store.loadSnapshot(snapshot)\n     * ```\n     *\n     * @param scope - The scope of records to serialize. Defaults to 'document'.\n     * @public\n     */\n    function getSnapshot() {\n      var scope = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"document\";\n      return {\n        store: this.serialize(scope),\n        schema: this.schema.serialize()\n      };\n    }\n    /**\n     * Load a serialized snapshot.\n     *\n     * ```ts\n     * const snapshot = store.getSnapshot()\n     * store.loadSnapshot(snapshot)\n     * ```\n     *\n     * @param snapshot - The snapshot to load.\n     *\n     * @public\n     */\n  }, {\n    key: \"loadSnapshot\",\n    value: function loadSnapshot(snapshot) {\n      var _this4 = this;\n      var migrationResult = this.schema.migrateStoreSnapshot(snapshot.store, snapshot.schema);\n      if (migrationResult.type === \"error\") {\n        throw new Error(\"Failed to migrate snapshot: \".concat(migrationResult.reason));\n      }\n      transact(function () {\n        _this4.clear();\n        _this4.put(Object.values(migrationResult.value));\n        _this4.ensureStoreIsUsable();\n      });\n    }\n  }, {\n    key: \"extractingChanges\",\n    value: function extractingChanges(fn) {\n      var changes = [];\n      var dispose = this.historyAccumulator.intercepting(function (entry) {\n        return changes.push(entry.changes);\n      });\n      try {\n        transact(fn);\n        return squashRecordDiffs(changes);\n      } finally {\n        dispose();\n      }\n    }\n  }, {\n    key: \"applyDiff\",\n    value: function applyDiff(diff) {\n      var _this5 = this;\n      var runCallbacks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var prevRunCallbacks = this._runCallbacks;\n      try {\n        this._runCallbacks = runCallbacks;\n        transact(function () {\n          var toPut = objectMapValues(diff.added).concat(objectMapValues(diff.updated).map(function (_ref5) {\n            var _ref6 = _slicedToArray(_ref5, 2),\n              _from = _ref6[0],\n              to = _ref6[1];\n            return to;\n          }));\n          var toRemove = objectMapKeys(diff.removed);\n          if (toPut.length) {\n            _this5.put(toPut);\n          }\n          if (toRemove.length) {\n            _this5.remove(toRemove);\n          }\n        });\n      } finally {\n        this._runCallbacks = prevRunCallbacks;\n      }\n    }\n  }, {\n    key: \"ensureStoreIsUsable\",\n    value: /** @internal */\n    function ensureStoreIsUsable() {\n      var _this$_integrityCheck, _this$_integrityCheck2;\n      (_this$_integrityCheck = this._integrityChecker) !== null && _this$_integrityCheck !== void 0 ? _this$_integrityCheck : this._integrityChecker = this.schema.createIntegrityChecker(this);\n      (_this$_integrityCheck2 = this._integrityChecker) === null || _this$_integrityCheck2 === void 0 || _this$_integrityCheck2.call(this);\n    }\n  }, {\n    key: \"markAsPossiblyCorrupted\",\n    value: /** @internal */\n    function markAsPossiblyCorrupted() {\n      this._isPossiblyCorrupted = true;\n    }\n    /** @internal */\n  }, {\n    key: \"isPossiblyCorrupted\",\n    value: function isPossiblyCorrupted() {\n      return this._isPossiblyCorrupted;\n    }\n  }]);\n  return Store;\n}();\nfunction squashRecordDiffs(diffs) {\n  var result = {\n    added: {},\n    removed: {},\n    updated: {}\n  };\n  var _iterator6 = _createForOfIteratorHelper(diffs),\n    _step6;\n  try {\n    for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n      var diff = _step6.value;\n      var _iterator7 = _createForOfIteratorHelper(objectMapEntries(diff.added)),\n        _step7;\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var _step7$value = _slicedToArray(_step7.value, 2),\n            id = _step7$value[0],\n            value = _step7$value[1];\n          if (result.removed[id]) {\n            var original = result.removed[id];\n            delete result.removed[id];\n            if (original !== value) {\n              result.updated[id] = [original, value];\n            }\n          } else {\n            result.added[id] = value;\n          }\n        }\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n      var _iterator8 = _createForOfIteratorHelper(objectMapEntries(diff.updated)),\n        _step8;\n      try {\n        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n          var _step8$value = _slicedToArray(_step8.value, 2),\n            _id2 = _step8$value[0],\n            _step8$value$ = _slicedToArray(_step8$value[1], 2),\n            _from = _step8$value$[0],\n            to = _step8$value$[1];\n          if (result.added[_id2]) {\n            result.added[_id2] = to;\n            delete result.updated[_id2];\n            delete result.removed[_id2];\n            continue;\n          }\n          if (result.updated[_id2]) {\n            result.updated[_id2][1] = to;\n            delete result.removed[_id2];\n            continue;\n          }\n          result.updated[_id2] = diff.updated[_id2];\n          delete result.removed[_id2];\n        }\n      } catch (err) {\n        _iterator8.e(err);\n      } finally {\n        _iterator8.f();\n      }\n      var _iterator9 = _createForOfIteratorHelper(objectMapEntries(diff.removed)),\n        _step9;\n      try {\n        for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n          var _step9$value = _slicedToArray(_step9.value, 2),\n            _id3 = _step9$value[0],\n            _value = _step9$value[1];\n          if (result.added[_id3]) {\n            delete result.added[_id3];\n          } else if (result.updated[_id3]) {\n            result.removed[_id3] = result.updated[_id3][0];\n            delete result.updated[_id3];\n          } else {\n            result.removed[_id3] = _value;\n          }\n        }\n      } catch (err) {\n        _iterator9.e(err);\n      } finally {\n        _iterator9.f();\n      }\n    }\n  } catch (err) {\n    _iterator6.e(err);\n  } finally {\n    _iterator6.f();\n  }\n  return result;\n}\nfunction squashHistoryEntries(entries) {\n  var result = [];\n  var current = entries[0];\n  var entry;\n  for (var i = 1, n = entries.length; i < n; i++) {\n    entry = entries[i];\n    if (current.source !== entry.source) {\n      result.push(current);\n      current = entry;\n    } else {\n      current = {\n        source: current.source,\n        changes: squashRecordDiffs([current.changes, entry.changes])\n      };\n    }\n  }\n  result.push(current);\n  return result;\n}\nfunction reverseRecordsDiff(diff) {\n  var result = {\n    added: diff.removed,\n    removed: diff.added,\n    updated: {}\n  };\n  for (var _i = 0, _Object$values = Object.values(diff.updated); _i < _Object$values.length; _i++) {\n    var _Object$values$_i = _slicedToArray(_Object$values[_i], 2),\n      from = _Object$values$_i[0],\n      to = _Object$values$_i[1];\n    result.updated[from.id] = [to, from];\n  }\n  return result;\n}\nvar HistoryAccumulator = /*#__PURE__*/function () {\n  function HistoryAccumulator() {\n    _classCallCheck(this, HistoryAccumulator);\n    _defineProperty(this, \"_history\", []);\n    _defineProperty(this, \"_interceptors\", /* @__PURE__ */new Set());\n  }\n  _createClass(HistoryAccumulator, [{\n    key: \"intercepting\",\n    value: function intercepting(fn) {\n      var _this6 = this;\n      this._interceptors.add(fn);\n      return function () {\n        _this6._interceptors.delete(fn);\n      };\n    }\n  }, {\n    key: \"add\",\n    value: function add(entry) {\n      this._history.push(entry);\n      var _iterator10 = _createForOfIteratorHelper(this._interceptors),\n        _step10;\n      try {\n        for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n          var interceptor = _step10.value;\n          interceptor(entry);\n        }\n      } catch (err) {\n        _iterator10.e(err);\n      } finally {\n        _iterator10.f();\n      }\n    }\n  }, {\n    key: \"flush\",\n    value: function flush() {\n      var history = squashHistoryEntries(this._history);\n      this._history = [];\n      return history;\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this._history = [];\n    }\n  }, {\n    key: \"hasChanges\",\n    value: function hasChanges() {\n      return this._history.length > 0;\n    }\n  }]);\n  return HistoryAccumulator;\n}();\nexport { Store, reverseRecordsDiff, squashRecordDiffs };","map":{"version":3,"names":["filterEntries","objectMapEntries","objectMapFromEntries","objectMapKeys","objectMapValues","throttledRaf","nanoid","atom","computed","reactor","transact","Cache","StoreQueries","devFreeze","Store","config","_this","_classCallCheck","_defineProperty","historyLength","atoms","history","Set","HistoryAccumulator","records","phaseOverride","updates","additions","currentMap","__unsafe__getWithoutCapture","map","record","didChange","i","n","length","_map","recordAtom","id","initialValue","schema","validateRecord","set","finalValue","_objectSpread","updateHistory","added","updated","removed","onAfterCreate","onAfterChange","_runCallbacks","Object","values","forEach","record2","_ref","_ref2","_slicedToArray","from","to","ids","onBeforeDelete","_iterator","_createForOfIteratorHelper","_step","s","done","value","atom2","err","e","f","update","_result","result","_iterator2","_step2","onAfterDelete","_this$atoms$value$id","_this$atoms$value$id2","scope","arguments","undefined","_iterator3","_step3","_step3$value","scopedTypes","has","typeName","remove","updater","console","error","concat","put","onHistory","filters","_filters$source","_filters$scope","_flushHistory","listener","source","listeners","add","historyReactor","scheduler","isActivelyListening","start","delete","size","stop","fn","isMergingRemoteChanges","name","derive","cache","get","selector","d","initialData","props","_ref3","_ref4","scheduleEffect","cb","document","types","filter","t","session","presence","_createClass","key","historyAccumulator","hasChanges","entries","flush","_iterator4","_step4","_step4$value","changes","instanceChanges","documentChanges","presenceChanges","_iterator5","_step5","_step5$value","_documentChanges","filterChangesByScope","_instanceChanges","_presenceChanges","change","_this2","_","r","keys","clear","validate","phase","_this3","allRecords","getSnapshot","store","serialize","loadSnapshot","snapshot","_this4","migrationResult","migrateStoreSnapshot","type","Error","reason","ensureStoreIsUsable","extractingChanges","dispose","intercepting","entry","push","squashRecordDiffs","applyDiff","diff","_this5","runCallbacks","prevRunCallbacks","toPut","_ref5","_ref6","_from","toRemove","_this$_integrityCheck","_this$_integrityCheck2","_integrityChecker","createIntegrityChecker","call","markAsPossiblyCorrupted","_isPossiblyCorrupted","isPossiblyCorrupted","diffs","_iterator6","_step6","_iterator7","_step7","_step7$value","original","_iterator8","_step8","_step8$value","_step8$value$","_iterator9","_step9","_step9$value","squashHistoryEntries","current","reverseRecordsDiff","_i","_Object$values","_Object$values$_i","_this6","_interceptors","_history","_iterator10","_step10","interceptor"],"sources":["/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@tldraw/store/src/lib/Store.ts"],"sourcesContent":["import {\n\tfilterEntries,\n\tobjectMapEntries,\n\tobjectMapFromEntries,\n\tobjectMapKeys,\n\tobjectMapValues,\n\tthrottledRaf,\n} from '@tldraw/utils'\nimport { nanoid } from 'nanoid'\nimport { Atom, Computed, Reactor, atom, computed, reactor, transact } from 'signia'\nimport { IdOf, RecordId, UnknownRecord } from './BaseRecord'\nimport { Cache } from './Cache'\nimport { RecordScope } from './RecordType'\nimport { StoreQueries } from './StoreQueries'\nimport { SerializedSchema, StoreSchema } from './StoreSchema'\nimport { devFreeze } from './devFreeze'\n\ntype RecFromId<K extends RecordId<UnknownRecord>> = K extends RecordId<infer R> ? R : never\n\n/**\n * A diff describing the changes to a record.\n *\n * @public\n */\nexport type RecordsDiff<R extends UnknownRecord> = {\n\tadded: Record<IdOf<R>, R>\n\tupdated: Record<IdOf<R>, [from: R, to: R]>\n\tremoved: Record<IdOf<R>, R>\n}\n\n/**\n * A diff describing the changes to a collection.\n *\n * @public\n */\nexport type CollectionDiff<T> = { added?: Set<T>; removed?: Set<T> }\n\nexport type ChangeSource = 'user' | 'remote'\n\nexport type StoreListenerFilters = {\n\tsource: ChangeSource | 'all'\n\tscope: RecordScope | 'all'\n}\n\n/**\n * An entry containing changes that originated either by user actions or remote changes.\n *\n * @public\n */\nexport type HistoryEntry<R extends UnknownRecord = UnknownRecord> = {\n\tchanges: RecordsDiff<R>\n\tsource: ChangeSource\n}\n\n/**\n * A function that will be called when the history changes.\n *\n * @public\n */\nexport type StoreListener<R extends UnknownRecord> = (entry: HistoryEntry<R>) => void\n\n/**\n * A record store is a collection of records of different types.\n *\n * @public\n */\nexport type ComputedCache<Data, R extends UnknownRecord> = {\n\tget(id: IdOf<R>): Data | undefined\n}\n\n/**\n * A serialized snapshot of the record store's values.\n *\n * @public\n */\nexport type StoreSnapshot<R extends UnknownRecord> = Record<IdOf<R>, R>\n\n/** @public */\nexport type StoreValidator<R extends UnknownRecord> = {\n\tvalidate: (record: unknown) => R\n}\n\n/** @public */\nexport type StoreValidators<R extends UnknownRecord> = {\n\t[K in R['typeName']]: StoreValidator<Extract<R, { typeName: K }>>\n}\n\n/** @public */\nexport type StoreError = {\n\terror: Error\n\tphase: 'initialize' | 'createRecord' | 'updateRecord' | 'tests'\n\trecordBefore?: unknown\n\trecordAfter: unknown\n\tisExistingValidationIssue: boolean\n}\n\n/** @internal */\nexport type StoreRecord<S extends Store<any>> = S extends Store<infer R> ? R : never\n\n/**\n * A store of records.\n *\n * @public\n */\nexport class Store<R extends UnknownRecord = UnknownRecord, Props = unknown> {\n\t/**\n\t * The random id of the store.\n\t */\n\tpublic readonly id = nanoid()\n\t/**\n\t * An atom containing the store's atoms.\n\t *\n\t * @internal\n\t * @readonly\n\t */\n\tprivate readonly atoms = atom('store_atoms', {} as Record<IdOf<R>, Atom<R>>)\n\n\t/**\n\t * An atom containing the store's history.\n\t *\n\t * @public\n\t * @readonly\n\t */\n\treadonly history: Atom<number, RecordsDiff<R>> = atom('history', 0, {\n\t\thistoryLength: 1000,\n\t})\n\n\t/**\n\t * A StoreQueries instance for this store.\n\t *\n\t * @public\n\t * @readonly\n\t */\n\treadonly query = new StoreQueries<R>(this.atoms, this.history)\n\n\t/**\n\t * A set containing listeners that have been added to this store.\n\t *\n\t * @internal\n\t */\n\tprivate listeners = new Set<{ onHistory: StoreListener<R>; filters: StoreListenerFilters }>()\n\n\t/**\n\t * An array of history entries that have not yet been flushed.\n\t *\n\t * @internal\n\t */\n\tprivate historyAccumulator = new HistoryAccumulator<R>()\n\n\t/**\n\t * A reactor that responds to changes to the history by squashing the accumulated history and\n\t * notifying listeners of the changes.\n\t *\n\t * @internal\n\t */\n\tprivate historyReactor: Reactor\n\n\treadonly schema: StoreSchema<R, Props>\n\n\treadonly props: Props\n\n\tpublic readonly scopedTypes: { readonly [K in RecordScope]: ReadonlySet<R['typeName']> }\n\n\tconstructor(config: {\n\t\t/** The store's initial data. */\n\t\tinitialData?: StoreSnapshot<R>\n\t\t/**\n\t\t * A map of validators for each record type. A record's validator will be called when the record\n\t\t * is created or updated. It should throw an error if the record is invalid.\n\t\t */\n\t\tschema: StoreSchema<R, Props>\n\t\tprops: Props\n\t}) {\n\t\tconst { initialData, schema } = config\n\n\t\tthis.schema = schema\n\t\tthis.props = config.props\n\n\t\tif (initialData) {\n\t\t\tthis.atoms.set(\n\t\t\t\tobjectMapFromEntries(\n\t\t\t\t\tobjectMapEntries(initialData).map(([id, record]) => [\n\t\t\t\t\t\tid,\n\t\t\t\t\t\tatom('atom:' + id, this.schema.validateRecord(this, record, 'initialize', null)),\n\t\t\t\t\t])\n\t\t\t\t)\n\t\t\t)\n\t\t}\n\n\t\tthis.historyReactor = reactor(\n\t\t\t'Store.historyReactor',\n\t\t\t() => {\n\t\t\t\t// deref to make sure we're subscribed regardless of whether we need to propagate\n\t\t\t\tthis.history.value\n\t\t\t\t// If we have accumulated history, flush it and update listeners\n\t\t\t\tthis._flushHistory()\n\t\t\t},\n\t\t\t{ scheduleEffect: (cb) => throttledRaf(cb) }\n\t\t)\n\t\tthis.scopedTypes = {\n\t\t\tdocument: new Set(\n\t\t\t\tobjectMapValues(this.schema.types)\n\t\t\t\t\t.filter((t) => t.scope === 'document')\n\t\t\t\t\t.map((t) => t.typeName)\n\t\t\t),\n\t\t\tsession: new Set(\n\t\t\t\tobjectMapValues(this.schema.types)\n\t\t\t\t\t.filter((t) => t.scope === 'session')\n\t\t\t\t\t.map((t) => t.typeName)\n\t\t\t),\n\t\t\tpresence: new Set(\n\t\t\t\tobjectMapValues(this.schema.types)\n\t\t\t\t\t.filter((t) => t.scope === 'presence')\n\t\t\t\t\t.map((t) => t.typeName)\n\t\t\t),\n\t\t}\n\t}\n\n\tpublic _flushHistory() {\n\t\t// If we have accumulated history, flush it and update listeners\n\t\tif (this.historyAccumulator.hasChanges()) {\n\t\t\tconst entries = this.historyAccumulator.flush()\n\t\t\tfor (const { changes, source } of entries) {\n\t\t\t\tlet instanceChanges = null as null | RecordsDiff<R>\n\t\t\t\tlet documentChanges = null as null | RecordsDiff<R>\n\t\t\t\tlet presenceChanges = null as null | RecordsDiff<R>\n\t\t\t\tfor (const { onHistory, filters } of this.listeners) {\n\t\t\t\t\tif (filters.source !== 'all' && filters.source !== source) {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tif (filters.scope !== 'all') {\n\t\t\t\t\t\tif (filters.scope === 'document') {\n\t\t\t\t\t\t\tdocumentChanges ??= this.filterChangesByScope(changes, 'document')\n\t\t\t\t\t\t\tif (!documentChanges) continue\n\t\t\t\t\t\t\tonHistory({ changes: documentChanges, source })\n\t\t\t\t\t\t} else if (filters.scope === 'session') {\n\t\t\t\t\t\t\tinstanceChanges ??= this.filterChangesByScope(changes, 'session')\n\t\t\t\t\t\t\tif (!instanceChanges) continue\n\t\t\t\t\t\t\tonHistory({ changes: instanceChanges, source })\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tpresenceChanges ??= this.filterChangesByScope(changes, 'presence')\n\t\t\t\t\t\t\tif (!presenceChanges) continue\n\t\t\t\t\t\t\tonHistory({ changes: presenceChanges, source })\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tonHistory({ changes, source })\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Filters out non-document changes from a diff. Returns null if there are no changes left.\n\t * @param change - the records diff\n\t * @returns\n\t */\n\tfilterChangesByScope(change: RecordsDiff<R>, scope: RecordScope) {\n\t\tconst result = {\n\t\t\tadded: filterEntries(change.added, (_, r) => this.scopedTypes[scope].has(r.typeName)),\n\t\t\tupdated: filterEntries(change.updated, (_, r) => this.scopedTypes[scope].has(r[1].typeName)),\n\t\t\tremoved: filterEntries(change.removed, (_, r) => this.scopedTypes[scope].has(r.typeName)),\n\t\t}\n\t\tif (\n\t\t\tObject.keys(result.added).length === 0 &&\n\t\t\tObject.keys(result.updated).length === 0 &&\n\t\t\tObject.keys(result.removed).length === 0\n\t\t) {\n\t\t\treturn null\n\t\t}\n\t\treturn result\n\t}\n\n\t/**\n\t * Update the history with a diff of changes.\n\t *\n\t * @param changes - The changes to add to the history.\n\t */\n\tprivate updateHistory(changes: RecordsDiff<R>): void {\n\t\tthis.historyAccumulator.add({\n\t\t\tchanges,\n\t\t\tsource: this.isMergingRemoteChanges ? 'remote' : 'user',\n\t\t})\n\t\tif (this.listeners.size === 0) {\n\t\t\tthis.historyAccumulator.clear()\n\t\t}\n\t\tthis.history.set(this.history.value + 1, changes)\n\t}\n\n\tvalidate(phase: 'initialize' | 'createRecord' | 'updateRecord' | 'tests') {\n\t\tthis.allRecords().forEach((record) => this.schema.validateRecord(this, record, phase, null))\n\t}\n\n\t/**\n\t * A callback fired after a record is created. Use this to perform related updates to other\n\t * records in the store.\n\t *\n\t * @param record - The record to be created\n\t */\n\tonAfterCreate?: (record: R) => void\n\n\t/**\n\t * A callback fired after each record's change.\n\t *\n\t * @param prev - The previous value, if any.\n\t * @param next - The next value.\n\t */\n\tonAfterChange?: (prev: R, next: R) => void\n\n\t/**\n\t * A callback fired before a record is deleted.\n\t *\n\t * @param prev - The record that will be deleted.\n\t */\n\tonBeforeDelete?: (prev: R) => void\n\n\t/**\n\t * A callback fired after a record is deleted.\n\t *\n\t * @param prev - The record that will be deleted.\n\t */\n\tonAfterDelete?: (prev: R) => void\n\n\t// used to avoid running callbacks when rolling back changes in sync client\n\tprivate _runCallbacks = true\n\n\t/**\n\t * Add some records to the store. It's an error if they already exist.\n\t *\n\t * @param records - The records to add.\n\t * @public\n\t */\n\tput = (records: R[], phaseOverride?: 'initialize'): void => {\n\t\ttransact(() => {\n\t\t\tconst updates: Record<IdOf<UnknownRecord>, [from: R, to: R]> = {}\n\t\t\tconst additions: Record<IdOf<UnknownRecord>, R> = {}\n\n\t\t\tconst currentMap = this.atoms.__unsafe__getWithoutCapture()\n\t\t\tlet map = null as null | Record<IdOf<UnknownRecord>, Atom<R>>\n\n\t\t\t// Iterate through all records, creating, updating or removing as needed\n\t\t\tlet record: R\n\n\t\t\t// There's a chance that, despite having records, all of the values are\n\t\t\t// identical to what they were before; and so we'd end up with an \"empty\"\n\t\t\t// history entry. Let's keep track of whether we've actually made any\n\t\t\t// changes (e.g. additions, deletions, or updates that produce a new value).\n\t\t\tlet didChange = false\n\n\t\t\tfor (let i = 0, n = records.length; i < n; i++) {\n\t\t\t\trecord = records[i]\n\n\t\t\t\tconst recordAtom = (map ?? currentMap)[record.id as IdOf<R>]\n\n\t\t\t\tif (recordAtom) {\n\t\t\t\t\t// If we already have an atom for this record, update its value.\n\n\t\t\t\t\tconst initialValue = recordAtom.__unsafe__getWithoutCapture()\n\n\t\t\t\t\t// Validate the record\n\t\t\t\t\trecord = this.schema.validateRecord(\n\t\t\t\t\t\tthis,\n\t\t\t\t\t\trecord,\n\t\t\t\t\t\tphaseOverride ?? 'updateRecord',\n\t\t\t\t\t\tinitialValue\n\t\t\t\t\t)\n\n\t\t\t\t\trecordAtom.set(devFreeze(record))\n\n\t\t\t\t\t// need to deref atom in case nextValue is not identical but is .equals?\n\t\t\t\t\tconst finalValue = recordAtom.__unsafe__getWithoutCapture()\n\n\t\t\t\t\t// If the value has changed, assign it to updates.\n\t\t\t\t\tif (initialValue !== finalValue) {\n\t\t\t\t\t\tdidChange = true\n\t\t\t\t\t\tupdates[record.id] = [initialValue, finalValue]\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tdidChange = true\n\n\t\t\t\t\t// If we don't have an atom, create one.\n\n\t\t\t\t\t// Validate the record\n\t\t\t\t\trecord = this.schema.validateRecord(\n\t\t\t\t\t\tthis,\n\t\t\t\t\t\trecord as R,\n\t\t\t\t\t\tphaseOverride ?? 'createRecord',\n\t\t\t\t\t\tnull\n\t\t\t\t\t)\n\n\t\t\t\t\t// Mark the change as a new addition.\n\t\t\t\t\tadditions[record.id] = record\n\n\t\t\t\t\t// Assign the atom to the map under the record's id.\n\t\t\t\t\tif (!map) {\n\t\t\t\t\t\tmap = { ...currentMap }\n\t\t\t\t\t}\n\t\t\t\t\tmap[record.id] = atom('atom:' + record.id, record)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Set the map of atoms to the store.\n\t\t\tif (map) {\n\t\t\t\tthis.atoms.set(map)\n\t\t\t}\n\n\t\t\t// If we did change, update the history\n\t\t\tif (!didChange) return\n\t\t\tthis.updateHistory({\n\t\t\t\tadded: additions,\n\t\t\t\tupdated: updates,\n\t\t\t\tremoved: {} as Record<IdOf<R>, R>,\n\t\t\t})\n\n\t\t\tconst { onAfterCreate, onAfterChange } = this\n\n\t\t\tif (onAfterCreate && this._runCallbacks) {\n\t\t\t\t// Run the onAfterChange callback for addition.\n\t\t\t\tObject.values(additions).forEach((record) => {\n\t\t\t\t\tonAfterCreate(record)\n\t\t\t\t})\n\t\t\t}\n\n\t\t\tif (onAfterChange && this._runCallbacks) {\n\t\t\t\t// Run the onAfterChange callback for update.\n\t\t\t\tObject.values(updates).forEach(([from, to]) => {\n\t\t\t\t\tonAfterChange(from, to)\n\t\t\t\t})\n\t\t\t}\n\t\t})\n\t}\n\n\t/**\n\t * Remove some records from the store via their ids.\n\t *\n\t * @param ids - The ids of the records to remove.\n\t * @public\n\t */\n\tremove = (ids: IdOf<R>[]): void => {\n\t\ttransact(() => {\n\t\t\tif (this.onBeforeDelete && this._runCallbacks) {\n\t\t\t\tfor (const id of ids) {\n\t\t\t\t\tconst atom = this.atoms.__unsafe__getWithoutCapture()[id]\n\t\t\t\t\tif (!atom) continue\n\n\t\t\t\t\tthis.onBeforeDelete(atom.value)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet removed = undefined as undefined | RecordsDiff<R>['removed']\n\n\t\t\t// For each map in our atoms, remove the ids that we are removing.\n\t\t\tthis.atoms.update((atoms) => {\n\t\t\t\tlet result: typeof atoms | undefined = undefined\n\n\t\t\t\tfor (const id of ids) {\n\t\t\t\t\tif (!(id in atoms)) continue\n\t\t\t\t\tif (!result) result = { ...atoms }\n\t\t\t\t\tif (!removed) removed = {} as Record<IdOf<R>, R>\n\t\t\t\t\tdelete result[id]\n\t\t\t\t\tremoved[id] = atoms[id].value\n\t\t\t\t}\n\n\t\t\t\treturn result ?? atoms\n\t\t\t})\n\n\t\t\tif (!removed) return\n\t\t\t// Update the history with the removed records.\n\t\t\tthis.updateHistory({ added: {}, updated: {}, removed } as RecordsDiff<R>)\n\n\t\t\t// If we have an onAfterChange, run it for each removed record.\n\t\t\tif (this.onAfterDelete && this._runCallbacks) {\n\t\t\t\tfor (let i = 0, n = ids.length; i < n; i++) {\n\t\t\t\t\tthis.onAfterDelete(removed[ids[i]])\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n\n\t/**\n\t * Get the value of a store record by its id.\n\t *\n\t * @param id - The id of the record to get.\n\t * @public\n\t */\n\tget = <K extends IdOf<R>>(id: K): RecFromId<K> | undefined => {\n\t\treturn this.atoms.value[id]?.value as any\n\t}\n\n\t/**\n\t * Get the value of a store record by its id without updating its epoch.\n\t *\n\t * @param id - The id of the record to get.\n\t * @public\n\t */\n\tunsafeGetWithoutCapture = <K extends IdOf<R>>(id: K): RecFromId<K> | undefined => {\n\t\treturn this.atoms.value[id]?.__unsafe__getWithoutCapture() as any\n\t}\n\n\t/**\n\t * Creates a JSON payload from the record store.\n\t *\n\t * @param scope - The scope of records to serialize. Defaults to 'document'.\n\t * @returns The record store snapshot as a JSON payload.\n\t */\n\tserialize = (scope: RecordScope | 'all' = 'document'): StoreSnapshot<R> => {\n\t\tconst result = {} as StoreSnapshot<R>\n\t\tfor (const [id, atom] of objectMapEntries(this.atoms.value)) {\n\t\t\tconst record = atom.value\n\t\t\tif (scope === 'all' || this.scopedTypes[scope].has(record.typeName)) {\n\t\t\t\tresult[id as IdOf<R>] = record\n\t\t\t}\n\t\t}\n\t\treturn result\n\t}\n\n\t/**\n\t * Get a serialized snapshot of the store and its schema.\n\t *\n\t * ```ts\n\t * const snapshot = store.getSnapshot()\n\t * store.loadSnapshot(snapshot)\n\t * ```\n\t *\n\t * @param scope - The scope of records to serialize. Defaults to 'document'.\n\t * @public\n\t */\n\tgetSnapshot(scope: RecordScope | 'all' = 'document') {\n\t\treturn {\n\t\t\tstore: this.serialize(scope),\n\t\t\tschema: this.schema.serialize(),\n\t\t}\n\t}\n\n\t/**\n\t * Load a serialized snapshot.\n\t *\n\t * ```ts\n\t * const snapshot = store.getSnapshot()\n\t * store.loadSnapshot(snapshot)\n\t * ```\n\t *\n\t * @param snapshot - The snapshot to load.\n\t *\n\t * @public\n\t */\n\tloadSnapshot(snapshot: { store: StoreSnapshot<R>; schema: SerializedSchema }): void {\n\t\tconst migrationResult = this.schema.migrateStoreSnapshot(snapshot.store, snapshot.schema)\n\n\t\tif (migrationResult.type === 'error') {\n\t\t\tthrow new Error(`Failed to migrate snapshot: ${migrationResult.reason}`)\n\t\t}\n\n\t\ttransact(() => {\n\t\t\tthis.clear()\n\t\t\tthis.put(Object.values(migrationResult.value))\n\t\t\tthis.ensureStoreIsUsable()\n\t\t})\n\t}\n\n\t/**\n\t * Get an array of all values in the store.\n\t *\n\t * @returns An array of all values in the store.\n\t * @public\n\t */\n\tallRecords = (): R[] => {\n\t\treturn objectMapValues(this.atoms.value).map((atom) => atom.value)\n\t}\n\n\t/**\n\t * Removes all records from the store.\n\t *\n\t * @public\n\t */\n\tclear = (): void => {\n\t\tthis.remove(objectMapKeys(this.atoms.value))\n\t}\n\n\t/**\n\t * Update a record. To update multiple records at once, use the `update` method of the\n\t * `TypedStore` class.\n\t *\n\t * @param id - The id of the record to update.\n\t * @param updater - A function that updates the record.\n\t */\n\tupdate = <K extends IdOf<R>>(id: K, updater: (record: RecFromId<K>) => RecFromId<K>) => {\n\t\tconst atom = this.atoms.value[id]\n\t\tif (!atom) {\n\t\t\tconsole.error(`Record ${id} not found. This is probably an error`)\n\t\t\treturn\n\t\t}\n\t\tthis.put([updater(atom.__unsafe__getWithoutCapture() as any as RecFromId<K>) as any])\n\t}\n\n\t/**\n\t * Get whether the record store has a id.\n\t *\n\t * @param id - The id of the record to check.\n\t * @public\n\t */\n\thas = <K extends IdOf<R>>(id: K): boolean => {\n\t\treturn !!this.atoms.value[id]\n\t}\n\n\t/**\n\t * Add a new listener to the store.\n\t *\n\t * @param onHistory - The listener to call when the store updates.\n\t * @param filters - Filters to apply to the listener.\n\t * @returns A function to remove the listener.\n\t */\n\tlisten = (onHistory: StoreListener<R>, filters?: Partial<StoreListenerFilters>) => {\n\t\t// flush history so that this listener's history starts from exactly now\n\t\tthis._flushHistory()\n\n\t\tconst listener = {\n\t\t\tonHistory,\n\t\t\tfilters: {\n\t\t\t\tsource: filters?.source ?? 'all',\n\t\t\t\tscope: filters?.scope ?? 'all',\n\t\t\t},\n\t\t}\n\n\t\tthis.listeners.add(listener)\n\n\t\tif (!this.historyReactor.scheduler.isActivelyListening) {\n\t\t\tthis.historyReactor.start()\n\t\t}\n\n\t\treturn () => {\n\t\t\tthis.listeners.delete(listener)\n\n\t\t\tif (this.listeners.size === 0) {\n\t\t\t\tthis.historyReactor.stop()\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate isMergingRemoteChanges = false\n\n\t/**\n\t * Merge changes from a remote source without triggering listeners.\n\t *\n\t * @param fn - A function that merges the external changes.\n\t * @public\n\t */\n\tmergeRemoteChanges = (fn: () => void) => {\n\t\tif (this.isMergingRemoteChanges) {\n\t\t\treturn fn()\n\t\t}\n\n\t\ttry {\n\t\t\tthis.isMergingRemoteChanges = true\n\t\t\ttransact(fn)\n\t\t} finally {\n\t\t\tthis.isMergingRemoteChanges = false\n\t\t}\n\t}\n\n\textractingChanges(fn: () => void): RecordsDiff<R> {\n\t\tconst changes: Array<RecordsDiff<R>> = []\n\t\tconst dispose = this.historyAccumulator.intercepting((entry) => changes.push(entry.changes))\n\t\ttry {\n\t\t\ttransact(fn)\n\t\t\treturn squashRecordDiffs(changes)\n\t\t} finally {\n\t\t\tdispose()\n\t\t}\n\t}\n\n\tapplyDiff(diff: RecordsDiff<R>, runCallbacks = true) {\n\t\tconst prevRunCallbacks = this._runCallbacks\n\t\ttry {\n\t\t\tthis._runCallbacks = runCallbacks\n\t\t\ttransact(() => {\n\t\t\t\tconst toPut = objectMapValues(diff.added).concat(\n\t\t\t\t\tobjectMapValues(diff.updated).map(([_from, to]) => to)\n\t\t\t\t)\n\t\t\t\tconst toRemove = objectMapKeys(diff.removed)\n\t\t\t\tif (toPut.length) {\n\t\t\t\t\tthis.put(toPut)\n\t\t\t\t}\n\t\t\t\tif (toRemove.length) {\n\t\t\t\t\tthis.remove(toRemove)\n\t\t\t\t}\n\t\t\t})\n\t\t} finally {\n\t\t\tthis._runCallbacks = prevRunCallbacks\n\t\t}\n\t}\n\n\t/**\n\t * Create a computed cache.\n\t *\n\t * @param name - The name of the derivation cache.\n\t * @param derive - A function used to derive the value of the cache.\n\t * @public\n\t */\n\tcreateComputedCache = <T, V extends R = R>(\n\t\tname: string,\n\t\tderive: (record: V) => T | undefined\n\t): ComputedCache<T, V> => {\n\t\tconst cache = new Cache<Atom<any>, Computed<T | undefined>>()\n\t\treturn {\n\t\t\tget: (id: IdOf<V>) => {\n\t\t\t\tconst atom = this.atoms.value[id]\n\t\t\t\tif (!atom) {\n\t\t\t\t\treturn undefined\n\t\t\t\t}\n\t\t\t\treturn cache.get(atom, () =>\n\t\t\t\t\tcomputed<T | undefined>(name + ':' + id, () => derive(atom.value as V))\n\t\t\t\t).value\n\t\t\t},\n\t\t}\n\t}\n\n\t/**\n\t * Create a computed cache from a selector\n\t *\n\t * @param name - The name of the derivation cache.\n\t * @param selector - A function that returns a subset of the original shape\n\t * @param derive - A function used to derive the value of the cache.\n\t * @public\n\t */\n\tcreateSelectedComputedCache = <T, J, V extends R = R>(\n\t\tname: string,\n\t\tselector: (record: V) => T | undefined,\n\t\tderive: (input: T) => J | undefined\n\t): ComputedCache<J, V> => {\n\t\tconst cache = new Cache<Atom<any>, Computed<J | undefined>>()\n\t\treturn {\n\t\t\tget: (id: IdOf<V>) => {\n\t\t\t\tconst atom = this.atoms.value[id]\n\t\t\t\tif (!atom) {\n\t\t\t\t\treturn undefined\n\t\t\t\t}\n\n\t\t\t\tconst d = computed<T | undefined>(name + ':' + id + ':selector', () =>\n\t\t\t\t\tselector(atom.value as V)\n\t\t\t\t)\n\t\t\t\treturn cache.get(atom, () =>\n\t\t\t\t\tcomputed<J | undefined>(name + ':' + id, () => derive(d.value as T))\n\t\t\t\t).value\n\t\t\t},\n\t\t}\n\t}\n\n\tprivate _integrityChecker?: () => void | undefined\n\n\t/** @internal */\n\tensureStoreIsUsable() {\n\t\tthis._integrityChecker ??= this.schema.createIntegrityChecker(this)\n\t\tthis._integrityChecker?.()\n\t}\n\n\tprivate _isPossiblyCorrupted = false\n\t/** @internal */\n\tmarkAsPossiblyCorrupted() {\n\t\tthis._isPossiblyCorrupted = true\n\t}\n\t/** @internal */\n\tisPossiblyCorrupted() {\n\t\treturn this._isPossiblyCorrupted\n\t}\n}\n\n/**\n * Squash a collection of diffs into a single diff.\n *\n * @param diffs - An array of diffs to squash.\n * @returns A single diff that represents the squashed diffs.\n * @public\n */\nexport function squashRecordDiffs<T extends UnknownRecord>(\n\tdiffs: RecordsDiff<T>[]\n): RecordsDiff<T> {\n\tconst result = { added: {}, removed: {}, updated: {} } as RecordsDiff<T>\n\n\tfor (const diff of diffs) {\n\t\tfor (const [id, value] of objectMapEntries(diff.added)) {\n\t\t\tif (result.removed[id]) {\n\t\t\t\tconst original = result.removed[id]\n\t\t\t\tdelete result.removed[id]\n\t\t\t\tif (original !== value) {\n\t\t\t\t\tresult.updated[id] = [original, value]\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tresult.added[id] = value\n\t\t\t}\n\t\t}\n\n\t\tfor (const [id, [_from, to]] of objectMapEntries(diff.updated)) {\n\t\t\tif (result.added[id]) {\n\t\t\t\tresult.added[id] = to\n\t\t\t\tdelete result.updated[id]\n\t\t\t\tdelete result.removed[id]\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif (result.updated[id]) {\n\t\t\t\tresult.updated[id][1] = to\n\t\t\t\tdelete result.removed[id]\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tresult.updated[id] = diff.updated[id]\n\t\t\tdelete result.removed[id]\n\t\t}\n\n\t\tfor (const [id, value] of objectMapEntries(diff.removed)) {\n\t\t\t// the same record was added in this diff sequence, just drop it\n\t\t\tif (result.added[id]) {\n\t\t\t\tdelete result.added[id]\n\t\t\t} else if (result.updated[id]) {\n\t\t\t\tresult.removed[id] = result.updated[id][0]\n\t\t\t\tdelete result.updated[id]\n\t\t\t} else {\n\t\t\t\tresult.removed[id] = value\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result\n}\n\n/**\n * Collect all history entries by their sources.\n *\n * @param entries - The array of history entries.\n * @returns A map of history entries by their sources.\n * @public\n */\nfunction squashHistoryEntries<T extends UnknownRecord>(\n\tentries: HistoryEntry<T>[]\n): HistoryEntry<T>[] {\n\tconst result: HistoryEntry<T>[] = []\n\n\tlet current = entries[0]\n\tlet entry: HistoryEntry<T>\n\n\tfor (let i = 1, n = entries.length; i < n; i++) {\n\t\tentry = entries[i]\n\n\t\tif (current.source !== entry.source) {\n\t\t\tresult.push(current)\n\t\t\tcurrent = entry\n\t\t} else {\n\t\t\tcurrent = {\n\t\t\t\tsource: current.source,\n\t\t\t\tchanges: squashRecordDiffs([current.changes, entry.changes]),\n\t\t\t}\n\t\t}\n\t}\n\n\tresult.push(current)\n\n\treturn result\n}\n\n/** @public */\nexport function reverseRecordsDiff(diff: RecordsDiff<any>) {\n\tconst result: RecordsDiff<any> = { added: diff.removed, removed: diff.added, updated: {} }\n\tfor (const [from, to] of Object.values(diff.updated)) {\n\t\tresult.updated[from.id] = [to, from]\n\t}\n\treturn result\n}\n\nclass HistoryAccumulator<T extends UnknownRecord> {\n\tprivate _history: HistoryEntry<T>[] = []\n\n\tprivate _interceptors: Set<(entry: HistoryEntry<T>) => void> = new Set()\n\n\tintercepting(fn: (entry: HistoryEntry<T>) => void) {\n\t\tthis._interceptors.add(fn)\n\t\treturn () => {\n\t\t\tthis._interceptors.delete(fn)\n\t\t}\n\t}\n\n\tadd(entry: HistoryEntry<T>) {\n\t\tthis._history.push(entry)\n\t\tfor (const interceptor of this._interceptors) {\n\t\t\tinterceptor(entry)\n\t\t}\n\t}\n\n\tflush() {\n\t\tconst history = squashHistoryEntries(this._history)\n\t\tthis._history = []\n\t\treturn history\n\t}\n\n\tclear() {\n\t\tthis._history = []\n\t}\n\n\thasChanges() {\n\t\treturn this._history.length > 0\n\t}\n}\n"],"mappings":";;;;;;AAAA,SACCA,aAAA,EACAC,gBAAA,EACAC,oBAAA,EACAC,aAAA,EACAC,eAAA,EACAC,YAAA,QACM;AACP,SAASC,MAAA,QAAc;AACvB,SAAkCC,IAAA,EAAMC,QAAA,EAAUC,OAAA,EAASC,QAAA,QAAgB;AAE3E,SAASC,KAAA,QAAa;AAEtB,SAASC,YAAA,QAAoB;AAE7B,SAASC,SAAA,QAAiB;AAAA,IAyFbC,KAAA;EA2DZ,SAAAA,MAAYC,MAAA,EAST;IAAA,IAAAC,KAAA;IAAAC,eAAA,OAAAH,KAAA;IApEyE;AAAA;AAAA;IAAAI,eAAA,aAIvDZ,MAAA,CAAO;IAAA;AAAA;AAAA;AAAA;AAAA;AAAA;IAAAY,eAAA,gBAOHX,IAAA,CAAK,eAAe,CAAC,CAA6B;IAAA;AAAA;AAAA;AAAA;AAAA;AAAA;IAAAW,eAAA,kBAQ1BX,IAAA,CAAK,WAAW,GAAG;MACnEY,aAAA,EAAe;IAChB,CAAC;IAAA;AAAA;AAAA;AAAA;AAAA;AAAA;IAAAD,eAAA,gBAQgB,IAAIN,YAAA,CAAgB,KAAKQ,KAAA,EAAO,KAAKC,OAAO;IAAA;AAAA;AAAA;AAAA;AAAA;IAAAH,eAAA,oBAOzC,mBAAII,GAAA,CAAoE;IAAA;AAAA;AAAA;AAAA;AAAA;IAAAJ,eAAA,6BAO/D,IAAIK,kBAAA,CAAsB;IAAA;AAAA;AAAA;AAAA;AAAA;AAAA;IAAAL,eAAA;IAAAA,eAAA;IAAAA,eAAA;IAAAA,eAAA;IAgJvD;AAAA;AAAA;AAAA;AAAA;AAAA;IAAAA,eAAA;IAQA;AAAA;AAAA;AAAA;AAAA;AAAA;IAAAA,eAAA;IAQA;AAAA;AAAA;AAAA;AAAA;IAAAA,eAAA;IAOA;AAAA;AAAA;AAAA;AAAA;IAAAA,eAAA;IAOA;IAAAA,eAAA,wBAGwB;IAAA;AAAA;AAAA;AAAA;AAAA;AAAA;IAAAA,eAAA,cAQlB,UAACM,OAAA,EAAcC,aAAA,EAAuC;MAC3Df,QAAA,CAAS,YAAM;QACd,IAAMgB,OAAA,GAAyD,CAAC;QAChE,IAAMC,SAAA,GAA4C,CAAC;QAEnD,IAAMC,UAAA,GAAaZ,KAAA,CAAKI,KAAA,CAAMS,2BAAA,CAA4B;QAC1D,IAAIC,GAAA,GAAM;QAGV,IAAIC,MAAA;QAMJ,IAAIC,SAAA,GAAY;QAEhB,SAASC,CAAA,GAAI,GAAGC,CAAA,GAAIV,OAAA,CAAQW,MAAA,EAAQF,CAAA,GAAIC,CAAA,EAAGD,CAAA,IAAK;UAAA,IAAAG,IAAA;UAC/CL,MAAA,GAASP,OAAA,CAAQS,CAAC;UAElB,IAAMI,UAAA,KAAAD,IAAA,GAAcN,GAAA,cAAAM,IAAA,cAAAA,IAAA,GAAOR,UAAA,EAAYG,MAAA,CAAOO,EAAa;UAE3D,IAAID,UAAA,EAAY;YAGf,IAAME,YAAA,GAAeF,UAAA,CAAWR,2BAAA,CAA4B;YAG5DE,MAAA,GAASf,KAAA,CAAKwB,MAAA,CAAOC,cAAA,CACpBzB,KAAA,EACAe,MAAA,EACAN,aAAA,aAAAA,aAAA,cAAAA,aAAA,GAAiB,gBACjBc,YACD;YAEAF,UAAA,CAAWK,GAAA,CAAI7B,SAAA,CAAUkB,MAAM,CAAC;YAGhC,IAAMY,UAAA,GAAaN,UAAA,CAAWR,2BAAA,CAA4B;YAG1D,IAAIU,YAAA,KAAiBI,UAAA,EAAY;cAChCX,SAAA,GAAY;cACZN,OAAA,CAAQK,MAAA,CAAOO,EAAE,IAAI,CAACC,YAAA,EAAcI,UAAU;YAC/C;UACD,OAAO;YACNX,SAAA,GAAY;YAKZD,MAAA,GAASf,KAAA,CAAKwB,MAAA,CAAOC,cAAA,CACpBzB,KAAA,EACAe,MAAA,EACAN,aAAA,aAAAA,aAAA,cAAAA,aAAA,GAAiB,gBACjB,IACD;YAGAE,SAAA,CAAUI,MAAA,CAAOO,EAAE,IAAIP,MAAA;YAGvB,IAAI,CAACD,GAAA,EAAK;cACTA,GAAA,GAAAc,aAAA,KAAWhB,UAAA,CAAW;YACvB;YACAE,GAAA,CAAIC,MAAA,CAAOO,EAAE,IAAI/B,IAAA,CAAK,UAAUwB,MAAA,CAAOO,EAAA,EAAIP,MAAM;UAClD;QACD;QAGA,IAAID,GAAA,EAAK;UACRd,KAAA,CAAKI,KAAA,CAAMsB,GAAA,CAAIZ,GAAG;QACnB;QAGA,IAAI,CAACE,SAAA,EAAW;QAChBhB,KAAA,CAAK6B,aAAA,CAAc;UAClBC,KAAA,EAAOnB,SAAA;UACPoB,OAAA,EAASrB,OAAA;UACTsB,OAAA,EAAS,CAAC;QACX,CAAC;QAED,IAAQC,aAAA,GAAiCjC,KAAA,CAAjCiC,aAAA;UAAeC,aAAA,GAAkBlC,KAAA,CAAlBkC,aAAA;QAEvB,IAAID,aAAA,IAAiBjC,KAAA,CAAKmC,aAAA,EAAe;UAExCC,MAAA,CAAOC,MAAA,CAAO1B,SAAS,EAAE2B,OAAA,CAAQ,UAACC,OAAA,EAAW;YAC5CN,aAAA,CAAcM,OAAM;UACrB,CAAC;QACF;QAEA,IAAIL,aAAA,IAAiBlC,KAAA,CAAKmC,aAAA,EAAe;UAExCC,MAAA,CAAOC,MAAA,CAAO3B,OAAO,EAAE4B,OAAA,CAAQ,UAAAE,IAAA,EAAgB;YAAA,IAAAC,KAAA,GAAAC,cAAA,CAAAF,IAAA;cAAdG,IAAA,GAAAF,KAAA;cAAMG,EAAE,GAAAH,KAAA;YACxCP,aAAA,CAAcS,IAAA,EAAMC,EAAE;UACvB,CAAC;QACF;MACD,CAAC;IACF;IAAA;AAAA;AAAA;AAAA;AAAA;AAAA;IAAA1C,eAAA,iBAQS,UAAC2C,GAAA,EAAyB;MAClCnD,QAAA,CAAS,YAAM;QACd,IAAIM,KAAA,CAAK8C,cAAA,IAAkB9C,KAAA,CAAKmC,aAAA,EAAe;UAAA,IAAAY,SAAA,GAAAC,0BAAA,CAC7BH,GAAA;YAAAI,KAAA;UAAA;YAAjB,KAAAF,SAAA,CAAAG,CAAA,MAAAD,KAAA,GAAAF,SAAA,CAAA7B,CAAA,IAAAiC,IAAA,GAAsB;cAAA,IAAX7B,EAAA,GAAA2B,KAAA,CAAAG,KAAA;cACV,IAAMC,KAAA,GAAOrD,KAAA,CAAKI,KAAA,CAAMS,2BAAA,CAA4B,EAAES,EAAE;cACxD,IAAI,CAAC+B,KAAA,EAAM;cAEXrD,KAAA,CAAK8C,cAAA,CAAeO,KAAA,CAAKD,KAAK;YAC/B;UAAA,SAAAE,GAAA;YAAAP,SAAA,CAAAQ,CAAA,CAAAD,GAAA;UAAA;YAAAP,SAAA,CAAAS,CAAA;UAAA;QACD;QAEA,IAAIxB,OAAA,GAAU;QAGdhC,KAAA,CAAKI,KAAA,CAAMqD,MAAA,CAAO,UAACrD,KAAA,EAAU;UAAA,IAAAsD,OAAA;UAC5B,IAAIC,MAAA,GAAmC;UAAA,IAAAC,UAAA,GAAAZ,0BAAA,CAEtBH,GAAA;YAAAgB,MAAA;UAAA;YAAjB,KAAAD,UAAA,CAAAV,CAAA,MAAAW,MAAA,GAAAD,UAAA,CAAA1C,CAAA,IAAAiC,IAAA,GAAsB;cAAA,IAAX7B,GAAA,GAAAuC,MAAA,CAAAT,KAAA;cACV,IAAI,EAAE9B,GAAA,IAAMlB,KAAA,GAAQ;cACpB,IAAI,CAACuD,MAAA,EAAQA,MAAA,GAAA/B,aAAA,KAAcxB,KAAA,CAAM;cACjC,IAAI,CAAC4B,OAAA,EAASA,OAAA,GAAU,CAAC;cACzB,OAAO2B,MAAA,CAAOrC,GAAE;cAChBU,OAAA,CAAQV,GAAE,IAAIlB,KAAA,CAAMkB,GAAE,EAAE8B,KAAA;YACzB;UAAA,SAAAE,GAAA;YAAAM,UAAA,CAAAL,CAAA,CAAAD,GAAA;UAAA;YAAAM,UAAA,CAAAJ,CAAA;UAAA;UAEA,QAAAE,OAAA,GAAOC,MAAA,cAAAD,OAAA,cAAAA,OAAA,GAAUtD,KAAA;QAClB,CAAC;QAED,IAAI,CAAC4B,OAAA,EAAS;QAEdhC,KAAA,CAAK6B,aAAA,CAAc;UAAEC,KAAA,EAAO,CAAC;UAAGC,OAAA,EAAS,CAAC;UAAGC,OAAA,EAAAA;QAAQ,CAAmB;QAGxE,IAAIhC,KAAA,CAAK8D,aAAA,IAAiB9D,KAAA,CAAKmC,aAAA,EAAe;UAC7C,SAASlB,CAAA,GAAI,GAAGC,CAAA,GAAI2B,GAAA,CAAI1B,MAAA,EAAQF,CAAA,GAAIC,CAAA,EAAGD,CAAA,IAAK;YAC3CjB,KAAA,CAAK8D,aAAA,CAAc9B,OAAA,CAAQa,GAAA,CAAI5B,CAAC,CAAC,CAAC;UACnC;QACD;MACD,CAAC;IACF;IAAA;AAAA;AAAA;AAAA;AAAA;AAAA;IAAAf,eAAA,cAQM,UAAoBoB,EAAA,EAAoC;MAAA,IAAAyC,oBAAA;MAC7D,QAAAA,oBAAA,GAAO/D,KAAA,CAAKI,KAAA,CAAMgD,KAAA,CAAM9B,EAAE,eAAAyC,oBAAA,uBAAnBA,oBAAA,CAAsBX,KAAA;IAC9B;IAAA;AAAA;AAAA;AAAA;AAAA;AAAA;IAAAlD,eAAA,kCAQ0B,UAAoBoB,EAAA,EAAoC;MAAA,IAAA0C,qBAAA;MACjF,QAAAA,qBAAA,GAAOhE,KAAA,CAAKI,KAAA,CAAMgD,KAAA,CAAM9B,EAAE,eAAA0C,qBAAA,uBAAnBA,qBAAA,CAAsBnD,2BAAA,CAA4B;IAC1D;IAAA;AAAA;AAAA;AAAA;AAAA;AAAA;IAAAX,eAAA,oBAQY,YAA+D;MAAA,IAA9D+D,KAAA,GAAAC,SAAA,CAAA/C,MAAA,QAAA+C,SAAA,QAAAC,SAAA,GAAAD,SAAA,MAA6B;MACzC,IAAMP,MAAA,GAAS,CAAC;MAAA,IAAAS,UAAA,GAAApB,0BAAA,CACS/D,gBAAA,CAAiBe,KAAA,CAAKI,KAAA,CAAMgD,KAAK;QAAAiB,MAAA;MAAA;QAA1D,KAAAD,UAAA,CAAAlB,CAAA,MAAAmB,MAAA,GAAAD,UAAA,CAAAlD,CAAA,IAAAiC,IAAA,GAA6D;UAAA,IAAAmB,YAAA,GAAA5B,cAAA,CAAA2B,MAAA,CAAAjB,KAAA;YAAjD9B,EAAA,GAAAgD,YAAA;YAAIjB,KAAI,GAAAiB,YAAA;UACnB,IAAMvD,MAAA,GAASsC,KAAA,CAAKD,KAAA;UACpB,IAAIa,KAAA,KAAU,SAASjE,KAAA,CAAKuE,WAAA,CAAYN,KAAK,EAAEO,GAAA,CAAIzD,MAAA,CAAO0D,QAAQ,GAAG;YACpEd,MAAA,CAAOrC,EAAa,IAAIP,MAAA;UACzB;QACD;MAAA,SAAAuC,GAAA;QAAAc,UAAA,CAAAb,CAAA,CAAAD,GAAA;MAAA;QAAAc,UAAA,CAAAZ,CAAA;MAAA;MACA,OAAOG,MAAA;IACR;IA4CA;AAAA;AAAA;AAAA;AAAA;AAAA;IAAAzD,eAAA,qBAQa,YAAW;MACvB,OAAOd,eAAA,CAAgBY,KAAA,CAAKI,KAAA,CAAMgD,KAAK,EAAEtC,GAAA,CAAI,UAACuC,KAAA;QAAA,OAASA,KAAA,CAAKD,KAAK;MAAA;IAClE;IAAA;AAAA;AAAA;AAAA;AAAA;IAAAlD,eAAA,gBAOQ,YAAY;MACnBF,KAAA,CAAK0E,MAAA,CAAOvF,aAAA,CAAca,KAAA,CAAKI,KAAA,CAAMgD,KAAK,CAAC;IAC5C;IAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;IAAAlD,eAAA,iBASS,UAAoBoB,EAAA,EAAOqD,OAAA,EAAoD;MACvF,IAAMtB,KAAA,GAAOrD,KAAA,CAAKI,KAAA,CAAMgD,KAAA,CAAM9B,EAAE;MAChC,IAAI,CAAC+B,KAAA,EAAM;QACVuB,OAAA,CAAQC,KAAA,WAAAC,MAAA,CAAgBxD,EAAA,0CAAyC;QACjE;MACD;MACAtB,KAAA,CAAK+E,GAAA,CAAI,CAACJ,OAAA,CAAQtB,KAAA,CAAKxC,2BAAA,CAA4B,CAAwB,CAAQ,CAAC;IACrF;IAAA;AAAA;AAAA;AAAA;AAAA;AAAA;IAAAX,eAAA,cAQM,UAAoBoB,EAAA,EAAmB;MAC5C,OAAO,CAAC,CAACtB,KAAA,CAAKI,KAAA,CAAMgD,KAAA,CAAM9B,EAAE;IAC7B;IAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;IAAApB,eAAA,iBASS,UAAC8E,SAAA,EAA6BC,OAAA,EAA4C;MAAA,IAAAC,eAAA,EAAAC,cAAA;MAElFnF,KAAA,CAAKoF,aAAA,CAAc;MAEnB,IAAMC,QAAA,GAAW;QAChBL,SAAA,EAAAA,SAAA;QACAC,OAAA,EAAS;UACRK,MAAA,GAAAJ,eAAA,GAAQD,OAAA,aAAAA,OAAA,uBAAAA,OAAA,CAASK,MAAA,cAAAJ,eAAA,cAAAA,eAAA,GAAU;UAC3BjB,KAAA,GAAAkB,cAAA,GAAOF,OAAA,aAAAA,OAAA,uBAAAA,OAAA,CAAShB,KAAA,cAAAkB,cAAA,cAAAA,cAAA,GAAS;QAC1B;MACD;MAEAnF,KAAA,CAAKuF,SAAA,CAAUC,GAAA,CAAIH,QAAQ;MAE3B,IAAI,CAACrF,KAAA,CAAKyF,cAAA,CAAeC,SAAA,CAAUC,mBAAA,EAAqB;QACvD3F,KAAA,CAAKyF,cAAA,CAAeG,KAAA,CAAM;MAC3B;MAEA,OAAO,YAAM;QACZ5F,KAAA,CAAKuF,SAAA,CAAUM,MAAA,CAAOR,QAAQ;QAE9B,IAAIrF,KAAA,CAAKuF,SAAA,CAAUO,IAAA,KAAS,GAAG;UAC9B9F,KAAA,CAAKyF,cAAA,CAAeM,IAAA,CAAK;QAC1B;MACD;IACD;IAAA7F,eAAA,iCAEiC;IAAA;AAAA;AAAA;AAAA;AAAA;AAAA;IAAAA,eAAA,6BAQZ,UAAC8F,EAAA,EAAmB;MACxC,IAAIhG,KAAA,CAAKiG,sBAAA,EAAwB;QAChC,OAAOD,EAAA,CAAG;MACX;MAEA,IAAI;QACHhG,KAAA,CAAKiG,sBAAA,GAAyB;QAC9BvG,QAAA,CAASsG,EAAE;MACZ,UAAE;QACDhG,KAAA,CAAKiG,sBAAA,GAAyB;MAC/B;IACD;IAgCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;IAAA/F,eAAA,8BASsB,UACrBgG,IAAA,EACAC,MAAA,EACyB;MACzB,IAAMC,KAAA,GAAQ,IAAIzG,KAAA,CAA0C;MAC5D,OAAO;QACN0G,GAAA,EAAK,SAAAA,IAAC/E,EAAA,EAAgB;UACrB,IAAM+B,KAAA,GAAOrD,KAAA,CAAKI,KAAA,CAAMgD,KAAA,CAAM9B,EAAE;UAChC,IAAI,CAAC+B,KAAA,EAAM;YACV,OAAO;UACR;UACA,OAAO+C,KAAA,CAAMC,GAAA,CAAIhD,KAAA,EAAM;YAAA,OACtB7D,QAAA,CAAwB0G,IAAA,GAAO,MAAM5E,EAAA,EAAI;cAAA,OAAM6E,MAAA,CAAO9C,KAAA,CAAKD,KAAU,CAAC;YAAA;UAAA,CACvE,EAAEA,KAAA;QACH;MACD;IACD;IAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;IAAAlD,eAAA,sCAU8B,UAC7BgG,IAAA,EACAI,QAAA,EACAH,MAAA,EACyB;MACzB,IAAMC,KAAA,GAAQ,IAAIzG,KAAA,CAA0C;MAC5D,OAAO;QACN0G,GAAA,EAAK,SAAAA,IAAC/E,EAAA,EAAgB;UACrB,IAAM+B,KAAA,GAAOrD,KAAA,CAAKI,KAAA,CAAMgD,KAAA,CAAM9B,EAAE;UAChC,IAAI,CAAC+B,KAAA,EAAM;YACV,OAAO;UACR;UAEA,IAAMkD,CAAA,GAAI/G,QAAA,CAAwB0G,IAAA,GAAO,MAAM5E,EAAA,GAAK,aAAa;YAAA,OAChEgF,QAAA,CAASjD,KAAA,CAAKD,KAAU;UAAA,CACzB;UACA,OAAOgD,KAAA,CAAMC,GAAA,CAAIhD,KAAA,EAAM;YAAA,OACtB7D,QAAA,CAAwB0G,IAAA,GAAO,MAAM5E,EAAA,EAAI;cAAA,OAAM6E,MAAA,CAAOI,CAAA,CAAEnD,KAAU,CAAC;YAAA;UAAA,CACpE,EAAEA,KAAA;QACH;MACD;IACD;IAAAlD,eAAA;IAAAA,eAAA,+BAU+B;IAvkB9B,IAAQsG,WAAA,GAAwBzG,MAAA,CAAxByG,WAAA;MAAahF,MAAA,GAAWzB,MAAA,CAAXyB,MAAA;IAErB,KAAKA,MAAA,GAASA,MAAA;IACd,KAAKiF,KAAA,GAAQ1G,MAAA,CAAO0G,KAAA;IAEpB,IAAID,WAAA,EAAa;MAChB,KAAKpG,KAAA,CAAMsB,GAAA,CACVxC,oBAAA,CACCD,gBAAA,CAAiBuH,WAAW,EAAE1F,GAAA,CAAI,UAAA4F,KAAA;QAAA,IAAAC,KAAA,GAAAjE,cAAA,CAAAgE,KAAA;UAAEpF,EAAA,GAAAqF,KAAA;UAAI5F,MAAM,GAAA4F,KAAA;QAAA,OAAM,CACnDrF,EAAA,EACA/B,IAAA,CAAK,UAAU+B,EAAA,EAAItB,KAAA,CAAKwB,MAAA,CAAOC,cAAA,CAAezB,KAAA,EAAMe,MAAA,EAAQ,cAAc,IAAI,CAAC,EAC/E;MAAA,EACF,CACD;IACD;IAEA,KAAK0E,cAAA,GAAiBhG,OAAA,CACrB,wBACA,YAAM;MAELO,KAAA,CAAKK,OAAA,CAAQ+C,KAAA;MAEbpD,KAAA,CAAKoF,aAAA,CAAc;IACpB,GACA;MAAEwB,cAAA,EAAgB,SAAAA,eAACC,EAAA;QAAA,OAAOxH,YAAA,CAAawH,EAAE;MAAA;IAAE,CAC5C;IACA,KAAKtC,WAAA,GAAc;MAClBuC,QAAA,EAAU,IAAIxG,GAAA,CACblB,eAAA,CAAgB,KAAKoC,MAAA,CAAOuF,KAAK,EAC/BC,MAAA,CAAO,UAACC,CAAA;QAAA,OAAMA,CAAA,CAAEhD,KAAA,KAAU,UAAU;MAAA,GACpCnD,GAAA,CAAI,UAACmG,CAAA;QAAA,OAAMA,CAAA,CAAExC,QAAQ;MAAA,EACxB;MACAyC,OAAA,EAAS,IAAI5G,GAAA,CACZlB,eAAA,CAAgB,KAAKoC,MAAA,CAAOuF,KAAK,EAC/BC,MAAA,CAAO,UAACC,CAAA;QAAA,OAAMA,CAAA,CAAEhD,KAAA,KAAU,SAAS;MAAA,GACnCnD,GAAA,CAAI,UAACmG,CAAA;QAAA,OAAMA,CAAA,CAAExC,QAAQ;MAAA,EACxB;MACA0C,QAAA,EAAU,IAAI7G,GAAA,CACblB,eAAA,CAAgB,KAAKoC,MAAA,CAAOuF,KAAK,EAC/BC,MAAA,CAAO,UAACC,CAAA;QAAA,OAAMA,CAAA,CAAEhD,KAAA,KAAU,UAAU;MAAA,GACpCnD,GAAA,CAAI,UAACmG,CAAA;QAAA,OAAMA,CAAA,CAAExC,QAAQ;MAAA,EACxB;IACD;EACD;EAAA2C,YAAA,CAAAtH,KAAA;IAAAuH,GAAA;IAAAjE,KAAA,EAEO,SAAAgC,cAAA,EAAgB;MAEtB,IAAI,KAAKkC,kBAAA,CAAmBC,UAAA,CAAW,GAAG;QACzC,IAAMC,OAAA,GAAU,KAAKF,kBAAA,CAAmBG,KAAA,CAAM;QAAA,IAAAC,UAAA,GAAA1E,0BAAA,CACZwE,OAAA;UAAAG,MAAA;QAAA;UAAlC,KAAAD,UAAA,CAAAxE,CAAA,MAAAyE,MAAA,GAAAD,UAAA,CAAAxG,CAAA,IAAAiC,IAAA,GAA2C;YAAA,IAAAyE,YAAA,GAAAD,MAAA,CAAAvE,KAAA;cAA9ByE,OAAA,GAAAD,YAAA,CAAAC,OAAA;cAASvC,MAAA,GAAAsC,YAAA,CAAAtC,MAAA;YACrB,IAAIwC,eAAA,GAAkB;YACtB,IAAIC,eAAA,GAAkB;YACtB,IAAIC,eAAA,GAAkB;YAAA,IAAAC,UAAA,GAAAjF,0BAAA,CACe,KAAKuC,SAAA;cAAA2C,MAAA;YAAA;cAA1C,KAAAD,UAAA,CAAA/E,CAAA,MAAAgF,MAAA,GAAAD,UAAA,CAAA/G,CAAA,IAAAiC,IAAA,GAAqD;gBAAA,IAAAgF,YAAA,GAAAD,MAAA,CAAA9E,KAAA;kBAAxC4B,SAAA,GAAAmD,YAAA,CAAAnD,SAAA;kBAAWC,OAAA,GAAAkD,YAAA,CAAAlD,OAAA;gBACvB,IAAIA,OAAA,CAAQK,MAAA,KAAW,SAASL,OAAA,CAAQK,MAAA,KAAWA,MAAA,EAAQ;kBAC1D;gBACD;gBACA,IAAIL,OAAA,CAAQhB,KAAA,KAAU,OAAO;kBAC5B,IAAIgB,OAAA,CAAQhB,KAAA,KAAU,YAAY;oBAAA,IAAAmE,gBAAA;oBACjC,CAAAA,gBAAA,GAAAL,eAAA,cAAAK,gBAAA,cAAAA,gBAAA,GAAAL,eAAA,GAAoB,KAAKM,oBAAA,CAAqBR,OAAA,EAAS,UAAU;oBACjE,IAAI,CAACE,eAAA,EAAiB;oBACtB/C,SAAA,CAAU;sBAAE6C,OAAA,EAASE,eAAA;sBAAiBzC,MAAA,EAAAA;oBAAO,CAAC;kBAC/C,WAAWL,OAAA,CAAQhB,KAAA,KAAU,WAAW;oBAAA,IAAAqE,gBAAA;oBACvC,CAAAA,gBAAA,GAAAR,eAAA,cAAAQ,gBAAA,cAAAA,gBAAA,GAAAR,eAAA,GAAoB,KAAKO,oBAAA,CAAqBR,OAAA,EAAS,SAAS;oBAChE,IAAI,CAACC,eAAA,EAAiB;oBACtB9C,SAAA,CAAU;sBAAE6C,OAAA,EAASC,eAAA;sBAAiBxC,MAAA,EAAAA;oBAAO,CAAC;kBAC/C,OAAO;oBAAA,IAAAiD,gBAAA;oBACN,CAAAA,gBAAA,GAAAP,eAAA,cAAAO,gBAAA,cAAAA,gBAAA,GAAAP,eAAA,GAAoB,KAAKK,oBAAA,CAAqBR,OAAA,EAAS,UAAU;oBACjE,IAAI,CAACG,eAAA,EAAiB;oBACtBhD,SAAA,CAAU;sBAAE6C,OAAA,EAASG,eAAA;sBAAiB1C,MAAA,EAAAA;oBAAO,CAAC;kBAC/C;gBACD,OAAO;kBACNN,SAAA,CAAU;oBAAE6C,OAAA,EAAAA,OAAA;oBAASvC,MAAA,EAAAA;kBAAO,CAAC;gBAC9B;cACD;YAAA,SAAAhC,GAAA;cAAA2E,UAAA,CAAA1E,CAAA,CAAAD,GAAA;YAAA;cAAA2E,UAAA,CAAAzE,CAAA;YAAA;UACD;QAAA,SAAAF,GAAA;UAAAoE,UAAA,CAAAnE,CAAA,CAAAD,GAAA;QAAA;UAAAoE,UAAA,CAAAlE,CAAA;QAAA;MACD;IACD;IAAA;AAAA;AAAA;AAAA;AAAA;EAAA;IAAA6D,GAAA;IAAAjE,KAAA,EAOA,SAAAiF,qBAAqBG,MAAA,EAAwBvE,KAAA,EAAoB;MAAA,IAAAwE,MAAA;MAChE,IAAM9E,MAAA,GAAS;QACd7B,KAAA,EAAO9C,aAAA,CAAcwJ,MAAA,CAAO1G,KAAA,EAAO,UAAC4G,CAAA,EAAGC,CAAA;UAAA,OAAMF,MAAA,CAAKlE,WAAA,CAAYN,KAAK,EAAEO,GAAA,CAAImE,CAAA,CAAElE,QAAQ,CAAC;QAAA;QACpF1C,OAAA,EAAS/C,aAAA,CAAcwJ,MAAA,CAAOzG,OAAA,EAAS,UAAC2G,CAAA,EAAGC,CAAA;UAAA,OAAMF,MAAA,CAAKlE,WAAA,CAAYN,KAAK,EAAEO,GAAA,CAAImE,CAAA,CAAE,CAAC,EAAElE,QAAQ,CAAC;QAAA;QAC3FzC,OAAA,EAAShD,aAAA,CAAcwJ,MAAA,CAAOxG,OAAA,EAAS,UAAC0G,CAAA,EAAGC,CAAA;UAAA,OAAMF,MAAA,CAAKlE,WAAA,CAAYN,KAAK,EAAEO,GAAA,CAAImE,CAAA,CAAElE,QAAQ,CAAC;QAAA;MACzF;MACA,IACCrC,MAAA,CAAOwG,IAAA,CAAKjF,MAAA,CAAO7B,KAAK,EAAEX,MAAA,KAAW,KACrCiB,MAAA,CAAOwG,IAAA,CAAKjF,MAAA,CAAO5B,OAAO,EAAEZ,MAAA,KAAW,KACvCiB,MAAA,CAAOwG,IAAA,CAAKjF,MAAA,CAAO3B,OAAO,EAAEb,MAAA,KAAW,GACtC;QACD,OAAO;MACR;MACA,OAAOwC,MAAA;IACR;IAAA;AAAA;AAAA;AAAA;AAAA;EAAA;IAAA0D,GAAA;IAAAjE,KAAA,EAOQ,SAAAvB,cAAcgG,OAAA,EAA+B;MACpD,KAAKP,kBAAA,CAAmB9B,GAAA,CAAI;QAC3BqC,OAAA,EAAAA,OAAA;QACAvC,MAAA,EAAQ,KAAKW,sBAAA,GAAyB,WAAW;MAClD,CAAC;MACD,IAAI,KAAKV,SAAA,CAAUO,IAAA,KAAS,GAAG;QAC9B,KAAKwB,kBAAA,CAAmBuB,KAAA,CAAM;MAC/B;MACA,KAAKxI,OAAA,CAAQqB,GAAA,CAAI,KAAKrB,OAAA,CAAQ+C,KAAA,GAAQ,GAAGyE,OAAO;IACjD;EAAA;IAAAR,GAAA;IAAAjE,KAAA,EAEA,SAAA0F,SAASC,KAAA,EAAiE;MAAA,IAAAC,MAAA;MACzE,KAAKC,UAAA,CAAW,EAAE3G,OAAA,CAAQ,UAACvB,MAAA;QAAA,OAAWiI,MAAA,CAAKxH,MAAA,CAAOC,cAAA,CAAeuH,MAAA,EAAMjI,MAAA,EAAQgI,KAAA,EAAO,IAAI,CAAC;MAAA;IAC5F;EAAA;IAAA1B,GAAA;IAAAjE,KAAA;IA+NA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;IAaA,SAAA8F,YAAA,EAAqD;MAAA,IAAzCjF,KAAA,GAAAC,SAAA,CAAA/C,MAAA,QAAA+C,SAAA,QAAAC,SAAA,GAAAD,SAAA,MAA6B;MACxC,OAAO;QACNiF,KAAA,EAAO,KAAKC,SAAA,CAAUnF,KAAK;QAC3BzC,MAAA,EAAQ,KAAKA,MAAA,CAAO4H,SAAA,CAAU;MAC/B;IACD;IAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;EAAA;IAAA/B,GAAA;IAAAjE,KAAA,EAcA,SAAAiG,aAAaC,QAAA,EAAuE;MAAA,IAAAC,MAAA;MACnF,IAAMC,eAAA,GAAkB,KAAKhI,MAAA,CAAOiI,oBAAA,CAAqBH,QAAA,CAASH,KAAA,EAAOG,QAAA,CAAS9H,MAAM;MAExF,IAAIgI,eAAA,CAAgBE,IAAA,KAAS,SAAS;QACrC,MAAM,IAAIC,KAAA,gCAAA7E,MAAA,CAAqC0E,eAAA,CAAgBI,MAAA,CAAQ;MACxE;MAEAlK,QAAA,CAAS,YAAM;QACd6J,MAAA,CAAKV,KAAA,CAAM;QACXU,MAAA,CAAKxE,GAAA,CAAI3C,MAAA,CAAOC,MAAA,CAAOmH,eAAA,CAAgBpG,KAAK,CAAC;QAC7CmG,MAAA,CAAKM,mBAAA,CAAoB;MAC1B,CAAC;IACF;EAAA;IAAAxC,GAAA;IAAAjE,KAAA,EAsGA,SAAA0G,kBAAkB9D,EAAA,EAAgC;MACjD,IAAM6B,OAAA,GAAiC,EAAC;MACxC,IAAMkC,OAAA,GAAU,KAAKzC,kBAAA,CAAmB0C,YAAA,CAAa,UAACC,KAAA;QAAA,OAAUpC,OAAA,CAAQqC,IAAA,CAAKD,KAAA,CAAMpC,OAAO,CAAC;MAAA;MAC3F,IAAI;QACHnI,QAAA,CAASsG,EAAE;QACX,OAAOmE,iBAAA,CAAkBtC,OAAO;MACjC,UAAE;QACDkC,OAAA,CAAQ;MACT;IACD;EAAA;IAAA1C,GAAA;IAAAjE,KAAA,EAEA,SAAAgH,UAAUC,IAAA,EAA2C;MAAA,IAAAC,MAAA;MAAA,IAArBC,YAAA,GAAArG,SAAA,CAAA/C,MAAA,QAAA+C,SAAA,QAAAC,SAAA,GAAAD,SAAA,MAAe;MAC9C,IAAMsG,gBAAA,GAAmB,KAAKrI,aAAA;MAC9B,IAAI;QACH,KAAKA,aAAA,GAAgBoI,YAAA;QACrB7K,QAAA,CAAS,YAAM;UACd,IAAM+K,KAAA,GAAQrL,eAAA,CAAgBiL,IAAA,CAAKvI,KAAK,EAAEgD,MAAA,CACzC1F,eAAA,CAAgBiL,IAAA,CAAKtI,OAAO,EAAEjB,GAAA,CAAI,UAAA4J,KAAA;YAAA,IAAAC,KAAA,GAAAjI,cAAA,CAAAgI,KAAA;cAAEE,KAAA,GAAAD,KAAA;cAAO/H,EAAE,GAAA+H,KAAA;YAAA,OAAM/H,EAAE;UAAA,EACtD;UACA,IAAMiI,QAAA,GAAW1L,aAAA,CAAckL,IAAA,CAAKrI,OAAO;UAC3C,IAAIyI,KAAA,CAAMtJ,MAAA,EAAQ;YACjBmJ,MAAA,CAAKvF,GAAA,CAAI0F,KAAK;UACf;UACA,IAAII,QAAA,CAAS1J,MAAA,EAAQ;YACpBmJ,MAAA,CAAK5F,MAAA,CAAOmG,QAAQ;UACrB;QACD,CAAC;MACF,UAAE;QACD,KAAK1I,aAAA,GAAgBqI,gBAAA;MACtB;IACD;EAAA;IAAAnD,GAAA;IAAAjE,KAAA,EA0DQ;IAGR,SAAAyG,oBAAA,EAAsB;MAAA,IAAAiB,qBAAA,EAAAC,sBAAA;MACrB,CAAAD,qBAAA,QAAKE,iBAAA,cAAAF,qBAAA,cAAAA,qBAAA,GAAL,KAAKE,iBAAA,GAAsB,KAAKxJ,MAAA,CAAOyJ,sBAAA,CAAuB,IAAI;MAClE,CAAAF,sBAAA,QAAKC,iBAAA,cAAAD,sBAAA,eAALA,sBAAA,CAAAG,IAAA,KAAyB;IAC1B;EAAA;IAAA7D,GAAA;IAAAjE,KAAA,EAE+B;IAE/B,SAAA+H,wBAAA,EAA0B;MACzB,KAAKC,oBAAA,GAAuB;IAC7B;IAAA;EAAA;IAAA/D,GAAA;IAAAjE,KAAA,EAEA,SAAAiI,oBAAA,EAAsB;MACrB,OAAO,KAAKD,oBAAA;IACb;EAAA;EAAA,OAAAtL,KAAA;AAAA;AAUM,SAASqK,kBACfmB,KAAA,EACiB;EACjB,IAAM3H,MAAA,GAAS;IAAE7B,KAAA,EAAO,CAAC;IAAGE,OAAA,EAAS,CAAC;IAAGD,OAAA,EAAS,CAAC;EAAE;EAAA,IAAAwJ,UAAA,GAAAvI,0BAAA,CAElCsI,KAAA;IAAAE,MAAA;EAAA;IAAnB,KAAAD,UAAA,CAAArI,CAAA,MAAAsI,MAAA,GAAAD,UAAA,CAAArK,CAAA,IAAAiC,IAAA,GAA0B;MAAA,IAAfkH,IAAA,GAAAmB,MAAA,CAAApI,KAAA;MAAA,IAAAqI,UAAA,GAAAzI,0BAAA,CACgB/D,gBAAA,CAAiBoL,IAAA,CAAKvI,KAAK;QAAA4J,MAAA;MAAA;QAArD,KAAAD,UAAA,CAAAvI,CAAA,MAAAwI,MAAA,GAAAD,UAAA,CAAAvK,CAAA,IAAAiC,IAAA,GAAwD;UAAA,IAAAwI,YAAA,GAAAjJ,cAAA,CAAAgJ,MAAA,CAAAtI,KAAA;YAA5C9B,EAAA,GAAAqK,YAAA;YAAIvI,KAAK,GAAAuI,YAAA;UACpB,IAAIhI,MAAA,CAAO3B,OAAA,CAAQV,EAAE,GAAG;YACvB,IAAMsK,QAAA,GAAWjI,MAAA,CAAO3B,OAAA,CAAQV,EAAE;YAClC,OAAOqC,MAAA,CAAO3B,OAAA,CAAQV,EAAE;YACxB,IAAIsK,QAAA,KAAaxI,KAAA,EAAO;cACvBO,MAAA,CAAO5B,OAAA,CAAQT,EAAE,IAAI,CAACsK,QAAA,EAAUxI,KAAK;YACtC;UACD,OAAO;YACNO,MAAA,CAAO7B,KAAA,CAAMR,EAAE,IAAI8B,KAAA;UACpB;QACD;MAAA,SAAAE,GAAA;QAAAmI,UAAA,CAAAlI,CAAA,CAAAD,GAAA;MAAA;QAAAmI,UAAA,CAAAjI,CAAA;MAAA;MAAA,IAAAqI,UAAA,GAAA7I,0BAAA,CAEgC/D,gBAAA,CAAiBoL,IAAA,CAAKtI,OAAO;QAAA+J,MAAA;MAAA;QAA7D,KAAAD,UAAA,CAAA3I,CAAA,MAAA4I,MAAA,GAAAD,UAAA,CAAA3K,CAAA,IAAAiC,IAAA,GAAgE;UAAA,IAAA4I,YAAA,GAAArJ,cAAA,CAAAoJ,MAAA,CAAA1I,KAAA;YAApD9B,IAAA,GAAAyK,YAAA;YAAAC,aAAA,GAAAtJ,cAAA,CAAAqJ,YAAA;YAAKnB,KAAA,GAAAoB,aAAA;YAAOpJ,EAAE,GAAAoJ,aAAA;UACzB,IAAIrI,MAAA,CAAO7B,KAAA,CAAMR,IAAE,GAAG;YACrBqC,MAAA,CAAO7B,KAAA,CAAMR,IAAE,IAAIsB,EAAA;YACnB,OAAOe,MAAA,CAAO5B,OAAA,CAAQT,IAAE;YACxB,OAAOqC,MAAA,CAAO3B,OAAA,CAAQV,IAAE;YACxB;UACD;UACA,IAAIqC,MAAA,CAAO5B,OAAA,CAAQT,IAAE,GAAG;YACvBqC,MAAA,CAAO5B,OAAA,CAAQT,IAAE,EAAE,CAAC,IAAIsB,EAAA;YACxB,OAAOe,MAAA,CAAO3B,OAAA,CAAQV,IAAE;YACxB;UACD;UAEAqC,MAAA,CAAO5B,OAAA,CAAQT,IAAE,IAAI+I,IAAA,CAAKtI,OAAA,CAAQT,IAAE;UACpC,OAAOqC,MAAA,CAAO3B,OAAA,CAAQV,IAAE;QACzB;MAAA,SAAAgC,GAAA;QAAAuI,UAAA,CAAAtI,CAAA,CAAAD,GAAA;MAAA;QAAAuI,UAAA,CAAArI,CAAA;MAAA;MAAA,IAAAyI,UAAA,GAAAjJ,0BAAA,CAE0B/D,gBAAA,CAAiBoL,IAAA,CAAKrI,OAAO;QAAAkK,MAAA;MAAA;QAAvD,KAAAD,UAAA,CAAA/I,CAAA,MAAAgJ,MAAA,GAAAD,UAAA,CAAA/K,CAAA,IAAAiC,IAAA,GAA0D;UAAA,IAAAgJ,YAAA,GAAAzJ,cAAA,CAAAwJ,MAAA,CAAA9I,KAAA;YAA9C9B,IAAA,GAAA6K,YAAA;YAAI/I,MAAK,GAAA+I,YAAA;UAEpB,IAAIxI,MAAA,CAAO7B,KAAA,CAAMR,IAAE,GAAG;YACrB,OAAOqC,MAAA,CAAO7B,KAAA,CAAMR,IAAE;UACvB,WAAWqC,MAAA,CAAO5B,OAAA,CAAQT,IAAE,GAAG;YAC9BqC,MAAA,CAAO3B,OAAA,CAAQV,IAAE,IAAIqC,MAAA,CAAO5B,OAAA,CAAQT,IAAE,EAAE,CAAC;YACzC,OAAOqC,MAAA,CAAO5B,OAAA,CAAQT,IAAE;UACzB,OAAO;YACNqC,MAAA,CAAO3B,OAAA,CAAQV,IAAE,IAAI8B,MAAA;UACtB;QACD;MAAA,SAAAE,GAAA;QAAA2I,UAAA,CAAA1I,CAAA,CAAAD,GAAA;MAAA;QAAA2I,UAAA,CAAAzI,CAAA;MAAA;IACD;EAAA,SAAAF,GAAA;IAAAiI,UAAA,CAAAhI,CAAA,CAAAD,GAAA;EAAA;IAAAiI,UAAA,CAAA/H,CAAA;EAAA;EAEA,OAAOG,MAAA;AACR;AASA,SAASyI,qBACR5E,OAAA,EACoB;EACpB,IAAM7D,MAAA,GAA4B,EAAC;EAEnC,IAAI0I,OAAA,GAAU7E,OAAA,CAAQ,CAAC;EACvB,IAAIyC,KAAA;EAEJ,SAAShJ,CAAA,GAAI,GAAGC,CAAA,GAAIsG,OAAA,CAAQrG,MAAA,EAAQF,CAAA,GAAIC,CAAA,EAAGD,CAAA,IAAK;IAC/CgJ,KAAA,GAAQzC,OAAA,CAAQvG,CAAC;IAEjB,IAAIoL,OAAA,CAAQ/G,MAAA,KAAW2E,KAAA,CAAM3E,MAAA,EAAQ;MACpC3B,MAAA,CAAOuG,IAAA,CAAKmC,OAAO;MACnBA,OAAA,GAAUpC,KAAA;IACX,OAAO;MACNoC,OAAA,GAAU;QACT/G,MAAA,EAAQ+G,OAAA,CAAQ/G,MAAA;QAChBuC,OAAA,EAASsC,iBAAA,CAAkB,CAACkC,OAAA,CAAQxE,OAAA,EAASoC,KAAA,CAAMpC,OAAO,CAAC;MAC5D;IACD;EACD;EAEAlE,MAAA,CAAOuG,IAAA,CAAKmC,OAAO;EAEnB,OAAO1I,MAAA;AACR;AAGO,SAAS2I,mBAAmBjC,IAAA,EAAwB;EAC1D,IAAM1G,MAAA,GAA2B;IAAE7B,KAAA,EAAOuI,IAAA,CAAKrI,OAAA;IAASA,OAAA,EAASqI,IAAA,CAAKvI,KAAA;IAAOC,OAAA,EAAS,CAAC;EAAE;EACzF,SAAAwK,EAAA,MAAAC,cAAA,GAAyBpK,MAAA,CAAOC,MAAA,CAAOgI,IAAA,CAAKtI,OAAO,GAAAwK,EAAA,GAAAC,cAAA,CAAArL,MAAA,EAAAoL,EAAA,IAAG;IAAtD,IAAAE,iBAAA,GAAA/J,cAAA,CAAA8J,cAAA,CAAAD,EAAA;MAAY5J,IAAA,GAAA8J,iBAAA;MAAM7J,EAAE,GAAA6J,iBAAA;IACnB9I,MAAA,CAAO5B,OAAA,CAAQY,IAAA,CAAKrB,EAAE,IAAI,CAACsB,EAAA,EAAID,IAAI;EACpC;EACA,OAAOgB,MAAA;AACR;AAAA,IAEMpD,kBAAA;EAAA,SAAAA,mBAAA;IAAAN,eAAA,OAAAM,kBAAA;IAAAL,eAAA,mBACiC,EAAC;IAAAA,eAAA,wBAEwB,mBAAII,GAAA,CAAI;EAAA;EAAA8G,YAAA,CAAA7G,kBAAA;IAAA8G,GAAA;IAAAjE,KAAA,EAEvE,SAAA4G,aAAahE,EAAA,EAAsC;MAAA,IAAA0G,MAAA;MAClD,KAAKC,aAAA,CAAcnH,GAAA,CAAIQ,EAAE;MACzB,OAAO,YAAM;QACZ0G,MAAA,CAAKC,aAAA,CAAc9G,MAAA,CAAOG,EAAE;MAC7B;IACD;EAAA;IAAAqB,GAAA;IAAAjE,KAAA,EAEA,SAAAoC,IAAIyE,KAAA,EAAwB;MAC3B,KAAK2C,QAAA,CAAS1C,IAAA,CAAKD,KAAK;MAAA,IAAA4C,WAAA,GAAA7J,0BAAA,CACE,KAAK2J,aAAA;QAAAG,OAAA;MAAA;QAA/B,KAAAD,WAAA,CAAA3J,CAAA,MAAA4J,OAAA,GAAAD,WAAA,CAAA3L,CAAA,IAAAiC,IAAA,GAA8C;UAAA,IAAnC4J,WAAA,GAAAD,OAAA,CAAA1J,KAAA;UACV2J,WAAA,CAAY9C,KAAK;QAClB;MAAA,SAAA3G,GAAA;QAAAuJ,WAAA,CAAAtJ,CAAA,CAAAD,GAAA;MAAA;QAAAuJ,WAAA,CAAArJ,CAAA;MAAA;IACD;EAAA;IAAA6D,GAAA;IAAAjE,KAAA,EAEA,SAAAqE,MAAA,EAAQ;MACP,IAAMpH,OAAA,GAAU+L,oBAAA,CAAqB,KAAKQ,QAAQ;MAClD,KAAKA,QAAA,GAAW,EAAC;MACjB,OAAOvM,OAAA;IACR;EAAA;IAAAgH,GAAA;IAAAjE,KAAA,EAEA,SAAAyF,MAAA,EAAQ;MACP,KAAK+D,QAAA,GAAW,EAAC;IAClB;EAAA;IAAAvF,GAAA;IAAAjE,KAAA,EAEA,SAAAmE,WAAA,EAAa;MACZ,OAAO,KAAKqF,QAAA,CAASzL,MAAA,GAAS;IAC/B;EAAA;EAAA,OAAAZ,kBAAA;AAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}