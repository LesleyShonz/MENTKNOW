{"ast":null,"code":"import { Box2d } from \"./Box2d.mjs\";\nimport { Vec2d } from \"./Vec2d.mjs\";\nvar PI = Math.PI;\nvar TAU = PI / 2;\nvar PI2 = PI * 2;\nvar EPSILON = Math.PI / 180;\nvar SIN = Math.sin;\nfunction clamp(n, min, max) {\n  return Math.max(min, typeof max !== \"undefined\" ? Math.min(n, max) : n);\n}\nfunction toPrecision(n) {\n  var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1e10;\n  if (!n) return 0;\n  return Math.round(n * precision) / precision;\n}\nfunction approximately(a, b) {\n  var precision = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1e-6;\n  return Math.abs(a - b) <= precision;\n}\nfunction perimeterOfEllipse(rx, ry) {\n  var h = Math.pow(rx - ry, 2) / Math.pow(rx + ry, 2);\n  var p = PI * (rx + ry) * (1 + 3 * h / (10 + Math.sqrt(4 - 3 * h)));\n  return p;\n}\nfunction canolicalizeRotation(a) {\n  a = a % PI2;\n  if (a < 0) {\n    a = a + PI2;\n  } else if (a === 0) {\n    a = 0;\n  }\n  return a;\n}\nfunction shortAngleDist(a0, a1) {\n  var da = (a1 - a0) % PI2;\n  return 2 * da % PI2 - da;\n}\nfunction longAngleDist(a0, a1) {\n  return PI2 - shortAngleDist(a0, a1);\n}\nfunction lerpAngles(a0, a1, t) {\n  return a0 + shortAngleDist(a0, a1) * t;\n}\nfunction angleDelta(a0, a1) {\n  return shortAngleDist(a0, a1);\n}\nfunction getSweep(C, A, B) {\n  return angleDelta(Vec2d.Angle(C, A), Vec2d.Angle(C, B));\n}\nfunction clampRadians(r) {\n  return (PI2 + r) % PI2;\n}\nfunction snapAngle(r, segments) {\n  var seg = PI2 / segments;\n  var ang = Math.floor((clampRadians(r) + seg / 2) / seg) * seg % PI2;\n  if (ang < PI) ang += PI2;\n  if (ang > PI) ang -= PI2;\n  return ang;\n}\nfunction areAnglesCompatible(a, b) {\n  return a === b || approximately(a % (Math.PI / 2) - b % (Math.PI / 2), 0);\n}\nfunction isAngleBetween(a, b, c) {\n  if (c === a || c === b) return true;\n  var AB = (b - a + TAU) % TAU;\n  var AC = (c - a + TAU) % TAU;\n  return AB <= PI !== AC > AB;\n}\nfunction degreesToRadians(d) {\n  return d * PI / 180;\n}\nfunction radiansToDegrees(r) {\n  return r * 180 / PI;\n}\nfunction getArcLength(C, r, A, B) {\n  var sweep = getSweep(C, A, B);\n  return r * PI2 * (sweep / PI2);\n}\nfunction getPointOnCircle(cx, cy, r, a) {\n  return new Vec2d(cx + r * Math.cos(a), cy + r * Math.sin(a));\n}\nfunction getPolygonVertices(width, height, sides) {\n  var cx = width / 2;\n  var cy = height / 2;\n  var pointsOnPerimeter = [];\n  for (var i = 0; i < sides; i++) {\n    var step = PI2 / sides;\n    var t = -TAU + i * step;\n    pointsOnPerimeter.push(new Vec2d(cx + cx * Math.cos(t), cy + cy * Math.sin(t)));\n  }\n  return pointsOnPerimeter;\n}\nfunction rangesOverlap(a0, a1, b0, b1) {\n  return a0 < b1 && b0 < a1;\n}\nfunction rangeIntersection(a0, a1, b0, b1) {\n  var min = Math.max(a0, b0);\n  var max = Math.min(a1, b1);\n  if (min <= max) {\n    return [min, max];\n  }\n  return null;\n}\nvar getStarBounds = function getStarBounds(sides, w, h) {\n  var step = PI2 / sides / 2;\n  var rightMostIndex = Math.floor(sides / 4) * 2;\n  var leftMostIndex = sides * 2 - rightMostIndex;\n  var topMostIndex = 0;\n  var bottomMostIndex = Math.floor(sides / 2) * 2;\n  var maxX = Math.cos(-TAU + rightMostIndex * step) * w / 2;\n  var minX = Math.cos(-TAU + leftMostIndex * step) * w / 2;\n  var minY = Math.sin(-TAU + topMostIndex * step) * h / 2;\n  var maxY = Math.sin(-TAU + bottomMostIndex * step) * h / 2;\n  return new Box2d(0, 0, maxX - minX, maxY - minY);\n};\nfunction cross(x, y, z) {\n  return (y.x - x.x) * (z.y - x.y) - (z.x - x.x) * (y.y - x.y);\n}\nfunction pointInCircle(A, C, r) {\n  return Vec2d.Dist(A, C) <= r;\n}\nfunction pointInEllipse(A, C, rx, ry) {\n  var rotation = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n  rotation = rotation || 0;\n  var cos = Math.cos(rotation);\n  var sin = Math.sin(rotation);\n  var delta = Vec2d.Sub(A, C);\n  var tdx = cos * delta.x + sin * delta.y;\n  var tdy = sin * delta.x - cos * delta.y;\n  return tdx * tdx / (rx * rx) + tdy * tdy / (ry * ry) <= 1;\n}\nfunction pointInRect(A, point, size) {\n  return !(A.x < point.x || A.x > point.x + size.x || A.y < point.y || A.y > point.y + size.y);\n}\nfunction pointInPolygon(A, points) {\n  var windingNumber = 0;\n  var a;\n  var b;\n  for (var i = 0; i < points.length; i++) {\n    a = points[i];\n    b = points[(i + 1) % points.length];\n    if (a.y <= A.y) {\n      if (b.y > A.y && cross(a, b, A) > 0) {\n        windingNumber += 1;\n      }\n    } else if (b.y <= A.y && cross(a, b, A) < 0) {\n      windingNumber -= 1;\n    }\n  }\n  return windingNumber !== 0;\n}\nfunction pointInBounds(A, b) {\n  return !(A.x < b.minX || A.x > b.maxX || A.y < b.minY || A.y > b.maxY);\n}\nfunction pointInPolyline(A, points) {\n  var distance = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 3;\n  for (var i = 1; i < points.length; i++) {\n    if (Vec2d.DistanceToLineSegment(points[i - 1], points[i], A) < distance) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction pointNearToPolyline(A, points) {\n  var distance = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 8;\n  var len = points.length;\n  for (var i = 1; i < len; i++) {\n    var p1 = points[i - 1];\n    var p2 = points[i];\n    var d = Vec2d.DistanceToLineSegment(p1, p2, A);\n    if (d < distance) return true;\n  }\n  return false;\n}\nfunction pointNearToLineSegment(A, p1, p2) {\n  var distance = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 8;\n  var d = Vec2d.DistanceToLineSegment(p1, p2, A);\n  if (d < distance) return true;\n  return false;\n}\nfunction simplify(points) {\n  var tolerance = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  var len = points.length;\n  var a = points[0];\n  var b = points[len - 1];\n  var x1 = a.x,\n    y1 = a.y;\n  var x2 = b.x,\n    y2 = b.y;\n  if (len > 2) {\n    var distance = 0;\n    var index = 0;\n    var max = new Vec2d(y2 - y1, x2 - x1).len2();\n    for (var i = 1; i < len - 1; i++) {\n      var _points$i = points[i],\n        x0 = _points$i.x,\n        y0 = _points$i.y;\n      var d = Math.pow(x0 * (y2 - y1) + x1 * (y0 - y2) + x2 * (y1 - y0), 2) / max;\n      if (distance > d) continue;\n      distance = d;\n      index = i;\n    }\n    if (distance > tolerance) {\n      var l0 = simplify(points.slice(0, index + 1), tolerance);\n      var l1 = simplify(points.slice(index + 1), tolerance);\n      return l0.concat(l1.slice(1));\n    }\n  }\n  return [a, b];\n}\nfunction _getSqSegDist(p, p1, p2) {\n  var x = p1.x;\n  var y = p1.y;\n  var dx = p2.x - x;\n  var dy = p2.y - y;\n  if (dx !== 0 || dy !== 0) {\n    var t = ((p.x - x) * dx + (p.y - y) * dy) / (dx * dx + dy * dy);\n    if (t > 1) {\n      x = p2.x;\n      y = p2.y;\n    } else if (t > 0) {\n      x += dx * t;\n      y += dy * t;\n    }\n  }\n  dx = p.x - x;\n  dy = p.y - y;\n  return dx * dx + dy * dy;\n}\nfunction _simplifyStep(points, first, last, sqTolerance, result) {\n  var maxSqDist = sqTolerance;\n  var index = -1;\n  for (var i = first + 1; i < last; i++) {\n    var sqDist = _getSqSegDist(points[i], points[first], points[last]);\n    if (sqDist > maxSqDist) {\n      index = i;\n      maxSqDist = sqDist;\n    }\n  }\n  if (index > -1 && maxSqDist > sqTolerance) {\n    if (index - first > 1) _simplifyStep(points, first, index, sqTolerance, result);\n    result.push(points[index]);\n    if (last - index > 1) _simplifyStep(points, index, last, sqTolerance, result);\n  }\n}\nfunction simplify2(points) {\n  var tolerance = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  if (points.length <= 2) return points;\n  var sqTolerance = tolerance * tolerance;\n  var A = points[0];\n  var B = points[1];\n  var newPoints = [A];\n  for (var i = 1, len = points.length; i < len; i++) {\n    B = points[i];\n    if ((B.x - A.x) * (B.x - A.x) + (B.y - A.y) * (B.y - A.y) > sqTolerance) {\n      newPoints.push(B);\n      A = B;\n    }\n  }\n  if (A !== B) newPoints.push(B);\n  var last = newPoints.length - 1;\n  var result = [newPoints[0]];\n  _simplifyStep(newPoints, 0, last, sqTolerance, result);\n  result.push(newPoints[last], points[points.length - 1]);\n  return result;\n}\nfunction getMinX(pts) {\n  var top = pts[0];\n  for (var i = 1; i < pts.length; i++) {\n    if (pts[i].x < top.x) {\n      top = pts[i];\n    }\n  }\n  return top.x;\n}\nfunction getMinY(pts) {\n  var top = pts[0];\n  for (var i = 1; i < pts.length; i++) {\n    if (pts[i].y < top.y) {\n      top = pts[i];\n    }\n  }\n  return top.y;\n}\nfunction getMaxX(pts) {\n  var top = pts[0];\n  for (var i = 1; i < pts.length; i++) {\n    if (pts[i].x > top.x) {\n      top = pts[i];\n    }\n  }\n  return top.x;\n}\nfunction getMaxY(pts) {\n  var top = pts[0];\n  for (var i = 1; i < pts.length; i++) {\n    if (pts[i].y > top.y) {\n      top = pts[i];\n    }\n  }\n  return top.y;\n}\nfunction getMidX(pts) {\n  var a = getMinX(pts);\n  var b = getMaxX(pts);\n  return a + (b - a) / 2;\n}\nfunction getMidY(pts) {\n  var a = getMinY(pts);\n  var b = getMaxY(pts);\n  return a + (b - a) / 2;\n}\nfunction getWidth(pts) {\n  var a = getMinX(pts);\n  var b = getMaxX(pts);\n  return b - a;\n}\nfunction getHeight(pts) {\n  var a = getMinY(pts);\n  var b = getMaxY(pts);\n  return b - a;\n}\nfunction toDomPrecision(v) {\n  return +v.toFixed(4);\n}\nfunction toFixed(v) {\n  return +v.toFixed(2);\n}\nvar isSafeFloat = function isSafeFloat(n) {\n  return Math.abs(n) < Number.MAX_SAFE_INTEGER;\n};\nexport { EPSILON, PI, PI2, SIN, TAU, angleDelta, approximately, areAnglesCompatible, canolicalizeRotation, clamp, clampRadians, degreesToRadians, getArcLength, getHeight, getMaxX, getMaxY, getMidX, getMidY, getMinX, getMinY, getPointOnCircle, getPolygonVertices, getStarBounds, getSweep, getWidth, isAngleBetween, isSafeFloat, lerpAngles, longAngleDist, perimeterOfEllipse, pointInBounds, pointInCircle, pointInEllipse, pointInPolygon, pointInPolyline, pointInRect, pointNearToLineSegment, pointNearToPolyline, radiansToDegrees, rangeIntersection, rangesOverlap, shortAngleDist, simplify, simplify2, snapAngle, toDomPrecision, toFixed, toPrecision };","map":{"version":3,"names":["Box2d","Vec2d","PI","Math","TAU","PI2","EPSILON","SIN","sin","clamp","n","min","max","toPrecision","precision","arguments","length","undefined","round","approximately","a","b","abs","perimeterOfEllipse","rx","ry","h","pow","p","sqrt","canolicalizeRotation","shortAngleDist","a0","a1","da","longAngleDist","lerpAngles","t","angleDelta","getSweep","C","A","B","Angle","clampRadians","r","snapAngle","segments","seg","ang","floor","areAnglesCompatible","isAngleBetween","c","AB","AC","degreesToRadians","d","radiansToDegrees","getArcLength","sweep","getPointOnCircle","cx","cy","cos","getPolygonVertices","width","height","sides","pointsOnPerimeter","i","step","push","rangesOverlap","b0","b1","rangeIntersection","getStarBounds","w","rightMostIndex","leftMostIndex","topMostIndex","bottomMostIndex","maxX","minX","minY","maxY","cross","x","y","z","pointInCircle","Dist","pointInEllipse","rotation","delta","Sub","tdx","tdy","pointInRect","point","size","pointInPolygon","points","windingNumber","pointInBounds","pointInPolyline","distance","DistanceToLineSegment","pointNearToPolyline","len","p1","p2","pointNearToLineSegment","simplify","tolerance","x1","y1","x2","y2","index","len2","_points$i","x0","y0","l0","slice","l1","concat","_getSqSegDist","dx","dy","_simplifyStep","first","last","sqTolerance","result","maxSqDist","sqDist","simplify2","newPoints","getMinX","pts","top","getMinY","getMaxX","getMaxY","getMidX","getMidY","getWidth","getHeight","toDomPrecision","v","toFixed","isSafeFloat","Number","MAX_SAFE_INTEGER"],"sources":["/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@tldraw/primitives/src/lib/utils.ts"],"sourcesContent":["import { Box2d } from './Box2d'\nimport { Vec2d, VecLike } from './Vec2d'\n\n/** @public */\nexport const PI = Math.PI\n/** @public */\nexport const TAU = PI / 2\n/** @public */\nexport const PI2 = PI * 2\n/** @public */\nexport const EPSILON = Math.PI / 180\n/** @public */\nexport const SIN = Math.sin\n\n/**\n * Clamp a value into a range.\n *\n * @example\n *\n * ```ts\n * const A = clamp(0, 1) // 1\n * ```\n *\n * @param n - The number to clamp.\n * @param min - The minimum value.\n * @public\n */\nexport function clamp(n: number, min: number): number\n/**\n * Clamp a value into a range.\n *\n * @example\n *\n * ```ts\n * const A = clamp(0, 1, 10) // 1\n * const B = clamp(11, 1, 10) // 10\n * const C = clamp(5, 1, 10) // 5\n * ```\n *\n * @param n - The number to clamp.\n * @param min - The minimum value.\n * @param max - The maximum value.\n * @public\n */\nexport function clamp(n: number, min: number, max: number): number\nexport function clamp(n: number, min: number, max?: number): number {\n\treturn Math.max(min, typeof max !== 'undefined' ? Math.min(n, max) : n)\n}\n\n/**\n * Get a number to a precision.\n *\n * @param n - The number.\n * @param precision - The precision.\n * @public\n */\nexport function toPrecision(n: number, precision = 10000000000) {\n\tif (!n) return 0\n\treturn Math.round(n * precision) / precision\n}\n\n/**\n * Whether two numbers numbers a and b are approximately equal.\n *\n * @param a - The first point.\n * @param b - The second point.\n * @public\n */\nexport function approximately(a: number, b: number, precision = 0.000001) {\n\treturn Math.abs(a - b) <= precision\n}\n\n/**\n * Find the approximate perimeter of an ellipse.\n *\n * @param rx - The ellipse's x radius.\n * @param ry - The ellipse's y radius.\n * @public\n */\nexport function perimeterOfEllipse(rx: number, ry: number): number {\n\tconst h = Math.pow(rx - ry, 2) / Math.pow(rx + ry, 2)\n\tconst p = PI * (rx + ry) * (1 + (3 * h) / (10 + Math.sqrt(4 - 3 * h)))\n\treturn p\n}\n\n/**\n * @param a - Any angle in radians\n * @returns A number between 0 and 2 * PI\n * @public\n */\nexport function canolicalizeRotation(a: number) {\n\ta = a % PI2\n\tif (a < 0) {\n\t\ta = a + PI2\n\t} else if (a === 0) {\n\t\t// prevent negative zero\n\t\ta = 0\n\t}\n\treturn a\n}\n\n/**\n * Get the short angle distance between two angles.\n *\n * @param a0 - The first angle.\n * @param a1 - The second angle.\n * @public\n */\nexport function shortAngleDist(a0: number, a1: number): number {\n\tconst da = (a1 - a0) % PI2\n\treturn ((2 * da) % PI2) - da\n}\n\n/**\n * Get the long angle distance between two angles.\n *\n * @param a0 - The first angle.\n * @param a1 - The second angle.\n * @public\n */\nexport function longAngleDist(a0: number, a1: number): number {\n\treturn PI2 - shortAngleDist(a0, a1)\n}\n\n/**\n * Interpolate an angle between two angles.\n *\n * @param a0 - The first angle.\n * @param a1 - The second angle.\n * @param t - The interpolation value.\n * @public\n */\nexport function lerpAngles(a0: number, a1: number, t: number): number {\n\treturn a0 + shortAngleDist(a0, a1) * t\n}\n\n/**\n * Get the short distance between two angles.\n *\n * @param a0 - The first angle.\n * @param a1 - The second angle.\n * @public\n */\nexport function angleDelta(a0: number, a1: number): number {\n\treturn shortAngleDist(a0, a1)\n}\n\n/**\n * Get the \"sweep\" or short distance between two points on a circle's perimeter.\n *\n * @param C - The center of the circle.\n * @param A - The first point.\n * @param B - The second point.\n * @public\n */\nexport function getSweep(C: VecLike, A: VecLike, B: VecLike): number {\n\treturn angleDelta(Vec2d.Angle(C, A), Vec2d.Angle(C, B))\n}\n\n/**\n * Clamp radians within 0 and 2PI\n *\n * @param r - The radian value.\n * @public\n */\nexport function clampRadians(r: number): number {\n\treturn (PI2 + r) % PI2\n}\n\n/**\n * Clamp rotation to even segments.\n *\n * @param r - The rotation in radians.\n * @param segments - The number of segments.\n * @public\n */\nexport function snapAngle(r: number, segments: number): number {\n\tconst seg = PI2 / segments\n\tlet ang = (Math.floor((clampRadians(r) + seg / 2) / seg) * seg) % PI2\n\tif (ang < PI) ang += PI2\n\tif (ang > PI) ang -= PI2\n\treturn ang\n}\n\n/**\n * Checks whether two angles are approximately at right-angles or parallel to each other\n *\n * @param a - Angle a (radians)\n * @param b - Angle b (radians)\n * @returns True iff the angles are approximately at right-angles or parallel to each other\n * @public\n */\nexport function areAnglesCompatible(a: number, b: number) {\n\treturn a === b || approximately((a % (Math.PI / 2)) - (b % (Math.PI / 2)), 0)\n}\n\n/**\n * Is angle c between angles a and b?\n *\n * @param a - The first angle.\n * @param b - The second angle.\n * @param c - The third angle.\n * @public\n */\nexport function isAngleBetween(a: number, b: number, c: number): boolean {\n\tif (c === a || c === b) return true\n\n\tconst AB = (b - a + TAU) % TAU\n\tconst AC = (c - a + TAU) % TAU\n\treturn AB <= PI !== AC > AB\n}\n\n/**\n * Convert degrees to radians.\n *\n * @param d - The degree in degrees.\n * @public\n */\nexport function degreesToRadians(d: number): number {\n\treturn (d * PI) / 180\n}\n\n/**\n * Convert radians to degrees.\n *\n * @param r - The degree in radians.\n * @public\n */\nexport function radiansToDegrees(r: number): number {\n\treturn (r * 180) / PI\n}\n\n/**\n * Get the length of an arc between two points on a circle's perimeter.\n *\n * @param C - The circle's center as [x, y].\n * @param r - The circle's radius.\n * @param A - The first point.\n * @param B - The second point.\n * @public\n */\nexport function getArcLength(C: VecLike, r: number, A: VecLike, B: VecLike): number {\n\tconst sweep = getSweep(C, A, B)\n\treturn r * PI2 * (sweep / PI2)\n}\n\n/**\n * Get a point on the perimeter of a circle.\n *\n * @param cx - The center x of the circle.\n * @param cy - The center y of the circle.\n * @param r - The radius of the circle.\n * @param a - The normalized point on the circle.\n * @public\n */\nexport function getPointOnCircle(cx: number, cy: number, r: number, a: number) {\n\treturn new Vec2d(cx + r * Math.cos(a), cy + r * Math.sin(a))\n}\n/** @public */\nexport function getPolygonVertices(width: number, height: number, sides: number) {\n\tconst cx = width / 2\n\tconst cy = height / 2\n\tconst pointsOnPerimeter = []\n\tfor (let i = 0; i < sides; i++) {\n\t\tconst step = PI2 / sides\n\t\tconst t = -TAU + i * step\n\t\tpointsOnPerimeter.push(new Vec2d(cx + cx * Math.cos(t), cy + cy * Math.sin(t)))\n\t}\n\treturn pointsOnPerimeter\n}\n\n/**\n * @param a0 - The start point in the A range\n * @param a1 - The end point in the A range\n * @param b0 - The start point in the B range\n * @param b1 - The end point in the B range\n * @returns True if the ranges overlap\n * @public\n */\nexport function rangesOverlap(a0: number, a1: number, b0: number, b1: number): boolean {\n\treturn a0 < b1 && b0 < a1\n}\n\n/**\n * Finds the intersection of two ranges.\n *\n * @param a0 - The start point in the A range\n * @param a1 - The end point in the A range\n * @param b0 - The start point in the B range\n * @param b1 - The end point in the B range\n * @returns The intersection of the ranges, or null if no intersection\n * @public\n */\nexport function rangeIntersection(\n\ta0: number,\n\ta1: number,\n\tb0: number,\n\tb1: number\n): [number, number] | null {\n\tconst min = Math.max(a0, b0)\n\tconst max = Math.min(a1, b1)\n\tif (min <= max) {\n\t\treturn [min, max]\n\t}\n\treturn null\n}\n\n/**\n * Gets the width/height of a star given its input bounds.\n *\n * @param sides - Number of sides\n * @param w - T target width\n * @param h - Target height\n * @returns Box2d\n * @public\n */\nexport const getStarBounds = (sides: number, w: number, h: number): Box2d => {\n\tconst step = PI2 / sides / 2\n\tconst rightMostIndex = Math.floor(sides / 4) * 2\n\tconst leftMostIndex = sides * 2 - rightMostIndex\n\tconst topMostIndex = 0\n\tconst bottomMostIndex = Math.floor(sides / 2) * 2\n\tconst maxX = (Math.cos(-TAU + rightMostIndex * step) * w) / 2\n\tconst minX = (Math.cos(-TAU + leftMostIndex * step) * w) / 2\n\tconst minY = (Math.sin(-TAU + topMostIndex * step) * h) / 2\n\tconst maxY = (Math.sin(-TAU + bottomMostIndex * step) * h) / 2\n\treturn new Box2d(0, 0, maxX - minX, maxY - minY)\n}\n\n/** Helper for point in polygon */\nfunction cross(x: VecLike, y: VecLike, z: VecLike): number {\n\treturn (y.x - x.x) * (z.y - x.y) - (z.x - x.x) * (y.y - x.y)\n}\n\n/**\n * Utils for working with points.\n *\n * @public\n */\n/**\n * Get whether a point is inside of a circle.\n *\n * @param A - The point to check.\n * @param C - The circle's center point as [x, y].\n * @param r - The circle's radius.\n * @returns Boolean\n * @public\n */\nexport function pointInCircle(A: VecLike, C: VecLike, r: number): boolean {\n\treturn Vec2d.Dist(A, C) <= r\n}\n\n/**\n * Get whether a point is inside of an ellipse.\n *\n * @param point - The point to check.\n * @param center - The ellipse's center point as [x, y].\n * @param rx - The ellipse's x radius.\n * @param ry - The ellipse's y radius.\n * @param rotation - The ellipse's rotation.\n * @returns Boolean\n * @public\n */\nexport function pointInEllipse(\n\tA: VecLike,\n\tC: VecLike,\n\trx: number,\n\try: number,\n\trotation = 0\n): boolean {\n\trotation = rotation || 0\n\tconst cos = Math.cos(rotation)\n\tconst sin = Math.sin(rotation)\n\tconst delta = Vec2d.Sub(A, C)\n\tconst tdx = cos * delta.x + sin * delta.y\n\tconst tdy = sin * delta.x - cos * delta.y\n\n\treturn (tdx * tdx) / (rx * rx) + (tdy * tdy) / (ry * ry) <= 1\n}\n\n/**\n * Get whether a point is inside of a rectangle.\n *\n * @param A - The point to check.\n * @param point - The rectangle's top left point as [x, y].\n * @param size - The rectangle's size as [width, height].\n * @public\n */\nexport function pointInRect(A: VecLike, point: VecLike, size: VecLike): boolean {\n\treturn !(A.x < point.x || A.x > point.x + size.x || A.y < point.y || A.y > point.y + size.y)\n}\n\n/**\n * Get whether a point is inside of a polygon.\n *\n * ```ts\n * const result = pointInPolygon(myPoint, myPoints)\n * ```\n *\n * @public\n */\nexport function pointInPolygon(A: VecLike, points: VecLike[]): boolean {\n\tlet windingNumber = 0\n\tlet a: VecLike\n\tlet b: VecLike\n\n\tfor (let i = 0; i < points.length; i++) {\n\t\ta = points[i]\n\t\tb = points[(i + 1) % points.length]\n\n\t\tif (a.y <= A.y) {\n\t\t\tif (b.y > A.y && cross(a, b, A) > 0) {\n\t\t\t\twindingNumber += 1\n\t\t\t}\n\t\t} else if (b.y <= A.y && cross(a, b, A) < 0) {\n\t\t\twindingNumber -= 1\n\t\t}\n\t}\n\n\treturn windingNumber !== 0\n}\n\n/**\n * Get whether a point is inside of a bounds.\n *\n * @param A - The point to check.\n * @param b - The bounds to check.\n * @returns Boolean\n * @public\n */\nexport function pointInBounds(A: VecLike, b: Box2d): boolean {\n\treturn !(A.x < b.minX || A.x > b.maxX || A.y < b.minY || A.y > b.maxY)\n}\n\n/**\n * Hit test a point and a polyline using a minimum distance.\n *\n * @param A - The point to check.\n * @param points - The points that make up the polyline.\n * @param distance - The mininum distance that qualifies a hit.\n * @returns Boolean\n * @public\n */\nexport function pointInPolyline(A: VecLike, points: VecLike[], distance = 3): boolean {\n\tfor (let i = 1; i < points.length; i++) {\n\t\tif (Vec2d.DistanceToLineSegment(points[i - 1], points[i], A) < distance) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n/**\n * Get whether a point is within a certain distance from a polyline.\n *\n * @param A - The point to check.\n * @param points - The points that make up the polyline.\n * @param distance - The mininum distance that qualifies a hit.\n * @public\n */\nexport function pointNearToPolyline(A: VecLike, points: VecLike[], distance = 8) {\n\tconst len = points.length\n\tfor (let i = 1; i < len; i++) {\n\t\tconst p1 = points[i - 1]\n\t\tconst p2 = points[i]\n\t\tconst d = Vec2d.DistanceToLineSegment(p1, p2, A)\n\t\tif (d < distance) return true\n\t}\n\treturn false\n}\n\n/**\n * Get whether a point is within a certain distance from a line segment.\n *\n * @param A - The point to check.\n * @param p1 - The polyline's first point.\n * @param p2 - The polyline's second point.\n * @param distance - The mininum distance that qualifies a hit.\n * @public\n */\nexport function pointNearToLineSegment(A: VecLike, p1: VecLike, p2: VecLike, distance = 8) {\n\tconst d = Vec2d.DistanceToLineSegment(p1, p2, A)\n\tif (d < distance) return true\n\treturn false\n}\n\n/**\n * Simplify a line (using Ramer-Douglas-Peucker algorithm).\n *\n * @param points - An array of points as [x, y, ...][]\n * @param tolerance - The minimum line distance (also called epsilon).\n * @returns Simplified array as [x, y, ...][]\n * @public\n */\nexport function simplify(points: VecLike[], tolerance = 1): VecLike[] {\n\tconst len = points.length\n\tconst a = points[0]\n\tconst b = points[len - 1]\n\tconst { x: x1, y: y1 } = a\n\tconst { x: x2, y: y2 } = b\n\tif (len > 2) {\n\t\tlet distance = 0\n\t\tlet index = 0\n\t\tconst max = new Vec2d(y2 - y1, x2 - x1).len2()\n\t\tfor (let i = 1; i < len - 1; i++) {\n\t\t\tconst { x: x0, y: y0 } = points[i]\n\t\t\tconst d = Math.pow(x0 * (y2 - y1) + x1 * (y0 - y2) + x2 * (y1 - y0), 2) / max\n\t\t\tif (distance > d) continue\n\t\t\tdistance = d\n\t\t\tindex = i\n\t\t}\n\t\tif (distance > tolerance) {\n\t\t\tconst l0 = simplify(points.slice(0, index + 1), tolerance)\n\t\t\tconst l1 = simplify(points.slice(index + 1), tolerance)\n\t\t\treturn l0.concat(l1.slice(1))\n\t\t}\n\t}\n\treturn [a, b]\n}\n\nfunction _getSqSegDist(p: VecLike, p1: VecLike, p2: VecLike) {\n\tlet x = p1.x\n\tlet y = p1.y\n\tlet dx = p2.x - x\n\tlet dy = p2.y - y\n\tif (dx !== 0 || dy !== 0) {\n\t\tconst t = ((p.x - x) * dx + (p.y - y) * dy) / (dx * dx + dy * dy)\n\t\tif (t > 1) {\n\t\t\tx = p2.x\n\t\t\ty = p2.y\n\t\t} else if (t > 0) {\n\t\t\tx += dx * t\n\t\t\ty += dy * t\n\t\t}\n\t}\n\tdx = p.x - x\n\tdy = p.y - y\n\treturn dx * dx + dy * dy\n}\n\nfunction _simplifyStep(\n\tpoints: VecLike[],\n\tfirst: number,\n\tlast: number,\n\tsqTolerance: number,\n\tresult: VecLike[]\n) {\n\tlet maxSqDist = sqTolerance\n\tlet index = -1\n\tfor (let i = first + 1; i < last; i++) {\n\t\tconst sqDist = _getSqSegDist(points[i], points[first], points[last])\n\t\tif (sqDist > maxSqDist) {\n\t\t\tindex = i\n\t\t\tmaxSqDist = sqDist\n\t\t}\n\t}\n\tif (index > -1 && maxSqDist > sqTolerance) {\n\t\tif (index - first > 1) _simplifyStep(points, first, index, sqTolerance, result)\n\t\tresult.push(points[index])\n\t\tif (last - index > 1) _simplifyStep(points, index, last, sqTolerance, result)\n\t}\n}\n\n/** @public */\nexport function simplify2(points: VecLike[], tolerance = 1) {\n\tif (points.length <= 2) return points\n\tconst sqTolerance = tolerance * tolerance\n\t// Radial distance\n\tlet A = points[0]\n\tlet B = points[1]\n\tconst newPoints = [A]\n\tfor (let i = 1, len = points.length; i < len; i++) {\n\t\tB = points[i]\n\t\tif ((B.x - A.x) * (B.x - A.x) + (B.y - A.y) * (B.y - A.y) > sqTolerance) {\n\t\t\tnewPoints.push(B)\n\t\t\tA = B\n\t\t}\n\t}\n\tif (A !== B) newPoints.push(B)\n\t// Ramer-Douglas-Peucker\n\tconst last = newPoints.length - 1\n\tconst result = [newPoints[0]]\n\t_simplifyStep(newPoints, 0, last, sqTolerance, result)\n\tresult.push(newPoints[last], points[points.length - 1])\n\treturn result\n}\n\n/** @public */\nexport function getMinX(pts: VecLike[]) {\n\tlet top = pts[0]\n\tfor (let i = 1; i < pts.length; i++) {\n\t\tif (pts[i].x < top.x) {\n\t\t\ttop = pts[i]\n\t\t}\n\t}\n\treturn top.x\n}\n\n/** @public */\nexport function getMinY(pts: VecLike[]) {\n\tlet top = pts[0]\n\tfor (let i = 1; i < pts.length; i++) {\n\t\tif (pts[i].y < top.y) {\n\t\t\ttop = pts[i]\n\t\t}\n\t}\n\treturn top.y\n}\n\n/** @public */\nexport function getMaxX(pts: VecLike[]) {\n\tlet top = pts[0]\n\tfor (let i = 1; i < pts.length; i++) {\n\t\tif (pts[i].x > top.x) {\n\t\t\ttop = pts[i]\n\t\t}\n\t}\n\treturn top.x\n}\n\n/** @public */\nexport function getMaxY(pts: VecLike[]) {\n\tlet top = pts[0]\n\tfor (let i = 1; i < pts.length; i++) {\n\t\tif (pts[i].y > top.y) {\n\t\t\ttop = pts[i]\n\t\t}\n\t}\n\treturn top.y\n}\n\n/** @public */\nexport function getMidX(pts: VecLike[]) {\n\tconst a = getMinX(pts)\n\tconst b = getMaxX(pts)\n\n\treturn a + (b - a) / 2\n}\n\n/** @public */\nexport function getMidY(pts: VecLike[]) {\n\tconst a = getMinY(pts)\n\tconst b = getMaxY(pts)\n\n\treturn a + (b - a) / 2\n}\n\n/** @public */\nexport function getWidth(pts: VecLike[]) {\n\tconst a = getMinX(pts)\n\tconst b = getMaxX(pts)\n\treturn b - a\n}\n\n/** @public */\nexport function getHeight(pts: VecLike[]) {\n\tconst a = getMinY(pts)\n\tconst b = getMaxY(pts)\n\treturn b - a\n}\n\n/**\n * The DOM likes values to be fixed to 3 decimal places\n *\n * @public\n */\nexport function toDomPrecision(v: number) {\n\treturn +v.toFixed(4)\n}\n\n/**\n * @public\n */\nexport function toFixed(v: number) {\n\treturn +v.toFixed(2)\n}\n\n/**\n * Check if a float is safe to use. ie: Not too big or small.\n * @public\n */\nexport const isSafeFloat = (n: number) => {\n\treturn Math.abs(n) < Number.MAX_SAFE_INTEGER\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}