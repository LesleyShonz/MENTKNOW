{"ast":null,"code":"import { Matrix2d, Vec2d } from \"@tldraw/primitives\";\nfunction getIsArrowStraight(shape) {\n  return Math.abs(shape.props.bend) < 8;\n}\nfunction getBoundShapeInfoForTerminal(editor, terminal) {\n  if (terminal.type === \"point\") {\n    return;\n  }\n  var shape = editor.getShapeById(terminal.boundShapeId);\n  var util = editor.getShapeUtil(shape);\n  var transform = editor.getPageTransform(shape);\n  return {\n    shape: shape,\n    util: util,\n    transform: transform,\n    isExact: terminal.isExact,\n    didIntersect: false\n  };\n}\nfunction getArrowTerminalInArrowSpace(editor, arrowPageTransform, terminal) {\n  if (terminal.type === \"point\") {\n    return Vec2d.From(terminal);\n  }\n  var boundShape = editor.getShapeById(terminal.boundShapeId);\n  if (!boundShape) {\n    return new Vec2d(0, 0);\n  } else {\n    var _editor$getBounds = editor.getBounds(boundShape),\n      point = _editor$getBounds.point,\n      size = _editor$getBounds.size;\n    var shapePoint = Vec2d.Add(point, Vec2d.MulV(terminal.normalizedAnchor, size));\n    var pagePoint = Matrix2d.applyToPoint(editor.getPageTransform(boundShape), shapePoint);\n    var arrowPoint = Matrix2d.applyToPoint(Matrix2d.Inverse(arrowPageTransform), pagePoint);\n    return arrowPoint;\n  }\n}\nfunction getArrowTerminalsInArrowSpace(editor, shape) {\n  var arrowPageTransform = editor.getPageTransform(shape);\n  var start = getArrowTerminalInArrowSpace(editor, arrowPageTransform, shape.props.start);\n  var end = getArrowTerminalInArrowSpace(editor, arrowPageTransform, shape.props.end);\n  return {\n    start: start,\n    end: end\n  };\n}\nvar MIN_ARROW_LENGTH = 48;\nvar BOUND_ARROW_OFFSET = 10;\nvar WAY_TOO_BIG_ARROW_BEND_FACTOR = 10;\nexport { BOUND_ARROW_OFFSET, MIN_ARROW_LENGTH, WAY_TOO_BIG_ARROW_BEND_FACTOR, getArrowTerminalInArrowSpace, getArrowTerminalsInArrowSpace, getBoundShapeInfoForTerminal, getIsArrowStraight };","map":{"version":3,"names":["Matrix2d","Vec2d","getIsArrowStraight","shape","Math","abs","props","bend","getBoundShapeInfoForTerminal","editor","terminal","type","getShapeById","boundShapeId","util","getShapeUtil","transform","getPageTransform","isExact","didIntersect","getArrowTerminalInArrowSpace","arrowPageTransform","From","boundShape","_editor$getBounds","getBounds","point","size","shapePoint","Add","MulV","normalizedAnchor","pagePoint","applyToPoint","arrowPoint","Inverse","getArrowTerminalsInArrowSpace","start","end","MIN_ARROW_LENGTH","BOUND_ARROW_OFFSET","WAY_TOO_BIG_ARROW_BEND_FACTOR"],"sources":["/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@tldraw/editor/src/lib/editor/shapes/arrow/arrow/shared.ts"],"sourcesContent":["import { Matrix2d, Vec2d } from '@tldraw/primitives'\nimport { TLArrowShape, TLArrowShapeTerminal, TLShape } from '@tldraw/tlschema'\nimport { Editor } from '../../../Editor'\nimport { ShapeUtil } from '../../ShapeUtil'\n\nexport function getIsArrowStraight(shape: TLArrowShape) {\n\treturn Math.abs(shape.props.bend) < 8 // snap to +-8px\n}\n\nexport type BoundShapeInfo<T extends TLShape = TLShape> = {\n\tshape: T\n\tutil: ShapeUtil<T>\n\tdidIntersect: boolean\n\tisExact: boolean\n\ttransform: Matrix2d\n}\n\nexport function getBoundShapeInfoForTerminal(\n\teditor: Editor,\n\tterminal: TLArrowShapeTerminal\n): BoundShapeInfo | undefined {\n\tif (terminal.type === 'point') {\n\t\treturn\n\t}\n\n\tconst shape = editor.getShapeById(terminal.boundShapeId)!\n\tconst util = editor.getShapeUtil(shape)\n\tconst transform = editor.getPageTransform(shape)!\n\n\treturn {\n\t\tshape,\n\t\tutil,\n\t\ttransform,\n\t\tisExact: terminal.isExact,\n\t\tdidIntersect: false,\n\t}\n}\n\nexport function getArrowTerminalInArrowSpace(\n\teditor: Editor,\n\tarrowPageTransform: Matrix2d,\n\tterminal: TLArrowShapeTerminal\n) {\n\tif (terminal.type === 'point') {\n\t\treturn Vec2d.From(terminal)\n\t}\n\n\tconst boundShape = editor.getShapeById(terminal.boundShapeId)\n\n\tif (!boundShape) {\n\t\t// this can happen in multiplayer contexts where the shape is being deleted\n\t\treturn new Vec2d(0, 0)\n\t} else {\n\t\t// Find the actual local point of the normalized terminal on\n\t\t// the bound shape and transform it to page space, then transform\n\t\t// it to arrow space\n\t\tconst { point, size } = editor.getBounds(boundShape)\n\t\tconst shapePoint = Vec2d.Add(point, Vec2d.MulV(terminal.normalizedAnchor, size))\n\t\tconst pagePoint = Matrix2d.applyToPoint(editor.getPageTransform(boundShape)!, shapePoint)\n\t\tconst arrowPoint = Matrix2d.applyToPoint(Matrix2d.Inverse(arrowPageTransform), pagePoint)\n\t\treturn arrowPoint\n\t}\n}\n\nexport function getArrowTerminalsInArrowSpace(editor: Editor, shape: TLArrowShape) {\n\tconst arrowPageTransform = editor.getPageTransform(shape)!\n\n\tconst start = getArrowTerminalInArrowSpace(editor, arrowPageTransform, shape.props.start)\n\tconst end = getArrowTerminalInArrowSpace(editor, arrowPageTransform, shape.props.end)\n\n\treturn { start, end }\n}\n\n/** @internal */\nexport const MIN_ARROW_LENGTH = 48\n/** @internal */\nexport const BOUND_ARROW_OFFSET = 10\n/** @internal */\nexport const WAY_TOO_BIG_ARROW_BEND_FACTOR = 10\n"],"mappings":"AAAA,SAASA,QAAA,EAAUC,KAAA,QAAa;AAKzB,SAASC,mBAAmBC,KAAA,EAAqB;EACvD,OAAOC,IAAA,CAAKC,GAAA,CAAIF,KAAA,CAAMG,KAAA,CAAMC,IAAI,IAAI;AACrC;AAUO,SAASC,6BACfC,MAAA,EACAC,QAAA,EAC6B;EAC7B,IAAIA,QAAA,CAASC,IAAA,KAAS,SAAS;IAC9B;EACD;EAEA,IAAMR,KAAA,GAAQM,MAAA,CAAOG,YAAA,CAAaF,QAAA,CAASG,YAAY;EACvD,IAAMC,IAAA,GAAOL,MAAA,CAAOM,YAAA,CAAaZ,KAAK;EACtC,IAAMa,SAAA,GAAYP,MAAA,CAAOQ,gBAAA,CAAiBd,KAAK;EAE/C,OAAO;IACNA,KAAA,EAAAA,KAAA;IACAW,IAAA,EAAAA,IAAA;IACAE,SAAA,EAAAA,SAAA;IACAE,OAAA,EAASR,QAAA,CAASQ,OAAA;IAClBC,YAAA,EAAc;EACf;AACD;AAEO,SAASC,6BACfX,MAAA,EACAY,kBAAA,EACAX,QAAA,EACC;EACD,IAAIA,QAAA,CAASC,IAAA,KAAS,SAAS;IAC9B,OAAOV,KAAA,CAAMqB,IAAA,CAAKZ,QAAQ;EAC3B;EAEA,IAAMa,UAAA,GAAad,MAAA,CAAOG,YAAA,CAAaF,QAAA,CAASG,YAAY;EAE5D,IAAI,CAACU,UAAA,EAAY;IAEhB,OAAO,IAAItB,KAAA,CAAM,GAAG,CAAC;EACtB,OAAO;IAIN,IAAAuB,iBAAA,GAAwBf,MAAA,CAAOgB,SAAA,CAAUF,UAAU;MAA3CG,KAAA,GAAAF,iBAAA,CAAAE,KAAA;MAAOC,IAAA,GAAAH,iBAAA,CAAAG,IAAA;IACf,IAAMC,UAAA,GAAa3B,KAAA,CAAM4B,GAAA,CAAIH,KAAA,EAAOzB,KAAA,CAAM6B,IAAA,CAAKpB,QAAA,CAASqB,gBAAA,EAAkBJ,IAAI,CAAC;IAC/E,IAAMK,SAAA,GAAYhC,QAAA,CAASiC,YAAA,CAAaxB,MAAA,CAAOQ,gBAAA,CAAiBM,UAAU,GAAIK,UAAU;IACxF,IAAMM,UAAA,GAAalC,QAAA,CAASiC,YAAA,CAAajC,QAAA,CAASmC,OAAA,CAAQd,kBAAkB,GAAGW,SAAS;IACxF,OAAOE,UAAA;EACR;AACD;AAEO,SAASE,8BAA8B3B,MAAA,EAAgBN,KAAA,EAAqB;EAClF,IAAMkB,kBAAA,GAAqBZ,MAAA,CAAOQ,gBAAA,CAAiBd,KAAK;EAExD,IAAMkC,KAAA,GAAQjB,4BAAA,CAA6BX,MAAA,EAAQY,kBAAA,EAAoBlB,KAAA,CAAMG,KAAA,CAAM+B,KAAK;EACxF,IAAMC,GAAA,GAAMlB,4BAAA,CAA6BX,MAAA,EAAQY,kBAAA,EAAoBlB,KAAA,CAAMG,KAAA,CAAMgC,GAAG;EAEpF,OAAO;IAAED,KAAA,EAAAA,KAAA;IAAOC,GAAA,EAAAA;EAAI;AACrB;AAGO,IAAMC,gBAAA,GAAmB;AAEzB,IAAMC,kBAAA,GAAqB;AAE3B,IAAMC,6BAAA,GAAgC"},"metadata":{},"sourceType":"module","externalDependencies":[]}