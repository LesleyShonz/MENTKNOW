{"ast":null,"code":"import _inherits from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _createClass from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\n/**\n * Efficient schema-less binary decoding with support for variable length encoding.\n *\n * Use [lib0/decoding] with [lib0/encoding]. Every encoding function has a corresponding decoding function.\n *\n * Encodes numbers in little-endian order (least to most significant byte order)\n * and is compatible with Golang's binary encoding (https://golang.org/pkg/encoding/binary/)\n * which is also used in Protocol Buffers.\n *\n * ```js\n * // encoding step\n * const encoder = encoding.createEncoder()\n * encoding.writeVarUint(encoder, 256)\n * encoding.writeVarString(encoder, 'Hello world!')\n * const buf = encoding.toUint8Array(encoder)\n * ```\n *\n * ```js\n * // decoding step\n * const decoder = decoding.createDecoder(buf)\n * decoding.readVarUint(decoder) // => 256\n * decoding.readVarString(decoder) // => 'Hello world!'\n * decoding.hasContent(decoder) // => false - all data is read\n * ```\n *\n * @module decoding\n */\n\nimport * as buffer from './buffer.js';\nimport * as binary from './binary.js';\nimport * as math from './math.js';\nimport * as number from './number.js';\nimport * as string from './string.js';\nimport * as error from './error.js';\nimport * as encoding from './encoding.js';\nvar errorUnexpectedEndOfArray = error.create('Unexpected end of array');\nvar errorIntegerOutOfRange = error.create('Integer out of Range');\n\n/**\n * A Decoder handles the decoding of an Uint8Array.\n */\nexport var Decoder = /*#__PURE__*/_createClass(\n/**\n * @param {Uint8Array} uint8Array Binary data to decode\n */\nfunction Decoder(uint8Array) {\n  _classCallCheck(this, Decoder);\n  /**\n   * Decoding target.\n   *\n   * @type {Uint8Array}\n   */\n  this.arr = uint8Array;\n  /**\n   * Current decoding position.\n   *\n   * @type {number}\n   */\n  this.pos = 0;\n});\n\n/**\n * @function\n * @param {Uint8Array} uint8Array\n * @return {Decoder}\n */\nexport var createDecoder = function createDecoder(uint8Array) {\n  return new Decoder(uint8Array);\n};\n\n/**\n * @function\n * @param {Decoder} decoder\n * @return {boolean}\n */\nexport var hasContent = function hasContent(decoder) {\n  return decoder.pos !== decoder.arr.length;\n};\n\n/**\n * Clone a decoder instance.\n * Optionally set a new position parameter.\n *\n * @function\n * @param {Decoder} decoder The decoder instance\n * @param {number} [newPos] Defaults to current position\n * @return {Decoder} A clone of `decoder`\n */\nexport var clone = function clone(decoder) {\n  var newPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : decoder.pos;\n  var _decoder = createDecoder(decoder.arr);\n  _decoder.pos = newPos;\n  return _decoder;\n};\n\n/**\n * Create an Uint8Array view of the next `len` bytes and advance the position by `len`.\n *\n * Important: The Uint8Array still points to the underlying ArrayBuffer. Make sure to discard the result as soon as possible to prevent any memory leaks.\n *            Use `buffer.copyUint8Array` to copy the result into a new Uint8Array.\n *\n * @function\n * @param {Decoder} decoder The decoder instance\n * @param {number} len The length of bytes to read\n * @return {Uint8Array}\n */\nexport var readUint8Array = function readUint8Array(decoder, len) {\n  var view = buffer.createUint8ArrayViewFromArrayBuffer(decoder.arr.buffer, decoder.pos + decoder.arr.byteOffset, len);\n  decoder.pos += len;\n  return view;\n};\n\n/**\n * Read variable length Uint8Array.\n *\n * Important: The Uint8Array still points to the underlying ArrayBuffer. Make sure to discard the result as soon as possible to prevent any memory leaks.\n *            Use `buffer.copyUint8Array` to copy the result into a new Uint8Array.\n *\n * @function\n * @param {Decoder} decoder\n * @return {Uint8Array}\n */\nexport var readVarUint8Array = function readVarUint8Array(decoder) {\n  return readUint8Array(decoder, readVarUint(decoder));\n};\n\n/**\n * Read the rest of the content as an ArrayBuffer\n * @function\n * @param {Decoder} decoder\n * @return {Uint8Array}\n */\nexport var readTailAsUint8Array = function readTailAsUint8Array(decoder) {\n  return readUint8Array(decoder, decoder.arr.length - decoder.pos);\n};\n\n/**\n * Skip one byte, jump to the next position.\n * @function\n * @param {Decoder} decoder The decoder instance\n * @return {number} The next position\n */\nexport var skip8 = function skip8(decoder) {\n  return decoder.pos++;\n};\n\n/**\n * Read one byte as unsigned integer.\n * @function\n * @param {Decoder} decoder The decoder instance\n * @return {number} Unsigned 8-bit integer\n */\nexport var readUint8 = function readUint8(decoder) {\n  return decoder.arr[decoder.pos++];\n};\n\n/**\n * Read 2 bytes as unsigned integer.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nexport var readUint16 = function readUint16(decoder) {\n  var uint = decoder.arr[decoder.pos] + (decoder.arr[decoder.pos + 1] << 8);\n  decoder.pos += 2;\n  return uint;\n};\n\n/**\n * Read 4 bytes as unsigned integer.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nexport var readUint32 = function readUint32(decoder) {\n  var uint = decoder.arr[decoder.pos] + (decoder.arr[decoder.pos + 1] << 8) + (decoder.arr[decoder.pos + 2] << 16) + (decoder.arr[decoder.pos + 3] << 24) >>> 0;\n  decoder.pos += 4;\n  return uint;\n};\n\n/**\n * Read 4 bytes as unsigned integer in big endian order.\n * (most significant byte first)\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nexport var readUint32BigEndian = function readUint32BigEndian(decoder) {\n  var uint = decoder.arr[decoder.pos + 3] + (decoder.arr[decoder.pos + 2] << 8) + (decoder.arr[decoder.pos + 1] << 16) + (decoder.arr[decoder.pos] << 24) >>> 0;\n  decoder.pos += 4;\n  return uint;\n};\n\n/**\n * Look ahead without incrementing the position\n * to the next byte and read it as unsigned integer.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nexport var peekUint8 = function peekUint8(decoder) {\n  return decoder.arr[decoder.pos];\n};\n\n/**\n * Look ahead without incrementing the position\n * to the next byte and read it as unsigned integer.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nexport var peekUint16 = function peekUint16(decoder) {\n  return decoder.arr[decoder.pos] + (decoder.arr[decoder.pos + 1] << 8);\n};\n\n/**\n * Look ahead without incrementing the position\n * to the next byte and read it as unsigned integer.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nexport var peekUint32 = function peekUint32(decoder) {\n  return decoder.arr[decoder.pos] + (decoder.arr[decoder.pos + 1] << 8) + (decoder.arr[decoder.pos + 2] << 16) + (decoder.arr[decoder.pos + 3] << 24) >>> 0;\n};\n\n/**\n * Read unsigned integer (32bit) with variable length.\n * 1/8th of the storage is used as encoding overhead.\n *  * numbers < 2^7 is stored in one bytlength\n *  * numbers < 2^14 is stored in two bylength\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.length\n */\nexport var readVarUint = function readVarUint(decoder) {\n  var num = 0;\n  var mult = 1;\n  var len = decoder.arr.length;\n  while (decoder.pos < len) {\n    var r = decoder.arr[decoder.pos++];\n    // num = num | ((r & binary.BITS7) << len)\n    num = num + (r & binary.BITS7) * mult; // shift $r << (7*#iterations) and add it to num\n    mult *= 128; // next iteration, shift 7 \"more\" to the left\n    if (r < binary.BIT8) {\n      return num;\n    }\n    /* c8 ignore start */\n    if (num > number.MAX_SAFE_INTEGER) {\n      throw errorIntegerOutOfRange;\n    }\n    /* c8 ignore stop */\n  }\n\n  throw errorUnexpectedEndOfArray;\n};\n\n/**\n * Read signed integer (32bit) with variable length.\n * 1/8th of the storage is used as encoding overhead.\n *  * numbers < 2^7 is stored in one bytlength\n *  * numbers < 2^14 is stored in two bylength\n * @todo This should probably create the inverse ~num if number is negative - but this would be a breaking change.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.length\n */\nexport var readVarInt = function readVarInt(decoder) {\n  var r = decoder.arr[decoder.pos++];\n  var num = r & binary.BITS6;\n  var mult = 64;\n  var sign = (r & binary.BIT7) > 0 ? -1 : 1;\n  if ((r & binary.BIT8) === 0) {\n    // don't continue reading\n    return sign * num;\n  }\n  var len = decoder.arr.length;\n  while (decoder.pos < len) {\n    r = decoder.arr[decoder.pos++];\n    // num = num | ((r & binary.BITS7) << len)\n    num = num + (r & binary.BITS7) * mult;\n    mult *= 128;\n    if (r < binary.BIT8) {\n      return sign * num;\n    }\n    /* c8 ignore start */\n    if (num > number.MAX_SAFE_INTEGER) {\n      throw errorIntegerOutOfRange;\n    }\n    /* c8 ignore stop */\n  }\n\n  throw errorUnexpectedEndOfArray;\n};\n\n/**\n * Look ahead and read varUint without incrementing position\n *\n * @function\n * @param {Decoder} decoder\n * @return {number}\n */\nexport var peekVarUint = function peekVarUint(decoder) {\n  var pos = decoder.pos;\n  var s = readVarUint(decoder);\n  decoder.pos = pos;\n  return s;\n};\n\n/**\n * Look ahead and read varUint without incrementing position\n *\n * @function\n * @param {Decoder} decoder\n * @return {number}\n */\nexport var peekVarInt = function peekVarInt(decoder) {\n  var pos = decoder.pos;\n  var s = readVarInt(decoder);\n  decoder.pos = pos;\n  return s;\n};\n\n/**\n * We don't test this function anymore as we use native decoding/encoding by default now.\n * Better not modify this anymore..\n *\n * Transforming utf8 to a string is pretty expensive. The code performs 10x better\n * when String.fromCodePoint is fed with all characters as arguments.\n * But most environments have a maximum number of arguments per functions.\n * For effiency reasons we apply a maximum of 10000 characters at once.\n *\n * @function\n * @param {Decoder} decoder\n * @return {String} The read String.\n */\n/* c8 ignore start */\nexport var _readVarStringPolyfill = function _readVarStringPolyfill(decoder) {\n  var remainingLen = readVarUint(decoder);\n  if (remainingLen === 0) {\n    return '';\n  } else {\n    var encodedString = String.fromCodePoint(readUint8(decoder)); // remember to decrease remainingLen\n    if (--remainingLen < 100) {\n      // do not create a Uint8Array for small strings\n      while (remainingLen--) {\n        encodedString += String.fromCodePoint(readUint8(decoder));\n      }\n    } else {\n      while (remainingLen > 0) {\n        var nextLen = remainingLen < 10000 ? remainingLen : 10000;\n        // this is dangerous, we create a fresh array view from the existing buffer\n        var bytes = decoder.arr.subarray(decoder.pos, decoder.pos + nextLen);\n        decoder.pos += nextLen;\n        // Starting with ES5.1 we can supply a generic array-like object as arguments\n        encodedString += String.fromCodePoint.apply(null, /** @type {any} */bytes);\n        remainingLen -= nextLen;\n      }\n    }\n    return decodeURIComponent(escape(encodedString));\n  }\n};\n/* c8 ignore stop */\n\n/**\n * @function\n * @param {Decoder} decoder\n * @return {String} The read String\n */\nexport var _readVarStringNative = function _readVarStringNative(decoder) {\n  return (/** @type any */string.utf8TextDecoder.decode(readVarUint8Array(decoder))\n  );\n};\n\n/**\n * Read string of variable length\n * * varUint is used to store the length of the string\n *\n * @function\n * @param {Decoder} decoder\n * @return {String} The read String\n *\n */\n/* c8 ignore next */\nexport var readVarString = string.utf8TextDecoder ? _readVarStringNative : _readVarStringPolyfill;\n\n/**\n * @param {Decoder} decoder\n * @return {Uint8Array}\n */\nexport var readTerminatedUint8Array = function readTerminatedUint8Array(decoder) {\n  var encoder = encoding.createEncoder();\n  var b;\n  while (true) {\n    b = readUint8(decoder);\n    if (b === 0) {\n      return encoding.toUint8Array(encoder);\n    }\n    if (b === 1) {\n      b = readUint8(decoder);\n    }\n    encoding.write(encoder, b);\n  }\n};\n\n/**\n * @param {Decoder} decoder\n * @return {string}\n */\nexport var readTerminatedString = function readTerminatedString(decoder) {\n  return string.decodeUtf8(readTerminatedUint8Array(decoder));\n};\n\n/**\n * Look ahead and read varString without incrementing position\n *\n * @function\n * @param {Decoder} decoder\n * @return {string}\n */\nexport var peekVarString = function peekVarString(decoder) {\n  var pos = decoder.pos;\n  var s = readVarString(decoder);\n  decoder.pos = pos;\n  return s;\n};\n\n/**\n * @param {Decoder} decoder\n * @param {number} len\n * @return {DataView}\n */\nexport var readFromDataView = function readFromDataView(decoder, len) {\n  var dv = new DataView(decoder.arr.buffer, decoder.arr.byteOffset + decoder.pos, len);\n  decoder.pos += len;\n  return dv;\n};\n\n/**\n * @param {Decoder} decoder\n */\nexport var readFloat32 = function readFloat32(decoder) {\n  return readFromDataView(decoder, 4).getFloat32(0, false);\n};\n\n/**\n * @param {Decoder} decoder\n */\nexport var readFloat64 = function readFloat64(decoder) {\n  return readFromDataView(decoder, 8).getFloat64(0, false);\n};\n\n/**\n * @param {Decoder} decoder\n */\nexport var readBigInt64 = function readBigInt64(decoder) {\n  return (/** @type {any} */readFromDataView(decoder, 8).getBigInt64(0, false)\n  );\n};\n\n/**\n * @param {Decoder} decoder\n */\nexport var readBigUint64 = function readBigUint64(decoder) {\n  return (/** @type {any} */readFromDataView(decoder, 8).getBigUint64(0, false)\n  );\n};\n\n/**\n * @type {Array<function(Decoder):any>}\n */\nvar readAnyLookupTable = [function (decoder) {\n  return undefined;\n},\n// CASE 127: undefined\nfunction (decoder) {\n  return null;\n},\n// CASE 126: null\nreadVarInt,\n// CASE 125: integer\nreadFloat32,\n// CASE 124: float32\nreadFloat64,\n// CASE 123: float64\nreadBigInt64,\n// CASE 122: bigint\nfunction (decoder) {\n  return false;\n},\n// CASE 121: boolean (false)\nfunction (decoder) {\n  return true;\n},\n// CASE 120: boolean (true)\nreadVarString,\n// CASE 119: string\nfunction (decoder) {\n  // CASE 118: object<string,any>\n  var len = readVarUint(decoder);\n  /**\n   * @type {Object<string,any>}\n   */\n  var obj = {};\n  for (var i = 0; i < len; i++) {\n    var key = readVarString(decoder);\n    obj[key] = readAny(decoder);\n  }\n  return obj;\n}, function (decoder) {\n  // CASE 117: array<any>\n  var len = readVarUint(decoder);\n  var arr = [];\n  for (var i = 0; i < len; i++) {\n    arr.push(readAny(decoder));\n  }\n  return arr;\n}, readVarUint8Array // CASE 116: Uint8Array\n];\n\n/**\n * @param {Decoder} decoder\n */\nexport var readAny = function readAny(decoder) {\n  return readAnyLookupTable[127 - readUint8(decoder)](decoder);\n};\n\n/**\n * T must not be null.\n *\n * @template T\n */\nexport var RleDecoder = /*#__PURE__*/function (_Decoder) {\n  _inherits(RleDecoder, _Decoder);\n  var _super = _createSuper(RleDecoder);\n  /**\n   * @param {Uint8Array} uint8Array\n   * @param {function(Decoder):T} reader\n   */\n  function RleDecoder(uint8Array, reader) {\n    var _this;\n    _classCallCheck(this, RleDecoder);\n    _this = _super.call(this, uint8Array);\n    /**\n     * The reader\n     */\n    _this.reader = reader;\n    /**\n     * Current state\n     * @type {T|null}\n     */\n    _this.s = null;\n    _this.count = 0;\n    return _this;\n  }\n  _createClass(RleDecoder, [{\n    key: \"read\",\n    value: function read() {\n      if (this.count === 0) {\n        this.s = this.reader(this);\n        if (hasContent(this)) {\n          this.count = readVarUint(this) + 1; // see encoder implementation for the reason why this is incremented\n        } else {\n          this.count = -1; // read the current value forever\n        }\n      }\n\n      this.count--;\n      return (/** @type {T} */this.s\n      );\n    }\n  }]);\n  return RleDecoder;\n}(Decoder);\nexport var IntDiffDecoder = /*#__PURE__*/function (_Decoder2) {\n  _inherits(IntDiffDecoder, _Decoder2);\n  var _super2 = _createSuper(IntDiffDecoder);\n  /**\n   * @param {Uint8Array} uint8Array\n   * @param {number} start\n   */\n  function IntDiffDecoder(uint8Array, start) {\n    var _this2;\n    _classCallCheck(this, IntDiffDecoder);\n    _this2 = _super2.call(this, uint8Array);\n    /**\n     * Current state\n     * @type {number}\n     */\n    _this2.s = start;\n    return _this2;\n  }\n\n  /**\n   * @return {number}\n   */\n  _createClass(IntDiffDecoder, [{\n    key: \"read\",\n    value: function read() {\n      this.s += readVarInt(this);\n      return this.s;\n    }\n  }]);\n  return IntDiffDecoder;\n}(Decoder);\nexport var RleIntDiffDecoder = /*#__PURE__*/function (_Decoder3) {\n  _inherits(RleIntDiffDecoder, _Decoder3);\n  var _super3 = _createSuper(RleIntDiffDecoder);\n  /**\n   * @param {Uint8Array} uint8Array\n   * @param {number} start\n   */\n  function RleIntDiffDecoder(uint8Array, start) {\n    var _this3;\n    _classCallCheck(this, RleIntDiffDecoder);\n    _this3 = _super3.call(this, uint8Array);\n    /**\n     * Current state\n     * @type {number}\n     */\n    _this3.s = start;\n    _this3.count = 0;\n    return _this3;\n  }\n\n  /**\n   * @return {number}\n   */\n  _createClass(RleIntDiffDecoder, [{\n    key: \"read\",\n    value: function read() {\n      if (this.count === 0) {\n        this.s += readVarInt(this);\n        if (hasContent(this)) {\n          this.count = readVarUint(this) + 1; // see encoder implementation for the reason why this is incremented\n        } else {\n          this.count = -1; // read the current value forever\n        }\n      }\n\n      this.count--;\n      return (/** @type {number} */this.s\n      );\n    }\n  }]);\n  return RleIntDiffDecoder;\n}(Decoder);\nexport var UintOptRleDecoder = /*#__PURE__*/function (_Decoder4) {\n  _inherits(UintOptRleDecoder, _Decoder4);\n  var _super4 = _createSuper(UintOptRleDecoder);\n  /**\n   * @param {Uint8Array} uint8Array\n   */\n  function UintOptRleDecoder(uint8Array) {\n    var _this4;\n    _classCallCheck(this, UintOptRleDecoder);\n    _this4 = _super4.call(this, uint8Array);\n    /**\n     * @type {number}\n     */\n    _this4.s = 0;\n    _this4.count = 0;\n    return _this4;\n  }\n  _createClass(UintOptRleDecoder, [{\n    key: \"read\",\n    value: function read() {\n      if (this.count === 0) {\n        this.s = readVarInt(this);\n        // if the sign is negative, we read the count too, otherwise count is 1\n        var isNegative = math.isNegativeZero(this.s);\n        this.count = 1;\n        if (isNegative) {\n          this.s = -this.s;\n          this.count = readVarUint(this) + 2;\n        }\n      }\n      this.count--;\n      return (/** @type {number} */this.s\n      );\n    }\n  }]);\n  return UintOptRleDecoder;\n}(Decoder);\nexport var IncUintOptRleDecoder = /*#__PURE__*/function (_Decoder5) {\n  _inherits(IncUintOptRleDecoder, _Decoder5);\n  var _super5 = _createSuper(IncUintOptRleDecoder);\n  /**\n   * @param {Uint8Array} uint8Array\n   */\n  function IncUintOptRleDecoder(uint8Array) {\n    var _this5;\n    _classCallCheck(this, IncUintOptRleDecoder);\n    _this5 = _super5.call(this, uint8Array);\n    /**\n     * @type {number}\n     */\n    _this5.s = 0;\n    _this5.count = 0;\n    return _this5;\n  }\n  _createClass(IncUintOptRleDecoder, [{\n    key: \"read\",\n    value: function read() {\n      if (this.count === 0) {\n        this.s = readVarInt(this);\n        // if the sign is negative, we read the count too, otherwise count is 1\n        var isNegative = math.isNegativeZero(this.s);\n        this.count = 1;\n        if (isNegative) {\n          this.s = -this.s;\n          this.count = readVarUint(this) + 2;\n        }\n      }\n      this.count--;\n      return (/** @type {number} */this.s++\n      );\n    }\n  }]);\n  return IncUintOptRleDecoder;\n}(Decoder);\nexport var IntDiffOptRleDecoder = /*#__PURE__*/function (_Decoder6) {\n  _inherits(IntDiffOptRleDecoder, _Decoder6);\n  var _super6 = _createSuper(IntDiffOptRleDecoder);\n  /**\n   * @param {Uint8Array} uint8Array\n   */\n  function IntDiffOptRleDecoder(uint8Array) {\n    var _this6;\n    _classCallCheck(this, IntDiffOptRleDecoder);\n    _this6 = _super6.call(this, uint8Array);\n    /**\n     * @type {number}\n     */\n    _this6.s = 0;\n    _this6.count = 0;\n    _this6.diff = 0;\n    return _this6;\n  }\n\n  /**\n   * @return {number}\n   */\n  _createClass(IntDiffOptRleDecoder, [{\n    key: \"read\",\n    value: function read() {\n      if (this.count === 0) {\n        var diff = readVarInt(this);\n        // if the first bit is set, we read more data\n        var hasCount = diff & 1;\n        this.diff = math.floor(diff / 2); // shift >> 1\n        this.count = 1;\n        if (hasCount) {\n          this.count = readVarUint(this) + 2;\n        }\n      }\n      this.s += this.diff;\n      this.count--;\n      return this.s;\n    }\n  }]);\n  return IntDiffOptRleDecoder;\n}(Decoder);\nexport var StringDecoder = /*#__PURE__*/function () {\n  /**\n   * @param {Uint8Array} uint8Array\n   */\n  function StringDecoder(uint8Array) {\n    _classCallCheck(this, StringDecoder);\n    this.decoder = new UintOptRleDecoder(uint8Array);\n    this.str = readVarString(this.decoder);\n    /**\n     * @type {number}\n     */\n    this.spos = 0;\n  }\n\n  /**\n   * @return {string}\n   */\n  _createClass(StringDecoder, [{\n    key: \"read\",\n    value: function read() {\n      var end = this.spos + this.decoder.read();\n      var res = this.str.slice(this.spos, end);\n      this.spos = end;\n      return res;\n    }\n  }]);\n  return StringDecoder;\n}();","map":{"version":3,"names":["buffer","binary","math","number","string","error","encoding","errorUnexpectedEndOfArray","create","errorIntegerOutOfRange","Decoder","_createClass","uint8Array","_classCallCheck","arr","pos","createDecoder","hasContent","decoder","length","clone","newPos","arguments","undefined","_decoder","readUint8Array","len","view","createUint8ArrayViewFromArrayBuffer","byteOffset","readVarUint8Array","readVarUint","readTailAsUint8Array","skip8","readUint8","readUint16","uint","readUint32","readUint32BigEndian","peekUint8","peekUint16","peekUint32","num","mult","r","BITS7","BIT8","MAX_SAFE_INTEGER","readVarInt","BITS6","sign","BIT7","peekVarUint","s","peekVarInt","_readVarStringPolyfill","remainingLen","encodedString","String","fromCodePoint","nextLen","bytes","subarray","apply","decodeURIComponent","escape","_readVarStringNative","utf8TextDecoder","decode","readVarString","readTerminatedUint8Array","encoder","createEncoder","b","toUint8Array","write","readTerminatedString","decodeUtf8","peekVarString","readFromDataView","dv","DataView","readFloat32","getFloat32","readFloat64","getFloat64","readBigInt64","getBigInt64","readBigUint64","getBigUint64","readAnyLookupTable","obj","i","key","readAny","push","RleDecoder","_Decoder","_inherits","_super","_createSuper","reader","_this","call","count","value","read","IntDiffDecoder","_Decoder2","_super2","start","_this2","RleIntDiffDecoder","_Decoder3","_super3","_this3","UintOptRleDecoder","_Decoder4","_super4","_this4","isNegative","isNegativeZero","IncUintOptRleDecoder","_Decoder5","_super5","_this5","IntDiffOptRleDecoder","_Decoder6","_super6","_this6","diff","hasCount","floor","StringDecoder","str","spos","end","res","slice"],"sources":["/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/lib0/decoding.js"],"sourcesContent":["/**\n * Efficient schema-less binary decoding with support for variable length encoding.\n *\n * Use [lib0/decoding] with [lib0/encoding]. Every encoding function has a corresponding decoding function.\n *\n * Encodes numbers in little-endian order (least to most significant byte order)\n * and is compatible with Golang's binary encoding (https://golang.org/pkg/encoding/binary/)\n * which is also used in Protocol Buffers.\n *\n * ```js\n * // encoding step\n * const encoder = encoding.createEncoder()\n * encoding.writeVarUint(encoder, 256)\n * encoding.writeVarString(encoder, 'Hello world!')\n * const buf = encoding.toUint8Array(encoder)\n * ```\n *\n * ```js\n * // decoding step\n * const decoder = decoding.createDecoder(buf)\n * decoding.readVarUint(decoder) // => 256\n * decoding.readVarString(decoder) // => 'Hello world!'\n * decoding.hasContent(decoder) // => false - all data is read\n * ```\n *\n * @module decoding\n */\n\nimport * as buffer from './buffer.js'\nimport * as binary from './binary.js'\nimport * as math from './math.js'\nimport * as number from './number.js'\nimport * as string from './string.js'\nimport * as error from './error.js'\nimport * as encoding from './encoding.js'\n\nconst errorUnexpectedEndOfArray = error.create('Unexpected end of array')\nconst errorIntegerOutOfRange = error.create('Integer out of Range')\n\n/**\n * A Decoder handles the decoding of an Uint8Array.\n */\nexport class Decoder {\n  /**\n   * @param {Uint8Array} uint8Array Binary data to decode\n   */\n  constructor (uint8Array) {\n    /**\n     * Decoding target.\n     *\n     * @type {Uint8Array}\n     */\n    this.arr = uint8Array\n    /**\n     * Current decoding position.\n     *\n     * @type {number}\n     */\n    this.pos = 0\n  }\n}\n\n/**\n * @function\n * @param {Uint8Array} uint8Array\n * @return {Decoder}\n */\nexport const createDecoder = uint8Array => new Decoder(uint8Array)\n\n/**\n * @function\n * @param {Decoder} decoder\n * @return {boolean}\n */\nexport const hasContent = decoder => decoder.pos !== decoder.arr.length\n\n/**\n * Clone a decoder instance.\n * Optionally set a new position parameter.\n *\n * @function\n * @param {Decoder} decoder The decoder instance\n * @param {number} [newPos] Defaults to current position\n * @return {Decoder} A clone of `decoder`\n */\nexport const clone = (decoder, newPos = decoder.pos) => {\n  const _decoder = createDecoder(decoder.arr)\n  _decoder.pos = newPos\n  return _decoder\n}\n\n/**\n * Create an Uint8Array view of the next `len` bytes and advance the position by `len`.\n *\n * Important: The Uint8Array still points to the underlying ArrayBuffer. Make sure to discard the result as soon as possible to prevent any memory leaks.\n *            Use `buffer.copyUint8Array` to copy the result into a new Uint8Array.\n *\n * @function\n * @param {Decoder} decoder The decoder instance\n * @param {number} len The length of bytes to read\n * @return {Uint8Array}\n */\nexport const readUint8Array = (decoder, len) => {\n  const view = buffer.createUint8ArrayViewFromArrayBuffer(decoder.arr.buffer, decoder.pos + decoder.arr.byteOffset, len)\n  decoder.pos += len\n  return view\n}\n\n/**\n * Read variable length Uint8Array.\n *\n * Important: The Uint8Array still points to the underlying ArrayBuffer. Make sure to discard the result as soon as possible to prevent any memory leaks.\n *            Use `buffer.copyUint8Array` to copy the result into a new Uint8Array.\n *\n * @function\n * @param {Decoder} decoder\n * @return {Uint8Array}\n */\nexport const readVarUint8Array = decoder => readUint8Array(decoder, readVarUint(decoder))\n\n/**\n * Read the rest of the content as an ArrayBuffer\n * @function\n * @param {Decoder} decoder\n * @return {Uint8Array}\n */\nexport const readTailAsUint8Array = decoder => readUint8Array(decoder, decoder.arr.length - decoder.pos)\n\n/**\n * Skip one byte, jump to the next position.\n * @function\n * @param {Decoder} decoder The decoder instance\n * @return {number} The next position\n */\nexport const skip8 = decoder => decoder.pos++\n\n/**\n * Read one byte as unsigned integer.\n * @function\n * @param {Decoder} decoder The decoder instance\n * @return {number} Unsigned 8-bit integer\n */\nexport const readUint8 = decoder => decoder.arr[decoder.pos++]\n\n/**\n * Read 2 bytes as unsigned integer.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nexport const readUint16 = decoder => {\n  const uint =\n    decoder.arr[decoder.pos] +\n    (decoder.arr[decoder.pos + 1] << 8)\n  decoder.pos += 2\n  return uint\n}\n\n/**\n * Read 4 bytes as unsigned integer.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nexport const readUint32 = decoder => {\n  const uint =\n    (decoder.arr[decoder.pos] +\n    (decoder.arr[decoder.pos + 1] << 8) +\n    (decoder.arr[decoder.pos + 2] << 16) +\n    (decoder.arr[decoder.pos + 3] << 24)) >>> 0\n  decoder.pos += 4\n  return uint\n}\n\n/**\n * Read 4 bytes as unsigned integer in big endian order.\n * (most significant byte first)\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nexport const readUint32BigEndian = decoder => {\n  const uint =\n    (decoder.arr[decoder.pos + 3] +\n    (decoder.arr[decoder.pos + 2] << 8) +\n    (decoder.arr[decoder.pos + 1] << 16) +\n    (decoder.arr[decoder.pos] << 24)) >>> 0\n  decoder.pos += 4\n  return uint\n}\n\n/**\n * Look ahead without incrementing the position\n * to the next byte and read it as unsigned integer.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nexport const peekUint8 = decoder => decoder.arr[decoder.pos]\n\n/**\n * Look ahead without incrementing the position\n * to the next byte and read it as unsigned integer.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nexport const peekUint16 = decoder =>\n  decoder.arr[decoder.pos] +\n  (decoder.arr[decoder.pos + 1] << 8)\n\n/**\n * Look ahead without incrementing the position\n * to the next byte and read it as unsigned integer.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nexport const peekUint32 = decoder => (\n  decoder.arr[decoder.pos] +\n  (decoder.arr[decoder.pos + 1] << 8) +\n  (decoder.arr[decoder.pos + 2] << 16) +\n  (decoder.arr[decoder.pos + 3] << 24)\n) >>> 0\n\n/**\n * Read unsigned integer (32bit) with variable length.\n * 1/8th of the storage is used as encoding overhead.\n *  * numbers < 2^7 is stored in one bytlength\n *  * numbers < 2^14 is stored in two bylength\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.length\n */\nexport const readVarUint = decoder => {\n  let num = 0\n  let mult = 1\n  const len = decoder.arr.length\n  while (decoder.pos < len) {\n    const r = decoder.arr[decoder.pos++]\n    // num = num | ((r & binary.BITS7) << len)\n    num = num + (r & binary.BITS7) * mult // shift $r << (7*#iterations) and add it to num\n    mult *= 128 // next iteration, shift 7 \"more\" to the left\n    if (r < binary.BIT8) {\n      return num\n    }\n    /* c8 ignore start */\n    if (num > number.MAX_SAFE_INTEGER) {\n      throw errorIntegerOutOfRange\n    }\n    /* c8 ignore stop */\n  }\n  throw errorUnexpectedEndOfArray\n}\n\n/**\n * Read signed integer (32bit) with variable length.\n * 1/8th of the storage is used as encoding overhead.\n *  * numbers < 2^7 is stored in one bytlength\n *  * numbers < 2^14 is stored in two bylength\n * @todo This should probably create the inverse ~num if number is negative - but this would be a breaking change.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.length\n */\nexport const readVarInt = decoder => {\n  let r = decoder.arr[decoder.pos++]\n  let num = r & binary.BITS6\n  let mult = 64\n  const sign = (r & binary.BIT7) > 0 ? -1 : 1\n  if ((r & binary.BIT8) === 0) {\n    // don't continue reading\n    return sign * num\n  }\n  const len = decoder.arr.length\n  while (decoder.pos < len) {\n    r = decoder.arr[decoder.pos++]\n    // num = num | ((r & binary.BITS7) << len)\n    num = num + (r & binary.BITS7) * mult\n    mult *= 128\n    if (r < binary.BIT8) {\n      return sign * num\n    }\n    /* c8 ignore start */\n    if (num > number.MAX_SAFE_INTEGER) {\n      throw errorIntegerOutOfRange\n    }\n    /* c8 ignore stop */\n  }\n  throw errorUnexpectedEndOfArray\n}\n\n/**\n * Look ahead and read varUint without incrementing position\n *\n * @function\n * @param {Decoder} decoder\n * @return {number}\n */\nexport const peekVarUint = decoder => {\n  const pos = decoder.pos\n  const s = readVarUint(decoder)\n  decoder.pos = pos\n  return s\n}\n\n/**\n * Look ahead and read varUint without incrementing position\n *\n * @function\n * @param {Decoder} decoder\n * @return {number}\n */\nexport const peekVarInt = decoder => {\n  const pos = decoder.pos\n  const s = readVarInt(decoder)\n  decoder.pos = pos\n  return s\n}\n\n/**\n * We don't test this function anymore as we use native decoding/encoding by default now.\n * Better not modify this anymore..\n *\n * Transforming utf8 to a string is pretty expensive. The code performs 10x better\n * when String.fromCodePoint is fed with all characters as arguments.\n * But most environments have a maximum number of arguments per functions.\n * For effiency reasons we apply a maximum of 10000 characters at once.\n *\n * @function\n * @param {Decoder} decoder\n * @return {String} The read String.\n */\n/* c8 ignore start */\nexport const _readVarStringPolyfill = decoder => {\n  let remainingLen = readVarUint(decoder)\n  if (remainingLen === 0) {\n    return ''\n  } else {\n    let encodedString = String.fromCodePoint(readUint8(decoder)) // remember to decrease remainingLen\n    if (--remainingLen < 100) { // do not create a Uint8Array for small strings\n      while (remainingLen--) {\n        encodedString += String.fromCodePoint(readUint8(decoder))\n      }\n    } else {\n      while (remainingLen > 0) {\n        const nextLen = remainingLen < 10000 ? remainingLen : 10000\n        // this is dangerous, we create a fresh array view from the existing buffer\n        const bytes = decoder.arr.subarray(decoder.pos, decoder.pos + nextLen)\n        decoder.pos += nextLen\n        // Starting with ES5.1 we can supply a generic array-like object as arguments\n        encodedString += String.fromCodePoint.apply(null, /** @type {any} */ (bytes))\n        remainingLen -= nextLen\n      }\n    }\n    return decodeURIComponent(escape(encodedString))\n  }\n}\n/* c8 ignore stop */\n\n/**\n * @function\n * @param {Decoder} decoder\n * @return {String} The read String\n */\nexport const _readVarStringNative = decoder =>\n  /** @type any */ (string.utf8TextDecoder).decode(readVarUint8Array(decoder))\n\n/**\n * Read string of variable length\n * * varUint is used to store the length of the string\n *\n * @function\n * @param {Decoder} decoder\n * @return {String} The read String\n *\n */\n/* c8 ignore next */\nexport const readVarString = string.utf8TextDecoder ? _readVarStringNative : _readVarStringPolyfill\n\n/**\n * @param {Decoder} decoder\n * @return {Uint8Array}\n */\nexport const readTerminatedUint8Array = decoder => {\n  const encoder = encoding.createEncoder()\n  let b\n  while (true) {\n    b = readUint8(decoder)\n    if (b === 0) {\n      return encoding.toUint8Array(encoder)\n    }\n    if (b === 1) {\n      b = readUint8(decoder)\n    }\n    encoding.write(encoder, b)\n  }\n}\n\n/**\n * @param {Decoder} decoder\n * @return {string}\n */\nexport const readTerminatedString = decoder => string.decodeUtf8(readTerminatedUint8Array(decoder))\n\n/**\n * Look ahead and read varString without incrementing position\n *\n * @function\n * @param {Decoder} decoder\n * @return {string}\n */\nexport const peekVarString = decoder => {\n  const pos = decoder.pos\n  const s = readVarString(decoder)\n  decoder.pos = pos\n  return s\n}\n\n/**\n * @param {Decoder} decoder\n * @param {number} len\n * @return {DataView}\n */\nexport const readFromDataView = (decoder, len) => {\n  const dv = new DataView(decoder.arr.buffer, decoder.arr.byteOffset + decoder.pos, len)\n  decoder.pos += len\n  return dv\n}\n\n/**\n * @param {Decoder} decoder\n */\nexport const readFloat32 = decoder => readFromDataView(decoder, 4).getFloat32(0, false)\n\n/**\n * @param {Decoder} decoder\n */\nexport const readFloat64 = decoder => readFromDataView(decoder, 8).getFloat64(0, false)\n\n/**\n * @param {Decoder} decoder\n */\nexport const readBigInt64 = decoder => /** @type {any} */ (readFromDataView(decoder, 8)).getBigInt64(0, false)\n\n/**\n * @param {Decoder} decoder\n */\nexport const readBigUint64 = decoder => /** @type {any} */ (readFromDataView(decoder, 8)).getBigUint64(0, false)\n\n/**\n * @type {Array<function(Decoder):any>}\n */\nconst readAnyLookupTable = [\n  decoder => undefined, // CASE 127: undefined\n  decoder => null, // CASE 126: null\n  readVarInt, // CASE 125: integer\n  readFloat32, // CASE 124: float32\n  readFloat64, // CASE 123: float64\n  readBigInt64, // CASE 122: bigint\n  decoder => false, // CASE 121: boolean (false)\n  decoder => true, // CASE 120: boolean (true)\n  readVarString, // CASE 119: string\n  decoder => { // CASE 118: object<string,any>\n    const len = readVarUint(decoder)\n    /**\n     * @type {Object<string,any>}\n     */\n    const obj = {}\n    for (let i = 0; i < len; i++) {\n      const key = readVarString(decoder)\n      obj[key] = readAny(decoder)\n    }\n    return obj\n  },\n  decoder => { // CASE 117: array<any>\n    const len = readVarUint(decoder)\n    const arr = []\n    for (let i = 0; i < len; i++) {\n      arr.push(readAny(decoder))\n    }\n    return arr\n  },\n  readVarUint8Array // CASE 116: Uint8Array\n]\n\n/**\n * @param {Decoder} decoder\n */\nexport const readAny = decoder => readAnyLookupTable[127 - readUint8(decoder)](decoder)\n\n/**\n * T must not be null.\n *\n * @template T\n */\nexport class RleDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   * @param {function(Decoder):T} reader\n   */\n  constructor (uint8Array, reader) {\n    super(uint8Array)\n    /**\n     * The reader\n     */\n    this.reader = reader\n    /**\n     * Current state\n     * @type {T|null}\n     */\n    this.s = null\n    this.count = 0\n  }\n\n  read () {\n    if (this.count === 0) {\n      this.s = this.reader(this)\n      if (hasContent(this)) {\n        this.count = readVarUint(this) + 1 // see encoder implementation for the reason why this is incremented\n      } else {\n        this.count = -1 // read the current value forever\n      }\n    }\n    this.count--\n    return /** @type {T} */ (this.s)\n  }\n}\n\nexport class IntDiffDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   * @param {number} start\n   */\n  constructor (uint8Array, start) {\n    super(uint8Array)\n    /**\n     * Current state\n     * @type {number}\n     */\n    this.s = start\n  }\n\n  /**\n   * @return {number}\n   */\n  read () {\n    this.s += readVarInt(this)\n    return this.s\n  }\n}\n\nexport class RleIntDiffDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   * @param {number} start\n   */\n  constructor (uint8Array, start) {\n    super(uint8Array)\n    /**\n     * Current state\n     * @type {number}\n     */\n    this.s = start\n    this.count = 0\n  }\n\n  /**\n   * @return {number}\n   */\n  read () {\n    if (this.count === 0) {\n      this.s += readVarInt(this)\n      if (hasContent(this)) {\n        this.count = readVarUint(this) + 1 // see encoder implementation for the reason why this is incremented\n      } else {\n        this.count = -1 // read the current value forever\n      }\n    }\n    this.count--\n    return /** @type {number} */ (this.s)\n  }\n}\n\nexport class UintOptRleDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   */\n  constructor (uint8Array) {\n    super(uint8Array)\n    /**\n     * @type {number}\n     */\n    this.s = 0\n    this.count = 0\n  }\n\n  read () {\n    if (this.count === 0) {\n      this.s = readVarInt(this)\n      // if the sign is negative, we read the count too, otherwise count is 1\n      const isNegative = math.isNegativeZero(this.s)\n      this.count = 1\n      if (isNegative) {\n        this.s = -this.s\n        this.count = readVarUint(this) + 2\n      }\n    }\n    this.count--\n    return /** @type {number} */ (this.s)\n  }\n}\n\nexport class IncUintOptRleDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   */\n  constructor (uint8Array) {\n    super(uint8Array)\n    /**\n     * @type {number}\n     */\n    this.s = 0\n    this.count = 0\n  }\n\n  read () {\n    if (this.count === 0) {\n      this.s = readVarInt(this)\n      // if the sign is negative, we read the count too, otherwise count is 1\n      const isNegative = math.isNegativeZero(this.s)\n      this.count = 1\n      if (isNegative) {\n        this.s = -this.s\n        this.count = readVarUint(this) + 2\n      }\n    }\n    this.count--\n    return /** @type {number} */ (this.s++)\n  }\n}\n\nexport class IntDiffOptRleDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   */\n  constructor (uint8Array) {\n    super(uint8Array)\n    /**\n     * @type {number}\n     */\n    this.s = 0\n    this.count = 0\n    this.diff = 0\n  }\n\n  /**\n   * @return {number}\n   */\n  read () {\n    if (this.count === 0) {\n      const diff = readVarInt(this)\n      // if the first bit is set, we read more data\n      const hasCount = diff & 1\n      this.diff = math.floor(diff / 2) // shift >> 1\n      this.count = 1\n      if (hasCount) {\n        this.count = readVarUint(this) + 2\n      }\n    }\n    this.s += this.diff\n    this.count--\n    return this.s\n  }\n}\n\nexport class StringDecoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   */\n  constructor (uint8Array) {\n    this.decoder = new UintOptRleDecoder(uint8Array)\n    this.str = readVarString(this.decoder)\n    /**\n     * @type {number}\n     */\n    this.spos = 0\n  }\n\n  /**\n   * @return {string}\n   */\n  read () {\n    const end = this.spos + this.decoder.read()\n    const res = this.str.slice(this.spos, end)\n    this.spos = end\n    return res\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}