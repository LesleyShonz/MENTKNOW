{"ast":null,"code":"import _regeneratorRuntime from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _defineProperty from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport { compareSchemas, squashRecordDiffs } from \"@tldraw/store\";\nimport { assert } from \"@tldraw/utils\";\nimport { transact } from \"signia\";\nimport { TAB_ID, createSessionStateSnapshotSignal, extractSessionStateFromLegacySnapshot, loadSessionStateSnapshotIntoStore } from \"../../config/TLSessionStateSnapshot.mjs\";\nimport { showCantReadFromIndexDbAlert, showCantWriteToIndexDbAlert } from \"./alerts.mjs\";\nimport { loadDataFromStore, storeChangesInIndexedDb, storeSnapshotInIndexedDb } from \"./indexedDb.mjs\";\nvar PERSIST_THROTTLE_MS = 350;\nvar PERSIST_RETRY_THROTTLE_MS = 1e4;\nvar UPDATE_INSTANCE_STATE = Symbol(\"UPDATE_INSTANCE_STATE\");\nvar msg = function msg(msg2) {\n  return msg2;\n};\nvar BroadcastChannelMock = /*#__PURE__*/function () {\n  function BroadcastChannelMock(_name) {\n    _classCallCheck(this, BroadcastChannelMock);\n    _defineProperty(this, \"onmessage\", void 0);\n  }\n  _createClass(BroadcastChannelMock, [{\n    key: \"postMessage\",\n    value: function postMessage(_msg) {}\n  }, {\n    key: \"close\",\n    value: function close() {}\n  }]);\n  return BroadcastChannelMock;\n}();\nvar BC = typeof BroadcastChannel === \"undefined\" ? BroadcastChannelMock : BroadcastChannel;\nvar TLLocalSyncClient = /*#__PURE__*/function () {\n  function TLLocalSyncClient(store, _ref) {\n    var _this = this;\n    var persistenceKey = _ref.persistenceKey,\n      _ref$sessionId = _ref.sessionId,\n      sessionId = _ref$sessionId === void 0 ? TAB_ID : _ref$sessionId,\n      onLoad = _ref.onLoad,\n      onLoadError = _ref.onLoadError;\n    var channel = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new BC(\"tldraw-tab-sync-\".concat(persistenceKey));\n    _classCallCheck(this, TLLocalSyncClient);\n    _defineProperty(this, \"disposables\", /* @__PURE__ */new Set());\n    _defineProperty(this, \"diffQueue\", []);\n    _defineProperty(this, \"didDispose\", false);\n    _defineProperty(this, \"shouldDoFullDBWrite\", true);\n    _defineProperty(this, \"isReloading\", false);\n    _defineProperty(this, \"persistenceKey\", void 0);\n    _defineProperty(this, \"sessionId\", void 0);\n    _defineProperty(this, \"serializedSchema\", void 0);\n    _defineProperty(this, \"isDebugging\", false);\n    _defineProperty(this, \"documentTypes\", void 0);\n    _defineProperty(this, \"$sessionStateSnapshot\", void 0);\n    _defineProperty(this, \"initTime\", Date.now());\n    _defineProperty(this, \"isPersisting\", false);\n    _defineProperty(this, \"didLastWriteError\", false);\n    _defineProperty(this, \"scheduledPersistTimeout\", null);\n    this.store = store;\n    this.channel = channel;\n    if (typeof window !== \"undefined\") {\n      ;\n      window.tlsync = this;\n    }\n    this.persistenceKey = persistenceKey;\n    this.sessionId = sessionId;\n    this.serializedSchema = this.store.schema.serialize();\n    this.$sessionStateSnapshot = createSessionStateSnapshotSignal(this.store);\n    this.disposables.add(\n    // Set up a subscription to changes from the store: When\n    // the store changes (and if the change was made by the user)\n    // then immediately send the diff to other tabs via postMessage\n    // and schedule a persist.\n    store.listen(function (_ref2) {\n      var changes = _ref2.changes;\n      _this.diffQueue.push(changes);\n      _this.channel.postMessage(msg({\n        type: \"diff\",\n        storeId: _this.store.id,\n        changes: changes,\n        schema: _this.serializedSchema\n      }));\n      _this.schedulePersist();\n    }, {\n      source: \"user\",\n      scope: \"document\"\n    }));\n    this.disposables.add(store.listen(function () {\n      _this.diffQueue.push(UPDATE_INSTANCE_STATE);\n      _this.schedulePersist();\n    }, {\n      scope: \"session\"\n    }));\n    this.connect(onLoad, onLoadError);\n    this.documentTypes = new Set(Object.values(this.store.schema.types).filter(function (t) {\n      return t.scope === \"document\";\n    }).map(function (t) {\n      return t.typeName;\n    }));\n  }\n  _createClass(TLLocalSyncClient, [{\n    key: \"debug\",\n    value: function debug() {\n      if (this.isDebugging) {\n        var _console;\n        (_console = console).debug.apply(_console, arguments);\n      }\n    }\n  }, {\n    key: \"connect\",\n    value: function () {\n      var _connect = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(onLoad, onLoadError) {\n        var _this2 = this;\n        var data, _data$sessionStateSna, _data$schema, documentSnapshot, sessionStateSnapshot, migrationResult;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              this.debug(\"connecting\");\n              _context.prev = 1;\n              _context.next = 4;\n              return loadDataFromStore({\n                persistenceKey: this.persistenceKey,\n                sessionId: this.sessionId,\n                didCancel: function didCancel() {\n                  return _this2.didDispose;\n                }\n              });\n            case 4:\n              data = _context.sent;\n              _context.next = 13;\n              break;\n            case 7:\n              _context.prev = 7;\n              _context.t0 = _context[\"catch\"](1);\n              onLoadError(_context.t0);\n              showCantReadFromIndexDbAlert();\n              if (typeof window !== \"undefined\") {\n                window.location.reload();\n              }\n              return _context.abrupt(\"return\");\n            case 13:\n              this.debug(\"loaded data from store\", data, \"didDispose\", this.didDispose);\n              if (!this.didDispose) {\n                _context.next = 16;\n                break;\n              }\n              return _context.abrupt(\"return\");\n            case 16:\n              _context.prev = 16;\n              if (!data) {\n                _context.next = 27;\n                break;\n              }\n              documentSnapshot = Object.fromEntries(data.records.map(function (r) {\n                return [r.id, r];\n              }));\n              sessionStateSnapshot = (_data$sessionStateSna = data.sessionStateSnapshot) !== null && _data$sessionStateSna !== void 0 ? _data$sessionStateSna : extractSessionStateFromLegacySnapshot(documentSnapshot);\n              migrationResult = this.store.schema.migrateStoreSnapshot(documentSnapshot, (_data$schema = data.schema) !== null && _data$schema !== void 0 ? _data$schema : this.store.schema.serializeEarliestVersion());\n              if (!(migrationResult.type === \"error\")) {\n                _context.next = 25;\n                break;\n              }\n              console.error(\"failed to migrate store\", migrationResult);\n              onLoadError(new Error(\"Failed to migrate store: \".concat(migrationResult.reason)));\n              return _context.abrupt(\"return\");\n            case 25:\n              this.store.mergeRemoteChanges(function () {\n                _this2.store.put(Object.values(migrationResult.value).filter(function (r) {\n                  return _this2.documentTypes.has(r.typeName);\n                }), \"initialize\");\n              });\n              if (sessionStateSnapshot) {\n                loadSessionStateSnapshotIntoStore(this.store, sessionStateSnapshot);\n              }\n            case 27:\n              this.channel.onmessage = function (_ref3) {\n                var _msg2$schema;\n                var data2 = _ref3.data;\n                _this2.debug(\"got message\", data2);\n                var msg2 = data2;\n                var comparison = compareSchemas(_this2.serializedSchema, (_msg2$schema = msg2.schema) !== null && _msg2$schema !== void 0 ? _msg2$schema : _this2.store.schema.serializeEarliestVersion());\n                if (comparison === -1) {\n                  var _window, _window$reload;\n                  var timeSinceInit = Date.now() - _this2.initTime;\n                  if (timeSinceInit < 5e3) {\n                    onLoadError(new Error(\"Schema mismatch, please close other tabs and reload the page\"));\n                    return;\n                  }\n                  _this2.debug(\"reloading\");\n                  _this2.isReloading = true;\n                  (_window = window) === null || _window === void 0 || (_window = _window.location) === null || _window === void 0 || (_window$reload = _window.reload) === null || _window$reload === void 0 || _window$reload.call(_window);\n                  return;\n                } else if (comparison === 1) {\n                  _this2.debug(\"telling them to reload\");\n                  _this2.channel.postMessage({\n                    type: \"announce\",\n                    schema: _this2.serializedSchema\n                  });\n                  _this2.shouldDoFullDBWrite = true;\n                  _this2.persistIfNeeded();\n                  return;\n                }\n                if (msg2.type === \"diff\") {\n                  _this2.debug(\"applying diff\");\n                  transact(function () {\n                    _this2.store.mergeRemoteChanges(function () {\n                      _this2.store.applyDiff(msg2.changes);\n                      _this2.store.ensureStoreIsUsable();\n                    });\n                  });\n                }\n              };\n              this.channel.postMessage({\n                type: \"announce\",\n                schema: this.serializedSchema\n              });\n              this.disposables.add(function () {\n                _this2.channel.close();\n              });\n              onLoad(this);\n              _context.next = 40;\n              break;\n            case 33:\n              _context.prev = 33;\n              _context.t1 = _context[\"catch\"](16);\n              this.debug(\"error loading data from store\", _context.t1);\n              if (!this.didDispose) {\n                _context.next = 38;\n                break;\n              }\n              return _context.abrupt(\"return\");\n            case 38:\n              onLoadError(_context.t1);\n              return _context.abrupt(\"return\");\n            case 40:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this, [[1, 7], [16, 33]]);\n      }));\n      function connect(_x, _x2) {\n        return _connect.apply(this, arguments);\n      }\n      return connect;\n    }()\n  }, {\n    key: \"close\",\n    value: function close() {\n      this.debug(\"closing\");\n      this.didDispose = true;\n      this.disposables.forEach(function (d) {\n        return d();\n      });\n    }\n  }, {\n    key: \"schedulePersist\",\n    value:\n    /**\n     * Schedule a persist. Persists don't happen immediately: they are throttled to avoid writing too\n     * often, and will retry if failed.\n     *\n     * @internal\n     */\n    function schedulePersist() {\n      var _this3 = this;\n      this.debug(\"schedulePersist\", this.scheduledPersistTimeout);\n      if (this.scheduledPersistTimeout) return;\n      this.scheduledPersistTimeout = setTimeout(function () {\n        _this3.scheduledPersistTimeout = null;\n        _this3.persistIfNeeded();\n      }, this.didLastWriteError ? PERSIST_RETRY_THROTTLE_MS : PERSIST_THROTTLE_MS);\n    }\n    /**\n     * Persist to IndexedDB only under certain circumstances:\n     *\n     * - If we're not already persisting\n     * - If we're not reloading the page\n     * - And we have something to persist (a full db write scheduled or changes in the diff queue)\n     *\n     * @internal\n     */\n  }, {\n    key: \"persistIfNeeded\",\n    value: function persistIfNeeded() {\n      this.debug(\"persistIfNeeded\", {\n        isPersisting: this.isPersisting,\n        isReloading: this.isReloading,\n        shouldDoFullDBWrite: this.shouldDoFullDBWrite,\n        diffQueueLength: this.diffQueue.length,\n        storeIsPossiblyCorrupt: this.store.isPossiblyCorrupted()\n      });\n      if (this.scheduledPersistTimeout) {\n        clearTimeout(this.scheduledPersistTimeout);\n        this.scheduledPersistTimeout = null;\n      }\n      if (this.isPersisting) return;\n      if (this.isReloading) return;\n      if (this.store.isPossiblyCorrupted()) return;\n      if (this.shouldDoFullDBWrite || this.diffQueue.length > 0) {\n        this.doPersist();\n      }\n    }\n    /**\n     * Actually persist to IndexedDB. If the write fails, then we'll retry with a full db write after\n     * a short delay.\n     */\n  }, {\n    key: \"doPersist\",\n    value: function () {\n      var _doPersist = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var _this4 = this;\n        var diffQueue, diffs;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              assert(!this.isPersisting, \"persist already in progress\");\n              this.isPersisting = true;\n              this.debug(\"doPersist start\");\n              diffQueue = this.diffQueue;\n              this.diffQueue = [];\n              _context2.prev = 5;\n              if (!this.shouldDoFullDBWrite) {\n                _context2.next = 12;\n                break;\n              }\n              this.shouldDoFullDBWrite = false;\n              _context2.next = 10;\n              return storeSnapshotInIndexedDb({\n                persistenceKey: this.persistenceKey,\n                schema: this.store.schema,\n                snapshot: this.store.serialize(),\n                didCancel: function didCancel() {\n                  return _this4.didDispose;\n                },\n                sessionId: this.sessionId,\n                sessionStateSnapshot: this.$sessionStateSnapshot.value\n              });\n            case 10:\n              _context2.next = 15;\n              break;\n            case 12:\n              diffs = squashRecordDiffs(diffQueue.filter(function (d) {\n                return d !== UPDATE_INSTANCE_STATE;\n              }));\n              _context2.next = 15;\n              return storeChangesInIndexedDb({\n                persistenceKey: this.persistenceKey,\n                changes: diffs,\n                schema: this.store.schema,\n                didCancel: function didCancel() {\n                  return _this4.didDispose;\n                },\n                sessionId: this.sessionId,\n                sessionStateSnapshot: this.$sessionStateSnapshot.value\n              });\n            case 15:\n              this.didLastWriteError = false;\n              _context2.next = 25;\n              break;\n            case 18:\n              _context2.prev = 18;\n              _context2.t0 = _context2[\"catch\"](5);\n              this.shouldDoFullDBWrite = true;\n              this.didLastWriteError = true;\n              console.error(\"failed to store changes in indexed db\", _context2.t0);\n              showCantWriteToIndexDbAlert();\n              if (typeof window !== \"undefined\") {\n                window.location.reload();\n              }\n            case 25:\n              this.isPersisting = false;\n              this.debug(\"doPersist end\");\n              this.schedulePersist();\n            case 28:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this, [[5, 18]]);\n      }));\n      function doPersist() {\n        return _doPersist.apply(this, arguments);\n      }\n      return doPersist;\n    }()\n  }]);\n  return TLLocalSyncClient;\n}();\nexport { BroadcastChannelMock, TLLocalSyncClient };","map":{"version":3,"names":["compareSchemas","squashRecordDiffs","assert","transact","TAB_ID","createSessionStateSnapshotSignal","extractSessionStateFromLegacySnapshot","loadSessionStateSnapshotIntoStore","showCantReadFromIndexDbAlert","showCantWriteToIndexDbAlert","loadDataFromStore","storeChangesInIndexedDb","storeSnapshotInIndexedDb","PERSIST_THROTTLE_MS","PERSIST_RETRY_THROTTLE_MS","UPDATE_INSTANCE_STATE","Symbol","msg","msg2","BroadcastChannelMock","_name","_classCallCheck","_defineProperty","_createClass","key","value","postMessage","_msg","close","BC","BroadcastChannel","TLLocalSyncClient","store","_ref","_this","persistenceKey","_ref$sessionId","sessionId","onLoad","onLoadError","channel","arguments","length","undefined","concat","Set","Date","now","window","tlsync","serializedSchema","schema","serialize","$sessionStateSnapshot","disposables","add","listen","_ref2","changes","diffQueue","push","type","storeId","id","schedulePersist","source","scope","connect","documentTypes","Object","values","types","filter","t","map","typeName","debug","isDebugging","_console","console","apply","_connect","_asyncToGenerator","_regeneratorRuntime","mark","_callee","_this2","data","_data$sessionStateSna","_data$schema","documentSnapshot","sessionStateSnapshot","migrationResult","wrap","_callee$","_context","prev","next","didCancel","didDispose","sent","t0","location","reload","abrupt","fromEntries","records","r","migrateStoreSnapshot","serializeEarliestVersion","error","Error","reason","mergeRemoteChanges","put","has","onmessage","_ref3","_msg2$schema","data2","comparison","_window","_window$reload","timeSinceInit","initTime","isReloading","call","shouldDoFullDBWrite","persistIfNeeded","applyDiff","ensureStoreIsUsable","t1","stop","_x","_x2","forEach","d","_this3","scheduledPersistTimeout","setTimeout","didLastWriteError","isPersisting","diffQueueLength","storeIsPossiblyCorrupt","isPossiblyCorrupted","clearTimeout","doPersist","_doPersist","_callee2","_this4","diffs","_callee2$","_context2","snapshot"],"sources":["/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@tldraw/editor/src/lib/utils/sync/TLLocalSyncClient.ts"],"sourcesContent":["import {\n\tRecordsDiff,\n\tSerializedSchema,\n\tUnknownRecord,\n\tcompareSchemas,\n\tsquashRecordDiffs,\n} from '@tldraw/store'\nimport { TLStore } from '@tldraw/tlschema'\nimport { assert } from '@tldraw/utils'\nimport { Signal, transact } from 'signia'\nimport {\n\tTAB_ID,\n\tTLSessionStateSnapshot,\n\tcreateSessionStateSnapshotSignal,\n\textractSessionStateFromLegacySnapshot,\n\tloadSessionStateSnapshotIntoStore,\n} from '../../config/TLSessionStateSnapshot'\nimport { showCantReadFromIndexDbAlert, showCantWriteToIndexDbAlert } from './alerts'\nimport { loadDataFromStore, storeChangesInIndexedDb, storeSnapshotInIndexedDb } from './indexedDb'\n\n/** How should we debounce persists? */\nconst PERSIST_THROTTLE_MS = 350\n/** If we're in an error state, how long should we wait before retrying a write? */\nconst PERSIST_RETRY_THROTTLE_MS = 10_000\n\nconst UPDATE_INSTANCE_STATE = Symbol('UPDATE_INSTANCE_STATE')\n\n/**\n * IMPORTANT!!!\n *\n * This is just a quick-n-dirty temporary solution that will be replaced with the remote sync client\n * once it has the db integrated\n */\n\ntype SyncMessage = {\n\ttype: 'diff'\n\tstoreId: string\n\tchanges: RecordsDiff<UnknownRecord>\n\tschema: SerializedSchema\n}\n\n// Sent by new clients when they connect\n// If another client is on the channel with a newer schema version\n// It will\ntype AnnounceMessage = {\n\ttype: 'announce'\n\tschema: SerializedSchema\n}\n\ntype Message = SyncMessage | AnnounceMessage\n\ntype UnpackPromise<T> = T extends Promise<infer U> ? U : T\n\nconst msg = (msg: Message) => msg\n\n/** @internal */\nexport class BroadcastChannelMock {\n\tonmessage?: (e: MessageEvent) => void\n\tconstructor(_name: string) {\n\t\t// noop\n\t}\n\tpostMessage(_msg: Message) {\n\t\t// noop\n\t}\n\tclose() {\n\t\t// noop\n\t}\n}\n\nconst BC = typeof BroadcastChannel === 'undefined' ? BroadcastChannelMock : BroadcastChannel\n\n/** @internal */\nexport class TLLocalSyncClient {\n\tprivate disposables = new Set<() => void>()\n\tprivate diffQueue: Array<RecordsDiff<UnknownRecord> | typeof UPDATE_INSTANCE_STATE> = []\n\tprivate didDispose = false\n\tprivate shouldDoFullDBWrite = true\n\tprivate isReloading = false\n\treadonly persistenceKey: string\n\treadonly sessionId: string\n\treadonly serializedSchema: SerializedSchema\n\tprivate isDebugging = false\n\tprivate readonly documentTypes: ReadonlySet<string>\n\tprivate readonly $sessionStateSnapshot: Signal<TLSessionStateSnapshot | null>\n\n\tinitTime = Date.now()\n\tprivate debug(...args: any[]) {\n\t\tif (this.isDebugging) {\n\t\t\t// eslint-disable-next-line no-console\n\t\t\tconsole.debug(...args)\n\t\t}\n\t}\n\tconstructor(\n\t\tpublic readonly store: TLStore,\n\t\t{\n\t\t\tpersistenceKey,\n\t\t\tsessionId = TAB_ID,\n\t\t\tonLoad,\n\t\t\tonLoadError,\n\t\t}: {\n\t\t\tpersistenceKey: string\n\t\t\tsessionId?: string\n\t\t\tonLoad: (self: TLLocalSyncClient) => void\n\t\t\tonLoadError: (error: Error) => void\n\t\t},\n\t\tpublic readonly channel = new BC(`tldraw-tab-sync-${persistenceKey}`)\n\t) {\n\t\tif (typeof window !== 'undefined') {\n\t\t\t;(window as any).tlsync = this\n\t\t}\n\t\tthis.persistenceKey = persistenceKey\n\t\tthis.sessionId = sessionId\n\n\t\tthis.serializedSchema = this.store.schema.serialize()\n\t\tthis.$sessionStateSnapshot = createSessionStateSnapshotSignal(this.store)\n\n\t\tthis.disposables.add(\n\t\t\t// Set up a subscription to changes from the store: When\n\t\t\t// the store changes (and if the change was made by the user)\n\t\t\t// then immediately send the diff to other tabs via postMessage\n\t\t\t// and schedule a persist.\n\t\t\tstore.listen(\n\t\t\t\t({ changes }) => {\n\t\t\t\t\tthis.diffQueue.push(changes)\n\t\t\t\t\tthis.channel.postMessage(\n\t\t\t\t\t\tmsg({\n\t\t\t\t\t\t\ttype: 'diff',\n\t\t\t\t\t\t\tstoreId: this.store.id,\n\t\t\t\t\t\t\tchanges,\n\t\t\t\t\t\t\tschema: this.serializedSchema,\n\t\t\t\t\t\t})\n\t\t\t\t\t)\n\t\t\t\t\tthis.schedulePersist()\n\t\t\t\t},\n\t\t\t\t{ source: 'user', scope: 'document' }\n\t\t\t)\n\t\t)\n\t\tthis.disposables.add(\n\t\t\tstore.listen(\n\t\t\t\t() => {\n\t\t\t\t\tthis.diffQueue.push(UPDATE_INSTANCE_STATE)\n\t\t\t\t\tthis.schedulePersist()\n\t\t\t\t},\n\t\t\t\t{ scope: 'session' }\n\t\t\t)\n\t\t)\n\n\t\tthis.connect(onLoad, onLoadError)\n\n\t\tthis.documentTypes = new Set(\n\t\t\tObject.values(this.store.schema.types)\n\t\t\t\t.filter((t) => t.scope === 'document')\n\t\t\t\t.map((t) => t.typeName)\n\t\t)\n\t}\n\n\tprivate async connect(onLoad: (client: this) => void, onLoadError: (error: Error) => void) {\n\t\tthis.debug('connecting')\n\t\tlet data: UnpackPromise<ReturnType<typeof loadDataFromStore>> | undefined\n\n\t\ttry {\n\t\t\tdata = await loadDataFromStore({\n\t\t\t\tpersistenceKey: this.persistenceKey,\n\t\t\t\tsessionId: this.sessionId,\n\t\t\t\tdidCancel: () => this.didDispose,\n\t\t\t})\n\t\t} catch (error: any) {\n\t\t\tonLoadError(error)\n\t\t\tshowCantReadFromIndexDbAlert()\n\t\t\tif (typeof window !== 'undefined') {\n\t\t\t\twindow.location.reload()\n\t\t\t}\n\t\t\treturn\n\t\t}\n\n\t\tthis.debug('loaded data from store', data, 'didDispose', this.didDispose)\n\t\tif (this.didDispose) return\n\n\t\ttry {\n\t\t\tif (data) {\n\t\t\t\tconst documentSnapshot = Object.fromEntries(data.records.map((r) => [r.id, r]))\n\t\t\t\tconst sessionStateSnapshot =\n\t\t\t\t\tdata.sessionStateSnapshot ?? extractSessionStateFromLegacySnapshot(documentSnapshot)\n\t\t\t\tconst migrationResult = this.store.schema.migrateStoreSnapshot(\n\t\t\t\t\tdocumentSnapshot,\n\t\t\t\t\tdata.schema ?? this.store.schema.serializeEarliestVersion()\n\t\t\t\t)\n\n\t\t\t\tif (migrationResult.type === 'error') {\n\t\t\t\t\tconsole.error('failed to migrate store', migrationResult)\n\t\t\t\t\tonLoadError(new Error(`Failed to migrate store: ${migrationResult.reason}`))\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\t// 3. Merge the changes into the REAL STORE\n\t\t\t\tthis.store.mergeRemoteChanges(() => {\n\t\t\t\t\t// Calling put will validate the records!\n\t\t\t\t\tthis.store.put(\n\t\t\t\t\t\tObject.values(migrationResult.value).filter((r) => this.documentTypes.has(r.typeName)),\n\t\t\t\t\t\t'initialize'\n\t\t\t\t\t)\n\t\t\t\t})\n\n\t\t\t\tif (sessionStateSnapshot) {\n\t\t\t\t\tloadSessionStateSnapshotIntoStore(this.store, sessionStateSnapshot)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.channel.onmessage = ({ data }) => {\n\t\t\t\tthis.debug('got message', data)\n\t\t\t\tconst msg = data as Message\n\t\t\t\t// if their schema is earlier than ours, we need to tell them so they can refresh\n\t\t\t\t// if their schema is later than ours, we need to refresh\n\t\t\t\tconst comparison = compareSchemas(\n\t\t\t\t\tthis.serializedSchema,\n\t\t\t\t\tmsg.schema ?? this.store.schema.serializeEarliestVersion()\n\t\t\t\t)\n\t\t\t\tif (comparison === -1) {\n\t\t\t\t\t// we are older, refresh\n\t\t\t\t\t// but add a safety check to make sure we don't get in an infinite loop\n\t\t\t\t\tconst timeSinceInit = Date.now() - this.initTime\n\t\t\t\t\tif (timeSinceInit < 5000) {\n\t\t\t\t\t\t// This tab was just reloaded, but is out of date compared to other tabs.\n\t\t\t\t\t\t// Not expecting this to ever happen. It should only happen if we roll back a release that incremented\n\t\t\t\t\t\t// the schema version (which we should never do)\n\t\t\t\t\t\t// Or maybe during development if you have multiple local tabs open running the app on prod mode and you\n\t\t\t\t\t\t// check out an older commit. Dev server should be fine.\n\t\t\t\t\t\tonLoadError(new Error('Schema mismatch, please close other tabs and reload the page'))\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tthis.debug('reloading')\n\t\t\t\t\tthis.isReloading = true\n\t\t\t\t\twindow?.location?.reload?.()\n\t\t\t\t\treturn\n\t\t\t\t} else if (comparison === 1) {\n\t\t\t\t\t// they are older, tell them to refresh and not write any more data\n\t\t\t\t\tthis.debug('telling them to reload')\n\t\t\t\t\tthis.channel.postMessage({ type: 'announce', schema: this.serializedSchema })\n\t\t\t\t\t// schedule a full db write in case they wrote data anyway\n\t\t\t\t\tthis.shouldDoFullDBWrite = true\n\t\t\t\t\tthis.persistIfNeeded()\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\t// otherwise, all good, same version :)\n\t\t\t\tif (msg.type === 'diff') {\n\t\t\t\t\tthis.debug('applying diff')\n\t\t\t\t\ttransact(() => {\n\t\t\t\t\t\tthis.store.mergeRemoteChanges(() => {\n\t\t\t\t\t\t\tthis.store.applyDiff(msg.changes as any)\n\t\t\t\t\t\t\tthis.store.ensureStoreIsUsable()\n\t\t\t\t\t\t})\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.channel.postMessage({ type: 'announce', schema: this.serializedSchema })\n\t\t\tthis.disposables.add(() => {\n\t\t\t\tthis.channel.close()\n\t\t\t})\n\t\t\tonLoad(this)\n\t\t} catch (e: any) {\n\t\t\tthis.debug('error loading data from store', e)\n\t\t\tif (this.didDispose) return\n\t\t\tonLoadError(e)\n\t\t\treturn\n\t\t}\n\t}\n\n\tclose() {\n\t\tthis.debug('closing')\n\t\tthis.didDispose = true\n\t\tthis.disposables.forEach((d) => d())\n\t}\n\n\tprivate isPersisting = false\n\tprivate didLastWriteError = false\n\tprivate scheduledPersistTimeout: ReturnType<typeof setTimeout> | null = null\n\n\t/**\n\t * Schedule a persist. Persists don't happen immediately: they are throttled to avoid writing too\n\t * often, and will retry if failed.\n\t *\n\t * @internal\n\t */\n\tprivate schedulePersist() {\n\t\tthis.debug('schedulePersist', this.scheduledPersistTimeout)\n\t\tif (this.scheduledPersistTimeout) return\n\t\tthis.scheduledPersistTimeout = setTimeout(\n\t\t\t() => {\n\t\t\t\tthis.scheduledPersistTimeout = null\n\t\t\t\tthis.persistIfNeeded()\n\t\t\t},\n\t\t\tthis.didLastWriteError ? PERSIST_RETRY_THROTTLE_MS : PERSIST_THROTTLE_MS\n\t\t)\n\t}\n\n\t/**\n\t * Persist to IndexedDB only under certain circumstances:\n\t *\n\t * - If we're not already persisting\n\t * - If we're not reloading the page\n\t * - And we have something to persist (a full db write scheduled or changes in the diff queue)\n\t *\n\t * @internal\n\t */\n\tprivate persistIfNeeded() {\n\t\tthis.debug('persistIfNeeded', {\n\t\t\tisPersisting: this.isPersisting,\n\t\t\tisReloading: this.isReloading,\n\t\t\tshouldDoFullDBWrite: this.shouldDoFullDBWrite,\n\t\t\tdiffQueueLength: this.diffQueue.length,\n\t\t\tstoreIsPossiblyCorrupt: this.store.isPossiblyCorrupted(),\n\t\t})\n\n\t\t// if we've scheduled a persist for the future, that's no longer needed\n\t\tif (this.scheduledPersistTimeout) {\n\t\t\tclearTimeout(this.scheduledPersistTimeout)\n\t\t\tthis.scheduledPersistTimeout = null\n\t\t}\n\n\t\t// if a persist is already in progress, we don't need to do anything -\n\t\t// if there are still outstanding changes once it's finished, it'll\n\t\t// schedule another persist\n\t\tif (this.isPersisting) return\n\n\t\t// if we're reloading the page, it's because there's a newer client\n\t\t// present so lets not overwrite their changes\n\t\tif (this.isReloading) return\n\n\t\t// if the store is possibly corrupted, we don't want to persist\n\t\tif (this.store.isPossiblyCorrupted()) return\n\n\t\t// if we're scheduled for a full write or if we have changes outstanding, let's persist them!\n\t\tif (this.shouldDoFullDBWrite || this.diffQueue.length > 0) {\n\t\t\tthis.doPersist()\n\t\t}\n\t}\n\n\t/**\n\t * Actually persist to IndexedDB. If the write fails, then we'll retry with a full db write after\n\t * a short delay.\n\t */\n\tprivate async doPersist() {\n\t\tassert(!this.isPersisting, 'persist already in progress')\n\t\tthis.isPersisting = true\n\n\t\tthis.debug('doPersist start')\n\n\t\t// instantly empty the diff queue, but keep our own copy of it. this way\n\t\t// diffs that come in during the persist will still get tracked\n\t\tconst diffQueue = this.diffQueue\n\t\tthis.diffQueue = []\n\n\t\ttry {\n\t\t\tif (this.shouldDoFullDBWrite) {\n\t\t\t\tthis.shouldDoFullDBWrite = false\n\t\t\t\tawait storeSnapshotInIndexedDb({\n\t\t\t\t\tpersistenceKey: this.persistenceKey,\n\t\t\t\t\tschema: this.store.schema,\n\t\t\t\t\tsnapshot: this.store.serialize(),\n\t\t\t\t\tdidCancel: () => this.didDispose,\n\t\t\t\t\tsessionId: this.sessionId,\n\t\t\t\t\tsessionStateSnapshot: this.$sessionStateSnapshot.value,\n\t\t\t\t})\n\t\t\t} else {\n\t\t\t\tconst diffs = squashRecordDiffs(\n\t\t\t\t\tdiffQueue.filter((d): d is RecordsDiff<UnknownRecord> => d !== UPDATE_INSTANCE_STATE)\n\t\t\t\t)\n\t\t\t\tawait storeChangesInIndexedDb({\n\t\t\t\t\tpersistenceKey: this.persistenceKey,\n\t\t\t\t\tchanges: diffs,\n\t\t\t\t\tschema: this.store.schema,\n\t\t\t\t\tdidCancel: () => this.didDispose,\n\t\t\t\t\tsessionId: this.sessionId,\n\t\t\t\t\tsessionStateSnapshot: this.$sessionStateSnapshot.value,\n\t\t\t\t})\n\t\t\t}\n\t\t\tthis.didLastWriteError = false\n\t\t} catch (e) {\n\t\t\t// set this.shouldDoFullDBWrite because we clear the diffQueue no matter what,\n\t\t\t// so if this is just a temporary error, we will still persist all changes\n\t\t\tthis.shouldDoFullDBWrite = true\n\t\t\tthis.didLastWriteError = true\n\t\t\tconsole.error('failed to store changes in indexed db', e)\n\n\t\t\tshowCantWriteToIndexDbAlert()\n\t\t\tif (typeof window !== 'undefined') {\n\t\t\t\t// adios\n\t\t\t\twindow.location.reload()\n\t\t\t}\n\t\t}\n\n\t\tthis.isPersisting = false\n\t\tthis.debug('doPersist end')\n\n\t\t// changes might have come in between when we started the persist and\n\t\t// now. we request another persist so any new changes can get written\n\t\tthis.schedulePersist()\n\t}\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}