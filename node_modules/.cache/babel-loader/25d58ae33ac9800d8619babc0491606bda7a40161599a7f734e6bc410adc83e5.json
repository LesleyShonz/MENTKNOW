{"ast":null,"code":"import _objectSpread from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _createForOfIteratorHelper from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _toConsumableArray from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _classCallCheck from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _inherits from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _defineProperty from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport { areAnglesCompatible, Matrix2d, PI, PI2, TAU, Vec2d } from \"@tldraw/primitives\";\nimport { FrameShapeUtil } from \"../../../shapes/frame/FrameShapeUtil.mjs\";\nimport { StateNode } from \"../../StateNode.mjs\";\nvar Resizing = /*#__PURE__*/function (_StateNode) {\n  _inherits(Resizing, _StateNode);\n  var _super = _createSuper(Resizing);\n  function Resizing() {\n    var _this;\n    _classCallCheck(this, Resizing);\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    _this = _super.call.apply(_super, [this].concat(args));\n    _defineProperty(_assertThisInitialized(_this), \"info\", {});\n    _defineProperty(_assertThisInitialized(_this), \"markId\", \"\");\n    // we transition into the resizing state from the geo pointing state, which starts with a shape of size w: 1, h: 1,\n    // so if the user drags x: +50, y: +50 after mouseDown, the shape will be w: 51, h: 51, which is too many pixels, alas\n    // so we allow passing a further offset into this state to negate such issues\n    _defineProperty(_assertThisInitialized(_this), \"creationCursorOffset\", {\n      x: 0,\n      y: 0\n    });\n    _defineProperty(_assertThisInitialized(_this), \"editAfterComplete\", false);\n    _defineProperty(_assertThisInitialized(_this), \"snapshot\", {});\n    _defineProperty(_assertThisInitialized(_this), \"onEnter\", function (info) {\n      var _info$isCreating = info.isCreating,\n        isCreating = _info$isCreating === void 0 ? false : _info$isCreating,\n        _info$editAfterComple = info.editAfterComplete,\n        editAfterComplete = _info$editAfterComple === void 0 ? false : _info$editAfterComple,\n        _info$creationCursorO = info.creationCursorOffset,\n        creationCursorOffset = _info$creationCursorO === void 0 ? {\n          x: 0,\n          y: 0\n        } : _info$creationCursorO;\n      _this.info = info;\n      _this.editAfterComplete = editAfterComplete;\n      _this.creationCursorOffset = creationCursorOffset;\n      if (info.isCreating) {\n        _this.editor.setCursor({\n          type: \"cross\",\n          rotation: 0\n        });\n      }\n      _this.snapshot = _this._createSnapshot();\n      _this.markId = isCreating ? \"creating\" : _this.editor.mark(\"starting resizing\");\n      _this.handleResizeStart();\n      _this.updateShapes();\n    });\n    _defineProperty(_assertThisInitialized(_this), \"onPointerMove\", function () {\n      _this.updateShapes();\n    });\n    _defineProperty(_assertThisInitialized(_this), \"onKeyDown\", function () {\n      _this.updateShapes();\n    });\n    _defineProperty(_assertThisInitialized(_this), \"onKeyUp\", function () {\n      _this.updateShapes();\n    });\n    _defineProperty(_assertThisInitialized(_this), \"onPointerUp\", function () {\n      _this.complete();\n    });\n    _defineProperty(_assertThisInitialized(_this), \"onComplete\", function () {\n      _this.complete();\n    });\n    _defineProperty(_assertThisInitialized(_this), \"onCancel\", function () {\n      _this.cancel();\n    });\n    _defineProperty(_assertThisInitialized(_this), \"onExit\", function () {\n      _this.editor.snaps.clear();\n    });\n    _defineProperty(_assertThisInitialized(_this), \"_createSnapshot\", function () {\n      var _this$editor = _this.editor,\n        selectedIds = _this$editor.selectedIds,\n        selectionRotation = _this$editor.selectionRotation,\n        originPagePoint = _this$editor.inputs.originPagePoint;\n      var selectionBounds = _this.editor.selectionBounds;\n      var dragHandlePoint = Vec2d.RotWith(selectionBounds.getHandlePoint(_this.info.handle), selectionBounds.point, selectionRotation);\n      var cursorHandleOffset = Vec2d.Sub(originPagePoint, dragHandlePoint);\n      var shapeSnapshots = /* @__PURE__ */new Map();\n      selectedIds.forEach(function (id) {\n        var shape = _this.editor.getShapeById(id);\n        if (shape) {\n          shapeSnapshots.set(shape.id, _this._createShapeSnapshot(shape));\n          if (_this.editor.isShapeOfType(shape, FrameShapeUtil) && selectedIds.length === 1) return;\n          _this.editor.visitDescendants(shape.id, function (descendantId) {\n            var descendent = _this.editor.getShapeById(descendantId);\n            if (descendent) {\n              shapeSnapshots.set(descendent.id, _this._createShapeSnapshot(descendent));\n              if (_this.editor.isShapeOfType(descendent, FrameShapeUtil)) {\n                return false;\n              }\n            }\n          });\n        }\n      });\n      var canShapesDeform = !_toConsumableArray(shapeSnapshots.values()).some(function (shape) {\n        return !areAnglesCompatible(shape.pageRotation, selectionRotation) || shape.isAspectRatioLocked;\n      });\n      return {\n        shapeSnapshots: shapeSnapshots,\n        selectionBounds: selectionBounds,\n        cursorHandleOffset: cursorHandleOffset,\n        selectionRotation: selectionRotation,\n        selectedIds: selectedIds,\n        canShapesDeform: canShapesDeform,\n        initialSelectionPageBounds: _this.editor.selectedPageBounds\n      };\n    });\n    _defineProperty(_assertThisInitialized(_this), \"_createShapeSnapshot\", function (shape) {\n      var pageTransform = _this.editor.getPageTransform(shape);\n      var util = _this.editor.getShapeUtil(shape);\n      return {\n        shape: shape,\n        bounds: util.bounds(shape),\n        pageTransform: pageTransform,\n        pageRotation: Matrix2d.Decompose(pageTransform).rotation,\n        isAspectRatioLocked: util.isAspectRatioLocked(shape)\n      };\n    });\n    return _this;\n  }\n  _createClass(Resizing, [{\n    key: \"cancel\",\n    value: function cancel() {\n      this.editor.bailToMark(this.markId);\n      if (this.info.onInteractionEnd) {\n        this.editor.setSelectedTool(this.info.onInteractionEnd, {});\n      } else {\n        this.parent.transition(\"idle\", {});\n      }\n    }\n  }, {\n    key: \"complete\",\n    value: function complete() {\n      this.handleResizeEnd();\n      if (this.editAfterComplete && this.editor.onlySelectedShape) {\n        this.editor.setEditingId(this.editor.onlySelectedShape.id);\n        this.editor.setSelectedTool(\"select\");\n        this.editor.root.current.value.transition(\"editing_shape\", {});\n        return;\n      }\n      if (this.editor.instanceState.isToolLocked && this.info.onInteractionEnd) {\n        this.editor.setSelectedTool(this.info.onInteractionEnd, {});\n        return;\n      }\n      this.parent.transition(\"idle\", {});\n    }\n  }, {\n    key: \"handleResizeStart\",\n    value: function handleResizeStart() {\n      var _this2 = this;\n      var shapeSnapshots = this.snapshot.shapeSnapshots;\n      var changes = [];\n      shapeSnapshots.forEach(function (_ref) {\n        var _util$onResizeStart;\n        var shape = _ref.shape;\n        var util = _this2.editor.getShapeUtil(shape);\n        var change = (_util$onResizeStart = util.onResizeStart) === null || _util$onResizeStart === void 0 ? void 0 : _util$onResizeStart.call(util, shape);\n        if (change) {\n          changes.push(change);\n        }\n      });\n      if (changes.length > 0) {\n        this.editor.updateShapes(changes);\n      }\n    }\n  }, {\n    key: \"handleResizeEnd\",\n    value: function handleResizeEnd() {\n      var _this3 = this;\n      var shapeSnapshots = this.snapshot.shapeSnapshots;\n      var changes = [];\n      shapeSnapshots.forEach(function (_ref2) {\n        var _util$onResizeEnd;\n        var shape = _ref2.shape;\n        var current = _this3.editor.getShapeById(shape.id);\n        var util = _this3.editor.getShapeUtil(shape);\n        var change = (_util$onResizeEnd = util.onResizeEnd) === null || _util$onResizeEnd === void 0 ? void 0 : _util$onResizeEnd.call(util, shape, current);\n        if (change) {\n          changes.push(change);\n        }\n      });\n      if (changes.length > 0) {\n        this.editor.updateShapes(changes);\n      }\n    }\n  }, {\n    key: \"updateShapes\",\n    value: function updateShapes() {\n      var _this$editor$inputs = this.editor.inputs,\n        altKey = _this$editor$inputs.altKey,\n        shiftKey = _this$editor$inputs.shiftKey;\n      var _this$snapshot = this.snapshot,\n        shapeSnapshots = _this$snapshot.shapeSnapshots,\n        selectionBounds = _this$snapshot.selectionBounds,\n        cursorHandleOffset = _this$snapshot.cursorHandleOffset,\n        selectedIds = _this$snapshot.selectedIds,\n        selectionRotation = _this$snapshot.selectionRotation,\n        canShapesDeform = _this$snapshot.canShapesDeform;\n      var isAspectRatioLocked = shiftKey || !canShapesDeform;\n      var ctrlKey = this.editor.inputs.ctrlKey;\n      var currentPagePoint = this.editor.inputs.currentPagePoint.clone().sub(cursorHandleOffset).sub(this.creationCursorOffset);\n      var originPagePoint = this.editor.inputs.originPagePoint.clone().sub(cursorHandleOffset);\n      if (this.editor.isGridMode && !ctrlKey) {\n        currentPagePoint.snapToGrid(this.editor.gridSize);\n      }\n      var dragHandle = this.info.handle;\n      var scaleOriginHandle = rotateSelectionHandle(dragHandle, Math.PI);\n      this.editor.snaps.clear();\n      var shouldSnap = this.editor.isSnapMode ? !ctrlKey : ctrlKey;\n      if (shouldSnap && selectionRotation % TAU === 0) {\n        var _this$editor$snaps$sn = this.editor.snaps.snapResize({\n            dragDelta: Vec2d.Sub(currentPagePoint, originPagePoint),\n            initialSelectionPageBounds: this.snapshot.initialSelectionPageBounds,\n            handle: rotateSelectionHandle(dragHandle, selectionRotation),\n            isAspectRatioLocked: isAspectRatioLocked,\n            isResizingFromCenter: altKey\n          }),\n          nudge = _this$editor$snaps$sn.nudge;\n        currentPagePoint.add(nudge);\n      }\n      var scaleOriginPage = Vec2d.RotWith(altKey ? selectionBounds.center : selectionBounds.getHandlePoint(scaleOriginHandle), selectionBounds.point, selectionRotation);\n      var distanceFromScaleOriginNow = Vec2d.Sub(currentPagePoint, scaleOriginPage).rot(-selectionRotation);\n      var distanceFromScaleOriginAtStart = Vec2d.Sub(originPagePoint, scaleOriginPage).rot(-selectionRotation);\n      var scale = Vec2d.DivV(distanceFromScaleOriginNow, distanceFromScaleOriginAtStart);\n      if (!Number.isFinite(scale.x)) scale.x = 1;\n      if (!Number.isFinite(scale.y)) scale.y = 1;\n      var isXLocked = dragHandle === \"top\" || dragHandle === \"bottom\";\n      var isYLocked = dragHandle === \"left\" || dragHandle === \"right\";\n      if (isAspectRatioLocked) {\n        if (isYLocked) {\n          scale.y = Math.abs(scale.x);\n        } else if (isXLocked) {\n          scale.x = Math.abs(scale.y);\n        } else if (Math.abs(scale.x) > Math.abs(scale.y)) {\n          scale.y = Math.abs(scale.x) * (scale.y < 0 ? -1 : 1);\n        } else {\n          scale.x = Math.abs(scale.y) * (scale.x < 0 ? -1 : 1);\n        }\n      } else {\n        if (isXLocked) {\n          scale.x = 1;\n        }\n        if (isYLocked) {\n          scale.y = 1;\n        }\n      }\n      if (!this.info.isCreating) {\n        this.updateCursor({\n          dragHandle: dragHandle,\n          isFlippedX: scale.x < 0,\n          isFlippedY: scale.y < 0,\n          rotation: selectionRotation\n        });\n      }\n      var _iterator = _createForOfIteratorHelper(shapeSnapshots.keys()),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var id = _step.value;\n          var snapshot = shapeSnapshots.get(id);\n          this.editor.resizeShape(id, scale, {\n            initialBounds: snapshot.bounds,\n            dragHandle: dragHandle,\n            initialPageTransform: snapshot.pageTransform,\n            initialShape: snapshot.shape,\n            mode: selectedIds.length === 1 && id === selectedIds[0] ? \"resize_bounds\" : \"scale_shape\",\n            scaleOrigin: scaleOriginPage,\n            scaleAxisRotation: selectionRotation\n          });\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n    // ---\n  }, {\n    key: \"updateCursor\",\n    value: function updateCursor(_ref3) {\n      var dragHandle = _ref3.dragHandle,\n        isFlippedX = _ref3.isFlippedX,\n        isFlippedY = _ref3.isFlippedY,\n        rotation = _ref3.rotation;\n      var nextCursor = _objectSpread({}, this.editor.cursor);\n      switch (dragHandle) {\n        case \"top_left\":\n        case \"bottom_right\":\n          {\n            nextCursor.type = \"nwse-resize\";\n            if (isFlippedX !== isFlippedY) {\n              nextCursor.type = \"nesw-resize\";\n            }\n            break;\n          }\n        case \"top_right\":\n        case \"bottom_left\":\n          {\n            nextCursor.type = \"nesw-resize\";\n            if (isFlippedX !== isFlippedY) {\n              nextCursor.type = \"nwse-resize\";\n            }\n            break;\n          }\n      }\n      nextCursor.rotation = rotation;\n      this.editor.setCursor(nextCursor);\n    }\n  }]);\n  return Resizing;\n}(StateNode);\n_defineProperty(Resizing, \"id\", \"resizing\");\nvar ORDERED_SELECTION_HANDLES = [\"top\", \"top_right\", \"right\", \"bottom_right\", \"bottom\", \"bottom_left\", \"left\", \"top_left\"];\nfunction rotateSelectionHandle(handle, rotation) {\n  rotation = rotation % PI2;\n  var numSteps = Math.round(rotation / (PI / 4));\n  var currentIndex = ORDERED_SELECTION_HANDLES.indexOf(handle);\n  return ORDERED_SELECTION_HANDLES[(currentIndex + numSteps) % ORDERED_SELECTION_HANDLES.length];\n}\nexport { Resizing, rotateSelectionHandle };","map":{"version":3,"names":["areAnglesCompatible","Matrix2d","PI","PI2","TAU","Vec2d","FrameShapeUtil","StateNode","Resizing","_StateNode","_inherits","_super","_createSuper","_this","_classCallCheck","_len","arguments","length","args","Array","_key","call","apply","concat","_defineProperty","_assertThisInitialized","x","y","info","_info$isCreating","isCreating","_info$editAfterComple","editAfterComplete","_info$creationCursorO","creationCursorOffset","editor","setCursor","type","rotation","snapshot","_createSnapshot","markId","mark","handleResizeStart","updateShapes","complete","cancel","snaps","clear","_this$editor","selectedIds","selectionRotation","originPagePoint","inputs","selectionBounds","dragHandlePoint","RotWith","getHandlePoint","handle","point","cursorHandleOffset","Sub","shapeSnapshots","Map","forEach","id","shape","getShapeById","set","_createShapeSnapshot","isShapeOfType","visitDescendants","descendantId","descendent","canShapesDeform","_toConsumableArray","values","some","pageRotation","isAspectRatioLocked","initialSelectionPageBounds","selectedPageBounds","pageTransform","getPageTransform","util","getShapeUtil","bounds","Decompose","_createClass","key","value","bailToMark","onInteractionEnd","setSelectedTool","parent","transition","handleResizeEnd","onlySelectedShape","setEditingId","root","current","instanceState","isToolLocked","_this2","changes","_ref","_util$onResizeStart","change","onResizeStart","push","_this3","_ref2","_util$onResizeEnd","onResizeEnd","_this$editor$inputs","altKey","shiftKey","_this$snapshot","ctrlKey","currentPagePoint","clone","sub","isGridMode","snapToGrid","gridSize","dragHandle","scaleOriginHandle","rotateSelectionHandle","Math","shouldSnap","isSnapMode","_this$editor$snaps$sn","snapResize","dragDelta","isResizingFromCenter","nudge","add","scaleOriginPage","center","distanceFromScaleOriginNow","rot","distanceFromScaleOriginAtStart","scale","DivV","Number","isFinite","isXLocked","isYLocked","abs","updateCursor","isFlippedX","isFlippedY","_iterator","_createForOfIteratorHelper","keys","_step","s","n","done","get","resizeShape","initialBounds","initialPageTransform","initialShape","mode","scaleOrigin","scaleAxisRotation","err","e","f","_ref3","nextCursor","_objectSpread","cursor","ORDERED_SELECTION_HANDLES","numSteps","round","currentIndex","indexOf"],"sources":["/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@tldraw/editor/src/lib/editor/tools/SelectTool/children/Resizing.ts"],"sourcesContent":["import {\n\tareAnglesCompatible,\n\tMatrix2d,\n\tPI,\n\tPI2,\n\tSelectionCorner,\n\tSelectionEdge,\n\tTAU,\n\tVec2d,\n\tVecLike,\n} from '@tldraw/primitives'\nimport { TLShape, TLShapeId, TLShapePartial } from '@tldraw/tlschema'\nimport { FrameShapeUtil } from '../../../shapes/frame/FrameShapeUtil'\nimport {\n\tTLEnterEventHandler,\n\tTLEventHandlers,\n\tTLPointerEventInfo,\n} from '../../../types/event-types'\nimport { StateNode } from '../../StateNode'\n\ntype ResizingInfo = TLPointerEventInfo & {\n\ttarget: 'selection'\n\thandle: SelectionEdge | SelectionCorner\n\tisCreating?: boolean\n\teditAfterComplete?: boolean\n\tcreationCursorOffset?: VecLike\n\tonInteractionEnd?: string\n}\n\nexport class Resizing extends StateNode {\n\tstatic override id = 'resizing'\n\n\tinfo = {} as ResizingInfo\n\n\tmarkId = ''\n\n\t// we transition into the resizing state from the geo pointing state, which starts with a shape of size w: 1, h: 1,\n\t// so if the user drags x: +50, y: +50 after mouseDown, the shape will be w: 51, h: 51, which is too many pixels, alas\n\t// so we allow passing a further offset into this state to negate such issues\n\tcreationCursorOffset = { x: 0, y: 0 } as VecLike\n\teditAfterComplete = false\n\n\tprivate snapshot = {} as any as Snapshot\n\n\tonEnter: TLEnterEventHandler = (info: ResizingInfo) => {\n\t\tconst {\n\t\t\tisCreating = false,\n\t\t\teditAfterComplete = false,\n\t\t\tcreationCursorOffset = { x: 0, y: 0 },\n\t\t} = info\n\n\t\tthis.info = info\n\t\tthis.editAfterComplete = editAfterComplete\n\t\tthis.creationCursorOffset = creationCursorOffset\n\n\t\tif (info.isCreating) {\n\t\t\tthis.editor.setCursor({ type: 'cross', rotation: 0 })\n\t\t}\n\n\t\tthis.snapshot = this._createSnapshot()\n\t\tthis.markId = isCreating ? 'creating' : this.editor.mark('starting resizing')\n\n\t\tthis.handleResizeStart()\n\t\tthis.updateShapes()\n\t}\n\n\tonPointerMove: TLEventHandlers['onPointerMove'] = () => {\n\t\tthis.updateShapes()\n\t}\n\n\tonKeyDown: TLEventHandlers['onKeyDown'] = () => {\n\t\tthis.updateShapes()\n\t}\n\tonKeyUp: TLEventHandlers['onKeyUp'] = () => {\n\t\tthis.updateShapes()\n\t}\n\n\tonPointerUp: TLEventHandlers['onPointerUp'] = () => {\n\t\tthis.complete()\n\t}\n\n\tonComplete: TLEventHandlers['onComplete'] = () => {\n\t\tthis.complete()\n\t}\n\n\tonCancel: TLEventHandlers['onCancel'] = () => {\n\t\tthis.cancel()\n\t}\n\n\tprivate cancel() {\n\t\t// Restore initial models\n\t\tthis.editor.bailToMark(this.markId)\n\t\tif (this.info.onInteractionEnd) {\n\t\t\tthis.editor.setSelectedTool(this.info.onInteractionEnd, {})\n\t\t} else {\n\t\t\tthis.parent.transition('idle', {})\n\t\t}\n\t}\n\n\tprivate complete() {\n\t\tthis.handleResizeEnd()\n\n\t\tif (this.editAfterComplete && this.editor.onlySelectedShape) {\n\t\t\tthis.editor.setEditingId(this.editor.onlySelectedShape.id)\n\t\t\tthis.editor.setSelectedTool('select')\n\t\t\tthis.editor.root.current.value!.transition('editing_shape', {})\n\t\t\treturn\n\t\t}\n\n\t\tif (this.editor.instanceState.isToolLocked && this.info.onInteractionEnd) {\n\t\t\tthis.editor.setSelectedTool(this.info.onInteractionEnd, {})\n\t\t\treturn\n\t\t}\n\n\t\tthis.parent.transition('idle', {})\n\t}\n\n\tprivate handleResizeStart() {\n\t\tconst { shapeSnapshots } = this.snapshot\n\n\t\tconst changes: TLShapePartial[] = []\n\n\t\tshapeSnapshots.forEach(({ shape }) => {\n\t\t\tconst util = this.editor.getShapeUtil(shape)\n\t\t\tconst change = util.onResizeStart?.(shape)\n\t\t\tif (change) {\n\t\t\t\tchanges.push(change)\n\t\t\t}\n\t\t})\n\n\t\tif (changes.length > 0) {\n\t\t\tthis.editor.updateShapes(changes)\n\t\t}\n\t}\n\n\tprivate handleResizeEnd() {\n\t\tconst { shapeSnapshots } = this.snapshot\n\n\t\tconst changes: TLShapePartial[] = []\n\n\t\tshapeSnapshots.forEach(({ shape }) => {\n\t\t\tconst current = this.editor.getShapeById(shape.id)!\n\t\t\tconst util = this.editor.getShapeUtil(shape)\n\t\t\tconst change = util.onResizeEnd?.(shape, current)\n\t\t\tif (change) {\n\t\t\t\tchanges.push(change)\n\t\t\t}\n\t\t})\n\n\t\tif (changes.length > 0) {\n\t\t\tthis.editor.updateShapes(changes)\n\t\t}\n\t}\n\n\tprivate updateShapes() {\n\t\tconst { altKey, shiftKey } = this.editor.inputs\n\t\tconst {\n\t\t\tshapeSnapshots,\n\t\t\tselectionBounds,\n\t\t\tcursorHandleOffset,\n\t\t\tselectedIds,\n\t\t\tselectionRotation,\n\t\t\tcanShapesDeform,\n\t\t} = this.snapshot\n\n\t\tconst isAspectRatioLocked = shiftKey || !canShapesDeform\n\n\t\t// first negate the 'cursor handle offset'\n\t\t// we need to do this because we do grid snapping based on the page point of the handle\n\t\t// rather than the page point of the cursor, so it's easier to pretend that the cursor\n\t\t// is really where the handle actually is\n\t\t//\n\t\t// *** Massively zoomed-in diagram of the initial mouseDown ***\n\t\t//\n\t\t//\n\t\t//                         │\n\t\t//                         │\n\t\t//                         │\n\t\t//                         │\n\t\t//                         │\n\t\t//                         │\n\t\t//                         │\n\t\t//                         │corner handle\n\t\t//                     ┌───┴───┐\n\t\t//   selection         │       │\n\t\t//  ───────────────────┤   x◄──┼──── drag handle point   ▲\n\t\t//                     │       │                         │\n\t\t//                     └───────┘                         ├─ cursorHandleOffset.y\n\t\t//                                                       │\n\t\t//        originPagePoint───────►x─┐                     ▼\n\t\t//                               │ └─┐\n\t\t//                               │   └─┐\n\t\t//                               │     │ mouse (sorry)\n\t\t//                               └──┐ ┌┘\n\t\t//                                  │ │\n\t\t//                                  └─┘\n\t\t//                         ◄──┬──►\n\t\t//                            │\n\t\t//                   cursorHandleOffset.x\n\n\t\tconst { ctrlKey } = this.editor.inputs\n\n\t\tconst currentPagePoint = this.editor.inputs.currentPagePoint\n\t\t\t.clone()\n\t\t\t.sub(cursorHandleOffset)\n\t\t\t.sub(this.creationCursorOffset)\n\t\tconst originPagePoint = this.editor.inputs.originPagePoint.clone().sub(cursorHandleOffset)\n\n\t\tif (this.editor.isGridMode && !ctrlKey) {\n\t\t\tcurrentPagePoint.snapToGrid(this.editor.gridSize)\n\t\t}\n\n\t\tconst dragHandle = this.info.handle as SelectionCorner | SelectionEdge\n\t\tconst scaleOriginHandle = rotateSelectionHandle(dragHandle, Math.PI)\n\n\t\tthis.editor.snaps.clear()\n\n\t\tconst shouldSnap = this.editor.isSnapMode ? !ctrlKey : ctrlKey\n\n\t\tif (shouldSnap && selectionRotation % TAU === 0) {\n\t\t\tconst { nudge } = this.editor.snaps.snapResize({\n\t\t\t\tdragDelta: Vec2d.Sub(currentPagePoint, originPagePoint),\n\t\t\t\tinitialSelectionPageBounds: this.snapshot.initialSelectionPageBounds,\n\t\t\t\thandle: rotateSelectionHandle(dragHandle, selectionRotation),\n\t\t\t\tisAspectRatioLocked,\n\t\t\t\tisResizingFromCenter: altKey,\n\t\t\t})\n\n\t\t\tcurrentPagePoint.add(nudge)\n\t\t}\n\n\t\t// get the page point of the selection handle opposite to the drag handle\n\t\t// or the center of the selection box if altKey is pressed\n\t\tconst scaleOriginPage = Vec2d.RotWith(\n\t\t\taltKey ? selectionBounds.center : selectionBounds.getHandlePoint(scaleOriginHandle),\n\t\t\tselectionBounds.point,\n\t\t\tselectionRotation\n\t\t)\n\n\t\t// calculate the scale by measuring the current distance between the drag handle and the scale origin\n\t\t// and dividing by the original distance between the drag handle and the scale origin\n\n\t\tconst distanceFromScaleOriginNow = Vec2d.Sub(currentPagePoint, scaleOriginPage).rot(\n\t\t\t-selectionRotation\n\t\t)\n\n\t\tconst distanceFromScaleOriginAtStart = Vec2d.Sub(originPagePoint, scaleOriginPage).rot(\n\t\t\t-selectionRotation\n\t\t)\n\n\t\tconst scale = Vec2d.DivV(distanceFromScaleOriginNow, distanceFromScaleOriginAtStart)\n\n\t\tif (!Number.isFinite(scale.x)) scale.x = 1\n\t\tif (!Number.isFinite(scale.y)) scale.y = 1\n\n\t\tconst isXLocked = dragHandle === 'top' || dragHandle === 'bottom'\n\t\tconst isYLocked = dragHandle === 'left' || dragHandle === 'right'\n\n\t\t// lock an axis if required\n\t\tif (isAspectRatioLocked) {\n\t\t\tif (isYLocked) {\n\t\t\t\t// holding shift and dragging either the left or the right edge\n\t\t\t\tscale.y = Math.abs(scale.x)\n\t\t\t} else if (isXLocked) {\n\t\t\t\t// holding shift and dragging either the top or the bottom edge\n\t\t\t\tscale.x = Math.abs(scale.y)\n\t\t\t} else if (Math.abs(scale.x) > Math.abs(scale.y)) {\n\t\t\t\t// holding shift and the drag has moved further in the x dimension\n\t\t\t\tscale.y = Math.abs(scale.x) * (scale.y < 0 ? -1 : 1)\n\t\t\t} else {\n\t\t\t\t// holding shift and the drag has moved further in the y dimension\n\t\t\t\tscale.x = Math.abs(scale.y) * (scale.x < 0 ? -1 : 1)\n\t\t\t}\n\t\t} else {\n\t\t\t// not holding shift, but still need to lock axes if dragging an edge\n\t\t\tif (isXLocked) {\n\t\t\t\tscale.x = 1\n\t\t\t}\n\t\t\tif (isYLocked) {\n\t\t\t\tscale.y = 1\n\t\t\t}\n\t\t}\n\n\t\tif (!this.info.isCreating) {\n\t\t\tthis.updateCursor({\n\t\t\t\tdragHandle,\n\t\t\t\tisFlippedX: scale.x < 0,\n\t\t\t\tisFlippedY: scale.y < 0,\n\t\t\t\trotation: selectionRotation,\n\t\t\t})\n\t\t}\n\n\t\tfor (const id of shapeSnapshots.keys()) {\n\t\t\tconst snapshot = shapeSnapshots.get(id)!\n\t\t\tthis.editor.resizeShape(id, scale, {\n\t\t\t\tinitialBounds: snapshot.bounds,\n\t\t\t\tdragHandle,\n\t\t\t\tinitialPageTransform: snapshot.pageTransform,\n\t\t\t\tinitialShape: snapshot.shape,\n\t\t\t\tmode: selectedIds.length === 1 && id === selectedIds[0] ? 'resize_bounds' : 'scale_shape',\n\t\t\t\tscaleOrigin: scaleOriginPage,\n\t\t\t\tscaleAxisRotation: selectionRotation,\n\t\t\t})\n\t\t}\n\t}\n\n\t// ---\n\n\tprivate updateCursor({\n\t\tdragHandle,\n\t\tisFlippedX,\n\t\tisFlippedY,\n\t\trotation,\n\t}: {\n\t\tdragHandle: SelectionCorner | SelectionEdge\n\t\tisFlippedX: boolean\n\t\tisFlippedY: boolean\n\t\trotation: number\n\t}) {\n\t\tconst nextCursor = { ...this.editor.cursor }\n\n\t\tswitch (dragHandle) {\n\t\t\tcase 'top_left':\n\t\t\tcase 'bottom_right': {\n\t\t\t\tnextCursor.type = 'nwse-resize'\n\t\t\t\tif (isFlippedX !== isFlippedY) {\n\t\t\t\t\tnextCursor.type = 'nesw-resize'\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase 'top_right':\n\t\t\tcase 'bottom_left': {\n\t\t\t\tnextCursor.type = 'nesw-resize'\n\t\t\t\tif (isFlippedX !== isFlippedY) {\n\t\t\t\t\tnextCursor.type = 'nwse-resize'\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tnextCursor.rotation = rotation\n\n\t\tthis.editor.setCursor(nextCursor)\n\t}\n\n\tonExit = () => {\n\t\tthis.editor.snaps.clear()\n\t}\n\n\t_createSnapshot = () => {\n\t\tconst {\n\t\t\tselectedIds,\n\t\t\tselectionRotation,\n\t\t\tinputs: { originPagePoint },\n\t\t} = this.editor\n\n\t\tconst selectionBounds = this.editor.selectionBounds!\n\n\t\tconst dragHandlePoint = Vec2d.RotWith(\n\t\t\tselectionBounds.getHandlePoint(this.info.handle!),\n\t\t\tselectionBounds.point,\n\t\t\tselectionRotation\n\t\t)\n\n\t\tconst cursorHandleOffset = Vec2d.Sub(originPagePoint, dragHandlePoint)\n\n\t\tconst shapeSnapshots = new Map<TLShapeId, ShapeSnapshot>()\n\n\t\tselectedIds.forEach((id) => {\n\t\t\tconst shape = this.editor.getShapeById(id)\n\t\t\tif (shape) {\n\t\t\t\tshapeSnapshots.set(shape.id, this._createShapeSnapshot(shape))\n\t\t\t\tif (this.editor.isShapeOfType(shape, FrameShapeUtil) && selectedIds.length === 1) return\n\t\t\t\tthis.editor.visitDescendants(shape.id, (descendantId) => {\n\t\t\t\t\tconst descendent = this.editor.getShapeById(descendantId)\n\t\t\t\t\tif (descendent) {\n\t\t\t\t\t\tshapeSnapshots.set(descendent.id, this._createShapeSnapshot(descendent))\n\t\t\t\t\t\tif (this.editor.isShapeOfType(descendent, FrameShapeUtil)) {\n\t\t\t\t\t\t\treturn false\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t}\n\t\t})\n\n\t\tconst canShapesDeform = ![...shapeSnapshots.values()].some(\n\t\t\t(shape) =>\n\t\t\t\t!areAnglesCompatible(shape.pageRotation, selectionRotation) || shape.isAspectRatioLocked\n\t\t)\n\n\t\treturn {\n\t\t\tshapeSnapshots,\n\t\t\tselectionBounds,\n\t\t\tcursorHandleOffset,\n\t\t\tselectionRotation,\n\t\t\tselectedIds,\n\t\t\tcanShapesDeform,\n\t\t\tinitialSelectionPageBounds: this.editor.selectedPageBounds!,\n\t\t}\n\t}\n\n\t_createShapeSnapshot = (shape: TLShape) => {\n\t\tconst pageTransform = this.editor.getPageTransform(shape)!\n\t\tconst util = this.editor.getShapeUtil(shape)\n\n\t\treturn {\n\t\t\tshape,\n\t\t\tbounds: util.bounds(shape),\n\t\t\tpageTransform,\n\t\t\tpageRotation: Matrix2d.Decompose(pageTransform!).rotation,\n\t\t\tisAspectRatioLocked: util.isAspectRatioLocked(shape),\n\t\t}\n\t}\n}\n\ntype Snapshot = ReturnType<Resizing['_createSnapshot']>\ntype ShapeSnapshot = ReturnType<Resizing['_createShapeSnapshot']>\n\nconst ORDERED_SELECTION_HANDLES: (SelectionEdge | SelectionCorner)[] = [\n\t'top',\n\t'top_right',\n\t'right',\n\t'bottom_right',\n\t'bottom',\n\t'bottom_left',\n\t'left',\n\t'top_left',\n]\n\nexport function rotateSelectionHandle(handle: SelectionEdge | SelectionCorner, rotation: number) {\n\t// first find out how many tau we need to rotate by\n\trotation = rotation % PI2\n\tconst numSteps = Math.round(rotation / (PI / 4))\n\n\tconst currentIndex = ORDERED_SELECTION_HANDLES.indexOf(handle)\n\treturn ORDERED_SELECTION_HANDLES[(currentIndex + numSteps) % ORDERED_SELECTION_HANDLES.length]\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}