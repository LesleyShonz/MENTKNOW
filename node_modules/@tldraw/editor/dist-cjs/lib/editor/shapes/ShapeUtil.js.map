{
  "version": 3,
  "sources": ["../../../../src/lib/editor/shapes/ShapeUtil.ts"],
  "sourcesContent": ["/* eslint-disable @typescript-eslint/no-unused-vars */\nimport { Box2d, linesIntersect, Vec2d, VecLike } from '@tldraw/primitives'\nimport { ComputedCache } from '@tldraw/store'\nimport { StyleProp, TLHandle, TLShape, TLShapePartial, TLUnknownShape } from '@tldraw/tlschema'\nimport { computed, EMPTY_ARRAY } from 'signia'\nimport type { Editor } from '../Editor'\nimport { TLResizeHandle } from '../types/selection-types'\nimport { TLExportColors } from './shared/TLExportColors'\n\n/** @public */\nexport interface TLShapeUtilConstructor<\n\tT extends TLUnknownShape,\n\tU extends ShapeUtil<T> = ShapeUtil<T>\n> {\n\tnew (editor: Editor, type: T['type'], styleProps: ReadonlyMap<StyleProp<unknown>, string>): U\n\ttype: T['type']\n}\n\n/** @public */\nexport type TLShapeUtilFlag<T> = (shape: T) => boolean\n\n/** @public */\nexport abstract class ShapeUtil<Shape extends TLUnknownShape = TLUnknownShape> {\n\tconstructor(\n\t\tpublic editor: Editor,\n\t\tpublic readonly type: Shape['type'],\n\t\tpublic readonly styleProps: ReadonlyMap<StyleProp<unknown>, string>\n\t) {}\n\n\thasStyle(style: StyleProp<unknown>) {\n\t\treturn this.styleProps.has(style)\n\t}\n\n\tgetStyleIfExists<T>(style: StyleProp<T>, shape: Shape | TLShapePartial<Shape>): T | undefined {\n\t\tconst styleKey = this.styleProps.get(style)\n\t\tif (!styleKey) return undefined\n\t\treturn (shape.props as any)[styleKey]\n\t}\n\n\t*iterateStyles(shape: Shape | TLShapePartial<Shape>) {\n\t\tfor (const [style, styleKey] of this.styleProps) {\n\t\t\tconst value = (shape.props as any)[styleKey]\n\t\t\tyield [style, value] as [StyleProp<unknown>, unknown]\n\t\t}\n\t}\n\n\tsetStyleInPartial<T>(\n\t\tstyle: StyleProp<T>,\n\t\tshape: TLShapePartial<Shape>,\n\t\tvalue: T\n\t): TLShapePartial<Shape> {\n\t\tconst styleKey = this.styleProps.get(style)\n\t\tif (!styleKey) return shape\n\t\treturn {\n\t\t\t...shape,\n\t\t\tprops: {\n\t\t\t\t...shape.props,\n\t\t\t\t[styleKey]: value,\n\t\t\t},\n\t\t}\n\t}\n\n\t/**\n\t * The type of the shape util, which should match the shape's type.\n\t *\n\t * @public\n\t */\n\tstatic type: string\n\n\t/**\n\t * Whether the shape can be snapped to by another shape.\n\t *\n\t * @public\n\t */\n\tcanSnap: TLShapeUtilFlag<Shape> = () => true\n\n\t/**\n\t * Whether the shape can be scrolled while editing.\n\t *\n\t * @public\n\t */\n\tcanScroll: TLShapeUtilFlag<Shape> = () => false\n\n\t/**\n\t * Whether the shape should unmount when not visible in the editor. Consider keeping this to false if the shape's `component` has local state.\n\t *\n\t * @public\n\t */\n\tcanUnmount: TLShapeUtilFlag<Shape> = () => true\n\n\t/**\n\t * Whether the shape can be bound to by an arrow.\n\t *\n\t * @param _otherShape - The other shape attempting to bind to this shape.\n\t * @public\n\t */\n\tcanBind = <K>(_shape: Shape, _otherShape?: K) => true\n\n\t/**\n\t * Whether the shape can be double clicked to edit.\n\t *\n\t * @public\n\t */\n\tcanEdit: TLShapeUtilFlag<Shape> = () => false\n\n\t/**\n\t * Whether the shape can be resized.\n\t *\n\t * @public\n\t */\n\tcanResize: TLShapeUtilFlag<Shape> = () => true\n\n\t/**\n\t * Whether the shape can be cropped.\n\t *\n\t * @public\n\t */\n\tcanCrop: TLShapeUtilFlag<Shape> = () => false\n\n\t/**\n\t * Bounds of the shape to edit.\n\t *\n\t * Note: this could be a text area within a shape for example arrow labels.\n\t *\n\t * @public\n\t */\n\tgetEditingBounds = (shape: Shape) => {\n\t\treturn this.bounds(shape)\n\t}\n\n\t/**\n\t * Whether the shape's outline is closed.\n\t *\n\t * @public\n\t */\n\tisClosed: TLShapeUtilFlag<Shape> = () => true\n\n\t/**\n\t * Whether the shape should hide its resize handles when selected.\n\t *\n\t * @public\n\t */\n\thideResizeHandles: TLShapeUtilFlag<Shape> = () => false\n\n\t/**\n\t * Whether the shape should hide its resize handles when selected.\n\t *\n\t * @public\n\t */\n\thideRotateHandle: TLShapeUtilFlag<Shape> = () => false\n\n\t/**\n\t * Whether the shape should hide its selection bounds background when selected.\n\t *\n\t * @public\n\t */\n\thideSelectionBoundsBg: TLShapeUtilFlag<Shape> = () => false\n\n\t/**\n\t * Whether the shape should hide its selection bounds foreground when selected.\n\t *\n\t * @public\n\t */\n\thideSelectionBoundsFg: TLShapeUtilFlag<Shape> = () => false\n\n\t/**\n\t * Whether the shape's aspect ratio is locked.\n\t *\n\t * @public\n\t */\n\tisAspectRatioLocked: TLShapeUtilFlag<Shape> = () => false\n\n\t/**\n\t * Get the default props for a shape.\n\t *\n\t * @public\n\t */\n\tabstract defaultProps(): Shape['props']\n\n\t/**\n\t * Get a JSX element for the shape (as an HTML element).\n\t *\n\t * @param shape - The shape.\n\t * @public\n\t */\n\tabstract component(shape: Shape): any\n\n\t/**\n\t * Get JSX describing the shape's indicator (as an SVG element).\n\t *\n\t * @param shape - The shape.\n\t * @public\n\t */\n\tabstract indicator(shape: Shape): any\n\n\t/**\n\t * Get a JSX element for the shape (as an HTML element) to be rendered as part of the canvas background - behind any other shape content.\n\t *\n\t * @param shape - The shape.\n\t * @internal\n\t */\n\trenderBackground?(shape: Shape): any\n\n\t/**\n\t * Get an array of handle models for the shape. This is an optional method.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * util.getHandles?.(myShape)\n\t * ```\n\t *\n\t * @param shape - The shape.\n\t * @public\n\t */\n\tprotected getHandles?(shape: Shape): TLHandle[]\n\n\t@computed\n\tprivate get handlesCache(): ComputedCache<TLHandle[], TLShape> {\n\t\treturn this.editor.store.createComputedCache('handles:' + this.type, (shape) => {\n\t\t\treturn this.getHandles!(shape as any)\n\t\t})\n\t}\n\n\t/**\n\t * Get the cached handles (this should not be overridden!)\n\t *\n\t * @param shape - The shape.\n\t * @public\n\t */\n\thandles(shape: Shape): TLHandle[] {\n\t\tif (!this.getHandles) return EMPTY_ARRAY\n\t\treturn this.handlesCache.get(shape.id) ?? EMPTY_ARRAY\n\t}\n\n\t/**\n\t * Get an array of outline segments for the shape. For most shapes,\n\t * this will be a single segment that includes the entire outline.\n\t * For shapes with handles, this might be segments of the outline\n\t * between each handle.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * util.getOutlineSegments(myShape)\n\t * ```\n\t *\n\t * @param shape - The shape.\n\t * @public\n\t */\n\tprotected getOutlineSegments(shape: Shape): Vec2d[][] {\n\t\treturn [this.outline(shape)]\n\t}\n\n\t@computed\n\tprivate get outlineSegmentsCache(): ComputedCache<Vec2d[][], TLShape> {\n\t\treturn this.editor.store.createComputedCache('outline-segments:' + this.type, (shape) => {\n\t\t\treturn this.getOutlineSegments!(shape as any)\n\t\t})\n\t}\n\n\t/**\n\t * Get the cached outline segments (this should not be overridden!)\n\t *\n\t * @param shape - The shape.\n\t * @public\n\t */\n\toutlineSegments(shape: Shape): Vec2d[][] {\n\t\tif (!this.getOutlineSegments) return EMPTY_ARRAY\n\t\treturn this.outlineSegmentsCache.get(shape.id) ?? EMPTY_ARRAY\n\t}\n\n\t/**\n\t * Get the (not cached) bounds for the shape.\n\t *\n\t * @param shape - The shape.\n\t * @public\n\t */\n\tprotected abstract getBounds(shape: Shape): Box2d\n\n\t@computed\n\tprivate get boundsCache(): ComputedCache<Box2d, TLShape> {\n\t\treturn this.editor.store.createComputedCache('bounds:' + this.type, (shape) => {\n\t\t\treturn this.getBounds(shape as any)\n\t\t})\n\t}\n\n\t/**\n\t * Get the cached bounds for the shape.\n\t *\n\t * @param shape - The shape.\n\t * @public\n\t */\n\tbounds(shape: Shape): Box2d {\n\t\tconst result = this.boundsCache.get(shape.id) ?? new Box2d()\n\t\tif (result.width === 0 || result.height === 0) {\n\t\t\treturn new Box2d(result.x, result.y, Math.max(result.width, 1), Math.max(result.height, 1))\n\t\t}\n\t\treturn result\n\t}\n\n\t/**\n\t * Get the shape's (not cached) outline. Do not override this method!\n\t *\n\t * @param shape - The shape.\n\t * @public\n\t */\n\tprotected abstract getOutline(shape: Shape): Vec2d[]\n\n\t@computed\n\tprivate get outlineCache(): ComputedCache<Vec2d[], TLShape> {\n\t\treturn this.editor.store.createComputedCache('outline:' + this.type, (shape) => {\n\t\t\treturn this.getOutline(shape as any)\n\t\t})\n\t}\n\n\t/**\n\t * Get the shape's outline. Do not override this method!\n\t *\n\t * @param shape - The shape.\n\t * @public\n\t */\n\toutline(shape: Shape): Vec2d[] {\n\t\treturn this.outlineCache.get(shape.id) ?? EMPTY_ARRAY\n\t}\n\n\t/**\n\t * Get the shape's snap points.\n\t *\n\t * @param shape - The shape.\n\t * @public\n\t */\n\tsnapPoints(shape: Shape) {\n\t\treturn this.bounds(shape).snapPoints\n\t}\n\n\t/**\n\t * Get the shape's cached center.\n\t *\n\t * @param shape - The shape.\n\t * @public\n\t */\n\tcenter(shape: Shape): Vec2d {\n\t\treturn this.getCenter(shape)\n\t}\n\n\t/**\n\t * Get the shape's (not cached) center.\n\t *\n\t * @param shape - The shape.\n\t * @public\n\t */\n\tabstract getCenter(shape: Shape): Vec2d\n\n\t/**\n\t * Get whether the shape can receive children of a given type.\n\t *\n\t * @param type - The shape type.\n\t * @public\n\t */\n\tcanReceiveNewChildrenOfType(shape: Shape, type: TLShape['type']) {\n\t\treturn false\n\t}\n\n\t/**\n\t * Get whether the shape can receive children of a given type.\n\t *\n\t * @param shape - The shape type.\n\t * @param shapes - The shapes that are being dropped.\n\t * @public\n\t */\n\tcanDropShapes(shape: Shape, shapes: TLShape[]) {\n\t\treturn false\n\t}\n\n\t/**\n\t * Get the shape as an SVG object.\n\t *\n\t * @param shape - The shape.\n\t * @param color - The shape's CSS color (actual).\n\t * @param font - The shape's CSS font (actual).\n\t * @returns An SVG element.\n\t * @public\n\t */\n\ttoSvg?(\n\t\tshape: Shape,\n\t\tfont: string | undefined,\n\t\tcolors: TLExportColors\n\t): SVGElement | Promise<SVGElement>\n\n\t/**\n\t * Get the shape's background layer as an SVG object.\n\t *\n\t * @param shape - The shape.\n\t * @param color - The shape's CSS color (actual).\n\t * @param font - The shape's CSS font (actual).\n\t * @returns An SVG element.\n\t * @public\n\t */\n\ttoBackgroundSvg?(\n\t\tshape: Shape,\n\t\tfont: string | undefined,\n\t\tcolors: TLExportColors\n\t): SVGElement | Promise<SVGElement> | null\n\n\t/**\n\t * Get whether a point intersects the shape.\n\t *\n\t * @param shape - The shape.\n\t * @param point - The point to test.\n\t * @returns Whether the point intersects the shape.\n\t * @public\n\t */\n\thitTestPoint(shape: Shape, point: VecLike): boolean {\n\t\treturn this.bounds(shape).containsPoint(point)\n\t}\n\n\t/**\n\t * Get whether a point intersects the shape.\n\t *\n\t * @param shape - The shape.\n\t * @param A - The line segment's first point.\n\t * @param B - The line segment's second point.\n\t * @returns Whether the line segment intersects the shape.\n\t * @public\n\t */\n\thitTestLineSegment(shape: Shape, A: VecLike, B: VecLike): boolean {\n\t\tconst outline = this.outline(shape)\n\n\t\tfor (let i = 0; i < outline.length; i++) {\n\t\t\tconst C = outline[i]\n\t\t\tconst D = outline[(i + 1) % outline.length]\n\t\t\tif (linesIntersect(A, B, C, D)) return true\n\t\t}\n\n\t\treturn false\n\t}\n\n\t/** @internal */\n\texpandSelectionOutlinePx(shape: Shape): number {\n\t\treturn 0\n\t}\n\n\t/**\n\t * Does this shape provide a background for its children? If this is true,\n\t * then any children with a `renderBackground` method will have their\n\t * backgrounds rendered _above_ this shape. Otherwise, the children's\n\t * backgrounds will be rendered above either the next ancestor that provides\n\t * a background, or the canvas background.\n\t *\n\t * @internal\n\t */\n\tprovidesBackgroundForChildren(shape: Shape): boolean {\n\t\treturn false\n\t}\n\n\t//  Events\n\n\t/**\n\t * A callback called just before a shape is created. This method provides a last chance to modify\n\t * the created shape.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * onBeforeCreate = (next) => {\n\t * \treturn { ...next, x: next.x + 1 }\n\t * }\n\t * ```\n\t *\n\t * @param next - The next shape.\n\t * @returns The next shape or void.\n\t * @public\n\t */\n\tonBeforeCreate?: TLOnBeforeCreateHandler<Shape>\n\n\t/**\n\t * A callback called just before a shape is updated. This method provides a last chance to modify\n\t * the updated shape.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * onBeforeUpdate = (prev, next) => {\n\t * \tif (prev.x === next.x) {\n\t * \t\treturn { ...next, x: next.x + 1 }\n\t * \t}\n\t * }\n\t * ```\n\t *\n\t * @param prev - The previous shape.\n\t * @param next - The next shape.\n\t * @returns The next shape or void.\n\t * @public\n\t */\n\tonBeforeUpdate?: TLOnBeforeUpdateHandler<Shape>\n\n\t/**\n\t * A callback called when some other shapes are dragged over this one.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * onDragShapesOver = (shape, shapes) => {\n\t * \treturn { shouldHint: true }\n\t * }\n\t * ```\n\t *\n\t * @param shape - The shape.\n\t * @param shapes - The shapes that are being dragged over this one.\n\t * @returns An object specifying whether the shape should hint that it can receive the dragged shapes.\n\t * @public\n\t */\n\tonDragShapesOver?: TLOnDragHandler<Shape, { shouldHint: boolean }>\n\n\t/**\n\t * A callback called when some other shapes are dragged out of this one.\n\t *\n\t * @param shape - The shape.\n\t * @param shapes - The shapes that are being dragged out.\n\t * @public\n\t */\n\tonDragShapesOut?: TLOnDragHandler<Shape>\n\n\t/**\n\t * A callback called when some other shapes are dropped over this one.\n\t *\n\t * @param shape - The shape.\n\t * @param shapes - The shapes that are being dropped over this one.\n\t * @public\n\t */\n\tonDropShapesOver?: TLOnDragHandler<Shape>\n\n\t/**\n\t * A callback called when a shape starts being resized.\n\t *\n\t * @param shape - The shape.\n\t * @returns A change to apply to the shape, or void.\n\t * @public\n\t */\n\tonResizeStart?: TLOnResizeStartHandler<Shape>\n\n\t/**\n\t * A callback called when a shape changes from a resize.\n\t *\n\t * @param shape - The shape at the start of the resize.\n\t * @param info - Info about the resize.\n\t * @returns A change to apply to the shape, or void.\n\t * @public\n\t */\n\tonResize?: TLOnResizeHandler<Shape>\n\n\t/**\n\t * A callback called when a shape finishes resizing.\n\t *\n\t * @param initial - The shape at the start of the resize.\n\t * @param current - The current shape.\n\t * @returns A change to apply to the shape, or void.\n\t * @public\n\t */\n\tonResizeEnd?: TLOnResizeEndHandler<Shape>\n\n\t/**\n\t * A callback called when a shape starts being translated.\n\t *\n\t * @param shape - The shape.\n\t * @returns A change to apply to the shape, or void.\n\t * @public\n\t */\n\tonTranslateStart?: TLOnTranslateStartHandler<Shape>\n\n\t/**\n\t * A callback called when a shape changes from a translation.\n\t *\n\t * @param initial - The shape at the start of the translation.\n\t * @param current - The current shape.\n\t * @returns A change to apply to the shape, or void.\n\t * @public\n\t */\n\tonTranslate?: TLOnTranslateHandler<Shape>\n\n\t/**\n\t * A callback called when a shape finishes translating.\n\t *\n\t * @param initial - The shape at the start of the translation.\n\t * @param current - The current shape.\n\t * @returns A change to apply to the shape, or void.\n\t * @public\n\t */\n\tonTranslateEnd?: TLOnTranslateEndHandler<Shape>\n\n\t/**\n\t * A callback called when a shape starts being rotated.\n\t *\n\t * @param shape - The shape.\n\t * @returns A change to apply to the shape, or void.\n\t * @public\n\t */\n\tonRotateStart?: TLOnRotateStartHandler<Shape>\n\n\t/**\n\t * A callback called when a shape changes from a rotation.\n\t *\n\t * @param initial - The shape at the start of the rotation.\n\t * @param current - The current shape.\n\t * @returns A change to apply to the shape, or void.\n\t * @public\n\t */\n\tonRotate?: TLOnRotateHandler<Shape>\n\n\t/**\n\t * A callback called when a shape finishes rotating.\n\t *\n\t * @param initial - The shape at the start of the rotation.\n\t * @param current - The current shape.\n\t * @returns A change to apply to the shape, or void.\n\t * @public\n\t */\n\tonRotateEnd?: TLOnRotateEndHandler<Shape>\n\n\t/**\n\t * A callback called when a shape's handle changes.\n\t *\n\t * @param shape - The shape.\n\t * @param info - An object containing the handle and whether the handle is 'precise' or not.\n\t * @returns A change to apply to the shape, or void.\n\t * @public\n\t */\n\tonHandleChange?: TLOnHandleChangeHandler<Shape>\n\n\t/**\n\t * Not currently used.\n\t *\n\t * @internal\n\t */\n\tonBindingChange?: TLOnBindingChangeHandler<Shape>\n\n\t/**\n\t * A callback called when a shape's children change.\n\t *\n\t * @param shape - The shape.\n\t * @returns An array of shape updates, or void.\n\t * @public\n\t */\n\tonChildrenChange?: TLOnChildrenChangeHandler<Shape>\n\n\t/**\n\t * A callback called when a shape's handle is double clicked.\n\t *\n\t * @param shape - The shape.\n\t * @param handle - The handle that is double-clicked.\n\t * @returns A change to apply to the shape, or void.\n\t * @public\n\t */\n\tonDoubleClickHandle?: TLOnDoubleClickHandleHandler<Shape>\n\n\t/**\n\t * A callback called when a shape's edge is double clicked.\n\t *\n\t * @param shape - The shape.\n\t * @returns A change to apply to the shape, or void.\n\t * @public\n\t */\n\tonDoubleClickEdge?: TLOnDoubleClickHandler<Shape>\n\n\t/**\n\t * A callback called when a shape is double clicked.\n\t *\n\t * @param shape - The shape.\n\t * @returns A change to apply to the shape, or void.\n\t * @public\n\t */\n\tonDoubleClick?: TLOnDoubleClickHandler<Shape>\n\n\t/**\n\t * A callback called when a shape is clicked.\n\t *\n\t * @param shape - The shape.\n\t * @returns A change to apply to the shape, or void.\n\t * @public\n\t */\n\tonClick?: TLOnClickHandler<Shape>\n\n\t/**\n\t * A callback called when a shape finishes being editing.\n\t *\n\t * @param shape - The shape.\n\t * @public\n\t */\n\tonEditEnd?: TLOnEditEndHandler<Shape>\n}\n\n/** @public */\nexport type TLOnBeforeCreateHandler<T extends TLShape> = (next: T) => T | void\n/** @public */\nexport type TLOnBeforeUpdateHandler<T extends TLShape> = (prev: T, next: T) => T | void\n/** @public */\nexport type TLOnTranslateStartHandler<T extends TLShape> = TLEventStartHandler<T>\n/** @public */\nexport type TLOnTranslateHandler<T extends TLShape> = TLEventChangeHandler<T>\n/** @public */\nexport type TLOnTranslateEndHandler<T extends TLShape> = TLEventChangeHandler<T>\n/** @public */\nexport type TLOnRotateStartHandler<T extends TLShape> = TLEventStartHandler<T>\n/** @public */\nexport type TLOnRotateHandler<T extends TLShape> = TLEventChangeHandler<T>\n/** @public */\nexport type TLOnRotateEndHandler<T extends TLShape> = TLEventChangeHandler<T>\n\n/**\n * The type of resize.\n *\n * 'scale_shape' - The shape is being scaled, usually as part of a larger selection.\n *\n * 'resize_bounds' - The user is directly manipulating an individual shape's bounds using a resize\n * handle. It is up to shape util implementers to decide how they want to handle the two\n * situations.\n *\n * @public\n */\nexport type TLResizeMode = 'scale_shape' | 'resize_bounds'\n\n/**\n * Info about a resize.\n * @param newPoint - The new local position of the shape.\n * @param handle - The handle being dragged.\n * @param mode - The type of resize.\n * @param scaleX - The scale in the x-axis.\n * @param scaleY - The scale in the y-axis.\n * @param initialBounds - The bounds of the shape at the start of the resize.\n * @param initialShape - The shape at the start of the resize.\n * @public\n */\nexport type TLResizeInfo<T extends TLShape> = {\n\tnewPoint: Vec2d\n\thandle: TLResizeHandle\n\tmode: TLResizeMode\n\tscaleX: number\n\tscaleY: number\n\tinitialBounds: Box2d\n\tinitialShape: T\n}\n\n/** @public */\nexport type TLOnResizeHandler<T extends TLShape> = (\n\tshape: T,\n\tinfo: TLResizeInfo<T>\n) => Partial<TLShapePartial<T>> | undefined | void\n\n/** @public */\nexport type TLOnResizeStartHandler<T extends TLShape> = TLEventStartHandler<T>\n\n/** @public */\nexport type TLOnResizeEndHandler<T extends TLShape> = TLEventChangeHandler<T>\n\n/* -------------------- Dragging -------------------- */\n\n/** @public */\nexport type TLOnDragHandler<T extends TLShape, R = void> = (shape: T, shapes: TLShape[]) => R\n\n/** @internal */\nexport type TLOnBindingChangeHandler<T extends TLShape> = (shape: T) => TLShapePartial<T> | void\n\n/** @public */\nexport type TLOnChildrenChangeHandler<T extends TLShape> = (shape: T) => TLShapePartial[] | void\n\n/** @public */\nexport type TLOnHandleChangeHandler<T extends TLShape> = (\n\tshape: T,\n\tinfo: {\n\t\thandle: TLHandle\n\t\tisPrecise: boolean\n\t}\n) => TLShapePartial<T> | void\n\n/** @public */\nexport type TLOnClickHandler<T extends TLShape> = (shape: T) => TLShapePartial<T> | void\n/** @public */\nexport type TLOnEditEndHandler<T extends TLShape> = (shape: T) => void\n/** @public */\nexport type TLOnDoubleClickHandler<T extends TLShape> = (shape: T) => TLShapePartial<T> | void\n/** @public */\nexport type TLOnDoubleClickHandleHandler<T extends TLShape> = (\n\tshape: T,\n\thandle: TLHandle\n) => TLShapePartial<T> | void\n\ntype TLEventStartHandler<T extends TLShape> = (shape: T) => TLShapePartial<T> | void\ntype TLEventChangeHandler<T extends TLShape> = (initial: T, current: T) => TLShapePartial<T> | void\n"],
  "mappings": "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",
  "names": []
}
