{"ast":null,"code":"import { assert } from \"@tldraw/utils\";\nimport { useCallback, useDebugValue, useLayoutEffect, useRef } from \"react\";\nfunction useEvent(handler) {\n  var handlerRef = useRef();\n  useLayoutEffect(function () {\n    handlerRef.current = handler;\n  });\n  useDebugValue(handler);\n  return useCallback(function () {\n    var fn = handlerRef.current;\n    assert(fn, \"fn does not exist\");\n    return fn.apply(void 0, arguments);\n  }, []);\n}\nexport { useEvent };","map":{"version":3,"names":["assert","useCallback","useDebugValue","useLayoutEffect","useRef","useEvent","handler","handlerRef","current","fn","apply","arguments"],"sources":["/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@tldraw/editor/src/lib/hooks/useEvent.tsx"],"sourcesContent":["import { assert } from '@tldraw/utils'\nimport { useCallback, useDebugValue, useLayoutEffect, useRef } from 'react'\n\n/**\n * Allows you to define event handlers that can read the latest props/state but has a stable\n * function identity.\n *\n * These event callbacks may not be called in React render functions! An error won't be thrown, but\n * in the real implementation it would be!\n *\n * Uses a modified version of the user-land implementation included in the [`useEvent()` RFC][1].\n * Our version until such a hook is available natively.\n *\n * The RFC was closed on 27 September 2022, the React team plans to come up with a new RFC to\n * provide similar functionality in the future. We will migrate to this functionality when\n * available.\n *\n * IMPORTANT CAVEAT: You should not call event callbacks in layout effects of React component\n * children! Internally this hook uses a layout effect and parent component layout effects run after\n * child component layout effects. Use this hook responsibly.\n *\n * [1]: https://github.com/reactjs/rfcs/pull/220\n *\n * @internal\n */\nexport function useEvent<Args extends Array<unknown>, Result>(\n\thandler: (...args: Args) => Result\n): (...args: Args) => Result {\n\tconst handlerRef = useRef<(...args: Args) => Result>()\n\n\t// In a real implementation, this would run before layout effects\n\tuseLayoutEffect(() => {\n\t\thandlerRef.current = handler\n\t})\n\n\tuseDebugValue(handler)\n\n\treturn useCallback((...args: Args) => {\n\t\t// In a real implementation, this would throw if called during render\n\t\tconst fn = handlerRef.current\n\t\tassert(fn, 'fn does not exist')\n\t\treturn fn(...args)\n\t}, [])\n}\n"],"mappings":"AAAA,SAASA,MAAA,QAAc;AACvB,SAASC,WAAA,EAAaC,aAAA,EAAeC,eAAA,EAAiBC,MAAA,QAAc;AAwB7D,SAASC,SACfC,OAAA,EAC4B;EAC5B,IAAMC,UAAA,GAAaH,MAAA,CAAkC;EAGrDD,eAAA,CAAgB,YAAM;IACrBI,UAAA,CAAWC,OAAA,GAAUF,OAAA;EACtB,CAAC;EAEDJ,aAAA,CAAcI,OAAO;EAErB,OAAOL,WAAA,CAAY,YAAmB;IAErC,IAAMQ,EAAA,GAAKF,UAAA,CAAWC,OAAA;IACtBR,MAAA,CAAOS,EAAA,EAAI,mBAAmB;IAC9B,OAAOA,EAAA,CAAAC,KAAA,SAAAC,SAAU;EAClB,GAAG,EAAE;AACN"},"metadata":{},"sourceType":"module","externalDependencies":[]}