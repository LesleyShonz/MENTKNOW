import { Vec2d } from "@tldraw/primitives";
import { useEffect, useState } from "react";
import { debugFlags } from "./debug-flags.mjs";
function loopToHtmlElement(elm) {
  if (elm instanceof HTMLElement)
    return elm;
  if (elm.parentElement)
    return loopToHtmlElement(elm.parentElement);
  else
    throw Error("Could not find a parent element of an HTML type!");
}
function preventDefault(event) {
  event.preventDefault();
  if (debugFlags.preventDefaultLogging.value) {
    console.warn("preventDefault called on event:", event);
  }
}
function setPointerCapture(element, event) {
  element.setPointerCapture(event.pointerId);
  if (debugFlags.pointerCaptureTracking.value) {
    const trackingObj = debugFlags.pointerCaptureTrackingObject.value;
    trackingObj.set(element, (trackingObj.get(element) ?? 0) + 1);
  }
  if (debugFlags.pointerCaptureLogging.value) {
    console.warn("setPointerCapture called on element:", element, event);
  }
}
function releasePointerCapture(element, event) {
  if (!element.hasPointerCapture(event.pointerId)) {
    return;
  }
  element.releasePointerCapture(event.pointerId);
  if (debugFlags.pointerCaptureTracking.value) {
    const trackingObj = debugFlags.pointerCaptureTrackingObject.value;
    if (trackingObj.get(element) === 1) {
      trackingObj.delete(element);
    } else if (trackingObj.has(element)) {
      trackingObj.set(element, trackingObj.get(element) - 1);
    } else {
      console.warn("Release without capture");
    }
  }
  if (debugFlags.pointerCaptureLogging.value) {
    console.warn("releasePointerCapture called on element:", element, event);
  }
}
const ROTATING_BOX_SHADOWS = [
  {
    offsetX: 0,
    offsetY: 2,
    blur: 4,
    spread: 0,
    color: "#00000029"
  },
  {
    offsetX: 0,
    offsetY: 3,
    blur: 6,
    spread: 0,
    color: "#0000001f"
  }
];
function getRotatedBoxShadow(rotation) {
  const cssStrings = ROTATING_BOX_SHADOWS.map((shadow) => {
    const { offsetX, offsetY, blur, spread, color } = shadow;
    const vec = new Vec2d(offsetX, offsetY);
    const { x, y } = vec.rot(-rotation);
    return `${x}px ${y}px ${blur}px ${spread}px ${color}`;
  });
  return cssStrings.join(", ");
}
function usePrefersReducedMotion() {
  const [prefersReducedMotion, setPrefersReducedMotion] = useState(false);
  useEffect(() => {
    const mql = window.matchMedia("(prefers-reduced-motion: reduce)");
    const handler = () => {
      setPrefersReducedMotion(mql.matches);
    };
    handler();
    mql.addEventListener("change", handler);
    return () => mql.removeEventListener("change", handler);
  }, []);
  return prefersReducedMotion;
}
const truncateStringWithEllipsis = (str, maxLength) => {
  return str.length <= maxLength ? str : str.substring(0, maxLength - 3) + "...";
};
const stopEventPropagation = (e) => e.stopPropagation();
export {
  ROTATING_BOX_SHADOWS,
  getRotatedBoxShadow,
  loopToHtmlElement,
  preventDefault,
  releasePointerCapture,
  setPointerCapture,
  stopEventPropagation,
  truncateStringWithEllipsis,
  usePrefersReducedMotion
};
//# sourceMappingURL=dom.mjs.map
