"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var PointingShape_exports = {};
__export(PointingShape_exports, {
  PointingShape: () => PointingShape
});
module.exports = __toCommonJS(PointingShape_exports);
var import_GroupShapeUtil = require("../../../shapes/group/GroupShapeUtil");
var import_StateNode = require("../../StateNode");
class PointingShape extends import_StateNode.StateNode {
  static id = "pointing_shape";
  eventTargetShape = {};
  selectingShape = {};
  didSelectOnEnter = false;
  onEnter = (info) => {
    this.eventTargetShape = info.shape;
    this.selectingShape = this.editor.getOutermostSelectableShape(info.shape);
    const util = this.editor.getShapeUtil(info.shape);
    if (util.onClick || this.selectingShape.id === this.editor.focusLayerId) {
      this.didSelectOnEnter = false;
      return;
    }
    const isSelected = this.editor.isWithinSelection(this.selectingShape.id);
    const isBehindSelectionBounds = this.editor.selectedIds.length > 1 && // only on 2+ selected shapes!
    this.editor.selectionBounds?.containsPoint(this.editor.inputs.currentPagePoint);
    this.didSelectOnEnter = !isSelected && this.selectingShape.id !== this.editor.focusLayerId && !isBehindSelectionBounds;
    if (this.didSelectOnEnter) {
      const { inputs, selectedIds } = this.editor;
      const parent = this.editor.getParentShape(info.shape);
      if (parent && this.editor.isShapeOfType(parent, import_GroupShapeUtil.GroupShapeUtil)) {
        this.editor.cancelDoubleClick();
      }
      if (inputs.shiftKey && !inputs.altKey) {
        if (!selectedIds.includes(this.selectingShape.id)) {
          this.editor.mark("shift selecting shape");
          this.editor.setSelectedIds([...selectedIds, this.selectingShape.id]);
        }
      } else {
        this.editor.mark("selecting shape");
        this.editor.setSelectedIds([this.selectingShape.id]);
      }
    }
  };
  onPointerUp = (info) => {
    const { shape } = info;
    if (shape) {
      const util = this.editor.getShapeUtil(shape);
      if (util.onClick) {
        const change = util.onClick?.(shape);
        if (change) {
          this.editor.updateShapes([change]);
          this.parent.transition("idle", info);
          return;
        }
      }
    }
    if (!this.didSelectOnEnter && this.selectingShape.id !== this.editor.focusLayerId) {
      this.editor.mark("selecting shape (pointer up)");
      const targetShape = this.editor.getOutermostSelectableShape(
        this.eventTargetShape,
        // if a group is selected, we want to stop before reaching that group
        // so we can drill down into the group
        (parent) => !this.editor.isSelected(parent.id)
      );
      if (this.editor.selectedIds.includes(targetShape.id)) {
        this.editor.setSelectedIds(
          this.editor.inputs.shiftKey ? this.editor.selectedIds.filter((id) => id !== this.selectingShape.id) : [this.selectingShape.id]
        );
      } else if (this.editor.inputs.shiftKey) {
        const ancestors = this.editor.getAncestors(targetShape);
        this.editor.setSelectedIds([
          ...this.editor.selectedIds.filter((id) => !ancestors.find((a) => a.id === id)),
          targetShape.id
        ]);
      } else {
        this.editor.setSelectedIds([targetShape.id]);
      }
    } else if (this.selectingShape.id === this.editor.focusLayerId) {
      if (this.editor.selectedIds.length > 0) {
        this.editor.setSelectedIds([]);
      } else {
        this.editor.popFocusLayer();
      }
    }
    this.parent.transition("idle", info);
  };
  onPointerMove = (info) => {
    if (this.editor.inputs.isDragging) {
      if (this.editor.isReadOnly)
        return;
      this.parent.transition("translating", info);
    }
  };
  onCancel = () => {
    this.cancel();
  };
  onComplete = () => {
    this.cancel();
  };
  onInterrupt = () => {
    this.cancel();
  };
  cancel() {
    this.parent.transition("idle", {});
  }
}
//# sourceMappingURL=PointingShape.js.map
