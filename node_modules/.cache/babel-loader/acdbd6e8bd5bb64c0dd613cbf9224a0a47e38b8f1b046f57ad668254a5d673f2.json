{"ast":null,"code":"import { useCallback, useEffect, useRef } from \"react\";\nimport { useValue } from \"signia-react\";\nimport { useEditor } from \"../../../hooks/useEditor.mjs\";\nimport { preventDefault, stopEventPropagation } from \"../../../utils/dom.mjs\";\nimport { INDENT, TextHelpers } from \"../text/TextHelpers.mjs\";\nfunction useEditableText(id, type, text) {\n  var editor = useEditor();\n  var rInput = useRef(null);\n  var isEditing = useValue(\"isEditing\", function () {\n    return editor.pageState.editingId === id;\n  }, [editor, id]);\n  var rSkipSelectOnFocus = useRef(false);\n  var rSelectionRanges = useRef();\n  var isEditableFromHover = useValue(\"is editable hovering\", function () {\n    if (type === \"text\" && editor.isIn(\"text\") && editor.hoveredId === id) {\n      return true;\n    }\n    if (editor.isIn(\"select.editing_shape\")) {\n      var editingShape = editor.editingShape;\n      if (!editingShape) return false;\n      return (\n        // The shape must be hovered\n        // and this shape must be capable of being editing in its current form\n        editor.hoveredId === id &&\n        // the editing shape must be the same type as this shape\n        editingShape.type === type && editor.getShapeUtil(editingShape).canEdit(editingShape)\n      );\n    }\n    return false;\n  }, [type, id]);\n  var handleFocus = useCallback(function () {\n    if (isEditableFromHover) return;\n    requestAnimationFrame(function () {\n      var elm = rInput.current;\n      if (!elm) return;\n      var shape = editor.getShapeById(id);\n      if (shape) {\n        elm.value = shape.props.text;\n        if (elm.value.length && !rSkipSelectOnFocus.current) {\n          elm.select();\n        }\n        rSkipSelectOnFocus.current = false;\n      }\n    });\n  }, [editor, id, isEditableFromHover]);\n  var handleBlur = useCallback(function () {\n    var ranges = rSelectionRanges.current;\n    requestAnimationFrame(function () {\n      var elm = rInput.current;\n      if (editor.isIn(\"select.editing_shape\") && elm) {\n        if (ranges) {\n          if (!ranges.length) {\n            elm.focus();\n          } else {\n            rSkipSelectOnFocus.current = true;\n            elm.focus();\n            var selection = window.getSelection();\n            if (selection) {\n              ranges.forEach(function (range) {\n                return selection.addRange(range);\n              });\n            }\n          }\n        } else {\n          elm.focus();\n        }\n      } else {\n        var _window$getSelection;\n        (_window$getSelection = window.getSelection()) === null || _window$getSelection === void 0 || _window$getSelection.removeAllRanges();\n        editor.complete();\n      }\n    });\n  }, [editor]);\n  var handleKeyDown = useCallback(function (e) {\n    if (e.ctrlKey || e.metaKey) stopEventPropagation(e);\n    switch (e.key) {\n      case \"Enter\":\n        {\n          if (e.ctrlKey || e.metaKey) {\n            editor.complete();\n          }\n          break;\n        }\n      case \"Tab\":\n        {\n          preventDefault(e);\n          if (e.shiftKey) {\n            TextHelpers.unindent(e.currentTarget);\n          } else {\n            TextHelpers.indent(e.currentTarget);\n          }\n          break;\n        }\n    }\n  }, [editor]);\n  var handleChange = useCallback(function (e) {\n    var text2 = TextHelpers.normalizeText(e.currentTarget.value);\n    var untabbedText = text2.replace(/\\t/g, INDENT);\n    if (untabbedText !== text2) {\n      var selectionStart = e.currentTarget.selectionStart;\n      e.currentTarget.value = untabbedText;\n      e.currentTarget.selectionStart = selectionStart + (untabbedText.length - text2.length);\n      e.currentTarget.selectionEnd = selectionStart + (untabbedText.length - text2.length);\n      text2 = untabbedText;\n    }\n    editor.updateShapes([{\n      id: id,\n      type: type,\n      props: {\n        text: text2\n      }\n    }]);\n  }, [editor, id, type]);\n  var isEmpty = text.trim().length === 0;\n  useEffect(function () {\n    var elm = rInput.current;\n    if (elm) {\n      var updateSelection2 = function updateSelection2() {\n        var _window$getSelection2, _window;\n        var selection = (_window$getSelection2 = (_window = window).getSelection) === null || _window$getSelection2 === void 0 ? void 0 : _window$getSelection2.call(_window);\n        if (selection && selection.type !== \"None\") {\n          var ranges = [];\n          if (selection) {\n            for (var i = 0; i < selection.rangeCount; i++) {\n              var _selection$getRangeAt;\n              ranges.push((_selection$getRangeAt = selection.getRangeAt) === null || _selection$getRangeAt === void 0 ? void 0 : _selection$getRangeAt.call(selection, i));\n            }\n          }\n          rSelectionRanges.current = ranges;\n        }\n      };\n      var updateSelection = updateSelection2;\n      document.addEventListener(\"selectionchange\", updateSelection2);\n      return function () {\n        document.removeEventListener(\"selectionchange\", updateSelection2);\n      };\n    }\n  });\n  return {\n    rInput: rInput,\n    isEditing: isEditing,\n    isEditableFromHover: isEditableFromHover,\n    handleFocus: handleFocus,\n    handleBlur: handleBlur,\n    handleKeyDown: handleKeyDown,\n    handleChange: handleChange,\n    isEmpty: isEmpty\n  };\n}\nexport { useEditableText };","map":{"version":3,"names":["useCallback","useEffect","useRef","useValue","useEditor","preventDefault","stopEventPropagation","INDENT","TextHelpers","useEditableText","id","type","text","editor","rInput","isEditing","pageState","editingId","rSkipSelectOnFocus","rSelectionRanges","isEditableFromHover","isIn","hoveredId","editingShape","getShapeUtil","canEdit","handleFocus","requestAnimationFrame","elm","current","shape","getShapeById","value","props","length","select","handleBlur","ranges","focus","selection","window","getSelection","forEach","range","addRange","_window$getSelection","removeAllRanges","complete","handleKeyDown","e","ctrlKey","metaKey","key","shiftKey","unindent","currentTarget","indent","handleChange","text2","normalizeText","untabbedText","replace","selectionStart","selectionEnd","updateShapes","isEmpty","trim","updateSelection2","_window$getSelection2","_window","call","i","rangeCount","_selection$getRangeAt","push","getRangeAt","updateSelection","document","addEventListener","removeEventListener"],"sources":["/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@tldraw/editor/src/lib/editor/shapes/shared/useEditableText.ts"],"sourcesContent":["/* eslint-disable no-inner-declarations */\nimport { TLShape, TLUnknownShape } from '@tldraw/tlschema'\nimport React, { useCallback, useEffect, useRef } from 'react'\nimport { useValue } from 'signia-react'\nimport { useEditor } from '../../../hooks/useEditor'\nimport { preventDefault, stopEventPropagation } from '../../../utils/dom'\nimport { INDENT, TextHelpers } from '../text/TextHelpers'\n\nexport function useEditableText<T extends Extract<TLShape, { props: { text: string } }>>(\n\tid: T['id'],\n\ttype: T['type'],\n\ttext: string\n) {\n\tconst editor = useEditor()\n\n\tconst rInput = useRef<HTMLTextAreaElement>(null)\n\n\tconst isEditing = useValue('isEditing', () => editor.pageState.editingId === id, [editor, id])\n\n\tconst rSkipSelectOnFocus = useRef(false)\n\tconst rSelectionRanges = useRef<Range[] | null>()\n\n\tconst isEditableFromHover = useValue(\n\t\t'is editable hovering',\n\t\t() => {\n\t\t\tif (type === 'text' && editor.isIn('text') && editor.hoveredId === id) {\n\t\t\t\treturn true\n\t\t\t}\n\n\t\t\tif (editor.isIn('select.editing_shape')) {\n\t\t\t\tconst { editingShape } = editor\n\t\t\t\tif (!editingShape) return false\n\t\t\t\treturn (\n\t\t\t\t\t// The shape must be hovered\n\t\t\t\t\teditor.hoveredId === id &&\n\t\t\t\t\t// the editing shape must be the same type as this shape\n\t\t\t\t\teditingShape.type === type &&\n\t\t\t\t\t// and this shape must be capable of being editing in its current form\n\t\t\t\t\teditor.getShapeUtil(editingShape).canEdit(editingShape)\n\t\t\t\t)\n\t\t\t}\n\n\t\t\treturn false\n\t\t},\n\t\t[type, id]\n\t)\n\n\t// When the label receives focus, set the value to the most\n\t// recent text value and select all of the text\n\tconst handleFocus = useCallback(() => {\n\t\tif (isEditableFromHover) return\n\n\t\trequestAnimationFrame(() => {\n\t\t\tconst elm = rInput.current\n\n\t\t\tif (!elm) return\n\n\t\t\tconst shape = editor.getShapeById<TLShape & { props: { text: string } }>(id)\n\t\t\tif (shape) {\n\t\t\t\telm.value = shape.props.text\n\t\t\t\tif (elm.value.length && !rSkipSelectOnFocus.current) {\n\t\t\t\t\telm.select()\n\t\t\t\t}\n\n\t\t\t\trSkipSelectOnFocus.current = false\n\t\t\t}\n\t\t})\n\t}, [editor, id, isEditableFromHover])\n\n\t// When the label blurs, deselect all of the text and complete.\n\t// This makes it so that the canvas does not have to be focused\n\t// in order to exit the editing state and complete the editing state\n\tconst handleBlur = useCallback(() => {\n\t\tconst ranges = rSelectionRanges.current\n\n\t\trequestAnimationFrame(() => {\n\t\t\tconst elm = rInput.current\n\t\t\tif (editor.isIn('select.editing_shape') && elm) {\n\t\t\t\tif (ranges) {\n\t\t\t\t\tif (!ranges.length) {\n\t\t\t\t\t\t// If we don't have any ranges, restore selection\n\t\t\t\t\t\t// and select all of the text\n\t\t\t\t\t\telm.focus()\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Otherwise, skip the select-all-on-focus behavior\n\t\t\t\t\t\t// and restore the selection\n\t\t\t\t\t\trSkipSelectOnFocus.current = true\n\t\t\t\t\t\telm.focus()\n\t\t\t\t\t\tconst selection = window.getSelection()\n\t\t\t\t\t\tif (selection) {\n\t\t\t\t\t\t\tranges.forEach((range) => selection.addRange(range))\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\telm.focus()\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\twindow.getSelection()?.removeAllRanges()\n\t\t\t\teditor.complete()\n\t\t\t}\n\t\t})\n\t}, [editor])\n\n\t// When the user presses ctrl / meta enter, complete the editing state.\n\t// When the user presses tab, indent or unindent the text.\n\tconst handleKeyDown = useCallback(\n\t\t(e: React.KeyboardEvent<HTMLTextAreaElement>) => {\n\t\t\tif (e.ctrlKey || e.metaKey) stopEventPropagation(e)\n\n\t\t\tswitch (e.key) {\n\t\t\t\tcase 'Enter': {\n\t\t\t\t\tif (e.ctrlKey || e.metaKey) {\n\t\t\t\t\t\teditor.complete()\n\t\t\t\t\t}\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tcase 'Tab': {\n\t\t\t\t\tpreventDefault(e)\n\t\t\t\t\tif (e.shiftKey) {\n\t\t\t\t\t\tTextHelpers.unindent(e.currentTarget)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tTextHelpers.indent(e.currentTarget)\n\t\t\t\t\t}\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t[editor]\n\t)\n\n\t// When the text changes, update the text value.\n\tconst handleChange = useCallback(\n\t\t(e: React.ChangeEvent<HTMLTextAreaElement>) => {\n\t\t\tlet text = TextHelpers.normalizeText(e.currentTarget.value)\n\n\t\t\t// ------- Bug fix ------------\n\t\t\t// Replace tabs with spaces when pasting\n\t\t\tconst untabbedText = text.replace(/\\t/g, INDENT)\n\t\t\tif (untabbedText !== text) {\n\t\t\t\tconst selectionStart = e.currentTarget.selectionStart\n\t\t\t\te.currentTarget.value = untabbedText\n\t\t\t\te.currentTarget.selectionStart = selectionStart + (untabbedText.length - text.length)\n\t\t\t\te.currentTarget.selectionEnd = selectionStart + (untabbedText.length - text.length)\n\t\t\t\ttext = untabbedText\n\t\t\t}\n\t\t\t// ----------------------------\n\n\t\t\teditor.updateShapes<TLUnknownShape & { props: { text: string } }>([\n\t\t\t\t{ id, type, props: { text } },\n\t\t\t])\n\t\t},\n\t\t[editor, id, type]\n\t)\n\n\tconst isEmpty = text.trim().length === 0\n\n\tuseEffect(() => {\n\t\tconst elm = rInput.current\n\t\tif (elm) {\n\t\t\tfunction updateSelection() {\n\t\t\t\tconst selection = window.getSelection?.()\n\t\t\t\tif (selection && selection.type !== 'None') {\n\t\t\t\t\tconst ranges: Range[] = []\n\n\t\t\t\t\tif (selection) {\n\t\t\t\t\t\tfor (let i = 0; i < selection.rangeCount; i++) {\n\t\t\t\t\t\t\tranges.push(selection.getRangeAt?.(i))\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\trSelectionRanges.current = ranges\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdocument.addEventListener('selectionchange', updateSelection)\n\n\t\t\treturn () => {\n\t\t\t\tdocument.removeEventListener('selectionchange', updateSelection)\n\t\t\t}\n\t\t}\n\t})\n\n\treturn {\n\t\trInput,\n\t\tisEditing,\n\t\tisEditableFromHover,\n\t\thandleFocus,\n\t\thandleBlur,\n\t\thandleKeyDown,\n\t\thandleChange,\n\t\tisEmpty,\n\t}\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}