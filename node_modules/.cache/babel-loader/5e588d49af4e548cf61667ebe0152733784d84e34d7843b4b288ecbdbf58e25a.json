{"ast":null,"code":"import _objectSpread from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _regeneratorRuntime from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _slicedToArray from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _createForOfIteratorHelper from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _defineProperty from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __decorateClass = function __decorateClass(decorators, target, key, kind) {\n  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;\n  for (var i = decorators.length - 1, decorator; i >= 0; i--) if (decorator = decorators[i]) result = (kind ? decorator(target, key, result) : decorator(result)) || result;\n  if (kind && result) __defProp(target, key, result);\n  return result;\n};\nimport { Box2d, linesIntersect } from \"@tldraw/primitives\";\nimport { computed, EMPTY_ARRAY } from \"signia\";\nvar ShapeUtil = /*#__PURE__*/function () {\n  function ShapeUtil(editor, type, styleProps) {\n    var _this = this;\n    _classCallCheck(this, ShapeUtil);\n    /**\n     * Whether the shape can be snapped to by another shape.\n     *\n     * @public\n     */\n    _defineProperty(this, \"canSnap\", function () {\n      return true;\n    });\n    /**\n     * Whether the shape can be scrolled while editing.\n     *\n     * @public\n     */\n    _defineProperty(this, \"canScroll\", function () {\n      return false;\n    });\n    /**\n     * Whether the shape should unmount when not visible in the editor. Consider keeping this to false if the shape's `component` has local state.\n     *\n     * @public\n     */\n    _defineProperty(this, \"canUnmount\", function () {\n      return true;\n    });\n    /**\n     * Whether the shape can be bound to by an arrow.\n     *\n     * @param _otherShape - The other shape attempting to bind to this shape.\n     * @public\n     */\n    _defineProperty(this, \"canBind\", function (_shape, _otherShape) {\n      return true;\n    });\n    /**\n     * Whether the shape can be double clicked to edit.\n     *\n     * @public\n     */\n    _defineProperty(this, \"canEdit\", function () {\n      return false;\n    });\n    /**\n     * Whether the shape can be resized.\n     *\n     * @public\n     */\n    _defineProperty(this, \"canResize\", function () {\n      return true;\n    });\n    /**\n     * Whether the shape can be cropped.\n     *\n     * @public\n     */\n    _defineProperty(this, \"canCrop\", function () {\n      return false;\n    });\n    /**\n     * Bounds of the shape to edit.\n     *\n     * Note: this could be a text area within a shape for example arrow labels.\n     *\n     * @public\n     */\n    _defineProperty(this, \"getEditingBounds\", function (shape) {\n      return _this.bounds(shape);\n    });\n    /**\n     * Whether the shape's outline is closed.\n     *\n     * @public\n     */\n    _defineProperty(this, \"isClosed\", function () {\n      return true;\n    });\n    /**\n     * Whether the shape should hide its resize handles when selected.\n     *\n     * @public\n     */\n    _defineProperty(this, \"hideResizeHandles\", function () {\n      return false;\n    });\n    /**\n     * Whether the shape should hide its resize handles when selected.\n     *\n     * @public\n     */\n    _defineProperty(this, \"hideRotateHandle\", function () {\n      return false;\n    });\n    /**\n     * Whether the shape should hide its selection bounds background when selected.\n     *\n     * @public\n     */\n    _defineProperty(this, \"hideSelectionBoundsBg\", function () {\n      return false;\n    });\n    /**\n     * Whether the shape should hide its selection bounds foreground when selected.\n     *\n     * @public\n     */\n    _defineProperty(this, \"hideSelectionBoundsFg\", function () {\n      return false;\n    });\n    /**\n     * Whether the shape's aspect ratio is locked.\n     *\n     * @public\n     */\n    _defineProperty(this, \"isAspectRatioLocked\", function () {\n      return false;\n    });\n    //  Events\n    /**\n     * A callback called just before a shape is created. This method provides a last chance to modify\n     * the created shape.\n     *\n     * @example\n     *\n     * ```ts\n     * onBeforeCreate = (next) => {\n     * \treturn { ...next, x: next.x + 1 }\n     * }\n     * ```\n     *\n     * @param next - The next shape.\n     * @returns The next shape or void.\n     * @public\n     */\n    _defineProperty(this, \"onBeforeCreate\", void 0);\n    /**\n     * A callback called just before a shape is updated. This method provides a last chance to modify\n     * the updated shape.\n     *\n     * @example\n     *\n     * ```ts\n     * onBeforeUpdate = (prev, next) => {\n     * \tif (prev.x === next.x) {\n     * \t\treturn { ...next, x: next.x + 1 }\n     * \t}\n     * }\n     * ```\n     *\n     * @param prev - The previous shape.\n     * @param next - The next shape.\n     * @returns The next shape or void.\n     * @public\n     */\n    _defineProperty(this, \"onBeforeUpdate\", void 0);\n    /**\n     * A callback called when some other shapes are dragged over this one.\n     *\n     * @example\n     *\n     * ```ts\n     * onDragShapesOver = (shape, shapes) => {\n     * \treturn { shouldHint: true }\n     * }\n     * ```\n     *\n     * @param shape - The shape.\n     * @param shapes - The shapes that are being dragged over this one.\n     * @returns An object specifying whether the shape should hint that it can receive the dragged shapes.\n     * @public\n     */\n    _defineProperty(this, \"onDragShapesOver\", void 0);\n    /**\n     * A callback called when some other shapes are dragged out of this one.\n     *\n     * @param shape - The shape.\n     * @param shapes - The shapes that are being dragged out.\n     * @public\n     */\n    _defineProperty(this, \"onDragShapesOut\", void 0);\n    /**\n     * A callback called when some other shapes are dropped over this one.\n     *\n     * @param shape - The shape.\n     * @param shapes - The shapes that are being dropped over this one.\n     * @public\n     */\n    _defineProperty(this, \"onDropShapesOver\", void 0);\n    /**\n     * A callback called when a shape starts being resized.\n     *\n     * @param shape - The shape.\n     * @returns A change to apply to the shape, or void.\n     * @public\n     */\n    _defineProperty(this, \"onResizeStart\", void 0);\n    /**\n     * A callback called when a shape changes from a resize.\n     *\n     * @param shape - The shape at the start of the resize.\n     * @param info - Info about the resize.\n     * @returns A change to apply to the shape, or void.\n     * @public\n     */\n    _defineProperty(this, \"onResize\", void 0);\n    /**\n     * A callback called when a shape finishes resizing.\n     *\n     * @param initial - The shape at the start of the resize.\n     * @param current - The current shape.\n     * @returns A change to apply to the shape, or void.\n     * @public\n     */\n    _defineProperty(this, \"onResizeEnd\", void 0);\n    /**\n     * A callback called when a shape starts being translated.\n     *\n     * @param shape - The shape.\n     * @returns A change to apply to the shape, or void.\n     * @public\n     */\n    _defineProperty(this, \"onTranslateStart\", void 0);\n    /**\n     * A callback called when a shape changes from a translation.\n     *\n     * @param initial - The shape at the start of the translation.\n     * @param current - The current shape.\n     * @returns A change to apply to the shape, or void.\n     * @public\n     */\n    _defineProperty(this, \"onTranslate\", void 0);\n    /**\n     * A callback called when a shape finishes translating.\n     *\n     * @param initial - The shape at the start of the translation.\n     * @param current - The current shape.\n     * @returns A change to apply to the shape, or void.\n     * @public\n     */\n    _defineProperty(this, \"onTranslateEnd\", void 0);\n    /**\n     * A callback called when a shape starts being rotated.\n     *\n     * @param shape - The shape.\n     * @returns A change to apply to the shape, or void.\n     * @public\n     */\n    _defineProperty(this, \"onRotateStart\", void 0);\n    /**\n     * A callback called when a shape changes from a rotation.\n     *\n     * @param initial - The shape at the start of the rotation.\n     * @param current - The current shape.\n     * @returns A change to apply to the shape, or void.\n     * @public\n     */\n    _defineProperty(this, \"onRotate\", void 0);\n    /**\n     * A callback called when a shape finishes rotating.\n     *\n     * @param initial - The shape at the start of the rotation.\n     * @param current - The current shape.\n     * @returns A change to apply to the shape, or void.\n     * @public\n     */\n    _defineProperty(this, \"onRotateEnd\", void 0);\n    /**\n     * A callback called when a shape's handle changes.\n     *\n     * @param shape - The shape.\n     * @param info - An object containing the handle and whether the handle is 'precise' or not.\n     * @returns A change to apply to the shape, or void.\n     * @public\n     */\n    _defineProperty(this, \"onHandleChange\", void 0);\n    /**\n     * Not currently used.\n     *\n     * @internal\n     */\n    _defineProperty(this, \"onBindingChange\", void 0);\n    /**\n     * A callback called when a shape's children change.\n     *\n     * @param shape - The shape.\n     * @returns An array of shape updates, or void.\n     * @public\n     */\n    _defineProperty(this, \"onChildrenChange\", void 0);\n    /**\n     * A callback called when a shape's handle is double clicked.\n     *\n     * @param shape - The shape.\n     * @param handle - The handle that is double-clicked.\n     * @returns A change to apply to the shape, or void.\n     * @public\n     */\n    _defineProperty(this, \"onDoubleClickHandle\", void 0);\n    /**\n     * A callback called when a shape's edge is double clicked.\n     *\n     * @param shape - The shape.\n     * @returns A change to apply to the shape, or void.\n     * @public\n     */\n    _defineProperty(this, \"onDoubleClickEdge\", void 0);\n    /**\n     * A callback called when a shape is double clicked.\n     *\n     * @param shape - The shape.\n     * @returns A change to apply to the shape, or void.\n     * @public\n     */\n    _defineProperty(this, \"onDoubleClick\", void 0);\n    /**\n     * A callback called when a shape is clicked.\n     *\n     * @param shape - The shape.\n     * @returns A change to apply to the shape, or void.\n     * @public\n     */\n    _defineProperty(this, \"onClick\", void 0);\n    /**\n     * A callback called when a shape finishes being editing.\n     *\n     * @param shape - The shape.\n     * @public\n     */\n    _defineProperty(this, \"onEditEnd\", void 0);\n    this.editor = editor;\n    this.type = type;\n    this.styleProps = styleProps;\n  }\n  _createClass(ShapeUtil, [{\n    key: \"hasStyle\",\n    value: function hasStyle(style) {\n      return this.styleProps.has(style);\n    }\n  }, {\n    key: \"getStyleIfExists\",\n    value: function getStyleIfExists(style, shape) {\n      var styleKey = this.styleProps.get(style);\n      if (!styleKey) return void 0;\n      return shape.props[styleKey];\n    }\n  }, {\n    key: \"iterateStyles\",\n    value: /*#__PURE__*/_regeneratorRuntime().mark(function iterateStyles(shape) {\n      var _iterator, _step, _step$value, style, styleKey, value;\n      return _regeneratorRuntime().wrap(function iterateStyles$(_context) {\n        while (1) switch (_context.prev = _context.next) {\n          case 0:\n            _iterator = _createForOfIteratorHelper(this.styleProps);\n            _context.prev = 1;\n            _iterator.s();\n          case 3:\n            if ((_step = _iterator.n()).done) {\n              _context.next = 10;\n              break;\n            }\n            _step$value = _slicedToArray(_step.value, 2), style = _step$value[0], styleKey = _step$value[1];\n            value = shape.props[styleKey];\n            _context.next = 8;\n            return [style, value];\n          case 8:\n            _context.next = 3;\n            break;\n          case 10:\n            _context.next = 15;\n            break;\n          case 12:\n            _context.prev = 12;\n            _context.t0 = _context[\"catch\"](1);\n            _iterator.e(_context.t0);\n          case 15:\n            _context.prev = 15;\n            _iterator.f();\n            return _context.finish(15);\n          case 18:\n          case \"end\":\n            return _context.stop();\n        }\n      }, iterateStyles, this, [[1, 12, 15, 18]]);\n    })\n  }, {\n    key: \"setStyleInPartial\",\n    value: function setStyleInPartial(style, shape, value) {\n      var styleKey = this.styleProps.get(style);\n      if (!styleKey) return shape;\n      return _objectSpread(_objectSpread({}, shape), {}, {\n        props: _objectSpread(_objectSpread({}, shape.props), {}, _defineProperty({}, styleKey, value))\n      });\n    }\n    /**\n     * The type of the shape util, which should match the shape's type.\n     *\n     * @public\n     */\n  }, {\n    key: \"handlesCache\",\n    get: function get() {\n      var _this2 = this;\n      return this.editor.store.createComputedCache(\"handles:\" + this.type, function (shape) {\n        return _this2.getHandles(shape);\n      });\n    }\n    /**\n     * Get the cached handles (this should not be overridden!)\n     *\n     * @param shape - The shape.\n     * @public\n     */\n  }, {\n    key: \"handles\",\n    value: function handles(shape) {\n      var _this$handlesCache$ge;\n      if (!this.getHandles) return EMPTY_ARRAY;\n      return (_this$handlesCache$ge = this.handlesCache.get(shape.id)) !== null && _this$handlesCache$ge !== void 0 ? _this$handlesCache$ge : EMPTY_ARRAY;\n    }\n    /**\n     * Get an array of outline segments for the shape. For most shapes,\n     * this will be a single segment that includes the entire outline.\n     * For shapes with handles, this might be segments of the outline\n     * between each handle.\n     *\n     * @example\n     *\n     * ```ts\n     * util.getOutlineSegments(myShape)\n     * ```\n     *\n     * @param shape - The shape.\n     * @public\n     */\n  }, {\n    key: \"getOutlineSegments\",\n    value: function getOutlineSegments(shape) {\n      return [this.outline(shape)];\n    }\n  }, {\n    key: \"outlineSegmentsCache\",\n    get: function get() {\n      var _this3 = this;\n      return this.editor.store.createComputedCache(\"outline-segments:\" + this.type, function (shape) {\n        return _this3.getOutlineSegments(shape);\n      });\n    }\n    /**\n     * Get the cached outline segments (this should not be overridden!)\n     *\n     * @param shape - The shape.\n     * @public\n     */\n  }, {\n    key: \"outlineSegments\",\n    value: function outlineSegments(shape) {\n      var _this$outlineSegments;\n      if (!this.getOutlineSegments) return EMPTY_ARRAY;\n      return (_this$outlineSegments = this.outlineSegmentsCache.get(shape.id)) !== null && _this$outlineSegments !== void 0 ? _this$outlineSegments : EMPTY_ARRAY;\n    }\n  }, {\n    key: \"boundsCache\",\n    get: function get() {\n      var _this4 = this;\n      return this.editor.store.createComputedCache(\"bounds:\" + this.type, function (shape) {\n        return _this4.getBounds(shape);\n      });\n    }\n    /**\n     * Get the cached bounds for the shape.\n     *\n     * @param shape - The shape.\n     * @public\n     */\n  }, {\n    key: \"bounds\",\n    value: function bounds(shape) {\n      var _this$boundsCache$get;\n      var result = (_this$boundsCache$get = this.boundsCache.get(shape.id)) !== null && _this$boundsCache$get !== void 0 ? _this$boundsCache$get : new Box2d();\n      if (result.width === 0 || result.height === 0) {\n        return new Box2d(result.x, result.y, Math.max(result.width, 1), Math.max(result.height, 1));\n      }\n      return result;\n    }\n  }, {\n    key: \"outlineCache\",\n    get: function get() {\n      var _this5 = this;\n      return this.editor.store.createComputedCache(\"outline:\" + this.type, function (shape) {\n        return _this5.getOutline(shape);\n      });\n    }\n    /**\n     * Get the shape's outline. Do not override this method!\n     *\n     * @param shape - The shape.\n     * @public\n     */\n  }, {\n    key: \"outline\",\n    value: function outline(shape) {\n      var _this$outlineCache$ge;\n      return (_this$outlineCache$ge = this.outlineCache.get(shape.id)) !== null && _this$outlineCache$ge !== void 0 ? _this$outlineCache$ge : EMPTY_ARRAY;\n    }\n    /**\n     * Get the shape's snap points.\n     *\n     * @param shape - The shape.\n     * @public\n     */\n  }, {\n    key: \"snapPoints\",\n    value: function snapPoints(shape) {\n      return this.bounds(shape).snapPoints;\n    }\n    /**\n     * Get the shape's cached center.\n     *\n     * @param shape - The shape.\n     * @public\n     */\n  }, {\n    key: \"center\",\n    value: function center(shape) {\n      return this.getCenter(shape);\n    }\n    /**\n     * Get whether the shape can receive children of a given type.\n     *\n     * @param type - The shape type.\n     * @public\n     */\n  }, {\n    key: \"canReceiveNewChildrenOfType\",\n    value: function canReceiveNewChildrenOfType(shape, type) {\n      return false;\n    }\n    /**\n     * Get whether the shape can receive children of a given type.\n     *\n     * @param shape - The shape type.\n     * @param shapes - The shapes that are being dropped.\n     * @public\n     */\n  }, {\n    key: \"canDropShapes\",\n    value: function canDropShapes(shape, shapes) {\n      return false;\n    }\n    /**\n     * Get whether a point intersects the shape.\n     *\n     * @param shape - The shape.\n     * @param point - The point to test.\n     * @returns Whether the point intersects the shape.\n     * @public\n     */\n  }, {\n    key: \"hitTestPoint\",\n    value: function hitTestPoint(shape, point) {\n      return this.bounds(shape).containsPoint(point);\n    }\n    /**\n     * Get whether a point intersects the shape.\n     *\n     * @param shape - The shape.\n     * @param A - The line segment's first point.\n     * @param B - The line segment's second point.\n     * @returns Whether the line segment intersects the shape.\n     * @public\n     */\n  }, {\n    key: \"hitTestLineSegment\",\n    value: function hitTestLineSegment(shape, A, B) {\n      var outline = this.outline(shape);\n      for (var i = 0; i < outline.length; i++) {\n        var C = outline[i];\n        var D = outline[(i + 1) % outline.length];\n        if (linesIntersect(A, B, C, D)) return true;\n      }\n      return false;\n    }\n    /** @internal */\n  }, {\n    key: \"expandSelectionOutlinePx\",\n    value: function expandSelectionOutlinePx(shape) {\n      return 0;\n    }\n    /**\n     * Does this shape provide a background for its children? If this is true,\n     * then any children with a `renderBackground` method will have their\n     * backgrounds rendered _above_ this shape. Otherwise, the children's\n     * backgrounds will be rendered above either the next ancestor that provides\n     * a background, or the canvas background.\n     *\n     * @internal\n     */\n  }, {\n    key: \"providesBackgroundForChildren\",\n    value: function providesBackgroundForChildren(shape) {\n      return false;\n    }\n  }]);\n  return ShapeUtil;\n}();\n_defineProperty(ShapeUtil, \"type\", void 0);\n__decorateClass([computed], ShapeUtil.prototype, \"handlesCache\", 1);\n__decorateClass([computed], ShapeUtil.prototype, \"outlineSegmentsCache\", 1);\n__decorateClass([computed], ShapeUtil.prototype, \"boundsCache\", 1);\n__decorateClass([computed], ShapeUtil.prototype, \"outlineCache\", 1);\nexport { ShapeUtil };","map":{"version":3,"names":["Box2d","linesIntersect","computed","EMPTY_ARRAY","ShapeUtil","editor","type","styleProps","_this","_classCallCheck","_defineProperty","_shape","_otherShape","shape","bounds","_createClass","key","value","hasStyle","style","has","getStyleIfExists","styleKey","get","props","_regeneratorRuntime","mark","iterateStyles","_iterator","_step","_step$value","wrap","iterateStyles$","_context","prev","next","_createForOfIteratorHelper","s","n","done","_slicedToArray","t0","e","f","finish","stop","setStyleInPartial","_objectSpread","_this2","store","createComputedCache","getHandles","handles","_this$handlesCache$ge","handlesCache","id","getOutlineSegments","outline","_this3","outlineSegments","_this$outlineSegments","outlineSegmentsCache","_this4","getBounds","_this$boundsCache$get","result","boundsCache","width","height","x","y","Math","max","_this5","getOutline","_this$outlineCache$ge","outlineCache","snapPoints","center","getCenter","canReceiveNewChildrenOfType","canDropShapes","shapes","hitTestPoint","point","containsPoint","hitTestLineSegment","A","B","i","length","C","D","expandSelectionOutlinePx","providesBackgroundForChildren","__decorateClass","prototype"],"sources":["/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@tldraw/editor/src/lib/editor/shapes/ShapeUtil.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-unused-vars */\nimport { Box2d, linesIntersect, Vec2d, VecLike } from '@tldraw/primitives'\nimport { ComputedCache } from '@tldraw/store'\nimport { StyleProp, TLHandle, TLShape, TLShapePartial, TLUnknownShape } from '@tldraw/tlschema'\nimport { computed, EMPTY_ARRAY } from 'signia'\nimport type { Editor } from '../Editor'\nimport { TLResizeHandle } from '../types/selection-types'\nimport { TLExportColors } from './shared/TLExportColors'\n\n/** @public */\nexport interface TLShapeUtilConstructor<\n\tT extends TLUnknownShape,\n\tU extends ShapeUtil<T> = ShapeUtil<T>\n> {\n\tnew (editor: Editor, type: T['type'], styleProps: ReadonlyMap<StyleProp<unknown>, string>): U\n\ttype: T['type']\n}\n\n/** @public */\nexport type TLShapeUtilFlag<T> = (shape: T) => boolean\n\n/** @public */\nexport abstract class ShapeUtil<Shape extends TLUnknownShape = TLUnknownShape> {\n\tconstructor(\n\t\tpublic editor: Editor,\n\t\tpublic readonly type: Shape['type'],\n\t\tpublic readonly styleProps: ReadonlyMap<StyleProp<unknown>, string>\n\t) {}\n\n\thasStyle(style: StyleProp<unknown>) {\n\t\treturn this.styleProps.has(style)\n\t}\n\n\tgetStyleIfExists<T>(style: StyleProp<T>, shape: Shape | TLShapePartial<Shape>): T | undefined {\n\t\tconst styleKey = this.styleProps.get(style)\n\t\tif (!styleKey) return undefined\n\t\treturn (shape.props as any)[styleKey]\n\t}\n\n\t*iterateStyles(shape: Shape | TLShapePartial<Shape>) {\n\t\tfor (const [style, styleKey] of this.styleProps) {\n\t\t\tconst value = (shape.props as any)[styleKey]\n\t\t\tyield [style, value] as [StyleProp<unknown>, unknown]\n\t\t}\n\t}\n\n\tsetStyleInPartial<T>(\n\t\tstyle: StyleProp<T>,\n\t\tshape: TLShapePartial<Shape>,\n\t\tvalue: T\n\t): TLShapePartial<Shape> {\n\t\tconst styleKey = this.styleProps.get(style)\n\t\tif (!styleKey) return shape\n\t\treturn {\n\t\t\t...shape,\n\t\t\tprops: {\n\t\t\t\t...shape.props,\n\t\t\t\t[styleKey]: value,\n\t\t\t},\n\t\t}\n\t}\n\n\t/**\n\t * The type of the shape util, which should match the shape's type.\n\t *\n\t * @public\n\t */\n\tstatic type: string\n\n\t/**\n\t * Whether the shape can be snapped to by another shape.\n\t *\n\t * @public\n\t */\n\tcanSnap: TLShapeUtilFlag<Shape> = () => true\n\n\t/**\n\t * Whether the shape can be scrolled while editing.\n\t *\n\t * @public\n\t */\n\tcanScroll: TLShapeUtilFlag<Shape> = () => false\n\n\t/**\n\t * Whether the shape should unmount when not visible in the editor. Consider keeping this to false if the shape's `component` has local state.\n\t *\n\t * @public\n\t */\n\tcanUnmount: TLShapeUtilFlag<Shape> = () => true\n\n\t/**\n\t * Whether the shape can be bound to by an arrow.\n\t *\n\t * @param _otherShape - The other shape attempting to bind to this shape.\n\t * @public\n\t */\n\tcanBind = <K>(_shape: Shape, _otherShape?: K) => true\n\n\t/**\n\t * Whether the shape can be double clicked to edit.\n\t *\n\t * @public\n\t */\n\tcanEdit: TLShapeUtilFlag<Shape> = () => false\n\n\t/**\n\t * Whether the shape can be resized.\n\t *\n\t * @public\n\t */\n\tcanResize: TLShapeUtilFlag<Shape> = () => true\n\n\t/**\n\t * Whether the shape can be cropped.\n\t *\n\t * @public\n\t */\n\tcanCrop: TLShapeUtilFlag<Shape> = () => false\n\n\t/**\n\t * Bounds of the shape to edit.\n\t *\n\t * Note: this could be a text area within a shape for example arrow labels.\n\t *\n\t * @public\n\t */\n\tgetEditingBounds = (shape: Shape) => {\n\t\treturn this.bounds(shape)\n\t}\n\n\t/**\n\t * Whether the shape's outline is closed.\n\t *\n\t * @public\n\t */\n\tisClosed: TLShapeUtilFlag<Shape> = () => true\n\n\t/**\n\t * Whether the shape should hide its resize handles when selected.\n\t *\n\t * @public\n\t */\n\thideResizeHandles: TLShapeUtilFlag<Shape> = () => false\n\n\t/**\n\t * Whether the shape should hide its resize handles when selected.\n\t *\n\t * @public\n\t */\n\thideRotateHandle: TLShapeUtilFlag<Shape> = () => false\n\n\t/**\n\t * Whether the shape should hide its selection bounds background when selected.\n\t *\n\t * @public\n\t */\n\thideSelectionBoundsBg: TLShapeUtilFlag<Shape> = () => false\n\n\t/**\n\t * Whether the shape should hide its selection bounds foreground when selected.\n\t *\n\t * @public\n\t */\n\thideSelectionBoundsFg: TLShapeUtilFlag<Shape> = () => false\n\n\t/**\n\t * Whether the shape's aspect ratio is locked.\n\t *\n\t * @public\n\t */\n\tisAspectRatioLocked: TLShapeUtilFlag<Shape> = () => false\n\n\t/**\n\t * Get the default props for a shape.\n\t *\n\t * @public\n\t */\n\tabstract defaultProps(): Shape['props']\n\n\t/**\n\t * Get a JSX element for the shape (as an HTML element).\n\t *\n\t * @param shape - The shape.\n\t * @public\n\t */\n\tabstract component(shape: Shape): any\n\n\t/**\n\t * Get JSX describing the shape's indicator (as an SVG element).\n\t *\n\t * @param shape - The shape.\n\t * @public\n\t */\n\tabstract indicator(shape: Shape): any\n\n\t/**\n\t * Get a JSX element for the shape (as an HTML element) to be rendered as part of the canvas background - behind any other shape content.\n\t *\n\t * @param shape - The shape.\n\t * @internal\n\t */\n\trenderBackground?(shape: Shape): any\n\n\t/**\n\t * Get an array of handle models for the shape. This is an optional method.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * util.getHandles?.(myShape)\n\t * ```\n\t *\n\t * @param shape - The shape.\n\t * @public\n\t */\n\tprotected getHandles?(shape: Shape): TLHandle[]\n\n\t@computed\n\tprivate get handlesCache(): ComputedCache<TLHandle[], TLShape> {\n\t\treturn this.editor.store.createComputedCache('handles:' + this.type, (shape) => {\n\t\t\treturn this.getHandles!(shape as any)\n\t\t})\n\t}\n\n\t/**\n\t * Get the cached handles (this should not be overridden!)\n\t *\n\t * @param shape - The shape.\n\t * @public\n\t */\n\thandles(shape: Shape): TLHandle[] {\n\t\tif (!this.getHandles) return EMPTY_ARRAY\n\t\treturn this.handlesCache.get(shape.id) ?? EMPTY_ARRAY\n\t}\n\n\t/**\n\t * Get an array of outline segments for the shape. For most shapes,\n\t * this will be a single segment that includes the entire outline.\n\t * For shapes with handles, this might be segments of the outline\n\t * between each handle.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * util.getOutlineSegments(myShape)\n\t * ```\n\t *\n\t * @param shape - The shape.\n\t * @public\n\t */\n\tprotected getOutlineSegments(shape: Shape): Vec2d[][] {\n\t\treturn [this.outline(shape)]\n\t}\n\n\t@computed\n\tprivate get outlineSegmentsCache(): ComputedCache<Vec2d[][], TLShape> {\n\t\treturn this.editor.store.createComputedCache('outline-segments:' + this.type, (shape) => {\n\t\t\treturn this.getOutlineSegments!(shape as any)\n\t\t})\n\t}\n\n\t/**\n\t * Get the cached outline segments (this should not be overridden!)\n\t *\n\t * @param shape - The shape.\n\t * @public\n\t */\n\toutlineSegments(shape: Shape): Vec2d[][] {\n\t\tif (!this.getOutlineSegments) return EMPTY_ARRAY\n\t\treturn this.outlineSegmentsCache.get(shape.id) ?? EMPTY_ARRAY\n\t}\n\n\t/**\n\t * Get the (not cached) bounds for the shape.\n\t *\n\t * @param shape - The shape.\n\t * @public\n\t */\n\tprotected abstract getBounds(shape: Shape): Box2d\n\n\t@computed\n\tprivate get boundsCache(): ComputedCache<Box2d, TLShape> {\n\t\treturn this.editor.store.createComputedCache('bounds:' + this.type, (shape) => {\n\t\t\treturn this.getBounds(shape as any)\n\t\t})\n\t}\n\n\t/**\n\t * Get the cached bounds for the shape.\n\t *\n\t * @param shape - The shape.\n\t * @public\n\t */\n\tbounds(shape: Shape): Box2d {\n\t\tconst result = this.boundsCache.get(shape.id) ?? new Box2d()\n\t\tif (result.width === 0 || result.height === 0) {\n\t\t\treturn new Box2d(result.x, result.y, Math.max(result.width, 1), Math.max(result.height, 1))\n\t\t}\n\t\treturn result\n\t}\n\n\t/**\n\t * Get the shape's (not cached) outline. Do not override this method!\n\t *\n\t * @param shape - The shape.\n\t * @public\n\t */\n\tprotected abstract getOutline(shape: Shape): Vec2d[]\n\n\t@computed\n\tprivate get outlineCache(): ComputedCache<Vec2d[], TLShape> {\n\t\treturn this.editor.store.createComputedCache('outline:' + this.type, (shape) => {\n\t\t\treturn this.getOutline(shape as any)\n\t\t})\n\t}\n\n\t/**\n\t * Get the shape's outline. Do not override this method!\n\t *\n\t * @param shape - The shape.\n\t * @public\n\t */\n\toutline(shape: Shape): Vec2d[] {\n\t\treturn this.outlineCache.get(shape.id) ?? EMPTY_ARRAY\n\t}\n\n\t/**\n\t * Get the shape's snap points.\n\t *\n\t * @param shape - The shape.\n\t * @public\n\t */\n\tsnapPoints(shape: Shape) {\n\t\treturn this.bounds(shape).snapPoints\n\t}\n\n\t/**\n\t * Get the shape's cached center.\n\t *\n\t * @param shape - The shape.\n\t * @public\n\t */\n\tcenter(shape: Shape): Vec2d {\n\t\treturn this.getCenter(shape)\n\t}\n\n\t/**\n\t * Get the shape's (not cached) center.\n\t *\n\t * @param shape - The shape.\n\t * @public\n\t */\n\tabstract getCenter(shape: Shape): Vec2d\n\n\t/**\n\t * Get whether the shape can receive children of a given type.\n\t *\n\t * @param type - The shape type.\n\t * @public\n\t */\n\tcanReceiveNewChildrenOfType(shape: Shape, type: TLShape['type']) {\n\t\treturn false\n\t}\n\n\t/**\n\t * Get whether the shape can receive children of a given type.\n\t *\n\t * @param shape - The shape type.\n\t * @param shapes - The shapes that are being dropped.\n\t * @public\n\t */\n\tcanDropShapes(shape: Shape, shapes: TLShape[]) {\n\t\treturn false\n\t}\n\n\t/**\n\t * Get the shape as an SVG object.\n\t *\n\t * @param shape - The shape.\n\t * @param color - The shape's CSS color (actual).\n\t * @param font - The shape's CSS font (actual).\n\t * @returns An SVG element.\n\t * @public\n\t */\n\ttoSvg?(\n\t\tshape: Shape,\n\t\tfont: string | undefined,\n\t\tcolors: TLExportColors\n\t): SVGElement | Promise<SVGElement>\n\n\t/**\n\t * Get the shape's background layer as an SVG object.\n\t *\n\t * @param shape - The shape.\n\t * @param color - The shape's CSS color (actual).\n\t * @param font - The shape's CSS font (actual).\n\t * @returns An SVG element.\n\t * @public\n\t */\n\ttoBackgroundSvg?(\n\t\tshape: Shape,\n\t\tfont: string | undefined,\n\t\tcolors: TLExportColors\n\t): SVGElement | Promise<SVGElement> | null\n\n\t/**\n\t * Get whether a point intersects the shape.\n\t *\n\t * @param shape - The shape.\n\t * @param point - The point to test.\n\t * @returns Whether the point intersects the shape.\n\t * @public\n\t */\n\thitTestPoint(shape: Shape, point: VecLike): boolean {\n\t\treturn this.bounds(shape).containsPoint(point)\n\t}\n\n\t/**\n\t * Get whether a point intersects the shape.\n\t *\n\t * @param shape - The shape.\n\t * @param A - The line segment's first point.\n\t * @param B - The line segment's second point.\n\t * @returns Whether the line segment intersects the shape.\n\t * @public\n\t */\n\thitTestLineSegment(shape: Shape, A: VecLike, B: VecLike): boolean {\n\t\tconst outline = this.outline(shape)\n\n\t\tfor (let i = 0; i < outline.length; i++) {\n\t\t\tconst C = outline[i]\n\t\t\tconst D = outline[(i + 1) % outline.length]\n\t\t\tif (linesIntersect(A, B, C, D)) return true\n\t\t}\n\n\t\treturn false\n\t}\n\n\t/** @internal */\n\texpandSelectionOutlinePx(shape: Shape): number {\n\t\treturn 0\n\t}\n\n\t/**\n\t * Does this shape provide a background for its children? If this is true,\n\t * then any children with a `renderBackground` method will have their\n\t * backgrounds rendered _above_ this shape. Otherwise, the children's\n\t * backgrounds will be rendered above either the next ancestor that provides\n\t * a background, or the canvas background.\n\t *\n\t * @internal\n\t */\n\tprovidesBackgroundForChildren(shape: Shape): boolean {\n\t\treturn false\n\t}\n\n\t//  Events\n\n\t/**\n\t * A callback called just before a shape is created. This method provides a last chance to modify\n\t * the created shape.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * onBeforeCreate = (next) => {\n\t * \treturn { ...next, x: next.x + 1 }\n\t * }\n\t * ```\n\t *\n\t * @param next - The next shape.\n\t * @returns The next shape or void.\n\t * @public\n\t */\n\tonBeforeCreate?: TLOnBeforeCreateHandler<Shape>\n\n\t/**\n\t * A callback called just before a shape is updated. This method provides a last chance to modify\n\t * the updated shape.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * onBeforeUpdate = (prev, next) => {\n\t * \tif (prev.x === next.x) {\n\t * \t\treturn { ...next, x: next.x + 1 }\n\t * \t}\n\t * }\n\t * ```\n\t *\n\t * @param prev - The previous shape.\n\t * @param next - The next shape.\n\t * @returns The next shape or void.\n\t * @public\n\t */\n\tonBeforeUpdate?: TLOnBeforeUpdateHandler<Shape>\n\n\t/**\n\t * A callback called when some other shapes are dragged over this one.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * onDragShapesOver = (shape, shapes) => {\n\t * \treturn { shouldHint: true }\n\t * }\n\t * ```\n\t *\n\t * @param shape - The shape.\n\t * @param shapes - The shapes that are being dragged over this one.\n\t * @returns An object specifying whether the shape should hint that it can receive the dragged shapes.\n\t * @public\n\t */\n\tonDragShapesOver?: TLOnDragHandler<Shape, { shouldHint: boolean }>\n\n\t/**\n\t * A callback called when some other shapes are dragged out of this one.\n\t *\n\t * @param shape - The shape.\n\t * @param shapes - The shapes that are being dragged out.\n\t * @public\n\t */\n\tonDragShapesOut?: TLOnDragHandler<Shape>\n\n\t/**\n\t * A callback called when some other shapes are dropped over this one.\n\t *\n\t * @param shape - The shape.\n\t * @param shapes - The shapes that are being dropped over this one.\n\t * @public\n\t */\n\tonDropShapesOver?: TLOnDragHandler<Shape>\n\n\t/**\n\t * A callback called when a shape starts being resized.\n\t *\n\t * @param shape - The shape.\n\t * @returns A change to apply to the shape, or void.\n\t * @public\n\t */\n\tonResizeStart?: TLOnResizeStartHandler<Shape>\n\n\t/**\n\t * A callback called when a shape changes from a resize.\n\t *\n\t * @param shape - The shape at the start of the resize.\n\t * @param info - Info about the resize.\n\t * @returns A change to apply to the shape, or void.\n\t * @public\n\t */\n\tonResize?: TLOnResizeHandler<Shape>\n\n\t/**\n\t * A callback called when a shape finishes resizing.\n\t *\n\t * @param initial - The shape at the start of the resize.\n\t * @param current - The current shape.\n\t * @returns A change to apply to the shape, or void.\n\t * @public\n\t */\n\tonResizeEnd?: TLOnResizeEndHandler<Shape>\n\n\t/**\n\t * A callback called when a shape starts being translated.\n\t *\n\t * @param shape - The shape.\n\t * @returns A change to apply to the shape, or void.\n\t * @public\n\t */\n\tonTranslateStart?: TLOnTranslateStartHandler<Shape>\n\n\t/**\n\t * A callback called when a shape changes from a translation.\n\t *\n\t * @param initial - The shape at the start of the translation.\n\t * @param current - The current shape.\n\t * @returns A change to apply to the shape, or void.\n\t * @public\n\t */\n\tonTranslate?: TLOnTranslateHandler<Shape>\n\n\t/**\n\t * A callback called when a shape finishes translating.\n\t *\n\t * @param initial - The shape at the start of the translation.\n\t * @param current - The current shape.\n\t * @returns A change to apply to the shape, or void.\n\t * @public\n\t */\n\tonTranslateEnd?: TLOnTranslateEndHandler<Shape>\n\n\t/**\n\t * A callback called when a shape starts being rotated.\n\t *\n\t * @param shape - The shape.\n\t * @returns A change to apply to the shape, or void.\n\t * @public\n\t */\n\tonRotateStart?: TLOnRotateStartHandler<Shape>\n\n\t/**\n\t * A callback called when a shape changes from a rotation.\n\t *\n\t * @param initial - The shape at the start of the rotation.\n\t * @param current - The current shape.\n\t * @returns A change to apply to the shape, or void.\n\t * @public\n\t */\n\tonRotate?: TLOnRotateHandler<Shape>\n\n\t/**\n\t * A callback called when a shape finishes rotating.\n\t *\n\t * @param initial - The shape at the start of the rotation.\n\t * @param current - The current shape.\n\t * @returns A change to apply to the shape, or void.\n\t * @public\n\t */\n\tonRotateEnd?: TLOnRotateEndHandler<Shape>\n\n\t/**\n\t * A callback called when a shape's handle changes.\n\t *\n\t * @param shape - The shape.\n\t * @param info - An object containing the handle and whether the handle is 'precise' or not.\n\t * @returns A change to apply to the shape, or void.\n\t * @public\n\t */\n\tonHandleChange?: TLOnHandleChangeHandler<Shape>\n\n\t/**\n\t * Not currently used.\n\t *\n\t * @internal\n\t */\n\tonBindingChange?: TLOnBindingChangeHandler<Shape>\n\n\t/**\n\t * A callback called when a shape's children change.\n\t *\n\t * @param shape - The shape.\n\t * @returns An array of shape updates, or void.\n\t * @public\n\t */\n\tonChildrenChange?: TLOnChildrenChangeHandler<Shape>\n\n\t/**\n\t * A callback called when a shape's handle is double clicked.\n\t *\n\t * @param shape - The shape.\n\t * @param handle - The handle that is double-clicked.\n\t * @returns A change to apply to the shape, or void.\n\t * @public\n\t */\n\tonDoubleClickHandle?: TLOnDoubleClickHandleHandler<Shape>\n\n\t/**\n\t * A callback called when a shape's edge is double clicked.\n\t *\n\t * @param shape - The shape.\n\t * @returns A change to apply to the shape, or void.\n\t * @public\n\t */\n\tonDoubleClickEdge?: TLOnDoubleClickHandler<Shape>\n\n\t/**\n\t * A callback called when a shape is double clicked.\n\t *\n\t * @param shape - The shape.\n\t * @returns A change to apply to the shape, or void.\n\t * @public\n\t */\n\tonDoubleClick?: TLOnDoubleClickHandler<Shape>\n\n\t/**\n\t * A callback called when a shape is clicked.\n\t *\n\t * @param shape - The shape.\n\t * @returns A change to apply to the shape, or void.\n\t * @public\n\t */\n\tonClick?: TLOnClickHandler<Shape>\n\n\t/**\n\t * A callback called when a shape finishes being editing.\n\t *\n\t * @param shape - The shape.\n\t * @public\n\t */\n\tonEditEnd?: TLOnEditEndHandler<Shape>\n}\n\n/** @public */\nexport type TLOnBeforeCreateHandler<T extends TLShape> = (next: T) => T | void\n/** @public */\nexport type TLOnBeforeUpdateHandler<T extends TLShape> = (prev: T, next: T) => T | void\n/** @public */\nexport type TLOnTranslateStartHandler<T extends TLShape> = TLEventStartHandler<T>\n/** @public */\nexport type TLOnTranslateHandler<T extends TLShape> = TLEventChangeHandler<T>\n/** @public */\nexport type TLOnTranslateEndHandler<T extends TLShape> = TLEventChangeHandler<T>\n/** @public */\nexport type TLOnRotateStartHandler<T extends TLShape> = TLEventStartHandler<T>\n/** @public */\nexport type TLOnRotateHandler<T extends TLShape> = TLEventChangeHandler<T>\n/** @public */\nexport type TLOnRotateEndHandler<T extends TLShape> = TLEventChangeHandler<T>\n\n/**\n * The type of resize.\n *\n * 'scale_shape' - The shape is being scaled, usually as part of a larger selection.\n *\n * 'resize_bounds' - The user is directly manipulating an individual shape's bounds using a resize\n * handle. It is up to shape util implementers to decide how they want to handle the two\n * situations.\n *\n * @public\n */\nexport type TLResizeMode = 'scale_shape' | 'resize_bounds'\n\n/**\n * Info about a resize.\n * @param newPoint - The new local position of the shape.\n * @param handle - The handle being dragged.\n * @param mode - The type of resize.\n * @param scaleX - The scale in the x-axis.\n * @param scaleY - The scale in the y-axis.\n * @param initialBounds - The bounds of the shape at the start of the resize.\n * @param initialShape - The shape at the start of the resize.\n * @public\n */\nexport type TLResizeInfo<T extends TLShape> = {\n\tnewPoint: Vec2d\n\thandle: TLResizeHandle\n\tmode: TLResizeMode\n\tscaleX: number\n\tscaleY: number\n\tinitialBounds: Box2d\n\tinitialShape: T\n}\n\n/** @public */\nexport type TLOnResizeHandler<T extends TLShape> = (\n\tshape: T,\n\tinfo: TLResizeInfo<T>\n) => Partial<TLShapePartial<T>> | undefined | void\n\n/** @public */\nexport type TLOnResizeStartHandler<T extends TLShape> = TLEventStartHandler<T>\n\n/** @public */\nexport type TLOnResizeEndHandler<T extends TLShape> = TLEventChangeHandler<T>\n\n/* -------------------- Dragging -------------------- */\n\n/** @public */\nexport type TLOnDragHandler<T extends TLShape, R = void> = (shape: T, shapes: TLShape[]) => R\n\n/** @internal */\nexport type TLOnBindingChangeHandler<T extends TLShape> = (shape: T) => TLShapePartial<T> | void\n\n/** @public */\nexport type TLOnChildrenChangeHandler<T extends TLShape> = (shape: T) => TLShapePartial[] | void\n\n/** @public */\nexport type TLOnHandleChangeHandler<T extends TLShape> = (\n\tshape: T,\n\tinfo: {\n\t\thandle: TLHandle\n\t\tisPrecise: boolean\n\t}\n) => TLShapePartial<T> | void\n\n/** @public */\nexport type TLOnClickHandler<T extends TLShape> = (shape: T) => TLShapePartial<T> | void\n/** @public */\nexport type TLOnEditEndHandler<T extends TLShape> = (shape: T) => void\n/** @public */\nexport type TLOnDoubleClickHandler<T extends TLShape> = (shape: T) => TLShapePartial<T> | void\n/** @public */\nexport type TLOnDoubleClickHandleHandler<T extends TLShape> = (\n\tshape: T,\n\thandle: TLHandle\n) => TLShapePartial<T> | void\n\ntype TLEventStartHandler<T extends TLShape> = (shape: T) => TLShapePartial<T> | void\ntype TLEventChangeHandler<T extends TLShape> = (initial: T, current: T) => TLShapePartial<T> | void\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}