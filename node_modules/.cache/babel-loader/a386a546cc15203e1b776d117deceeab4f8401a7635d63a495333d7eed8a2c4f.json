{"ast":null,"code":"import _slicedToArray from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\n// src/useStateTracking.ts\nimport React from \"react\";\nimport { EffectScheduler } from \"signia\";\nfunction useStateTracking(name, render) {\n  var renderRef = React.useRef(render);\n  renderRef.current = render;\n  var _React$useMemo = React.useMemo(function () {\n      var scheduleUpdate = null;\n      var subscribe2 = function subscribe2(cb) {\n        scheduleUpdate = cb;\n        return function () {\n          scheduleUpdate = null;\n        };\n      };\n      var scheduler2 = new EffectScheduler(\"useStateTracking(\".concat(name, \")\"),\n      // this is what `scheduler.execute()` will call\n      function () {\n        var _renderRef$current;\n        return (_renderRef$current = renderRef.current) === null || _renderRef$current === void 0 ? void 0 : _renderRef$current.call(renderRef);\n      },\n      // this is what will be invoked when signia detects a change in an upstream reactive value\n      {\n        scheduleEffect: function scheduleEffect() {\n          var _scheduleUpdate;\n          (_scheduleUpdate = scheduleUpdate) === null || _scheduleUpdate === void 0 || _scheduleUpdate();\n        }\n      });\n      var getSnapshot2 = function getSnapshot2() {\n        return scheduler2.scheduleCount;\n      };\n      return [scheduler2, subscribe2, getSnapshot2];\n    }, [name]),\n    _React$useMemo2 = _slicedToArray(_React$useMemo, 3),\n    scheduler = _React$useMemo2[0],\n    subscribe = _React$useMemo2[1],\n    getSnapshot = _React$useMemo2[2];\n  React.useSyncExternalStore(subscribe, getSnapshot, getSnapshot);\n  React.useEffect(function () {\n    scheduler.attach();\n    scheduler.maybeScheduleEffect();\n    return function () {\n      scheduler.detach();\n    };\n  }, [scheduler]);\n  return scheduler.execute();\n}\nexport { useStateTracking };","map":{"version":3,"names":["React","EffectScheduler","useStateTracking","name","render","renderRef","useRef","current","_React$useMemo","useMemo","scheduleUpdate","subscribe2","cb","scheduler2","concat","_renderRef$current","call","scheduleEffect","_scheduleUpdate","getSnapshot2","scheduleCount","_React$useMemo2","_slicedToArray","scheduler","subscribe","getSnapshot","useSyncExternalStore","useEffect","attach","maybeScheduleEffect","detach","execute"],"sources":["/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/signia-react/src/useStateTracking.ts"],"sourcesContent":["import React from 'react'\nimport { EffectScheduler } from 'signia'\n\n/** @internal */\nexport function useStateTracking<T>(name: string, render: () => T): T {\n\t// user render is only called at the bottom of this function, indirectly via scheduler.execute()\n\t// we need it to always be up-to-date when calling scheduler.execute() but it'd be wasteful to\n\t// instantiate a new EffectScheduler on every render, so we use an immediately-updated ref\n\t// to wrap it\n\tconst renderRef = React.useRef(render)\n\trenderRef.current = render\n\n\tconst [scheduler, subscribe, getSnapshot] = React.useMemo(() => {\n\t\tlet scheduleUpdate = null as null | (() => void)\n\t\t// useSyncExternalStore requires a subscribe function that returns an unsubscribe function\n\t\tconst subscribe = (cb: () => void) => {\n\t\t\tscheduleUpdate = cb\n\t\t\treturn () => {\n\t\t\t\tscheduleUpdate = null\n\t\t\t}\n\t\t}\n\n\t\tconst scheduler = new EffectScheduler(\n\t\t\t`useStateTracking(${name})`,\n\t\t\t// this is what `scheduler.execute()` will call\n\t\t\t() => renderRef.current?.(),\n\t\t\t// this is what will be invoked when signia detects a change in an upstream reactive value\n\t\t\t{\n\t\t\t\tscheduleEffect() {\n\t\t\t\t\tscheduleUpdate?.()\n\t\t\t\t},\n\t\t\t}\n\t\t)\n\n\t\t// we use an incrementing number based on when this\n\t\tconst getSnapshot = () => scheduler.scheduleCount\n\n\t\treturn [scheduler, subscribe, getSnapshot]\n\t}, [name])\n\n\tReact.useSyncExternalStore(subscribe, getSnapshot, getSnapshot)\n\n\t// reactive dependencies are captured when `scheduler.execute()` is called\n\t// and then to make it reactive we wait for a `useEffect` to 'attach'\n\t// this allows us to avoid rendering outside of React's render phase\n\t// and avoid 'zombie' components that try to render with bad/deleted data before\n\t// react has a chance to umount them.\n\tReact.useEffect(() => {\n\t\tscheduler.attach()\n\t\t// do not execute, we only do that in render\n\t\tscheduler.maybeScheduleEffect()\n\t\treturn () => {\n\t\t\tscheduler.detach()\n\t\t}\n\t}, [scheduler])\n\n\treturn scheduler.execute()\n}\n"],"mappings":";;AAAA,OAAOA,KAAA,MAAW;AAClB,SAASC,eAAA,QAAuB;AAGzB,SAASC,iBAAoBC,IAAA,EAAcC,MAAA,EAAoB;EAKrE,IAAMC,SAAA,GAAYL,KAAA,CAAMM,MAAA,CAAOF,MAAM;EACrCC,SAAA,CAAUE,OAAA,GAAUH,MAAA;EAEpB,IAAAI,cAAA,GAA4CR,KAAA,CAAMS,OAAA,CAAQ,YAAM;MAC/D,IAAIC,cAAA,GAAiB;MAErB,IAAMC,UAAA,GAAY,SAAZA,WAAaC,EAAA,EAAmB;QACrCF,cAAA,GAAiBE,EAAA;QACjB,OAAO,YAAM;UACZF,cAAA,GAAiB;QAClB;MACD;MAEA,IAAMG,UAAA,GAAY,IAAIZ,eAAA,qBAAAa,MAAA,CACDX,IAAA;MAAA;MAEpB;QAAA,IAAAY,kBAAA;QAAA,QAAAA,kBAAA,GAAMV,SAAA,CAAUE,OAAA,cAAAQ,kBAAA,uBAAVA,kBAAA,CAAAC,IAAA,CAAAX,SAAoB;MAAA;MAAA;MAE1B;QACCY,cAAA,WAAAA,eAAA,EAAiB;UAAA,IAAAC,eAAA;UAChB,CAAAA,eAAA,GAAAR,cAAA,cAAAQ,eAAA,eAAAA,eAAA,CAAiB;QAClB;MACD,CACD;MAGA,IAAMC,YAAA,GAAc,SAAdA,aAAA;QAAA,OAAoBN,UAAA,CAAUO,aAAA;MAAA;MAEpC,OAAO,CAACP,UAAA,EAAWF,UAAA,EAAWQ,YAAW;IAC1C,GAAG,CAAChB,IAAI,CAAC;IAAAkB,eAAA,GAAAC,cAAA,CAAAd,cAAA;IA1BFe,SAAA,GAAAF,eAAA;IAAWG,SAAA,GAAAH,eAAA;IAAWI,WAAW,GAAAJ,eAAA;EA4BxCrB,KAAA,CAAM0B,oBAAA,CAAqBF,SAAA,EAAWC,WAAA,EAAaA,WAAW;EAO9DzB,KAAA,CAAM2B,SAAA,CAAU,YAAM;IACrBJ,SAAA,CAAUK,MAAA,CAAO;IAEjBL,SAAA,CAAUM,mBAAA,CAAoB;IAC9B,OAAO,YAAM;MACZN,SAAA,CAAUO,MAAA,CAAO;IAClB;EACD,GAAG,CAACP,SAAS,CAAC;EAEd,OAAOA,SAAA,CAAUQ,OAAA,CAAQ;AAC1B"},"metadata":{},"sourceType":"module","externalDependencies":[]}