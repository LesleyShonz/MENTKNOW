import { Fragment, jsx, jsxs } from "react/jsx-runtime";
import {
  Box2d,
  getPolygonVertices,
  getRoundedInkyPolygonPath,
  getRoundedPolygonPoints,
  linesIntersect,
  PI,
  PI2,
  pointInPolygon,
  TAU,
  Vec2d
} from "@tldraw/primitives";
import { SVGContainer } from "../../../components/SVGContainer.mjs";
import { BaseBoxShapeUtil } from "../BaseBoxShapeUtil.mjs";
import {
  FONT_FAMILIES,
  LABEL_FONT_SIZES,
  STROKE_SIZES,
  TEXT_PROPS
} from "../shared/default-shape-constants.mjs";
import { getTextLabelSvgElement } from "../shared/getTextLabelSvgElement.mjs";
import { HyperlinkButton } from "../shared/HyperlinkButton.mjs";
import { TextLabel } from "../shared/TextLabel.mjs";
import { useForceSolid } from "../shared/useForceSolid.mjs";
import { DashStyleEllipse, DashStyleEllipseSvg } from "./components/DashStyleEllipse.mjs";
import { DashStyleOval, DashStyleOvalSvg } from "./components/DashStyleOval.mjs";
import { DashStylePolygon, DashStylePolygonSvg } from "./components/DashStylePolygon.mjs";
import { DrawStyleEllipseSvg, getEllipseIndicatorPath } from "./components/DrawStyleEllipse.mjs";
import { DrawStylePolygon, DrawStylePolygonSvg } from "./components/DrawStylePolygon.mjs";
import { SolidStyleEllipse, SolidStyleEllipseSvg } from "./components/SolidStyleEllipse.mjs";
import {
  getOvalIndicatorPath,
  SolidStyleOval,
  SolidStyleOvalSvg
} from "./components/SolidStyleOval.mjs";
import { SolidStylePolygon, SolidStylePolygonSvg } from "./components/SolidStylePolygon.mjs";
const LABEL_PADDING = 16;
const MIN_SIZE_WITH_LABEL = 17 * 3;
class GeoShapeUtil extends BaseBoxShapeUtil {
  static type = "geo";
  canEdit = () => true;
  defaultProps() {
    return {
      w: 100,
      h: 100,
      geo: "rectangle",
      color: "black",
      labelColor: "black",
      fill: "none",
      dash: "draw",
      size: "m",
      font: "draw",
      text: "",
      align: "middle",
      verticalAlign: "middle",
      growY: 0,
      url: ""
    };
  }
  hitTestLineSegment(shape, A, B) {
    const outline = this.outline(shape);
    for (let i = 0; i < outline.length; i++) {
      const C = outline[i];
      const D = outline[(i + 1) % outline.length];
      if (linesIntersect(A, B, C, D))
        return true;
    }
    const lines = getLines(shape.props, 0);
    if (lines !== void 0) {
      for (const [C, D] of lines) {
        if (linesIntersect(A, B, C, D))
          return true;
      }
    }
    return false;
  }
  hitTestPoint(shape, point) {
    const outline = this.outline(shape);
    if (shape.props.fill === "none") {
      const zoomLevel = this.editor.zoomLevel;
      const offsetDist = STROKE_SIZES[shape.props.size] / zoomLevel;
      for (let i = 0; i < outline.length; i++) {
        const C = outline[i];
        const D = outline[(i + 1) % outline.length];
        if (Vec2d.DistanceToLineSegment(C, D, point) < offsetDist)
          return true;
      }
      const lines = getLines(shape.props, 1);
      if (lines !== void 0) {
        for (const [C, D] of lines) {
          if (Vec2d.DistanceToLineSegment(C, D, point) < offsetDist)
            return true;
        }
      }
      return false;
    }
    return pointInPolygon(point, outline);
  }
  getBounds(shape) {
    return new Box2d(0, 0, shape.props.w, shape.props.h + shape.props.growY);
  }
  getCenter(shape) {
    return new Vec2d(shape.props.w / 2, (shape.props.h + shape.props.growY) / 2);
  }
  getOutline(shape) {
    const w = Math.max(1, shape.props.w);
    const h = Math.max(1, shape.props.h + shape.props.growY);
    const cx = w / 2;
    const cy = h / 2;
    switch (shape.props.geo) {
      case "triangle": {
        return [new Vec2d(cx, 0), new Vec2d(w, h), new Vec2d(0, h)];
      }
      case "diamond": {
        return [new Vec2d(cx, 0), new Vec2d(w, cy), new Vec2d(cx, h), new Vec2d(0, cy)];
      }
      case "pentagon": {
        return getPolygonVertices(w, h, 5);
      }
      case "hexagon": {
        return getPolygonVertices(w, h, 6);
      }
      case "octagon": {
        return getPolygonVertices(w, h, 8);
      }
      case "ellipse": {
        const q = Math.pow(cx - cy, 2) / Math.pow(cx + cy, 2);
        const p = PI * (cx + cy) * (1 + 3 * q / (10 + Math.sqrt(4 - 3 * q)));
        let len = Math.max(4, Math.ceil(p / 10));
        len = Math.ceil(len / 4) * 4;
        const step = PI2 / len;
        const a = Math.cos(step);
        const b = Math.sin(step);
        let sin = 0;
        let cos = 1;
        let ts = 0;
        let tc = 1;
        const points = Array(len);
        for (let i = 0; i < len; i++) {
          points[i] = new Vec2d(cx + cx * cos, cy + cy * sin);
          ts = b * cos + a * sin;
          tc = a * cos - b * sin;
          sin = ts;
          cos = tc;
        }
        return points;
      }
      case "oval": {
        const len = 10;
        const points = Array(len * 2);
        if (h > w) {
          for (let i = 0; i < len; i++) {
            const t1 = -PI + PI * i / (len - 2);
            const t2 = PI * i / (len - 2);
            points[i] = new Vec2d(cx + cx * Math.cos(t1), cx + cx * Math.sin(t1));
            points[i + len] = new Vec2d(cx + cx * Math.cos(t2), h - cx + cx * Math.sin(t2));
          }
        } else {
          for (let i = 0; i < len; i++) {
            const t1 = -TAU + PI * i / (len - 2);
            const t2 = TAU + PI * -i / (len - 2);
            points[i] = new Vec2d(w - cy + cy * Math.cos(t1), h - cy + cy * Math.sin(t1));
            points[i + len] = new Vec2d(cy - cy * Math.cos(t2), h - cy + cy * Math.sin(t2));
          }
        }
        return points;
      }
      case "star": {
        const sides = 5;
        const step = PI2 / sides / 2;
        const rightMostIndex = Math.floor(sides / 4) * 2;
        const leftMostIndex = sides * 2 - rightMostIndex;
        const topMostIndex = 0;
        const bottomMostIndex = Math.floor(sides / 2) * 2;
        const maxX = Math.cos(-TAU + rightMostIndex * step) * w / 2;
        const minX = Math.cos(-TAU + leftMostIndex * step) * w / 2;
        const minY = Math.sin(-TAU + topMostIndex * step) * h / 2;
        const maxY = Math.sin(-TAU + bottomMostIndex * step) * h / 2;
        const diffX = w - Math.abs(maxX - minX);
        const diffY = h - Math.abs(maxY - minY);
        const offsetX = w / 2 + minX - (w / 2 - maxX);
        const offsetY = h / 2 + minY - (h / 2 - maxY);
        const ratio = 1;
        const cx2 = (w - offsetX) / 2;
        const cy2 = (h - offsetY) / 2;
        const ox = (w + diffX) / 2;
        const oy = (h + diffY) / 2;
        const ix = ox * ratio / 2;
        const iy = oy * ratio / 2;
        return Array.from(Array(sides * 2)).map((_, i) => {
          const theta = -TAU + i * step;
          return new Vec2d(
            cx2 + (i % 2 ? ix : ox) * Math.cos(theta),
            cy2 + (i % 2 ? iy : oy) * Math.sin(theta)
          );
        });
      }
      case "rhombus": {
        const offset = Math.min(w * 0.38, h * 0.38);
        return [new Vec2d(offset, 0), new Vec2d(w, 0), new Vec2d(w - offset, h), new Vec2d(0, h)];
      }
      case "rhombus-2": {
        const offset = Math.min(w * 0.38, h * 0.38);
        return [new Vec2d(0, 0), new Vec2d(w - offset, 0), new Vec2d(w, h), new Vec2d(offset, h)];
      }
      case "trapezoid": {
        const offset = Math.min(w * 0.38, h * 0.38);
        return [new Vec2d(offset, 0), new Vec2d(w - offset, 0), new Vec2d(w, h), new Vec2d(0, h)];
      }
      case "arrow-right": {
        const ox = Math.min(w, h) * 0.38;
        const oy = h * 0.16;
        return [
          new Vec2d(0, oy),
          new Vec2d(w - ox, oy),
          new Vec2d(w - ox, 0),
          new Vec2d(w, h / 2),
          new Vec2d(w - ox, h),
          new Vec2d(w - ox, h - oy),
          new Vec2d(0, h - oy)
        ];
      }
      case "arrow-left": {
        const ox = Math.min(w, h) * 0.38;
        const oy = h * 0.16;
        return [
          new Vec2d(ox, 0),
          new Vec2d(ox, oy),
          new Vec2d(w, oy),
          new Vec2d(w, h - oy),
          new Vec2d(ox, h - oy),
          new Vec2d(ox, h),
          new Vec2d(0, h / 2)
        ];
      }
      case "arrow-up": {
        const ox = w * 0.16;
        const oy = Math.min(w, h) * 0.38;
        return [
          new Vec2d(w / 2, 0),
          new Vec2d(w, oy),
          new Vec2d(w - ox, oy),
          new Vec2d(w - ox, h),
          new Vec2d(ox, h),
          new Vec2d(ox, oy),
          new Vec2d(0, oy)
        ];
      }
      case "arrow-down": {
        const ox = w * 0.16;
        const oy = Math.min(w, h) * 0.38;
        return [
          new Vec2d(ox, 0),
          new Vec2d(w - ox, 0),
          new Vec2d(w - ox, h - oy),
          new Vec2d(w, h - oy),
          new Vec2d(w / 2, h),
          new Vec2d(0, h - oy),
          new Vec2d(ox, h - oy)
        ];
      }
      case "check-box":
      case "x-box":
      case "rectangle": {
        return [new Vec2d(0, 0), new Vec2d(w, 0), new Vec2d(w, h), new Vec2d(0, h)];
      }
    }
  }
  onEditEnd = (shape) => {
    const {
      id,
      type,
      props: { text }
    } = shape;
    if (text.trimEnd() !== shape.props.text) {
      this.editor.updateShapes([
        {
          id,
          type,
          props: {
            text: text.trimEnd()
          }
        }
      ]);
    }
  };
  component(shape) {
    const { id, type, props } = shape;
    const forceSolid = useForceSolid();
    const strokeWidth = STROKE_SIZES[props.size];
    const { w, color, labelColor, fill, dash, growY, font, align, verticalAlign, size, text } = props;
    const getShape = () => {
      const h = props.h + growY;
      switch (props.geo) {
        case "ellipse": {
          if (dash === "solid" || dash === "draw" && forceSolid) {
            return /* @__PURE__ */ jsx(SolidStyleEllipse, { strokeWidth, w, h, color, fill });
          } else if (dash === "dashed" || dash === "dotted") {
            return /* @__PURE__ */ jsx(
              DashStyleEllipse,
              {
                id,
                strokeWidth,
                w,
                h,
                dash: dash === "dashed" ? dash : size === "s" && forceSolid ? "dashed" : dash,
                color,
                fill
              }
            );
          } else if (dash === "draw") {
            return /* @__PURE__ */ jsx(SolidStyleEllipse, { strokeWidth, w, h, color, fill });
          }
          break;
        }
        case "oval": {
          if (dash === "solid" || dash === "draw" && forceSolid) {
            return /* @__PURE__ */ jsx(SolidStyleOval, { strokeWidth, w, h, color, fill });
          } else if (dash === "dashed" || dash === "dotted") {
            return /* @__PURE__ */ jsx(
              DashStyleOval,
              {
                id,
                strokeWidth,
                w,
                h,
                dash: dash === "dashed" ? dash : size === "s" && forceSolid ? "dashed" : dash,
                color,
                fill
              }
            );
          } else if (dash === "draw") {
            return /* @__PURE__ */ jsx(SolidStyleOval, { strokeWidth, w, h, color, fill });
          }
          break;
        }
        default: {
          const outline = this.outline(shape);
          const lines = getLines(shape.props, strokeWidth);
          if (dash === "solid" || dash === "draw" && forceSolid) {
            return /* @__PURE__ */ jsx(
              SolidStylePolygon,
              {
                fill,
                color,
                strokeWidth,
                outline,
                lines
              }
            );
          } else if (dash === "dashed" || dash === "dotted") {
            return /* @__PURE__ */ jsx(
              DashStylePolygon,
              {
                dash: dash === "dashed" ? dash : size === "s" && forceSolid ? "dashed" : dash,
                fill,
                color,
                strokeWidth,
                outline,
                lines
              }
            );
          } else if (dash === "draw") {
            return /* @__PURE__ */ jsx(
              DrawStylePolygon,
              {
                id,
                fill,
                color,
                strokeWidth,
                outline,
                lines
              }
            );
          }
        }
      }
    };
    return /* @__PURE__ */ jsxs(Fragment, { children: [
      /* @__PURE__ */ jsx(SVGContainer, { id, children: getShape() }),
      /* @__PURE__ */ jsx(
        TextLabel,
        {
          id,
          type,
          font,
          fill,
          size,
          align,
          verticalAlign,
          text,
          labelColor,
          wrap: true
        }
      ),
      shape.props.url && /* @__PURE__ */ jsx(HyperlinkButton, { url: shape.props.url, zoomLevel: this.editor.zoomLevel })
    ] });
  }
  indicator(shape) {
    const { id, props } = shape;
    const { w, h, growY, size } = props;
    const forceSolid = useForceSolid();
    const strokeWidth = STROKE_SIZES[size];
    switch (props.geo) {
      case "ellipse": {
        if (props.dash === "draw" && !forceSolid) {
          return /* @__PURE__ */ jsx("path", { d: getEllipseIndicatorPath(id, w, h + growY, strokeWidth) });
        }
        return /* @__PURE__ */ jsx("ellipse", { cx: w / 2, cy: (h + growY) / 2, rx: w / 2, ry: (h + growY) / 2 });
      }
      case "oval": {
        return /* @__PURE__ */ jsx("path", { d: getOvalIndicatorPath(w, h + growY) });
      }
      default: {
        const outline = this.outline(shape);
        let path;
        if (props.dash === "draw" && !forceSolid) {
          const polygonPoints = getRoundedPolygonPoints(id, outline, 0, strokeWidth * 2, 1);
          path = getRoundedInkyPolygonPath(polygonPoints);
        } else {
          path = "M" + outline[0] + "L" + outline.slice(1) + "Z";
        }
        const lines = getLines(shape.props, strokeWidth);
        if (lines) {
          for (const [A, B] of lines) {
            path += `M${A.x},${A.y}L${B.x},${B.y}`;
          }
        }
        return /* @__PURE__ */ jsx("path", { d: path });
      }
    }
  }
  toSvg(shape, font, colors) {
    const { id, props } = shape;
    const strokeWidth = STROKE_SIZES[props.size];
    let svgElm;
    switch (props.geo) {
      case "ellipse": {
        switch (props.dash) {
          case "draw":
            svgElm = DrawStyleEllipseSvg({
              id,
              w: props.w,
              h: props.h,
              color: props.color,
              fill: props.fill,
              strokeWidth,
              colors
            });
            break;
          case "solid":
            svgElm = SolidStyleEllipseSvg({
              strokeWidth,
              w: props.w,
              h: props.h,
              color: props.color,
              fill: props.fill,
              colors
            });
            break;
          default:
            svgElm = DashStyleEllipseSvg({
              id,
              strokeWidth,
              w: props.w,
              h: props.h,
              dash: props.dash,
              color: props.color,
              fill: props.fill,
              colors
            });
            break;
        }
        break;
      }
      case "oval": {
        switch (props.dash) {
          case "draw":
            svgElm = DashStyleOvalSvg({
              id,
              strokeWidth,
              w: props.w,
              h: props.h,
              dash: props.dash,
              color: props.color,
              fill: props.fill,
              colors
            });
            break;
          case "solid":
            svgElm = SolidStyleOvalSvg({
              strokeWidth,
              w: props.w,
              h: props.h,
              color: props.color,
              fill: props.fill,
              colors
            });
            break;
          default:
            svgElm = DashStyleOvalSvg({
              id,
              strokeWidth,
              w: props.w,
              h: props.h,
              dash: props.dash,
              color: props.color,
              fill: props.fill,
              colors
            });
        }
        break;
      }
      default: {
        const outline = this.outline(shape);
        const lines = getLines(shape.props, strokeWidth);
        switch (props.dash) {
          case "draw":
            svgElm = DrawStylePolygonSvg({
              id,
              fill: props.fill,
              color: props.color,
              strokeWidth,
              outline,
              lines,
              colors
            });
            break;
          case "solid":
            svgElm = SolidStylePolygonSvg({
              fill: props.fill,
              color: props.color,
              strokeWidth,
              outline,
              lines,
              colors
            });
            break;
          default:
            svgElm = DashStylePolygonSvg({
              dash: props.dash,
              fill: props.fill,
              color: props.color,
              strokeWidth,
              outline,
              lines,
              colors
            });
            break;
        }
        break;
      }
    }
    if (props.text) {
      const bounds = this.bounds(shape);
      const rootTextElm = getTextLabelSvgElement({
        editor: this.editor,
        shape,
        font,
        bounds
      });
      const textElm = rootTextElm.cloneNode(true);
      textElm.setAttribute("fill", colors.fill[shape.props.labelColor]);
      textElm.setAttribute("stroke", "none");
      const textBgEl = rootTextElm.cloneNode(true);
      textBgEl.setAttribute("stroke-width", "2");
      textBgEl.setAttribute("fill", colors.background);
      textBgEl.setAttribute("stroke", colors.background);
      const groupEl = document.createElementNS("http://www.w3.org/2000/svg", "g");
      groupEl.append(textBgEl);
      groupEl.append(textElm);
      if (svgElm.nodeName === "g") {
        svgElm.appendChild(groupEl);
        return svgElm;
      } else {
        const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
        g.appendChild(svgElm);
        g.appendChild(groupEl);
        return g;
      }
    }
    return svgElm;
  }
  onResize = (shape, { initialBounds, handle, newPoint, scaleX, scaleY }) => {
    let w = initialBounds.width * scaleX;
    let h = initialBounds.height * scaleY;
    let overShrinkX = 0;
    let overShrinkY = 0;
    if (shape.props.text.trim()) {
      let newW = Math.max(Math.abs(w), MIN_SIZE_WITH_LABEL);
      let newH = Math.max(Math.abs(h), MIN_SIZE_WITH_LABEL);
      if (newW < MIN_SIZE_WITH_LABEL && newH === MIN_SIZE_WITH_LABEL) {
        newW = MIN_SIZE_WITH_LABEL;
      }
      if (newW === MIN_SIZE_WITH_LABEL && newH < MIN_SIZE_WITH_LABEL) {
        newH = MIN_SIZE_WITH_LABEL;
      }
      const labelSize = getLabelSize(this.editor, {
        ...shape,
        props: {
          ...shape.props,
          w: newW,
          h: newH
        }
      });
      const nextW = Math.max(Math.abs(w), labelSize.w) * Math.sign(w);
      const nextH = Math.max(Math.abs(h), labelSize.h) * Math.sign(h);
      overShrinkX = Math.abs(nextW) - Math.abs(w);
      overShrinkY = Math.abs(nextH) - Math.abs(h);
      w = nextW;
      h = nextH;
    }
    const offset = new Vec2d(0, 0);
    if (scaleX < 0) {
      offset.x += w;
    }
    if (handle === "left" || handle === "top_left" || handle === "bottom_left") {
      offset.x += scaleX < 0 ? overShrinkX : -overShrinkX;
    }
    if (scaleY < 0) {
      offset.y += h;
    }
    if (handle === "top" || handle === "top_left" || handle === "top_right") {
      offset.y += scaleY < 0 ? overShrinkY : -overShrinkY;
    }
    const { x, y } = offset.rot(shape.rotation).add(newPoint);
    return {
      x,
      y,
      props: {
        w: Math.max(Math.abs(w), 1),
        h: Math.max(Math.abs(h), 1),
        growY: 0
      }
    };
  };
  onBeforeCreate = (shape) => {
    if (!shape.props.text) {
      if (shape.props.growY) {
        return {
          ...shape,
          props: {
            ...shape.props,
            growY: 0
          }
        };
      } else {
        return;
      }
    }
    const prevHeight = shape.props.h;
    const nextHeight = getLabelSize(this.editor, shape).h;
    let growY = null;
    if (nextHeight > prevHeight) {
      growY = nextHeight - prevHeight;
    } else {
      if (shape.props.growY) {
        growY = 0;
      }
    }
    if (growY !== null) {
      return {
        ...shape,
        props: {
          ...shape.props,
          growY
        }
      };
    }
  };
  onBeforeUpdate = (prev, next) => {
    const prevText = prev.props.text.trimEnd();
    const nextText = next.props.text.trimEnd();
    if (prevText === nextText && prev.props.font === next.props.font && prev.props.size === next.props.size) {
      return;
    }
    if (prevText && !nextText) {
      return {
        ...next,
        props: {
          ...next.props,
          growY: 0
        }
      };
    }
    const prevWidth = prev.props.w;
    const prevHeight = prev.props.h;
    const nextSize = getLabelSize(this.editor, next);
    const nextWidth = nextSize.w;
    const nextHeight = nextSize.h;
    if (!prevText && nextText && nextText.length === 1) {
      let w = Math.max(prevWidth, nextWidth);
      let h = Math.max(prevHeight, nextHeight);
      if (prev.props.w < MIN_SIZE_WITH_LABEL && prev.props.h < MIN_SIZE_WITH_LABEL) {
        w = Math.max(w, MIN_SIZE_WITH_LABEL);
        h = Math.max(h, MIN_SIZE_WITH_LABEL);
        w = Math.max(w, h);
        h = Math.max(w, h);
      }
      return {
        ...next,
        props: {
          ...next.props,
          w,
          h,
          growY: 0
        }
      };
    }
    let growY = null;
    if (nextHeight > prevHeight) {
      growY = nextHeight - prevHeight;
    } else {
      if (prev.props.growY) {
        growY = 0;
      }
    }
    if (growY !== null) {
      return {
        ...next,
        props: {
          ...next.props,
          growY,
          w: Math.max(next.props.w, nextWidth)
        }
      };
    }
    if (nextWidth > prev.props.w) {
      return {
        ...next,
        props: {
          ...next.props,
          w: nextWidth
        }
      };
    }
  };
  onDoubleClick = (shape) => {
    if (this.editor.inputs.altKey) {
      switch (shape.props.geo) {
        case "rectangle": {
          return {
            ...shape,
            props: {
              geo: "check-box"
            }
          };
        }
        case "check-box": {
          return {
            ...shape,
            props: {
              geo: "rectangle"
            }
          };
        }
      }
    }
    return;
  };
}
function getLabelSize(editor, shape) {
  const text = shape.props.text.trimEnd();
  if (!text) {
    return { w: 0, h: 0 };
  }
  const minSize = editor.textMeasure.measureText("w", {
    ...TEXT_PROPS,
    fontFamily: FONT_FAMILIES[shape.props.font],
    fontSize: LABEL_FONT_SIZES[shape.props.size],
    width: "fit-content",
    maxWidth: "100px"
  });
  const sizes = {
    s: 2,
    m: 3.5,
    l: 5,
    xl: 10
  };
  const size = editor.textMeasure.measureText(text, {
    ...TEXT_PROPS,
    fontFamily: FONT_FAMILIES[shape.props.font],
    fontSize: LABEL_FONT_SIZES[shape.props.size],
    width: "fit-content",
    minWidth: minSize.w + "px",
    maxWidth: Math.max(
      // Guard because a DOM nodes can't be less 0
      0,
      // A 'w' width that we're setting as the min-width
      Math.ceil(minSize.w + sizes[shape.props.size]),
      // The actual text size
      Math.ceil(shape.props.w - LABEL_PADDING * 2)
    ) + "px"
  });
  return {
    w: size.w + LABEL_PADDING * 2,
    h: size.h + LABEL_PADDING * 2
  };
}
function getLines(props, sw) {
  switch (props.geo) {
    case "x-box": {
      return getXBoxLines(props.w, props.h, sw, props.dash);
    }
    case "check-box": {
      return getCheckBoxLines(props.w, props.h);
    }
    default: {
      return void 0;
    }
  }
}
function getXBoxLines(w, h, sw, dash) {
  const inset = dash === "draw" ? 0.62 : 0;
  if (dash === "dashed") {
    return [
      [new Vec2d(0, 0), new Vec2d(w / 2, h / 2)],
      [new Vec2d(w, h), new Vec2d(w / 2, h / 2)],
      [new Vec2d(0, h), new Vec2d(w / 2, h / 2)],
      [new Vec2d(w, 0), new Vec2d(w / 2, h / 2)]
    ];
  }
  return [
    [new Vec2d(sw * inset, sw * inset), new Vec2d(w - sw * inset, h - sw * inset)],
    [new Vec2d(sw * inset, h - sw * inset), new Vec2d(w - sw * inset, sw * inset)]
  ];
}
function getCheckBoxLines(w, h) {
  const size = Math.min(w, h) * 0.82;
  const ox = (w - size) / 2;
  const oy = (h - size) / 2;
  return [
    [new Vec2d(ox + size * 0.25, oy + size * 0.52), new Vec2d(ox + size * 0.45, oy + size * 0.82)],
    [new Vec2d(ox + size * 0.45, oy + size * 0.82), new Vec2d(ox + size * 0.82, oy + size * 0.22)]
  ];
}
export {
  GeoShapeUtil
};
//# sourceMappingURL=GeoShapeUtil.mjs.map
