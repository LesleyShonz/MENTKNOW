import { Vec2d } from "@tldraw/primitives";
import { StateNode } from "../../../../StateNode.mjs";
import { getTranslateCroppedImageChange } from "./crop_helpers.mjs";
class Idle extends StateNode {
  static id = "idle";
  onEnter = () => {
    this.editor.setCursor({ type: "default" });
    const { onlySelectedShape } = this.editor;
    this.editor.on("change-history", this.cleanupCroppingState);
    this.editor.mark("crop");
    if (onlySelectedShape) {
      this.editor.setCroppingId(onlySelectedShape.id);
    }
  };
  onExit = () => {
    this.editor.setCursor({ type: "default" });
    this.editor.off("change-history", this.cleanupCroppingState);
  };
  onCancel = () => {
    this.editor.setCroppingId(null);
    this.editor.setSelectedTool("select.idle", {});
  };
  onPointerDown = (info) => {
    if (this.editor.isMenuOpen)
      return;
    if (info.ctrlKey) {
      this.editor.setCroppingId(null);
      this.editor.setSelectedTool("select.brushing", info);
      return;
    }
    switch (info.target) {
      case "canvas": {
        this.cancel();
        break;
      }
      case "shape": {
        if (info.shape.id === this.editor.croppingId) {
          this.editor.setSelectedTool("select.crop.pointing_crop", info);
          return;
        } else {
          if (this.editor.getShapeUtil(info.shape)?.canCrop(info.shape)) {
            this.editor.setCroppingId(info.shape.id);
            this.editor.setSelectedIds([info.shape.id]);
            this.editor.setSelectedTool("select.crop.pointing_crop", info);
          } else {
            this.cancel();
          }
        }
        break;
      }
      case "selection": {
        switch (info.handle) {
          case "mobile_rotate":
          case "top_left_rotate":
          case "top_right_rotate":
          case "bottom_left_rotate":
          case "bottom_right_rotate": {
            this.editor.setSelectedTool("select.pointing_rotate_handle", {
              ...info,
              onInteractionEnd: "select.crop"
            });
            break;
          }
          case "top":
          case "right":
          case "bottom":
          case "left": {
            this.editor.setSelectedTool("select.pointing_crop_handle", {
              ...info,
              onInteractionEnd: "select.crop"
            });
            break;
          }
          case "top_left":
          case "top_right":
          case "bottom_left":
          case "bottom_right": {
            this.editor.setSelectedTool("select.pointing_crop_handle", {
              ...info,
              onInteractionEnd: "select.crop"
            });
            break;
          }
          default: {
            this.cancel();
          }
        }
        break;
      }
    }
  };
  onDoubleClick = (info) => {
    if (info.phase !== "up")
      return;
    if (!this.editor.croppingId)
      return;
    const shape = this.editor.getShapeById(this.editor.croppingId);
    if (!shape)
      return;
    const util = this.editor.getShapeUtil(shape);
    if (!util)
      return;
    if (info.target === "selection") {
      util.onDoubleClickEdge?.(shape);
    }
  };
  onKeyDown = () => {
    this.nudgeCroppingImage(false);
  };
  onKeyRepeat = () => {
    this.nudgeCroppingImage(true);
  };
  onKeyUp = (info) => {
    switch (info.code) {
      case "Enter": {
        this.editor.setCroppingId(null);
        this.editor.setSelectedTool("select.idle", {});
        break;
      }
    }
  };
  cancel() {
    this.editor.setCroppingId(null);
    this.editor.setSelectedTool("select.idle", {});
  }
  cleanupCroppingState = () => {
    if (!this.editor.croppingId) {
      this.editor.setSelectedTool("select.idle", {});
    }
  };
  nudgeCroppingImage(ephemeral = false) {
    const {
      editor: {
        inputs: { keys }
      }
    } = this;
    const shiftKey = keys.has("ShiftLeft");
    const delta = new Vec2d(0, 0);
    if (keys.has("ArrowLeft"))
      delta.x += 1;
    if (keys.has("ArrowRight"))
      delta.x -= 1;
    if (keys.has("ArrowUp"))
      delta.y += 1;
    if (keys.has("ArrowDown"))
      delta.y -= 1;
    if (delta.equals(new Vec2d(0, 0)))
      return;
    if (shiftKey)
      delta.mul(10);
    const shape = this.editor.getShapeById(this.editor.croppingId);
    if (!shape)
      return;
    const partial = getTranslateCroppedImageChange(this.editor, shape, delta);
    if (partial) {
      if (!ephemeral) {
        this.editor.mark("translate crop");
      }
      this.editor.updateShapes([partial]);
    }
  }
}
export {
  Idle
};
//# sourceMappingURL=Idle.mjs.map
