import { jsx } from "react/jsx-runtime";
import { Box2d, Matrix2d } from "@tldraw/primitives";
import { SVGContainer } from "../../../components/SVGContainer.mjs";
import { ShapeUtil } from "../ShapeUtil.mjs";
import { DashedOutlineBox } from "../shared/DashedOutlineBox.mjs";
class GroupShapeUtil extends ShapeUtil {
  static type = "group";
  type = "group";
  hideSelectionBoundsBg = () => false;
  hideSelectionBoundsFg = () => true;
  canBind = () => false;
  defaultProps() {
    return {};
  }
  getBounds(shape) {
    const children = this.editor.getSortedChildIds(shape.id);
    if (children.length === 0) {
      return new Box2d();
    }
    const allChildPoints = children.flatMap((childId) => {
      const shape2 = this.editor.getShapeById(childId);
      return this.editor.getOutlineById(childId).map((point) => Matrix2d.applyToPoint(this.editor.getTransform(shape2), point));
    });
    return Box2d.FromPoints(allChildPoints);
  }
  getCenter(shape) {
    return this.bounds(shape).center;
  }
  getOutline(shape) {
    return this.bounds(shape).corners;
  }
  component(shape) {
    const {
      erasingIdsSet,
      pageState: { hintingIds, focusLayerId },
      zoomLevel
    } = this.editor;
    const isErasing = erasingIdsSet.has(shape.id);
    const isHintingOtherGroup = hintingIds.length > 0 && hintingIds.some(
      (id) => id !== shape.id && this.editor.isShapeOfType(this.editor.getShapeById(id), GroupShapeUtil)
    );
    if (
      // always show the outline while we're erasing the group
      !isErasing && // show the outline while the group is focused unless something outside of the group is being hinted
      // this happens dropping shapes from a group onto some outside group
      (shape.id !== focusLayerId || isHintingOtherGroup)
    ) {
      return null;
    }
    const bounds = this.bounds(shape);
    return /* @__PURE__ */ jsx(SVGContainer, { id: shape.id, children: /* @__PURE__ */ jsx(DashedOutlineBox, { className: "tl-group", bounds, zoomLevel }) });
  }
  indicator(shape) {
    const {
      camera: { z: zoomLevel }
    } = this.editor;
    const bounds = this.bounds(shape);
    return /* @__PURE__ */ jsx(DashedOutlineBox, { className: "", bounds, zoomLevel });
  }
  onChildrenChange = (group) => {
    const children = this.editor.getSortedChildIds(group.id);
    if (children.length === 0) {
      if (this.editor.pageState.focusLayerId === group.id) {
        this.editor.popFocusLayer();
      }
      this.editor.deleteShapes([group.id]);
      return;
    } else if (children.length === 1) {
      if (this.editor.pageState.focusLayerId === group.id) {
        this.editor.popFocusLayer();
      }
      this.editor.reparentShapesById(children, group.parentId);
      this.editor.deleteShapes([group.id]);
      return;
    }
  };
}
export {
  GroupShapeUtil
};
//# sourceMappingURL=GroupShapeUtil.mjs.map
