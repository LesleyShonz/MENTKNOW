{"ast":null,"code":"import _objectSpread from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _classCallCheck from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _inherits from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _defineProperty from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport { sortByIndex } from \"@tldraw/indices\";\nimport { Matrix2d, snapAngle, Vec2d } from \"@tldraw/primitives\";\nimport { deepCopy } from \"@tldraw/utils\";\nimport { StateNode } from \"../../StateNode.mjs\";\nvar DraggingHandle = /*#__PURE__*/function (_StateNode) {\n  _inherits(DraggingHandle, _StateNode);\n  var _super = _createSuper(DraggingHandle);\n  function DraggingHandle() {\n    var _this;\n    _classCallCheck(this, DraggingHandle);\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    _this = _super.call.apply(_super, [this].concat(args));\n    _defineProperty(_assertThisInitialized(_this), \"shapeId\", \"\");\n    _defineProperty(_assertThisInitialized(_this), \"initialHandle\", {});\n    _defineProperty(_assertThisInitialized(_this), \"initialAdjacentHandle\", null);\n    _defineProperty(_assertThisInitialized(_this), \"markId\", \"\");\n    _defineProperty(_assertThisInitialized(_this), \"initialPageTransform\", void 0);\n    _defineProperty(_assertThisInitialized(_this), \"initialPageRotation\", void 0);\n    _defineProperty(_assertThisInitialized(_this), \"info\", {});\n    _defineProperty(_assertThisInitialized(_this), \"isPrecise\", false);\n    _defineProperty(_assertThisInitialized(_this), \"isPreciseId\", null);\n    _defineProperty(_assertThisInitialized(_this), \"pointingId\", null);\n    _defineProperty(_assertThisInitialized(_this), \"onEnter\", function (info) {\n      var shape = info.shape,\n        isCreating = info.isCreating,\n        handle = info.handle;\n      _this.info = info;\n      _this.shapeId = shape.id;\n      _this.markId = isCreating ? \"creating\" : _this.editor.mark(\"dragging handle\");\n      _this.initialHandle = deepCopy(handle);\n      _this.initialPageTransform = _this.editor.getPageTransform(shape);\n      _this.initialPageRotation = _this.editor.getPageRotation(shape);\n      _this.editor.setCursor({\n        type: isCreating ? \"cross\" : \"grabbing\",\n        rotation: 0\n      });\n      var handles = _this.editor.getShapeUtil(shape).handles(shape).sort(sortByIndex);\n      var index = handles.findIndex(function (h) {\n        return h.id === info.handle.id;\n      });\n      _this.initialAdjacentHandle = null;\n      for (var i = index + 1; i < handles.length; i++) {\n        var handle2 = handles[i];\n        if (handle2.type === \"vertex\" && handle2.id !== \"middle\" && handle2.id !== info.handle.id) {\n          _this.initialAdjacentHandle = handle2;\n          break;\n        }\n      }\n      if (!_this.initialAdjacentHandle) {\n        for (var _i = handles.length - 1; _i >= 0; _i--) {\n          var _handle = handles[_i];\n          if (_handle.type === \"vertex\" && _handle.id !== \"middle\" && _handle.id !== info.handle.id) {\n            _this.initialAdjacentHandle = _handle;\n            break;\n          }\n        }\n      }\n      var initialTerminal = shape.props[info.handle.id];\n      _this.isPrecise = false;\n      if ((initialTerminal === null || initialTerminal === void 0 ? void 0 : initialTerminal.type) === \"binding\") {\n        _this.editor.setHintingIds([initialTerminal.boundShapeId]);\n        _this.isPrecise = !Vec2d.Equals(initialTerminal.normalizedAnchor, {\n          x: 0.5,\n          y: 0.5\n        });\n        if (_this.isPrecise) {\n          _this.isPreciseId = initialTerminal.boundShapeId;\n        } else {\n          _this.resetExactTimeout();\n        }\n      }\n      _this.update();\n    });\n    // Only relevant to arrows\n    _defineProperty(_assertThisInitialized(_this), \"exactTimeout\", -1);\n    _defineProperty(_assertThisInitialized(_this), \"onPointerMove\", function () {\n      _this.update();\n    });\n    _defineProperty(_assertThisInitialized(_this), \"onKeyDown\", function () {\n      _this.update();\n    });\n    _defineProperty(_assertThisInitialized(_this), \"onKeyUp\", function () {\n      _this.update();\n    });\n    _defineProperty(_assertThisInitialized(_this), \"onPointerUp\", function () {\n      _this.complete();\n    });\n    _defineProperty(_assertThisInitialized(_this), \"onComplete\", function () {\n      _this.complete();\n    });\n    _defineProperty(_assertThisInitialized(_this), \"onCancel\", function () {\n      _this.cancel();\n    });\n    _defineProperty(_assertThisInitialized(_this), \"onExit\", function () {\n      _this.editor.setHintingIds([]);\n      _this.editor.snaps.clear();\n      _this.editor.setCursor({\n        type: \"default\"\n      });\n    });\n    return _this;\n  }\n  _createClass(DraggingHandle, [{\n    key: \"resetExactTimeout\",\n    value:\n    // Only relevant to arrows\n    function resetExactTimeout() {\n      var _this2 = this;\n      if (this.exactTimeout !== -1) {\n        this.clearExactTimeout();\n      }\n      this.exactTimeout = setTimeout(function () {\n        if (_this2.isActive && !_this2.isPrecise) {\n          _this2.isPrecise = true;\n          _this2.isPreciseId = _this2.pointingId;\n          _this2.update();\n        }\n        _this2.exactTimeout = -1;\n      }, 750);\n    }\n    // Only relevant to arrows\n  }, {\n    key: \"clearExactTimeout\",\n    value: function clearExactTimeout() {\n      if (this.exactTimeout !== -1) {\n        clearTimeout(this.exactTimeout);\n        this.exactTimeout = -1;\n      }\n    }\n  }, {\n    key: \"complete\",\n    value: function complete() {\n      this.editor.snaps.clear();\n      var onInteractionEnd = this.info.onInteractionEnd;\n      if (this.editor.instanceState.isToolLocked && onInteractionEnd) {\n        this.editor.setSelectedTool(onInteractionEnd, {\n          shapeId: this.shapeId\n        });\n        return;\n      }\n      this.parent.transition(\"idle\", {});\n    }\n  }, {\n    key: \"cancel\",\n    value: function cancel() {\n      this.editor.bailToMark(this.markId);\n      this.editor.snaps.clear();\n      var onInteractionEnd = this.info.onInteractionEnd;\n      if (onInteractionEnd) {\n        this.editor.setSelectedTool(onInteractionEnd, {\n          shapeId: this.shapeId\n        });\n        return;\n      }\n      this.parent.transition(\"idle\", {});\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      var _util$onHandleChange;\n      var editor = this.editor,\n        shapeId = this.shapeId;\n      var initialHandle = this.initialHandle,\n        initialPageRotation = this.initialPageRotation,\n        initialAdjacentHandle = this.initialAdjacentHandle;\n      var isSnapMode = editor.isSnapMode,\n        hintingIds = editor.hintingIds,\n        snaps = editor.snaps,\n        _editor$inputs = editor.inputs,\n        currentPagePoint = _editor$inputs.currentPagePoint,\n        originPagePoint = _editor$inputs.originPagePoint,\n        shiftKey = _editor$inputs.shiftKey,\n        ctrlKey = _editor$inputs.ctrlKey,\n        altKey = _editor$inputs.altKey,\n        pointerVelocity = _editor$inputs.pointerVelocity;\n      var shape = editor.getShapeById(shapeId);\n      if (!shape) return;\n      var util = editor.getShapeUtil(shape);\n      var point = currentPagePoint.clone().sub(originPagePoint).rot(-initialPageRotation).add(initialHandle);\n      if (shiftKey && initialAdjacentHandle && initialHandle.id !== \"middle\") {\n        var angle = Vec2d.Angle(initialAdjacentHandle, point);\n        var snappedAngle = snapAngle(angle, 24);\n        var angleDifference = snappedAngle - angle;\n        point = Vec2d.RotWith(point, initialAdjacentHandle, angleDifference);\n      }\n      editor.snaps.clear();\n      if (isSnapMode ? !ctrlKey : ctrlKey) {\n        var pageTransform = editor.getPageTransformById(shape.id);\n        if (!pageTransform) throw Error(\"Expected a page transform\");\n        var additionalSegments = util.outlineSegments(shape).map(function (segment) {\n          return Matrix2d.applyToPoints(pageTransform, segment);\n        });\n        var handleIndex = util.handles(shape).filter(function (_ref) {\n          var type = _ref.type;\n          return type === \"vertex\";\n        }).sort(sortByIndex).findIndex(function (_ref2) {\n          var index = _ref2.index;\n          return initialHandle.index === index;\n        });\n        additionalSegments.splice(handleIndex - 1, 2);\n        var snapDelta = snaps.getSnappingHandleDelta({\n          additionalSegments: additionalSegments,\n          handlePoint: Matrix2d.applyToPoint(pageTransform, point)\n        });\n        if (snapDelta) {\n          point.add(editor.getDeltaInShapeSpace(shape, snapDelta));\n        }\n      }\n      var changes = (_util$onHandleChange = util.onHandleChange) === null || _util$onHandleChange === void 0 ? void 0 : _util$onHandleChange.call(util, shape, {\n        handle: _objectSpread(_objectSpread({}, initialHandle), {}, {\n          x: point.x,\n          y: point.y\n        }),\n        isPrecise: this.isPrecise || altKey\n      });\n      var next = _objectSpread(_objectSpread({}, shape), changes);\n      if (initialHandle.canBind) {\n        var bindingAfter = next.props[initialHandle.id];\n        if ((bindingAfter === null || bindingAfter === void 0 ? void 0 : bindingAfter.type) === \"binding\") {\n          if (hintingIds[0] !== bindingAfter.boundShapeId) {\n            editor.setHintingIds([bindingAfter.boundShapeId]);\n            this.pointingId = bindingAfter.boundShapeId;\n            this.isPrecise = pointerVelocity.len() < 0.5 || altKey;\n            this.isPreciseId = this.isPrecise ? bindingAfter.boundShapeId : null;\n            this.resetExactTimeout();\n          }\n        } else {\n          if (hintingIds.length > 0) {\n            editor.setHintingIds([]);\n            this.pointingId = null;\n            this.isPrecise = false;\n            this.isPreciseId = null;\n            this.resetExactTimeout();\n          }\n        }\n      }\n      if (changes) {\n        editor.updateShapes([next], true);\n      }\n    }\n  }]);\n  return DraggingHandle;\n}(StateNode);\n_defineProperty(DraggingHandle, \"id\", \"dragging_handle\");\nexport { DraggingHandle };","map":{"version":3,"names":["sortByIndex","Matrix2d","snapAngle","Vec2d","deepCopy","StateNode","DraggingHandle","_StateNode","_inherits","_super","_createSuper","_this","_classCallCheck","_len","arguments","length","args","Array","_key","call","apply","concat","_defineProperty","_assertThisInitialized","info","shape","isCreating","handle","shapeId","id","markId","editor","mark","initialHandle","initialPageTransform","getPageTransform","initialPageRotation","getPageRotation","setCursor","type","rotation","handles","getShapeUtil","sort","index","findIndex","h","initialAdjacentHandle","i","handle2","initialTerminal","props","isPrecise","setHintingIds","boundShapeId","Equals","normalizedAnchor","x","y","isPreciseId","resetExactTimeout","update","complete","cancel","snaps","clear","_createClass","key","value","_this2","exactTimeout","clearExactTimeout","setTimeout","isActive","pointingId","clearTimeout","onInteractionEnd","instanceState","isToolLocked","setSelectedTool","parent","transition","bailToMark","_util$onHandleChange","isSnapMode","hintingIds","_editor$inputs","inputs","currentPagePoint","originPagePoint","shiftKey","ctrlKey","altKey","pointerVelocity","getShapeById","util","point","clone","sub","rot","add","angle","Angle","snappedAngle","angleDifference","RotWith","pageTransform","getPageTransformById","Error","additionalSegments","outlineSegments","map","segment","applyToPoints","handleIndex","filter","_ref","_ref2","splice","snapDelta","getSnappingHandleDelta","handlePoint","applyToPoint","getDeltaInShapeSpace","changes","onHandleChange","_objectSpread","next","canBind","bindingAfter","len","updateShapes"],"sources":["/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@tldraw/editor/src/lib/editor/tools/SelectTool/children/DraggingHandle.ts"],"sourcesContent":["import { sortByIndex } from '@tldraw/indices'\nimport { Matrix2d, snapAngle, Vec2d } from '@tldraw/primitives'\nimport {\n\tTLArrowShape,\n\tTLArrowShapeTerminal,\n\tTLHandle,\n\tTLShapeId,\n\tTLShapePartial,\n} from '@tldraw/tlschema'\nimport { deepCopy } from '@tldraw/utils'\nimport {\n\tTLCancelEvent,\n\tTLEnterEventHandler,\n\tTLEventHandlers,\n\tTLKeyboardEvent,\n\tTLPointerEventInfo,\n} from '../../../types/event-types'\nimport { StateNode } from '../../StateNode'\n\nexport class DraggingHandle extends StateNode {\n\tstatic id = 'dragging_handle'\n\n\tshapeId = '' as TLShapeId\n\tinitialHandle = {} as TLHandle\n\tinitialAdjacentHandle = null as TLHandle | null\n\n\tmarkId = ''\n\tinitialPageTransform: any\n\tinitialPageRotation: any\n\n\tinfo = {} as TLPointerEventInfo & {\n\t\tshape: TLArrowShape\n\t\ttarget: 'handle'\n\t\tonInteractionEnd?: string\n\t\tisCreating: boolean\n\t}\n\n\tisPrecise = false\n\tisPreciseId = null as TLShapeId | null\n\tpointingId = null as TLShapeId | null\n\n\tonEnter: TLEnterEventHandler = (\n\t\tinfo: TLPointerEventInfo & {\n\t\t\tshape: TLArrowShape\n\t\t\ttarget: 'handle'\n\t\t\tonInteractionEnd?: string\n\t\t\tisCreating: boolean\n\t\t}\n\t) => {\n\t\tconst { shape, isCreating, handle } = info\n\t\tthis.info = info\n\t\tthis.shapeId = shape.id\n\t\tthis.markId = isCreating ? 'creating' : this.editor.mark('dragging handle')\n\t\tthis.initialHandle = deepCopy(handle)\n\t\tthis.initialPageTransform = this.editor.getPageTransform(shape)!\n\t\tthis.initialPageRotation = this.editor.getPageRotation(shape)!\n\n\t\tthis.editor.setCursor({ type: isCreating ? 'cross' : 'grabbing', rotation: 0 })\n\n\t\t// <!-- Only relevant to arrows\n\t\tconst handles = this.editor.getShapeUtil(shape).handles(shape).sort(sortByIndex)\n\t\tconst index = handles.findIndex((h) => h.id === info.handle.id)\n\n\t\t// Find the adjacent handle\n\t\tthis.initialAdjacentHandle = null\n\n\t\t// Start from the handle and work forward\n\t\tfor (let i = index + 1; i < handles.length; i++) {\n\t\t\tconst handle = handles[i]\n\t\t\tif (handle.type === 'vertex' && handle.id !== 'middle' && handle.id !== info.handle.id) {\n\t\t\t\tthis.initialAdjacentHandle = handle\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\t// If still no handle, start from the end and work backward\n\t\tif (!this.initialAdjacentHandle) {\n\t\t\tfor (let i = handles.length - 1; i >= 0; i--) {\n\t\t\t\tconst handle = handles[i]\n\t\t\t\tif (handle.type === 'vertex' && handle.id !== 'middle' && handle.id !== info.handle.id) {\n\t\t\t\t\tthis.initialAdjacentHandle = handle\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst initialTerminal = shape.props[info.handle.id as 'start' | 'end']\n\n\t\tthis.isPrecise = false\n\n\t\tif (initialTerminal?.type === 'binding') {\n\t\t\tthis.editor.setHintingIds([initialTerminal.boundShapeId])\n\n\t\t\tthis.isPrecise = !Vec2d.Equals(initialTerminal.normalizedAnchor, { x: 0.5, y: 0.5 })\n\t\t\tif (this.isPrecise) {\n\t\t\t\tthis.isPreciseId = initialTerminal.boundShapeId\n\t\t\t} else {\n\t\t\t\tthis.resetExactTimeout()\n\t\t\t}\n\t\t}\n\t\t// -->\n\n\t\tthis.update()\n\t}\n\n\t// Only relevant to arrows\n\tprivate exactTimeout = -1 as any\n\n\t// Only relevant to arrows\n\tprivate resetExactTimeout() {\n\t\tif (this.exactTimeout !== -1) {\n\t\t\tthis.clearExactTimeout()\n\t\t}\n\n\t\tthis.exactTimeout = setTimeout(() => {\n\t\t\tif (this.isActive && !this.isPrecise) {\n\t\t\t\tthis.isPrecise = true\n\t\t\t\tthis.isPreciseId = this.pointingId\n\t\t\t\tthis.update()\n\t\t\t}\n\t\t\tthis.exactTimeout = -1\n\t\t}, 750)\n\t}\n\n\t// Only relevant to arrows\n\tprivate clearExactTimeout() {\n\t\tif (this.exactTimeout !== -1) {\n\t\t\tclearTimeout(this.exactTimeout)\n\t\t\tthis.exactTimeout = -1\n\t\t}\n\t}\n\n\tonPointerMove: TLEventHandlers['onPointerMove'] = () => {\n\t\tthis.update()\n\t}\n\n\tonKeyDown: TLKeyboardEvent | undefined = () => {\n\t\tthis.update()\n\t}\n\n\tonKeyUp: TLKeyboardEvent | undefined = () => {\n\t\tthis.update()\n\t}\n\n\tonPointerUp: TLEventHandlers['onPointerUp'] = () => {\n\t\tthis.complete()\n\t}\n\n\tonComplete: TLEventHandlers['onComplete'] = () => {\n\t\tthis.complete()\n\t}\n\n\tonCancel: TLCancelEvent = () => {\n\t\tthis.cancel()\n\t}\n\n\tonExit = () => {\n\t\tthis.editor.setHintingIds([])\n\t\tthis.editor.snaps.clear()\n\t\tthis.editor.setCursor({ type: 'default' })\n\t}\n\n\tprivate complete() {\n\t\tthis.editor.snaps.clear()\n\n\t\tconst { onInteractionEnd } = this.info\n\t\tif (this.editor.instanceState.isToolLocked && onInteractionEnd) {\n\t\t\t// Return to the tool that was active before this one,\n\t\t\t// but only if tool lock is turned on!\n\t\t\tthis.editor.setSelectedTool(onInteractionEnd, { shapeId: this.shapeId })\n\t\t\treturn\n\t\t}\n\n\t\tthis.parent.transition('idle', {})\n\t}\n\n\tprivate cancel() {\n\t\tthis.editor.bailToMark(this.markId)\n\t\tthis.editor.snaps.clear()\n\n\t\tconst { onInteractionEnd } = this.info\n\t\tif (onInteractionEnd) {\n\t\t\t// Return to the tool that was active before this one,\n\t\t\t// whether tool lock is turned on or not!\n\t\t\tthis.editor.setSelectedTool(onInteractionEnd, { shapeId: this.shapeId })\n\t\t\treturn\n\t\t}\n\n\t\tthis.parent.transition('idle', {})\n\t}\n\n\tprivate update() {\n\t\tconst { editor, shapeId } = this\n\t\tconst { initialHandle, initialPageRotation, initialAdjacentHandle } = this\n\t\tconst {\n\t\t\tisSnapMode,\n\t\t\thintingIds,\n\t\t\tsnaps,\n\t\t\tinputs: { currentPagePoint, originPagePoint, shiftKey, ctrlKey, altKey, pointerVelocity },\n\t\t} = editor\n\n\t\tconst shape = editor.getShapeById(shapeId)\n\t\tif (!shape) return\n\n\t\tconst util = editor.getShapeUtil(shape)\n\n\t\tlet point = currentPagePoint\n\t\t\t.clone()\n\t\t\t.sub(originPagePoint)\n\t\t\t.rot(-initialPageRotation)\n\t\t\t.add(initialHandle)\n\n\t\tif (shiftKey && initialAdjacentHandle && initialHandle.id !== 'middle') {\n\t\t\tconst angle = Vec2d.Angle(initialAdjacentHandle, point)\n\t\t\tconst snappedAngle = snapAngle(angle, 24)\n\t\t\tconst angleDifference = snappedAngle - angle\n\t\t\tpoint = Vec2d.RotWith(point, initialAdjacentHandle, angleDifference)\n\t\t}\n\n\t\t// Clear any existing snaps\n\t\teditor.snaps.clear()\n\n\t\tif (isSnapMode ? !ctrlKey : ctrlKey) {\n\t\t\t// We're snapping\n\t\t\tconst pageTransform = editor.getPageTransformById(shape.id)\n\t\t\tif (!pageTransform) throw Error('Expected a page transform')\n\n\t\t\t// Get all the outline segments from the shape\n\t\t\tconst additionalSegments = util\n\t\t\t\t.outlineSegments(shape)\n\t\t\t\t.map((segment) => Matrix2d.applyToPoints(pageTransform, segment))\n\n\t\t\t// We want to skip the segments that include the handle, so\n\t\t\t// find the index of the handle that shares the same index property\n\t\t\t// as the initial dragging handle; this catches a quirk of create handles\n\t\t\tconst handleIndex = util\n\t\t\t\t.handles(shape)\n\t\t\t\t.filter(({ type }) => type === 'vertex')\n\t\t\t\t.sort(sortByIndex)\n\t\t\t\t.findIndex(({ index }) => initialHandle.index === index)\n\n\t\t\tadditionalSegments.splice(handleIndex - 1, 2)\n\n\t\t\tconst snapDelta = snaps.getSnappingHandleDelta({\n\t\t\t\tadditionalSegments,\n\t\t\t\thandlePoint: Matrix2d.applyToPoint(pageTransform, point),\n\t\t\t})\n\n\t\t\tif (snapDelta) {\n\t\t\t\tpoint.add(editor.getDeltaInShapeSpace(shape, snapDelta))\n\t\t\t}\n\t\t}\n\n\t\tconst changes = util.onHandleChange?.(shape, {\n\t\t\thandle: {\n\t\t\t\t...initialHandle,\n\t\t\t\tx: point.x,\n\t\t\t\ty: point.y,\n\t\t\t},\n\t\t\tisPrecise: this.isPrecise || altKey,\n\t\t})\n\n\t\tconst next: TLShapePartial<any> = { ...shape, ...changes }\n\n\t\t// Arrows\n\t\tif (initialHandle.canBind) {\n\t\t\tconst bindingAfter = (next.props as any)[initialHandle.id] as TLArrowShapeTerminal | undefined\n\n\t\t\tif (bindingAfter?.type === 'binding') {\n\t\t\t\tif (hintingIds[0] !== bindingAfter.boundShapeId) {\n\t\t\t\t\teditor.setHintingIds([bindingAfter.boundShapeId])\n\t\t\t\t\tthis.pointingId = bindingAfter.boundShapeId\n\t\t\t\t\tthis.isPrecise = pointerVelocity.len() < 0.5 || altKey\n\t\t\t\t\tthis.isPreciseId = this.isPrecise ? bindingAfter.boundShapeId : null\n\t\t\t\t\tthis.resetExactTimeout()\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (hintingIds.length > 0) {\n\t\t\t\t\teditor.setHintingIds([])\n\t\t\t\t\tthis.pointingId = null\n\t\t\t\t\tthis.isPrecise = false\n\t\t\t\t\tthis.isPreciseId = null\n\t\t\t\t\tthis.resetExactTimeout()\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (changes) {\n\t\t\teditor.updateShapes([next], true)\n\t\t}\n\t}\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}