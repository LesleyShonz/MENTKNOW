{"ast":null,"code":"import _classCallCheck from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _defineProperty from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _toConsumableArray from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _createForOfIteratorHelper from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __decorateClass = function __decorateClass(decorators, target, key, kind) {\n  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;\n  for (var i = decorators.length - 1, decorator; i >= 0; i--) if (decorator = decorators[i]) result = (kind ? decorator(target, key, result) : decorator(result)) || result;\n  if (kind && result) __defProp(target, key, result);\n  return result;\n};\nimport { Box2d, flipSelectionHandleX, flipSelectionHandleY, isSelectionCorner, Matrix2d, rangeIntersection, rangesOverlap, Vec2d } from \"@tldraw/primitives\";\nimport { dedupe, deepCopy } from \"@tldraw/utils\";\nimport { atom, computed, EMPTY_ARRAY } from \"signia\";\nimport { uniqueId } from \"../../utils/data.mjs\";\nimport { GroupShapeUtil } from \"../shapes/group/GroupShapeUtil.mjs\";\nvar round = function round(x) {\n  var decimalPlacesTolerance = 8;\n  return Math.round(x * Math.pow(10, decimalPlacesTolerance)) / Math.pow(10, decimalPlacesTolerance);\n};\nfunction findAdjacentGaps(gaps, shapeId, gapLength, direction, intersection, depth) {\n  if (depth > 20) return [];\n  var matches = gaps.filter(function (gap) {\n    return (direction === \"forward\" ? gap.startNode.id === shapeId : gap.endNode.id === shapeId) && round(gap.length) === round(gapLength) && rangeIntersection(gap.breadthIntersection[0], gap.breadthIntersection[1], intersection[0], intersection[1]);\n  });\n  if (matches.length === 0) return [];\n  var nextNodes = /* @__PURE__ */new Set();\n  var _iterator = _createForOfIteratorHelper(matches),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var match = _step.value;\n      var node = direction === \"forward\" ? match.endNode.id : match.startNode.id;\n      if (!nextNodes.has(node)) {\n        nextNodes.add(node);\n        matches.push.apply(matches, _toConsumableArray(findAdjacentGaps(gaps, node, gapLength, direction, rangeIntersection(match.breadthIntersection[0], match.breadthIntersection[1], intersection[0], intersection[1]), depth + 1)));\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return matches;\n}\nfunction dedupeGapSnaps(snaps) {\n  snaps.sort(function (a, b) {\n    return b.gaps.length - a.gaps.length;\n  });\n  for (var i = snaps.length - 1; i > 0; i--) {\n    var snap = snaps[i];\n    var _loop = function _loop() {\n      var otherSnap = snaps[j];\n      if (otherSnap.direction === snap.direction && snap.gaps.every(function (gap) {\n        return otherSnap.gaps.some(function (otherGap) {\n          return round(gap.startEdge[0].x) === round(otherGap.startEdge[0].x) && round(gap.startEdge[0].y) === round(otherGap.startEdge[0].y) && round(gap.startEdge[1].x) === round(otherGap.startEdge[1].x) && round(gap.startEdge[1].y) === round(otherGap.startEdge[1].y);\n        }) && otherSnap.gaps.some(function (otherGap) {\n          return round(gap.endEdge[0].x) === round(otherGap.endEdge[0].x) && round(gap.endEdge[0].y) === round(otherGap.endEdge[0].y) && round(gap.endEdge[1].x) === round(otherGap.endEdge[1].x) && round(gap.endEdge[1].y) === round(otherGap.endEdge[1].y);\n        });\n      })) {\n        snaps.splice(i, 1);\n        return 1; // break\n      }\n    };\n    for (var j = i - 1; j >= 0; j--) {\n      if (_loop()) break;\n    }\n  }\n}\nvar SnapManager = /*#__PURE__*/function () {\n  function SnapManager(editor) {\n    _classCallCheck(this, SnapManager);\n    _defineProperty(this, \"_snapLines\", atom(\"snapLines\", void 0));\n    this.editor = editor;\n  }\n  _createClass(SnapManager, [{\n    key: \"lines\",\n    get: function get() {\n      var _this$_snapLines$valu;\n      return (_this$_snapLines$valu = this._snapLines.value) !== null && _this$_snapLines$valu !== void 0 ? _this$_snapLines$valu : EMPTY_ARRAY;\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      if (this.lines.length) {\n        this._snapLines.set(void 0);\n      }\n    }\n  }, {\n    key: \"setLines\",\n    value: function setLines(lines) {\n      this._snapLines.set(lines);\n    }\n  }, {\n    key: \"snapPointsCache\",\n    get: function get() {\n      var _this = this;\n      return this.editor.store.createComputedCache(\"snapPoints\", function (shape) {\n        var pageTransfrorm = _this.editor.getPageTransformById(shape.id);\n        if (!pageTransfrorm) return void 0;\n        var util = _this.editor.getShapeUtil(shape);\n        var snapPoints = util.snapPoints(shape);\n        return snapPoints.map(function (point, i) {\n          var _Matrix2d$applyToPoin = Matrix2d.applyToPoint(pageTransfrorm, point),\n            x = _Matrix2d$applyToPoin.x,\n            y = _Matrix2d$applyToPoin.y;\n          return {\n            x: x,\n            y: y,\n            id: \"\".concat(shape.id, \":\").concat(i)\n          };\n        });\n      });\n    }\n  }, {\n    key: \"snapThreshold\",\n    get: function get() {\n      return 8 / this.editor.zoomLevel;\n    }\n  }, {\n    key: \"snappableShapes\",\n    get: function get() {\n      var _this$currentCommonAn;\n      var editor = this.editor;\n      var selectedIds = editor.selectedIds,\n        renderingBounds = editor.renderingBounds;\n      var snappableShapes = [];\n      var collectSnappableShapesFromParent = function collectSnappableShapesFromParent(parentId) {\n        var sortedChildIds = editor.getSortedChildIds(parentId);\n        var _iterator2 = _createForOfIteratorHelper(sortedChildIds),\n          _step2;\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var childId = _step2.value;\n            if (selectedIds.includes(childId)) continue;\n            var childShape = editor.getShapeById(childId);\n            if (!childShape) continue;\n            var util = editor.getShapeUtil(childShape);\n            if (!util.canSnap(childShape)) continue;\n            var pageBounds = editor.getPageBoundsById(childId);\n            if (!(pageBounds && renderingBounds.includes(pageBounds))) continue;\n            if (editor.isShapeOfType(childShape, GroupShapeUtil)) {\n              collectSnappableShapesFromParent(childId);\n              continue;\n            }\n            snappableShapes.push({\n              id: childId,\n              pageBounds: pageBounds,\n              isClosed: util.isClosed(childShape)\n            });\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      };\n      collectSnappableShapesFromParent((_this$currentCommonAn = this.currentCommonAncestor) !== null && _this$currentCommonAn !== void 0 ? _this$currentCommonAn : editor.currentPageId);\n      return snappableShapes;\n    }\n  }, {\n    key: \"currentCommonAncestor\",\n    get: function get() {\n      return this.editor.findCommonAncestor(this.editor.selectedShapes);\n    }\n  }, {\n    key: \"snappablePoints\",\n    get: function get() {\n      var snappableShapes = this.snappableShapes,\n        snapPointsCache = this.snapPointsCache;\n      var result = [];\n      snappableShapes.forEach(function (shape) {\n        var snapPoints = snapPointsCache.get(shape.id);\n        if (snapPoints) {\n          result.push.apply(result, _toConsumableArray(snapPoints));\n        }\n      });\n      return result;\n    }\n  }, {\n    key: \"visibleGaps\",\n    get: function get() {\n      var horizontal = [];\n      var vertical = [];\n      var startNode, endNode;\n      var sortedShapesHorizontal = this.snappableShapes.sort(function (a, b) {\n        return a.pageBounds.minX - b.pageBounds.minX;\n      });\n      for (var i = 0; i < sortedShapesHorizontal.length; i++) {\n        startNode = sortedShapesHorizontal[i];\n        for (var j = i + 1; j < sortedShapesHorizontal.length; j++) {\n          endNode = sortedShapesHorizontal[j];\n          if (\n          // is there space between the boxes\n          startNode.pageBounds.maxX < endNode.pageBounds.minX &&\n          // and they overlap in the y axis\n          rangesOverlap(startNode.pageBounds.minY, startNode.pageBounds.maxY, endNode.pageBounds.minY, endNode.pageBounds.maxY)) {\n            horizontal.push({\n              startNode: startNode,\n              endNode: endNode,\n              startEdge: [new Vec2d(startNode.pageBounds.maxX, startNode.pageBounds.minY), new Vec2d(startNode.pageBounds.maxX, startNode.pageBounds.maxY)],\n              endEdge: [new Vec2d(endNode.pageBounds.minX, endNode.pageBounds.minY), new Vec2d(endNode.pageBounds.minX, endNode.pageBounds.maxY)],\n              length: endNode.pageBounds.minX - startNode.pageBounds.maxX,\n              breadthIntersection: rangeIntersection(startNode.pageBounds.minY, startNode.pageBounds.maxY, endNode.pageBounds.minY, endNode.pageBounds.maxY)\n            });\n          }\n        }\n      }\n      var sortedShapesVertical = sortedShapesHorizontal.sort(function (a, b) {\n        return a.pageBounds.minY - b.pageBounds.minY;\n      });\n      for (var _i = 0; _i < sortedShapesVertical.length; _i++) {\n        startNode = sortedShapesVertical[_i];\n        for (var _j = _i + 1; _j < sortedShapesVertical.length; _j++) {\n          endNode = sortedShapesVertical[_j];\n          if (\n          // is there space between the boxes\n          startNode.pageBounds.maxY < endNode.pageBounds.minY &&\n          // do they overlap in the x axis\n          rangesOverlap(startNode.pageBounds.minX, startNode.pageBounds.maxX, endNode.pageBounds.minX, endNode.pageBounds.maxX)) {\n            vertical.push({\n              startNode: startNode,\n              endNode: endNode,\n              startEdge: [new Vec2d(startNode.pageBounds.minX, startNode.pageBounds.maxY), new Vec2d(startNode.pageBounds.maxX, startNode.pageBounds.maxY)],\n              endEdge: [new Vec2d(endNode.pageBounds.minX, endNode.pageBounds.minY), new Vec2d(endNode.pageBounds.maxX, endNode.pageBounds.minY)],\n              length: endNode.pageBounds.minY - startNode.pageBounds.maxY,\n              breadthIntersection: rangeIntersection(startNode.pageBounds.minX, startNode.pageBounds.maxX, endNode.pageBounds.minX, endNode.pageBounds.maxX)\n            });\n          }\n        }\n      }\n      return {\n        horizontal: horizontal,\n        vertical: vertical\n      };\n    }\n  }, {\n    key: \"snapTranslate\",\n    value: function snapTranslate(_ref) {\n      var _nearestSnapsX$0$nudg, _nearestSnapsX$, _nearestSnapsY$0$nudg, _nearestSnapsY$;\n      var lockedAxis = _ref.lockedAxis,\n        initialSelectionPageBounds = _ref.initialSelectionPageBounds,\n        initialSelectionSnapPoints = _ref.initialSelectionSnapPoints,\n        dragDelta = _ref.dragDelta;\n      var visibleSnapPointsNotInSelection = this.snappablePoints,\n        snapThreshold = this.snapThreshold;\n      var selectionPageBounds = initialSelectionPageBounds.clone().translate(dragDelta);\n      var selectionSnapPoints = initialSelectionSnapPoints.map(function (_ref2, i) {\n        var x = _ref2.x,\n          y = _ref2.y;\n        return {\n          id: \"selection:\" + i,\n          x: x + dragDelta.x,\n          y: y + dragDelta.y\n        };\n      });\n      var otherNodeSnapPoints = visibleSnapPointsNotInSelection;\n      var nearestSnapsX = [];\n      var nearestSnapsY = [];\n      var minOffset = new Vec2d(snapThreshold, snapThreshold);\n      this.collectPointSnaps({\n        minOffset: minOffset,\n        nearestSnapsX: nearestSnapsX,\n        nearestSnapsY: nearestSnapsY,\n        otherNodeSnapPoints: otherNodeSnapPoints,\n        selectionSnapPoints: selectionSnapPoints\n      });\n      this.collectGapSnaps({\n        selectionPageBounds: selectionPageBounds,\n        nearestSnapsX: nearestSnapsX,\n        nearestSnapsY: nearestSnapsY,\n        minOffset: minOffset\n      });\n      var nudge = new Vec2d(lockedAxis === \"x\" ? 0 : (_nearestSnapsX$0$nudg = (_nearestSnapsX$ = nearestSnapsX[0]) === null || _nearestSnapsX$ === void 0 ? void 0 : _nearestSnapsX$.nudge) !== null && _nearestSnapsX$0$nudg !== void 0 ? _nearestSnapsX$0$nudg : 0, lockedAxis === \"y\" ? 0 : (_nearestSnapsY$0$nudg = (_nearestSnapsY$ = nearestSnapsY[0]) === null || _nearestSnapsY$ === void 0 ? void 0 : _nearestSnapsY$.nudge) !== null && _nearestSnapsY$0$nudg !== void 0 ? _nearestSnapsY$0$nudg : 0);\n      minOffset.x = 0;\n      minOffset.y = 0;\n      nearestSnapsX.length = 0;\n      nearestSnapsY.length = 0;\n      selectionSnapPoints.forEach(function (s) {\n        s.x += nudge.x;\n        s.y += nudge.y;\n      });\n      selectionPageBounds.translate(nudge);\n      this.collectPointSnaps({\n        minOffset: minOffset,\n        nearestSnapsX: nearestSnapsX,\n        nearestSnapsY: nearestSnapsY,\n        otherNodeSnapPoints: otherNodeSnapPoints,\n        selectionSnapPoints: selectionSnapPoints\n      });\n      this.collectGapSnaps({\n        selectionPageBounds: selectionPageBounds,\n        nearestSnapsX: nearestSnapsX,\n        nearestSnapsY: nearestSnapsY,\n        minOffset: minOffset\n      });\n      var pointSnapsLines = this.getPointSnapLines({\n        nearestSnapsX: nearestSnapsX,\n        nearestSnapsY: nearestSnapsY\n      });\n      var gapSnapLines = this.getGapSnapLines({\n        selectionPageBounds: selectionPageBounds,\n        nearestSnapsX: nearestSnapsX,\n        nearestSnapsY: nearestSnapsY\n      });\n      this._snapLines.set([].concat(_toConsumableArray(gapSnapLines), _toConsumableArray(pointSnapsLines)));\n      return {\n        nudge: nudge\n      };\n    }\n  }, {\n    key: \"outlinesInPageSpace\",\n    get: function get() {\n      var _this2 = this;\n      return this.snappableShapes.map(function (_ref3) {\n        var id = _ref3.id,\n          isClosed = _ref3.isClosed;\n        var outline = deepCopy(_this2.editor.getOutlineById(id));\n        if (isClosed) outline.push(outline[0]);\n        var pageTransform = _this2.editor.getPageTransformById(id);\n        if (!pageTransform) throw Error(\"No page transform\");\n        return Matrix2d.applyToPoints(pageTransform, outline);\n      });\n    }\n  }, {\n    key: \"getSnappingHandleDelta\",\n    value: function getSnappingHandleDelta(_ref4) {\n      var handlePoint = _ref4.handlePoint,\n        additionalSegments = _ref4.additionalSegments;\n      var outlinesInPageSpace = this.outlinesInPageSpace,\n        snapThreshold = this.snapThreshold;\n      var minDistance = snapThreshold;\n      var nearestPoint = null;\n      var C, D, nearest, distance;\n      var allSegments = [].concat(_toConsumableArray(outlinesInPageSpace), _toConsumableArray(additionalSegments));\n      var _iterator3 = _createForOfIteratorHelper(allSegments),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var outline = _step3.value;\n          for (var i = 0; i < outline.length - 1; i++) {\n            C = outline[i];\n            D = outline[i + 1];\n            nearest = Vec2d.NearestPointOnLineSegment(C, D, handlePoint);\n            distance = Vec2d.Dist(handlePoint, nearest);\n            if (isNaN(distance)) continue;\n            if (distance < minDistance) {\n              minDistance = distance;\n              nearestPoint = nearest;\n            }\n          }\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n      if (nearestPoint) {\n        this._snapLines.set([{\n          id: uniqueId(),\n          type: \"points\",\n          points: [nearestPoint]\n        }]);\n        return Vec2d.Sub(nearestPoint, handlePoint);\n      }\n      return null;\n    }\n  }, {\n    key: \"snapResize\",\n    value: function snapResize(_ref5) {\n      var _nearestSnapsX$0$nudg2, _nearestSnapsX$2, _nearestSnapsY$0$nudg2, _nearestSnapsY$2;\n      var initialSelectionPageBounds = _ref5.initialSelectionPageBounds,\n        dragDelta = _ref5.dragDelta,\n        originalHandle = _ref5.handle,\n        isAspectRatioLocked = _ref5.isAspectRatioLocked,\n        isResizingFromCenter = _ref5.isResizingFromCenter;\n      var snapThreshold = this.snapThreshold;\n      var _Box2d$Resize = Box2d.Resize(initialSelectionPageBounds, originalHandle, isResizingFromCenter ? dragDelta.x * 2 : dragDelta.x, isResizingFromCenter ? dragDelta.y * 2 : dragDelta.y, isAspectRatioLocked),\n        unsnappedResizedPageBounds = _Box2d$Resize.box,\n        scaleX = _Box2d$Resize.scaleX,\n        scaleY = _Box2d$Resize.scaleY;\n      var handle = originalHandle;\n      if (scaleX < 0) {\n        handle = flipSelectionHandleX(handle);\n      }\n      if (scaleY < 0) {\n        handle = flipSelectionHandleY(handle);\n      }\n      if (isResizingFromCenter) {\n        unsnappedResizedPageBounds.center = initialSelectionPageBounds.center;\n      }\n      var isXLocked = handle === \"top\" || handle === \"bottom\";\n      var isYLocked = handle === \"left\" || handle === \"right\";\n      var selectionSnapPoints = getResizeSnapPointsForHandle(handle, unsnappedResizedPageBounds);\n      var otherNodeSnapPoints = this.snappablePoints;\n      var nearestSnapsX = [];\n      var nearestSnapsY = [];\n      var minOffset = new Vec2d(snapThreshold, snapThreshold);\n      this.collectPointSnaps({\n        minOffset: minOffset,\n        nearestSnapsX: nearestSnapsX,\n        nearestSnapsY: nearestSnapsY,\n        otherNodeSnapPoints: otherNodeSnapPoints,\n        selectionSnapPoints: selectionSnapPoints\n      });\n      var nudge = new Vec2d(isXLocked ? 0 : (_nearestSnapsX$0$nudg2 = (_nearestSnapsX$2 = nearestSnapsX[0]) === null || _nearestSnapsX$2 === void 0 ? void 0 : _nearestSnapsX$2.nudge) !== null && _nearestSnapsX$0$nudg2 !== void 0 ? _nearestSnapsX$0$nudg2 : 0, isYLocked ? 0 : (_nearestSnapsY$0$nudg2 = (_nearestSnapsY$2 = nearestSnapsY[0]) === null || _nearestSnapsY$2 === void 0 ? void 0 : _nearestSnapsY$2.nudge) !== null && _nearestSnapsY$0$nudg2 !== void 0 ? _nearestSnapsY$0$nudg2 : 0);\n      if (isAspectRatioLocked && isSelectionCorner(handle) && nudge.len() !== 0) {\n        var primaryNudgeAxis = nearestSnapsX.length && nearestSnapsY.length ? Math.abs(nudge.x) < Math.abs(nudge.y) ? \"x\" : \"y\" : nearestSnapsX.length ? \"x\" : \"y\";\n        var ratio = initialSelectionPageBounds.aspectRatio;\n        if (primaryNudgeAxis === \"x\") {\n          nearestSnapsY.length = 0;\n          nudge.y = nudge.x / ratio;\n          if (handle === \"bottom_left\" || handle === \"top_right\") {\n            nudge.y = -nudge.y;\n          }\n        } else {\n          nearestSnapsX.length = 0;\n          nudge.x = nudge.y * ratio;\n          if (handle === \"bottom_left\" || handle === \"top_right\") {\n            nudge.x = -nudge.x;\n          }\n        }\n      }\n      var snappedDelta = Vec2d.Add(dragDelta, nudge);\n      var _Box2d$Resize2 = Box2d.Resize(initialSelectionPageBounds, originalHandle, isResizingFromCenter ? snappedDelta.x * 2 : snappedDelta.x, isResizingFromCenter ? snappedDelta.y * 2 : snappedDelta.y, isAspectRatioLocked),\n        snappedResizedPageBounds = _Box2d$Resize2.box;\n      if (isResizingFromCenter) {\n        snappedResizedPageBounds.center = initialSelectionPageBounds.center;\n      }\n      var snappedSelectionPoints = getResizeSnapPointsForHandle(\"any\", snappedResizedPageBounds);\n      nearestSnapsX.length = 0;\n      nearestSnapsY.length = 0;\n      minOffset.x = 0;\n      minOffset.y = 0;\n      this.collectPointSnaps({\n        minOffset: minOffset,\n        nearestSnapsX: nearestSnapsX,\n        nearestSnapsY: nearestSnapsY,\n        otherNodeSnapPoints: otherNodeSnapPoints,\n        selectionSnapPoints: snappedSelectionPoints\n      });\n      var pointSnaps = this.getPointSnapLines({\n        nearestSnapsX: nearestSnapsX,\n        nearestSnapsY: nearestSnapsY\n      });\n      this._snapLines.set(_toConsumableArray(pointSnaps));\n      return {\n        nudge: nudge\n      };\n    }\n  }, {\n    key: \"collectPointSnaps\",\n    value: function collectPointSnaps(_ref6) {\n      var selectionSnapPoints = _ref6.selectionSnapPoints,\n        otherNodeSnapPoints = _ref6.otherNodeSnapPoints,\n        minOffset = _ref6.minOffset,\n        nearestSnapsX = _ref6.nearestSnapsX,\n        nearestSnapsY = _ref6.nearestSnapsY;\n      var _iterator4 = _createForOfIteratorHelper(selectionSnapPoints),\n        _step4;\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var thisSnapPoint = _step4.value;\n          var _iterator5 = _createForOfIteratorHelper(otherNodeSnapPoints),\n            _step5;\n          try {\n            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n              var otherSnapPoint = _step5.value;\n              var offset = Vec2d.Sub(thisSnapPoint, otherSnapPoint);\n              var offsetX = Math.abs(offset.x);\n              var offsetY = Math.abs(offset.y);\n              if (round(offsetX) <= round(minOffset.x)) {\n                if (round(offsetX) < round(minOffset.x)) {\n                  nearestSnapsX.length = 0;\n                }\n                nearestSnapsX.push({\n                  type: \"points\",\n                  points: {\n                    thisPoint: thisSnapPoint,\n                    otherPoint: otherSnapPoint\n                  },\n                  nudge: otherSnapPoint.x - thisSnapPoint.x\n                });\n                minOffset.x = offsetX;\n              }\n              if (round(offsetY) <= round(minOffset.y)) {\n                if (round(offsetY) < round(minOffset.y)) {\n                  nearestSnapsY.length = 0;\n                }\n                nearestSnapsY.push({\n                  type: \"points\",\n                  points: {\n                    thisPoint: thisSnapPoint,\n                    otherPoint: otherSnapPoint\n                  },\n                  nudge: otherSnapPoint.y - thisSnapPoint.y\n                });\n                minOffset.y = offsetY;\n              }\n            }\n          } catch (err) {\n            _iterator5.e(err);\n          } finally {\n            _iterator5.f();\n          }\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n    }\n  }, {\n    key: \"collectGapSnaps\",\n    value: function collectGapSnaps(_ref7) {\n      var selectionPageBounds = _ref7.selectionPageBounds,\n        minOffset = _ref7.minOffset,\n        nearestSnapsX = _ref7.nearestSnapsX,\n        nearestSnapsY = _ref7.nearestSnapsY;\n      var _this$visibleGaps = this.visibleGaps,\n        horizontal = _this$visibleGaps.horizontal,\n        vertical = _this$visibleGaps.vertical;\n      var _iterator6 = _createForOfIteratorHelper(horizontal),\n        _step6;\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var gap = _step6.value;\n          if (!rangesOverlap(gap.breadthIntersection[0], gap.breadthIntersection[1], selectionPageBounds.minY, selectionPageBounds.maxY)) {\n            continue;\n          }\n          var gapMidX = gap.startEdge[0].x + gap.length / 2;\n          var centerNudge = gapMidX - selectionPageBounds.center.x;\n          var gapIsLargerThanSelection = gap.length > selectionPageBounds.width;\n          if (gapIsLargerThanSelection && round(Math.abs(centerNudge)) <= round(minOffset.x)) {\n            if (round(Math.abs(centerNudge)) < round(minOffset.x)) {\n              nearestSnapsX.length = 0;\n            }\n            minOffset.x = Math.abs(centerNudge);\n            var snap = {\n              type: \"gap_center\",\n              gap: gap,\n              nudge: centerNudge\n            };\n            var otherCenterSnap = nearestSnapsX.find(function (_ref8) {\n              var type = _ref8.type;\n              return type === \"gap_center\";\n            });\n            var gapBreadthsOverlap = otherCenterSnap && rangeIntersection(gap.breadthIntersection[0], gap.breadthIntersection[1], otherCenterSnap.gap.breadthIntersection[0], otherCenterSnap.gap.breadthIntersection[1]);\n            if (otherCenterSnap && otherCenterSnap.gap.length > gap.length && gapBreadthsOverlap) {\n              nearestSnapsX[nearestSnapsX.indexOf(otherCenterSnap)] = snap;\n            } else if (!otherCenterSnap || !gapBreadthsOverlap) {\n              nearestSnapsX.push(snap);\n            }\n          }\n          var duplicationLeftX = gap.startNode.pageBounds.minX - gap.length;\n          var selectionRightX = selectionPageBounds.maxX;\n          var duplicationLeftNudge = duplicationLeftX - selectionRightX;\n          if (round(Math.abs(duplicationLeftNudge)) <= round(minOffset.x)) {\n            if (round(Math.abs(duplicationLeftNudge)) < round(minOffset.x)) {\n              nearestSnapsX.length = 0;\n            }\n            minOffset.x = Math.abs(duplicationLeftNudge);\n            nearestSnapsX.push({\n              type: \"gap_duplicate\",\n              gap: gap,\n              protrusionDirection: \"left\",\n              nudge: duplicationLeftNudge\n            });\n          }\n          var duplicationRightX = gap.endNode.pageBounds.maxX + gap.length;\n          var selectionLeftX = selectionPageBounds.minX;\n          var duplicationRightNudge = duplicationRightX - selectionLeftX;\n          if (round(Math.abs(duplicationRightNudge)) <= round(minOffset.x)) {\n            if (round(Math.abs(duplicationRightNudge)) < round(minOffset.x)) {\n              nearestSnapsX.length = 0;\n            }\n            minOffset.x = Math.abs(duplicationRightNudge);\n            nearestSnapsX.push({\n              type: \"gap_duplicate\",\n              gap: gap,\n              protrusionDirection: \"right\",\n              nudge: duplicationRightNudge\n            });\n          }\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n      var _iterator7 = _createForOfIteratorHelper(vertical),\n        _step7;\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var _gap = _step7.value;\n          if (!rangesOverlap(_gap.breadthIntersection[0], _gap.breadthIntersection[1], selectionPageBounds.minX, selectionPageBounds.maxX)) {\n            continue;\n          }\n          var gapMidY = _gap.startEdge[0].y + _gap.length / 2;\n          var _centerNudge = gapMidY - selectionPageBounds.center.y;\n          var _gapIsLargerThanSelection = _gap.length > selectionPageBounds.height;\n          if (_gapIsLargerThanSelection && round(Math.abs(_centerNudge)) <= round(minOffset.y)) {\n            if (round(Math.abs(_centerNudge)) < round(minOffset.y)) {\n              nearestSnapsY.length = 0;\n            }\n            minOffset.y = Math.abs(_centerNudge);\n            var _snap = {\n              type: \"gap_center\",\n              gap: _gap,\n              nudge: _centerNudge\n            };\n            var _otherCenterSnap = nearestSnapsY.find(function (_ref9) {\n              var type = _ref9.type;\n              return type === \"gap_center\";\n            });\n            var _gapBreadthsOverlap = _otherCenterSnap && rangesOverlap(_otherCenterSnap.gap.breadthIntersection[0], _otherCenterSnap.gap.breadthIntersection[1], _gap.breadthIntersection[0], _gap.breadthIntersection[1]);\n            if (_otherCenterSnap && _otherCenterSnap.gap.length > _gap.length && _gapBreadthsOverlap) {\n              nearestSnapsY[nearestSnapsY.indexOf(_otherCenterSnap)] = _snap;\n            } else if (!_otherCenterSnap || !_gapBreadthsOverlap) {\n              nearestSnapsY.push(_snap);\n            }\n            continue;\n          }\n          var duplicationTopY = _gap.startNode.pageBounds.minY - _gap.length;\n          var selectionBottomY = selectionPageBounds.maxY;\n          var duplicationTopNudge = duplicationTopY - selectionBottomY;\n          if (round(Math.abs(duplicationTopNudge)) <= round(minOffset.y)) {\n            if (round(Math.abs(duplicationTopNudge)) < round(minOffset.y)) {\n              nearestSnapsY.length = 0;\n            }\n            minOffset.y = Math.abs(duplicationTopNudge);\n            nearestSnapsY.push({\n              type: \"gap_duplicate\",\n              gap: _gap,\n              protrusionDirection: \"top\",\n              nudge: duplicationTopNudge\n            });\n          }\n          var duplicationBottomY = _gap.endNode.pageBounds.maxY + _gap.length;\n          var selectionTopY = selectionPageBounds.minY;\n          var duplicationBottomNudge = duplicationBottomY - selectionTopY;\n          if (round(Math.abs(duplicationBottomNudge)) <= round(minOffset.y)) {\n            if (round(Math.abs(duplicationBottomNudge)) < round(minOffset.y)) {\n              nearestSnapsY.length = 0;\n            }\n            minOffset.y = Math.abs(duplicationBottomNudge);\n            nearestSnapsY.push({\n              type: \"gap_duplicate\",\n              gap: _gap,\n              protrusionDirection: \"bottom\",\n              nudge: duplicationBottomNudge\n            });\n          }\n        }\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n    }\n  }, {\n    key: \"getPointSnapLines\",\n    value: function getPointSnapLines(_ref10) {\n      var nearestSnapsX = _ref10.nearestSnapsX,\n        nearestSnapsY = _ref10.nearestSnapsY;\n      var snapGroupsX = {};\n      var snapGroupsY = {};\n      if (nearestSnapsX.length > 0) {\n        var _iterator8 = _createForOfIteratorHelper(nearestSnapsX),\n          _step8;\n        try {\n          for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n            var snap = _step8.value;\n            if (snap.type === \"points\") {\n              var key = round(snap.points.otherPoint.x);\n              if (!snapGroupsX[key]) {\n                snapGroupsX[key] = [];\n              }\n              snapGroupsX[key].push(snap.points);\n            }\n          }\n        } catch (err) {\n          _iterator8.e(err);\n        } finally {\n          _iterator8.f();\n        }\n      }\n      if (nearestSnapsY.length > 0) {\n        var _iterator9 = _createForOfIteratorHelper(nearestSnapsY),\n          _step9;\n        try {\n          for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n            var _snap2 = _step9.value;\n            if (_snap2.type === \"points\") {\n              var _key = round(_snap2.points.otherPoint.y);\n              if (!snapGroupsY[_key]) {\n                snapGroupsY[_key] = [];\n              }\n              snapGroupsY[_key].push(_snap2.points);\n            }\n          }\n        } catch (err) {\n          _iterator9.e(err);\n        } finally {\n          _iterator9.f();\n        }\n      }\n      return Object.values(snapGroupsX).concat(Object.values(snapGroupsY)).map(function (snapGroup) {\n        return {\n          id: uniqueId(),\n          type: \"points\",\n          points: dedupe(snapGroup.map(function (snap) {\n            return Vec2d.From(snap.otherPoint);\n          }).concat(snapGroup.map(function (snap) {\n            return Vec2d.From(snap.thisPoint);\n          })), function (a, b) {\n            return a.equals(b);\n          })\n        };\n      });\n    }\n  }, {\n    key: \"getGapSnapLines\",\n    value: function getGapSnapLines(_ref11) {\n      var selectionPageBounds = _ref11.selectionPageBounds,\n        nearestSnapsX = _ref11.nearestSnapsX,\n        nearestSnapsY = _ref11.nearestSnapsY;\n      var _this$visibleGaps2 = this.visibleGaps,\n        vertical = _this$visibleGaps2.vertical,\n        horizontal = _this$visibleGaps2.horizontal;\n      var selectionSides = {\n        top: selectionPageBounds.sides[0],\n        right: selectionPageBounds.sides[1],\n        // need bottom and left to be sorted asc, which .sides is not.\n        bottom: [selectionPageBounds.corners[3], selectionPageBounds.corners[2]],\n        left: [selectionPageBounds.corners[0], selectionPageBounds.corners[3]]\n      };\n      var result = [];\n      if (nearestSnapsX.length > 0) {\n        var _iterator10 = _createForOfIteratorHelper(nearestSnapsX),\n          _step10;\n        try {\n          var _loop2 = function _loop2() {\n            var snap = _step10.value;\n            if (snap.type === \"points\") return 1; // continue\n            var _snap$gap = snap.gap,\n              breadthIntersection = _snap$gap.breadthIntersection,\n              startEdge = _snap$gap.startEdge,\n              startNode = _snap$gap.startNode,\n              endNode = _snap$gap.endNode,\n              length = _snap$gap.length,\n              endEdge = _snap$gap.endEdge;\n            switch (snap.type) {\n              case \"gap_center\":\n                {\n                  var newGapsLength = (length - selectionPageBounds.width) / 2;\n                  var gapBreadthIntersection = rangeIntersection(breadthIntersection[0], breadthIntersection[1], selectionPageBounds.minY, selectionPageBounds.maxY);\n                  result.push({\n                    type: \"gaps\",\n                    direction: \"horizontal\",\n                    id: uniqueId(),\n                    gaps: [].concat(_toConsumableArray(findAdjacentGaps(horizontal, startNode.id, newGapsLength, \"backward\", gapBreadthIntersection, 0)), [{\n                      startEdge: startEdge,\n                      endEdge: selectionSides.left\n                    }, {\n                      startEdge: selectionSides.right,\n                      endEdge: endEdge\n                    }], _toConsumableArray(findAdjacentGaps(horizontal, endNode.id, newGapsLength, \"forward\", gapBreadthIntersection, 0)))\n                  });\n                  break;\n                }\n              case \"gap_duplicate\":\n                {\n                  var _gapBreadthIntersection = rangeIntersection(breadthIntersection[0], breadthIntersection[1], selectionPageBounds.minY, selectionPageBounds.maxY);\n                  result.push({\n                    type: \"gaps\",\n                    direction: \"horizontal\",\n                    id: uniqueId(),\n                    gaps: snap.protrusionDirection === \"left\" ? [{\n                      startEdge: selectionSides.right,\n                      endEdge: startEdge.map(function (v) {\n                        return v.clone().addXY(-startNode.pageBounds.width, 0);\n                      })\n                    }, {\n                      startEdge: startEdge,\n                      endEdge: endEdge\n                    }].concat(_toConsumableArray(findAdjacentGaps(horizontal, endNode.id, length, \"forward\", _gapBreadthIntersection, 0))) : [].concat(_toConsumableArray(findAdjacentGaps(horizontal, startNode.id, length, \"backward\", _gapBreadthIntersection, 0)), [{\n                      startEdge: startEdge,\n                      endEdge: endEdge\n                    }, {\n                      startEdge: endEdge.map(function (v) {\n                        return v.clone().addXY(snap.gap.endNode.pageBounds.width, 0);\n                      }),\n                      endEdge: selectionSides.left\n                    }])\n                  });\n                  break;\n                }\n            }\n          };\n          for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n            if (_loop2()) continue;\n          }\n        } catch (err) {\n          _iterator10.e(err);\n        } finally {\n          _iterator10.f();\n        }\n      }\n      if (nearestSnapsY.length > 0) {\n        var _iterator11 = _createForOfIteratorHelper(nearestSnapsY),\n          _step11;\n        try {\n          var _loop3 = function _loop3() {\n            var snap = _step11.value;\n            if (snap.type === \"points\") return 1; // continue\n            var _snap$gap2 = snap.gap,\n              breadthIntersection = _snap$gap2.breadthIntersection,\n              startEdge = _snap$gap2.startEdge,\n              startNode = _snap$gap2.startNode,\n              endNode = _snap$gap2.endNode,\n              length = _snap$gap2.length,\n              endEdge = _snap$gap2.endEdge;\n            switch (snap.type) {\n              case \"gap_center\":\n                {\n                  var newGapsLength = (length - selectionPageBounds.height) / 2;\n                  var gapBreadthIntersection = rangeIntersection(breadthIntersection[0], breadthIntersection[1], selectionPageBounds.minX, selectionPageBounds.maxX);\n                  result.push({\n                    type: \"gaps\",\n                    direction: \"vertical\",\n                    id: uniqueId(),\n                    gaps: [].concat(_toConsumableArray(findAdjacentGaps(vertical, startNode.id, newGapsLength, \"backward\", gapBreadthIntersection, 0)), [{\n                      startEdge: startEdge,\n                      endEdge: selectionSides.top\n                    }, {\n                      startEdge: selectionSides.bottom,\n                      endEdge: endEdge\n                    }], _toConsumableArray(findAdjacentGaps(vertical, snap.gap.endNode.id, newGapsLength, \"forward\", gapBreadthIntersection, 0)))\n                  });\n                  break;\n                }\n              case \"gap_duplicate\":\n                {\n                  var _gapBreadthIntersection2 = rangeIntersection(breadthIntersection[0], breadthIntersection[1], selectionPageBounds.minX, selectionPageBounds.maxX);\n                  result.push({\n                    type: \"gaps\",\n                    direction: \"vertical\",\n                    id: uniqueId(),\n                    gaps: snap.protrusionDirection === \"top\" ? [{\n                      startEdge: selectionSides.bottom,\n                      endEdge: startEdge.map(function (v) {\n                        return v.clone().addXY(0, -startNode.pageBounds.height);\n                      })\n                    }, {\n                      startEdge: startEdge,\n                      endEdge: endEdge\n                    }].concat(_toConsumableArray(findAdjacentGaps(vertical, endNode.id, length, \"forward\", _gapBreadthIntersection2, 0))) : [].concat(_toConsumableArray(findAdjacentGaps(vertical, startNode.id, length, \"backward\", _gapBreadthIntersection2, 0)), [{\n                      startEdge: startEdge,\n                      endEdge: endEdge\n                    }, {\n                      startEdge: endEdge.map(function (v) {\n                        return v.clone().addXY(0, endNode.pageBounds.height);\n                      }),\n                      endEdge: selectionSides.top\n                    }])\n                  });\n                }\n                break;\n            }\n          };\n          for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n            if (_loop3()) continue;\n          }\n        } catch (err) {\n          _iterator11.e(err);\n        } finally {\n          _iterator11.f();\n        }\n      }\n      dedupeGapSnaps(result);\n      return result;\n    }\n  }]);\n  return SnapManager;\n}();\n__decorateClass([computed], SnapManager.prototype, \"snapPointsCache\", 1);\n__decorateClass([computed], SnapManager.prototype, \"snapThreshold\", 1);\n__decorateClass([computed], SnapManager.prototype, \"snappableShapes\", 1);\n__decorateClass([computed], SnapManager.prototype, \"currentCommonAncestor\", 1);\n__decorateClass([computed], SnapManager.prototype, \"snappablePoints\", 1);\n__decorateClass([computed], SnapManager.prototype, \"visibleGaps\", 1);\n__decorateClass([computed], SnapManager.prototype, \"outlinesInPageSpace\", 1);\nfunction getResizeSnapPointsForHandle(handle, selectionPageBounds) {\n  var minX = selectionPageBounds.minX,\n    maxX = selectionPageBounds.maxX,\n    minY = selectionPageBounds.minY,\n    maxY = selectionPageBounds.maxY;\n  var result = [];\n  switch (handle) {\n    case \"top\":\n    case \"left\":\n    case \"top_left\":\n    case \"any\":\n      result.push({\n        id: \"top_left\",\n        handle: \"top_left\",\n        x: minX,\n        y: minY\n      });\n  }\n  switch (handle) {\n    case \"top\":\n    case \"right\":\n    case \"top_right\":\n    case \"any\":\n      result.push({\n        id: \"top_right\",\n        handle: \"top_right\",\n        x: maxX,\n        y: minY\n      });\n  }\n  switch (handle) {\n    case \"bottom\":\n    case \"right\":\n    case \"bottom_right\":\n    case \"any\":\n      result.push({\n        id: \"bottom_right\",\n        handle: \"bottom_right\",\n        x: maxX,\n        y: maxY\n      });\n  }\n  switch (handle) {\n    case \"bottom\":\n    case \"left\":\n    case \"bottom_left\":\n    case \"any\":\n      result.push({\n        id: \"bottom_left\",\n        handle: \"bottom_left\",\n        x: minX,\n        y: maxY\n      });\n  }\n  return result;\n}\nexport { SnapManager };","map":{"version":3,"names":["Box2d","flipSelectionHandleX","flipSelectionHandleY","isSelectionCorner","Matrix2d","rangeIntersection","rangesOverlap","Vec2d","dedupe","deepCopy","atom","computed","EMPTY_ARRAY","uniqueId","GroupShapeUtil","round","x","decimalPlacesTolerance","Math","pow","findAdjacentGaps","gaps","shapeId","gapLength","direction","intersection","depth","matches","filter","gap","startNode","id","endNode","length","breadthIntersection","nextNodes","Set","_iterator","_createForOfIteratorHelper","_step","s","n","done","match","value","node","has","add","push","apply","_toConsumableArray","err","e","f","dedupeGapSnaps","snaps","sort","a","b","i","snap","_loop","otherSnap","j","every","some","otherGap","startEdge","y","endEdge","splice","SnapManager","editor","_classCallCheck","_defineProperty","_createClass","key","get","_this$_snapLines$valu","_snapLines","clear","lines","set","setLines","_this","store","createComputedCache","shape","pageTransfrorm","getPageTransformById","util","getShapeUtil","snapPoints","map","point","_Matrix2d$applyToPoin","applyToPoint","concat","zoomLevel","_this$currentCommonAn","selectedIds","renderingBounds","snappableShapes","collectSnappableShapesFromParent","parentId","sortedChildIds","getSortedChildIds","_iterator2","_step2","childId","includes","childShape","getShapeById","canSnap","pageBounds","getPageBoundsById","isShapeOfType","isClosed","currentCommonAncestor","currentPageId","findCommonAncestor","selectedShapes","snapPointsCache","result","forEach","horizontal","vertical","sortedShapesHorizontal","minX","maxX","minY","maxY","sortedShapesVertical","snapTranslate","_ref","_nearestSnapsX$0$nudg","_nearestSnapsX$","_nearestSnapsY$0$nudg","_nearestSnapsY$","lockedAxis","initialSelectionPageBounds","initialSelectionSnapPoints","dragDelta","visibleSnapPointsNotInSelection","snappablePoints","snapThreshold","selectionPageBounds","clone","translate","selectionSnapPoints","_ref2","otherNodeSnapPoints","nearestSnapsX","nearestSnapsY","minOffset","collectPointSnaps","collectGapSnaps","nudge","pointSnapsLines","getPointSnapLines","gapSnapLines","getGapSnapLines","_this2","_ref3","outline","getOutlineById","pageTransform","Error","applyToPoints","getSnappingHandleDelta","_ref4","handlePoint","additionalSegments","outlinesInPageSpace","minDistance","nearestPoint","C","D","nearest","distance","allSegments","_iterator3","_step3","NearestPointOnLineSegment","Dist","isNaN","type","points","Sub","snapResize","_ref5","_nearestSnapsX$0$nudg2","_nearestSnapsX$2","_nearestSnapsY$0$nudg2","_nearestSnapsY$2","originalHandle","handle","isAspectRatioLocked","isResizingFromCenter","_Box2d$Resize","Resize","unsnappedResizedPageBounds","box","scaleX","scaleY","center","isXLocked","isYLocked","getResizeSnapPointsForHandle","len","primaryNudgeAxis","abs","ratio","aspectRatio","snappedDelta","Add","_Box2d$Resize2","snappedResizedPageBounds","snappedSelectionPoints","pointSnaps","_ref6","_iterator4","_step4","thisSnapPoint","_iterator5","_step5","otherSnapPoint","offset","offsetX","offsetY","thisPoint","otherPoint","_ref7","_this$visibleGaps","visibleGaps","_iterator6","_step6","gapMidX","centerNudge","gapIsLargerThanSelection","width","otherCenterSnap","find","_ref8","gapBreadthsOverlap","indexOf","duplicationLeftX","selectionRightX","duplicationLeftNudge","protrusionDirection","duplicationRightX","selectionLeftX","duplicationRightNudge","_iterator7","_step7","gapMidY","height","_ref9","duplicationTopY","selectionBottomY","duplicationTopNudge","duplicationBottomY","selectionTopY","duplicationBottomNudge","_ref10","snapGroupsX","snapGroupsY","_iterator8","_step8","_iterator9","_step9","Object","values","snapGroup","From","equals","_ref11","_this$visibleGaps2","selectionSides","top","sides","right","bottom","corners","left","_iterator10","_step10","_loop2","_snap$gap","newGapsLength","gapBreadthIntersection","v","addXY","_iterator11","_step11","_loop3","_snap$gap2","__decorateClass","prototype"],"sources":["/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@tldraw/editor/src/lib/editor/managers/SnapManager.ts"],"sourcesContent":["import {\n\tBox2d,\n\tflipSelectionHandleX,\n\tflipSelectionHandleY,\n\tisSelectionCorner,\n\tMatrix2d,\n\trangeIntersection,\n\trangesOverlap,\n\tSelectionCorner,\n\tSelectionEdge,\n\tVec2d,\n\tVecLike,\n} from '@tldraw/primitives'\nimport { TLParentId, TLShape, TLShapeId, Vec2dModel } from '@tldraw/tlschema'\nimport { dedupe, deepCopy } from '@tldraw/utils'\nimport { atom, computed, EMPTY_ARRAY } from 'signia'\nimport { uniqueId } from '../../utils/data'\nimport type { Editor } from '../Editor'\nimport { GroupShapeUtil } from '../shapes/group/GroupShapeUtil'\n\nexport type PointsSnapLine = {\n\tid: string\n\ttype: 'points'\n\tpoints: VecLike[]\n}\nexport type GapsSnapLine = {\n\tid: string\n\ttype: 'gaps'\n\tdirection: 'horizontal' | 'vertical'\n\tgaps: Array<{\n\t\tstartEdge: [VecLike, VecLike]\n\t\tendEdge: [VecLike, VecLike]\n\t}>\n}\nexport type SnapLine = PointsSnapLine | GapsSnapLine\n\nexport type SnapInteractionType =\n\t| {\n\t\t\ttype: 'translate'\n\t\t\tlockedAxis: 'x' | 'y' | null\n\t\t\tinitialSelectionSnapPoints: Vec2d[]\n\t  }\n\t| {\n\t\t\ttype: 'resize'\n\t  }\n\nexport interface SnapPoint {\n\tid: string\n\tx: number\n\ty: number\n\thandle?: SelectionCorner\n}\n\ntype SnapPair = { thisPoint: SnapPoint; otherPoint: SnapPoint }\n\ntype NearestPointsSnap = {\n\t// selection snaps to a nearby snap point\n\ttype: 'points'\n\tpoints: SnapPair\n\tnudge: number\n}\n\ntype NearestSnap =\n\t| NearestPointsSnap\n\t| {\n\t\t\t// selection snaps to the center of a gap\n\t\t\ttype: 'gap_center'\n\t\t\tgap: Gap\n\t\t\tnudge: number\n\t  }\n\t| {\n\t\t\t// selection snaps to create a new gap of equal size to another gap\n\t\t\t// on the opposide side of some shape\n\t\t\ttype: 'gap_duplicate'\n\t\t\tgap: Gap\n\t\t\tprotrusionDirection: 'left' | 'right' | 'top' | 'bottom'\n\t\t\tnudge: number\n\t  }\n\ntype GapNode = {\n\tid: TLShapeId\n\tpageBounds: Box2d\n\tisClosed: boolean\n}\n\ntype Gap = {\n\t// e.g.\n\t//      start\n\t//      edge     │         breadth\n\t//               │       intersection\n\t//               ▼        [40,100]           end\n\t//                            │            │ edge\n\t// ┌───────────┐ │ 100,0      │            │\n\t// │           │ │            ▼            ▼\n\t// │           │ │\n\t// │  start    │ │            │     200,40 │ ┌───────────┐\n\t// │  node     │ │            │            │ │           │\n\t// │           │ ├────────────┼────────────┤ │  end      │\n\t// │           │ │            │            │ │  node     │\n\t// └───────────┘ │ 100,100    │            │ │           │\n\t//                                         │ │           │\n\t//                                 200,120 │ └───────────┘\n\t//\n\t//                       length 100\n\t//               ◄─────────────────────────►\n\tstartNode: GapNode\n\tendNode: GapNode\n\tstartEdge: [Vec2d, Vec2d]\n\tendEdge: [Vec2d, Vec2d]\n\tlength: number\n\tbreadthIntersection: [number, number]\n}\n\ninterface SnapData {\n\tnudge: Vec2d\n}\n\nconst round = (x: number) => {\n\t// round numbers to avoid glitches for floating point rounding errors\n\tconst decimalPlacesTolerance = 8\n\treturn Math.round(x * 10 ** decimalPlacesTolerance) / 10 ** decimalPlacesTolerance\n}\n\nfunction findAdjacentGaps(\n\tgaps: Gap[],\n\tshapeId: TLShapeId,\n\tgapLength: number,\n\tdirection: 'forward' | 'backward',\n\tintersection: [number, number],\n\tdepth: number\n): Gap[] {\n\tif (depth > 20) return []\n\n\t// TODO: take advantage of the fact that gaps is sorted by starting position?\n\tconst matches = gaps.filter(\n\t\t(gap) =>\n\t\t\t(direction === 'forward' ? gap.startNode.id === shapeId : gap.endNode.id === shapeId) &&\n\t\t\tround(gap.length) === round(gapLength) &&\n\t\t\trangeIntersection(\n\t\t\t\tgap.breadthIntersection[0],\n\t\t\t\tgap.breadthIntersection[1],\n\t\t\t\tintersection[0],\n\t\t\t\tintersection[1]\n\t\t\t)\n\t)\n\n\tif (matches.length === 0) return []\n\n\tconst nextNodes = new Set<TLShapeId>()\n\n\tfor (const match of matches) {\n\t\tconst node = direction === 'forward' ? match.endNode.id : match.startNode.id\n\t\tif (!nextNodes.has(node)) {\n\t\t\tnextNodes.add(node)\n\t\t\tmatches.push(\n\t\t\t\t...findAdjacentGaps(\n\t\t\t\t\tgaps,\n\t\t\t\t\tnode,\n\t\t\t\t\tgapLength,\n\t\t\t\t\tdirection,\n\t\t\t\t\trangeIntersection(\n\t\t\t\t\t\tmatch.breadthIntersection[0],\n\t\t\t\t\t\tmatch.breadthIntersection[1],\n\t\t\t\t\t\tintersection[0],\n\t\t\t\t\t\tintersection[1]\n\t\t\t\t\t)!,\n\t\t\t\t\tdepth + 1\n\t\t\t\t)\n\t\t\t)\n\t\t}\n\t}\n\n\treturn matches\n}\n\nfunction dedupeGapSnaps(snaps: Array<Extract<SnapLine, { type: 'gaps' }>>) {\n\t// sort by descending order of number of gaps\n\tsnaps.sort((a, b) => b.gaps.length - a.gaps.length)\n\t// pop off any that are included already\n\tfor (let i = snaps.length - 1; i > 0; i--) {\n\t\tconst snap = snaps[i]\n\t\tfor (let j = i - 1; j >= 0; j--) {\n\t\t\tconst otherSnap = snaps[j]\n\t\t\t// if every edge in this snap is included in the other snap somewhere, then it's redundant\n\t\t\tif (\n\t\t\t\totherSnap.direction === snap.direction &&\n\t\t\t\tsnap.gaps.every(\n\t\t\t\t\t(gap) =>\n\t\t\t\t\t\totherSnap.gaps.some(\n\t\t\t\t\t\t\t(otherGap) =>\n\t\t\t\t\t\t\t\tround(gap.startEdge[0].x) === round(otherGap.startEdge[0].x) &&\n\t\t\t\t\t\t\t\tround(gap.startEdge[0].y) === round(otherGap.startEdge[0].y) &&\n\t\t\t\t\t\t\t\tround(gap.startEdge[1].x) === round(otherGap.startEdge[1].x) &&\n\t\t\t\t\t\t\t\tround(gap.startEdge[1].y) === round(otherGap.startEdge[1].y)\n\t\t\t\t\t\t) &&\n\t\t\t\t\t\totherSnap.gaps.some(\n\t\t\t\t\t\t\t(otherGap) =>\n\t\t\t\t\t\t\t\tround(gap.endEdge[0].x) === round(otherGap.endEdge[0].x) &&\n\t\t\t\t\t\t\t\tround(gap.endEdge[0].y) === round(otherGap.endEdge[0].y) &&\n\t\t\t\t\t\t\t\tround(gap.endEdge[1].x) === round(otherGap.endEdge[1].x) &&\n\t\t\t\t\t\t\t\tround(gap.endEdge[1].y) === round(otherGap.endEdge[1].y)\n\t\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\tsnaps.splice(i, 1)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport class SnapManager {\n\tprivate _snapLines = atom<SnapLine[] | undefined>('snapLines', undefined)\n\n\tget lines() {\n\t\treturn this._snapLines.value ?? (EMPTY_ARRAY as SnapLine[])\n\t}\n\n\tclear() {\n\t\tif (this.lines.length) {\n\t\t\tthis._snapLines.set(undefined)\n\t\t}\n\t}\n\n\tsetLines(lines: SnapLine[]) {\n\t\tthis._snapLines.set(lines)\n\t}\n\n\tconstructor(public readonly editor: Editor) {}\n\n\t@computed get snapPointsCache() {\n\t\treturn this.editor.store.createComputedCache<SnapPoint[], TLShape>('snapPoints', (shape) => {\n\t\t\tconst pageTransfrorm = this.editor.getPageTransformById(shape.id)\n\t\t\tif (!pageTransfrorm) return undefined\n\t\t\tconst util = this.editor.getShapeUtil(shape)\n\t\t\tconst snapPoints = util.snapPoints(shape)\n\t\t\treturn snapPoints.map((point, i) => {\n\t\t\t\tconst { x, y } = Matrix2d.applyToPoint(pageTransfrorm, point)\n\t\t\t\treturn { x, y, id: `${shape.id}:${i}` }\n\t\t\t})\n\t\t})\n\t}\n\n\t@computed get snapThreshold() {\n\t\treturn 8 / this.editor.zoomLevel\n\t}\n\n\t// TODO: make this an incremental derivation\n\t@computed get snappableShapes(): GapNode[] {\n\t\tconst { editor } = this\n\t\tconst { selectedIds, renderingBounds: renderingBounds } = editor\n\n\t\tconst snappableShapes: GapNode[] = []\n\n\t\tconst collectSnappableShapesFromParent = (parentId: TLParentId) => {\n\t\t\tconst sortedChildIds = editor.getSortedChildIds(parentId)\n\t\t\tfor (const childId of sortedChildIds) {\n\t\t\t\t// Skip any selected ids\n\t\t\t\tif (selectedIds.includes(childId)) continue\n\t\t\t\tconst childShape = editor.getShapeById(childId)\n\t\t\t\tif (!childShape) continue\n\t\t\t\tconst util = editor.getShapeUtil(childShape)\n\t\t\t\t// Skip any shapes that don't allow snapping\n\t\t\t\tif (!util.canSnap(childShape)) continue\n\t\t\t\t// Only consider shapes if they're inside of the viewport page bounds\n\t\t\t\tconst pageBounds = editor.getPageBoundsById(childId)\n\t\t\t\tif (!(pageBounds && renderingBounds.includes(pageBounds))) continue\n\t\t\t\t// Snap to children of groups but not group itself\n\t\t\t\tif (editor.isShapeOfType(childShape, GroupShapeUtil)) {\n\t\t\t\t\tcollectSnappableShapesFromParent(childId)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tsnappableShapes.push({ id: childId, pageBounds, isClosed: util.isClosed(childShape) })\n\t\t\t}\n\t\t}\n\n\t\tcollectSnappableShapesFromParent(this.currentCommonAncestor ?? editor.currentPageId)\n\n\t\treturn snappableShapes\n\t}\n\n\t// This needs to be external from any expensive work\n\t@computed get currentCommonAncestor() {\n\t\treturn this.editor.findCommonAncestor(this.editor.selectedShapes)\n\t}\n\n\t// Points which belong to snappable shapes\n\t@computed get snappablePoints() {\n\t\tconst { snappableShapes, snapPointsCache } = this\n\t\tconst result: SnapPoint[] = []\n\n\t\tsnappableShapes.forEach((shape) => {\n\t\t\tconst snapPoints = snapPointsCache.get(shape.id)\n\t\t\tif (snapPoints) {\n\t\t\t\tresult.push(...snapPoints)\n\t\t\t}\n\t\t})\n\n\t\treturn result\n\t}\n\n\t@computed get visibleGaps(): { horizontal: Gap[]; vertical: Gap[] } {\n\t\tconst horizontal: Gap[] = []\n\t\tconst vertical: Gap[] = []\n\n\t\tlet startNode: GapNode, endNode: GapNode\n\n\t\tconst sortedShapesHorizontal = this.snappableShapes.sort((a, b) => {\n\t\t\treturn a.pageBounds.minX - b.pageBounds.minX\n\t\t})\n\n\t\t// Collect horizontal gaps\n\t\tfor (let i = 0; i < sortedShapesHorizontal.length; i++) {\n\t\t\tstartNode = sortedShapesHorizontal[i]\n\t\t\tfor (let j = i + 1; j < sortedShapesHorizontal.length; j++) {\n\t\t\t\tendNode = sortedShapesHorizontal[j]\n\n\t\t\t\tif (\n\t\t\t\t\t// is there space between the boxes\n\t\t\t\t\tstartNode.pageBounds.maxX < endNode.pageBounds.minX &&\n\t\t\t\t\t// and they overlap in the y axis\n\t\t\t\t\trangesOverlap(\n\t\t\t\t\t\tstartNode.pageBounds.minY,\n\t\t\t\t\t\tstartNode.pageBounds.maxY,\n\t\t\t\t\t\tendNode.pageBounds.minY,\n\t\t\t\t\t\tendNode.pageBounds.maxY\n\t\t\t\t\t)\n\t\t\t\t) {\n\t\t\t\t\thorizontal.push({\n\t\t\t\t\t\tstartNode,\n\t\t\t\t\t\tendNode,\n\t\t\t\t\t\tstartEdge: [\n\t\t\t\t\t\t\tnew Vec2d(startNode.pageBounds.maxX, startNode.pageBounds.minY),\n\t\t\t\t\t\t\tnew Vec2d(startNode.pageBounds.maxX, startNode.pageBounds.maxY),\n\t\t\t\t\t\t],\n\t\t\t\t\t\tendEdge: [\n\t\t\t\t\t\t\tnew Vec2d(endNode.pageBounds.minX, endNode.pageBounds.minY),\n\t\t\t\t\t\t\tnew Vec2d(endNode.pageBounds.minX, endNode.pageBounds.maxY),\n\t\t\t\t\t\t],\n\t\t\t\t\t\tlength: endNode.pageBounds.minX - startNode.pageBounds.maxX,\n\t\t\t\t\t\tbreadthIntersection: rangeIntersection(\n\t\t\t\t\t\t\tstartNode.pageBounds.minY,\n\t\t\t\t\t\t\tstartNode.pageBounds.maxY,\n\t\t\t\t\t\t\tendNode.pageBounds.minY,\n\t\t\t\t\t\t\tendNode.pageBounds.maxY\n\t\t\t\t\t\t)!,\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Collect vertical gaps\n\t\tconst sortedShapesVertical = sortedShapesHorizontal.sort((a, b) => {\n\t\t\treturn a.pageBounds.minY - b.pageBounds.minY\n\t\t})\n\n\t\tfor (let i = 0; i < sortedShapesVertical.length; i++) {\n\t\t\tstartNode = sortedShapesVertical[i]\n\t\t\tfor (let j = i + 1; j < sortedShapesVertical.length; j++) {\n\t\t\t\tendNode = sortedShapesVertical[j]\n\n\t\t\t\tif (\n\t\t\t\t\t// is there space between the boxes\n\t\t\t\t\tstartNode.pageBounds.maxY < endNode.pageBounds.minY &&\n\t\t\t\t\t// do they overlap in the x axis\n\t\t\t\t\trangesOverlap(\n\t\t\t\t\t\tstartNode.pageBounds.minX,\n\t\t\t\t\t\tstartNode.pageBounds.maxX,\n\t\t\t\t\t\tendNode.pageBounds.minX,\n\t\t\t\t\t\tendNode.pageBounds.maxX\n\t\t\t\t\t)\n\t\t\t\t) {\n\t\t\t\t\tvertical.push({\n\t\t\t\t\t\tstartNode,\n\t\t\t\t\t\tendNode,\n\t\t\t\t\t\tstartEdge: [\n\t\t\t\t\t\t\tnew Vec2d(startNode.pageBounds.minX, startNode.pageBounds.maxY),\n\t\t\t\t\t\t\tnew Vec2d(startNode.pageBounds.maxX, startNode.pageBounds.maxY),\n\t\t\t\t\t\t],\n\t\t\t\t\t\tendEdge: [\n\t\t\t\t\t\t\tnew Vec2d(endNode.pageBounds.minX, endNode.pageBounds.minY),\n\t\t\t\t\t\t\tnew Vec2d(endNode.pageBounds.maxX, endNode.pageBounds.minY),\n\t\t\t\t\t\t],\n\t\t\t\t\t\tlength: endNode.pageBounds.minY - startNode.pageBounds.maxY,\n\t\t\t\t\t\tbreadthIntersection: rangeIntersection(\n\t\t\t\t\t\t\tstartNode.pageBounds.minX,\n\t\t\t\t\t\t\tstartNode.pageBounds.maxX,\n\t\t\t\t\t\t\tendNode.pageBounds.minX,\n\t\t\t\t\t\t\tendNode.pageBounds.maxX\n\t\t\t\t\t\t)!,\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn { horizontal, vertical }\n\t}\n\n\tsnapTranslate({\n\t\tlockedAxis,\n\t\tinitialSelectionPageBounds,\n\t\tinitialSelectionSnapPoints,\n\t\tdragDelta,\n\t}: {\n\t\tlockedAxis: 'x' | 'y' | null\n\t\tinitialSelectionSnapPoints: SnapPoint[]\n\t\tinitialSelectionPageBounds: Box2d\n\t\tdragDelta: Vec2d\n\t}): SnapData {\n\t\tconst { snappablePoints: visibleSnapPointsNotInSelection, snapThreshold } = this\n\n\t\tconst selectionPageBounds = initialSelectionPageBounds.clone().translate(dragDelta)\n\n\t\tconst selectionSnapPoints: SnapPoint[] = initialSelectionSnapPoints.map(({ x, y }, i) => ({\n\t\t\tid: 'selection:' + i,\n\t\t\tx: x + dragDelta.x,\n\t\t\ty: y + dragDelta.y,\n\t\t}))\n\n\t\tconst otherNodeSnapPoints = visibleSnapPointsNotInSelection\n\n\t\tconst nearestSnapsX: NearestSnap[] = []\n\t\tconst nearestSnapsY: NearestSnap[] = []\n\t\tconst minOffset = new Vec2d(snapThreshold, snapThreshold)\n\n\t\tthis.collectPointSnaps({\n\t\t\tminOffset,\n\t\t\tnearestSnapsX,\n\t\t\tnearestSnapsY,\n\t\t\totherNodeSnapPoints,\n\t\t\tselectionSnapPoints,\n\t\t})\n\n\t\tthis.collectGapSnaps({\n\t\t\tselectionPageBounds,\n\t\t\tnearestSnapsX,\n\t\t\tnearestSnapsY,\n\t\t\tminOffset,\n\t\t})\n\n\t\t// at the same time, calculate how far we need to nudge the shape to 'snap' to the target point(s)\n\t\tconst nudge = new Vec2d(\n\t\t\tlockedAxis === 'x' ? 0 : nearestSnapsX[0]?.nudge ?? 0,\n\t\t\tlockedAxis === 'y' ? 0 : nearestSnapsY[0]?.nudge ?? 0\n\t\t)\n\n\t\t// ok we've figured out how much the box should be nudged, now let's find all the snap points\n\t\t// that are exact after making that translation, so we can render all of them.\n\t\t// first reset everything and adjust the original shapes to conform to the nudge\n\t\tminOffset.x = 0\n\t\tminOffset.y = 0\n\t\tnearestSnapsX.length = 0\n\t\tnearestSnapsY.length = 0\n\t\tselectionSnapPoints.forEach((s) => {\n\t\t\ts.x += nudge.x\n\t\t\ts.y += nudge.y\n\t\t})\n\t\tselectionPageBounds.translate(nudge)\n\n\t\tthis.collectPointSnaps({\n\t\t\tminOffset,\n\t\t\tnearestSnapsX,\n\t\t\tnearestSnapsY,\n\t\t\totherNodeSnapPoints,\n\t\t\tselectionSnapPoints,\n\t\t})\n\n\t\tthis.collectGapSnaps({\n\t\t\tselectionPageBounds,\n\t\t\tnearestSnapsX,\n\t\t\tnearestSnapsY,\n\t\t\tminOffset,\n\t\t})\n\n\t\tconst pointSnapsLines = this.getPointSnapLines({\n\t\t\tnearestSnapsX,\n\t\t\tnearestSnapsY,\n\t\t})\n\n\t\tconst gapSnapLines = this.getGapSnapLines({\n\t\t\tselectionPageBounds,\n\t\t\tnearestSnapsX,\n\t\t\tnearestSnapsY,\n\t\t})\n\n\t\tthis._snapLines.set([...gapSnapLines, ...pointSnapsLines])\n\n\t\treturn { nudge }\n\t}\n\n\t@computed get outlinesInPageSpace() {\n\t\treturn this.snappableShapes.map(({ id, isClosed }) => {\n\t\t\tconst outline = deepCopy(this.editor.getOutlineById(id))\n\t\t\tif (isClosed) outline.push(outline[0])\n\t\t\tconst pageTransform = this.editor.getPageTransformById(id)\n\t\t\tif (!pageTransform) throw Error('No page transform')\n\t\t\treturn Matrix2d.applyToPoints(pageTransform, outline)\n\t\t})\n\t}\n\n\tgetSnappingHandleDelta({\n\t\thandlePoint,\n\t\tadditionalSegments,\n\t}: {\n\t\thandlePoint: Vec2d\n\t\tadditionalSegments: Vec2d[][]\n\t}): Vec2d | null {\n\t\tconst { outlinesInPageSpace, snapThreshold } = this\n\n\t\t// Find the nearest point that is within the snap threshold\n\t\tlet minDistance = snapThreshold\n\t\tlet nearestPoint: Vec2d | null = null\n\t\tlet C: Vec2dModel, D: Vec2dModel, nearest: Vec2d, distance: number\n\n\t\tconst allSegments = [...outlinesInPageSpace, ...additionalSegments]\n\t\tfor (const outline of allSegments) {\n\t\t\tfor (let i = 0; i < outline.length - 1; i++) {\n\t\t\t\tC = outline[i]\n\t\t\t\tD = outline[i + 1]\n\n\t\t\t\tnearest = Vec2d.NearestPointOnLineSegment(C, D, handlePoint)\n\t\t\t\tdistance = Vec2d.Dist(handlePoint, nearest)\n\n\t\t\t\tif (isNaN(distance)) continue\n\t\t\t\tif (distance < minDistance) {\n\t\t\t\t\tminDistance = distance\n\t\t\t\t\tnearestPoint = nearest\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// If we found a point, display snap lines, and return the nudge\n\t\tif (nearestPoint) {\n\t\t\tthis._snapLines.set([\n\t\t\t\t{\n\t\t\t\t\tid: uniqueId(),\n\t\t\t\t\ttype: 'points',\n\t\t\t\t\tpoints: [nearestPoint],\n\t\t\t\t},\n\t\t\t])\n\n\t\t\treturn Vec2d.Sub(nearestPoint, handlePoint)\n\t\t}\n\n\t\treturn null\n\t}\n\n\tsnapResize({\n\t\tinitialSelectionPageBounds,\n\t\tdragDelta,\n\t\thandle: originalHandle,\n\t\tisAspectRatioLocked,\n\t\tisResizingFromCenter,\n\t}: {\n\t\t// the page bounds when the pointer went down, before any dragging\n\t\tinitialSelectionPageBounds: Box2d\n\t\t// how far the pointer has been dragged\n\t\tdragDelta: Vec2d\n\n\t\thandle: SelectionCorner | SelectionEdge\n\t\tisAspectRatioLocked: boolean\n\t\tisResizingFromCenter: boolean\n\t}): SnapData {\n\t\tconst { snapThreshold } = this\n\n\t\t// first figure out the new bounds of the selection\n\t\tconst {\n\t\t\tbox: unsnappedResizedPageBounds,\n\t\t\tscaleX,\n\t\t\tscaleY,\n\t\t} = Box2d.Resize(\n\t\t\tinitialSelectionPageBounds,\n\t\t\toriginalHandle,\n\t\t\tisResizingFromCenter ? dragDelta.x * 2 : dragDelta.x,\n\t\t\tisResizingFromCenter ? dragDelta.y * 2 : dragDelta.y,\n\t\t\tisAspectRatioLocked\n\t\t)\n\n\t\tlet handle = originalHandle\n\n\t\tif (scaleX < 0) {\n\t\t\thandle = flipSelectionHandleX(handle)\n\t\t}\n\t\tif (scaleY < 0) {\n\t\t\thandle = flipSelectionHandleY(handle)\n\t\t}\n\n\t\tif (isResizingFromCenter) {\n\t\t\t// reposition if resizing from center\n\t\t\tunsnappedResizedPageBounds.center = initialSelectionPageBounds.center\n\t\t}\n\n\t\tconst isXLocked = handle === 'top' || handle === 'bottom'\n\t\tconst isYLocked = handle === 'left' || handle === 'right'\n\n\t\tconst selectionSnapPoints = getResizeSnapPointsForHandle(handle, unsnappedResizedPageBounds)\n\n\t\tconst otherNodeSnapPoints = this.snappablePoints\n\n\t\tconst nearestSnapsX: NearestPointsSnap[] = []\n\t\tconst nearestSnapsY: NearestPointsSnap[] = []\n\t\tconst minOffset = new Vec2d(snapThreshold, snapThreshold)\n\n\t\tthis.collectPointSnaps({\n\t\t\tminOffset,\n\t\t\tnearestSnapsX,\n\t\t\tnearestSnapsY,\n\t\t\totherNodeSnapPoints,\n\t\t\tselectionSnapPoints,\n\t\t})\n\n\t\t// at the same time, calculate how far we need to nudge the shape to 'snap' to the target point(s)\n\t\tconst nudge = new Vec2d(\n\t\t\tisXLocked ? 0 : nearestSnapsX[0]?.nudge ?? 0,\n\t\t\tisYLocked ? 0 : nearestSnapsY[0]?.nudge ?? 0\n\t\t)\n\n\t\tif (isAspectRatioLocked && isSelectionCorner(handle) && nudge.len() !== 0) {\n\t\t\t// if the aspect ratio is locked we need to make the nudge diagonal rather than independent in each axis\n\t\t\t// so we use the aspect ratio along with one axis value to set the other axis value, but which axis we use\n\t\t\t// as a source of truth depends what we have snapped to and how far.\n\n\t\t\t// if we found a snap in both axes, pick the closest one and discard the other\n\t\t\tconst primaryNudgeAxis: 'x' | 'y' =\n\t\t\t\tnearestSnapsX.length && nearestSnapsY.length\n\t\t\t\t\t? Math.abs(nudge.x) < Math.abs(nudge.y)\n\t\t\t\t\t\t? 'x'\n\t\t\t\t\t\t: 'y'\n\t\t\t\t\t: nearestSnapsX.length\n\t\t\t\t\t? 'x'\n\t\t\t\t\t: 'y'\n\n\t\t\tconst ratio = initialSelectionPageBounds.aspectRatio\n\n\t\t\tif (primaryNudgeAxis === 'x') {\n\t\t\t\tnearestSnapsY.length = 0\n\t\t\t\tnudge.y = nudge.x / ratio\n\t\t\t\tif (handle === 'bottom_left' || handle === 'top_right') {\n\t\t\t\t\tnudge.y = -nudge.y\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnearestSnapsX.length = 0\n\t\t\t\tnudge.x = nudge.y * ratio\n\t\t\t\tif (handle === 'bottom_left' || handle === 'top_right') {\n\t\t\t\t\tnudge.x = -nudge.x\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// now resize the box after nudging, calculate the snaps again, and return the snap lines to match\n\t\t// the fully resized box\n\t\tconst snappedDelta = Vec2d.Add(dragDelta, nudge)\n\n\t\t// first figure out the new bounds of the selection\n\t\tconst { box: snappedResizedPageBounds } = Box2d.Resize(\n\t\t\tinitialSelectionPageBounds,\n\t\t\toriginalHandle,\n\t\t\tisResizingFromCenter ? snappedDelta.x * 2 : snappedDelta.x,\n\t\t\tisResizingFromCenter ? snappedDelta.y * 2 : snappedDelta.y,\n\t\t\tisAspectRatioLocked\n\t\t)\n\n\t\tif (isResizingFromCenter) {\n\t\t\t// reposition if resizing from center\n\t\t\tsnappedResizedPageBounds.center = initialSelectionPageBounds.center\n\t\t}\n\n\t\tconst snappedSelectionPoints = getResizeSnapPointsForHandle('any', snappedResizedPageBounds)\n\t\t// calculate snaps again using all points\n\t\tnearestSnapsX.length = 0\n\t\tnearestSnapsY.length = 0\n\t\tminOffset.x = 0\n\t\tminOffset.y = 0\n\n\t\tthis.collectPointSnaps({\n\t\t\tminOffset,\n\t\t\tnearestSnapsX,\n\t\t\tnearestSnapsY,\n\t\t\totherNodeSnapPoints,\n\t\t\tselectionSnapPoints: snappedSelectionPoints,\n\t\t})\n\t\tconst pointSnaps = this.getPointSnapLines({\n\t\t\tnearestSnapsX,\n\t\t\tnearestSnapsY,\n\t\t})\n\n\t\tthis._snapLines.set([...pointSnaps])\n\n\t\treturn { nudge }\n\t}\n\n\tprivate collectPointSnaps({\n\t\tselectionSnapPoints,\n\t\totherNodeSnapPoints,\n\t\tminOffset,\n\t\tnearestSnapsX,\n\t\tnearestSnapsY,\n\t}: {\n\t\tselectionSnapPoints: SnapPoint[]\n\t\totherNodeSnapPoints: SnapPoint[]\n\t\tminOffset: Vec2d\n\t\tnearestSnapsX: NearestSnap[]\n\t\tnearestSnapsY: NearestSnap[]\n\t}) {\n\t\t// for each snap point on the bounding box of the selection, find the set of points\n\t\t// which are closest to it in each axis\n\t\tfor (const thisSnapPoint of selectionSnapPoints) {\n\t\t\tfor (const otherSnapPoint of otherNodeSnapPoints) {\n\t\t\t\tconst offset = Vec2d.Sub(thisSnapPoint, otherSnapPoint)\n\t\t\t\tconst offsetX = Math.abs(offset.x)\n\t\t\t\tconst offsetY = Math.abs(offset.y)\n\n\t\t\t\tif (round(offsetX) <= round(minOffset.x)) {\n\t\t\t\t\tif (round(offsetX) < round(minOffset.x)) {\n\t\t\t\t\t\t// we found a point that is significantly closer than all previous points\n\t\t\t\t\t\t// so wipe the slate clean and start over\n\t\t\t\t\t\tnearestSnapsX.length = 0\n\t\t\t\t\t}\n\n\t\t\t\t\tnearestSnapsX.push({\n\t\t\t\t\t\ttype: 'points',\n\t\t\t\t\t\tpoints: { thisPoint: thisSnapPoint, otherPoint: otherSnapPoint },\n\t\t\t\t\t\tnudge: otherSnapPoint.x - thisSnapPoint.x,\n\t\t\t\t\t})\n\t\t\t\t\tminOffset.x = offsetX\n\t\t\t\t}\n\n\t\t\t\tif (round(offsetY) <= round(minOffset.y)) {\n\t\t\t\t\tif (round(offsetY) < round(minOffset.y)) {\n\t\t\t\t\t\t// we found a point that is significantly closer than all previous points\n\t\t\t\t\t\t// so wipe the slate clean and start over\n\t\t\t\t\t\tnearestSnapsY.length = 0\n\t\t\t\t\t}\n\t\t\t\t\tnearestSnapsY.push({\n\t\t\t\t\t\ttype: 'points',\n\t\t\t\t\t\tpoints: { thisPoint: thisSnapPoint, otherPoint: otherSnapPoint },\n\t\t\t\t\t\tnudge: otherSnapPoint.y - thisSnapPoint.y,\n\t\t\t\t\t})\n\t\t\t\t\tminOffset.y = offsetY\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate collectGapSnaps({\n\t\tselectionPageBounds,\n\t\tminOffset,\n\t\tnearestSnapsX,\n\t\tnearestSnapsY,\n\t}: {\n\t\tselectionPageBounds: Box2d\n\t\tminOffset: Vec2d\n\t\tnearestSnapsX: NearestSnap[]\n\t\tnearestSnapsY: NearestSnap[]\n\t}) {\n\t\tconst { horizontal, vertical } = this.visibleGaps\n\n\t\tfor (const gap of horizontal) {\n\t\t\t// ignore this gap if the selection doesn't overlap with it in the y axis\n\t\t\tif (\n\t\t\t\t!rangesOverlap(\n\t\t\t\t\tgap.breadthIntersection[0],\n\t\t\t\t\tgap.breadthIntersection[1],\n\t\t\t\t\tselectionPageBounds.minY,\n\t\t\t\t\tselectionPageBounds.maxY\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// check for center match\n\t\t\tconst gapMidX = gap.startEdge[0].x + gap.length / 2\n\t\t\tconst centerNudge = gapMidX - selectionPageBounds.center.x\n\t\t\tconst gapIsLargerThanSelection = gap.length > selectionPageBounds.width\n\n\t\t\tif (gapIsLargerThanSelection && round(Math.abs(centerNudge)) <= round(minOffset.x)) {\n\t\t\t\tif (round(Math.abs(centerNudge)) < round(minOffset.x)) {\n\t\t\t\t\t// reset if we found a closer snap\n\t\t\t\t\tnearestSnapsX.length = 0\n\t\t\t\t}\n\t\t\t\tminOffset.x = Math.abs(centerNudge)\n\n\t\t\t\tconst snap: NearestSnap = {\n\t\t\t\t\ttype: 'gap_center',\n\t\t\t\t\tgap,\n\t\t\t\t\tnudge: centerNudge,\n\t\t\t\t}\n\n\t\t\t\t// we need to avoid creating visual noise with too many center snaps in situations\n\t\t\t\t// where there are lots of adjacent items with even spacing\n\t\t\t\t// so let's only show other center snaps where the gap's breadth does not overlap with this one\n\t\t\t\t// i.e.\n\t\t\t\t//                ┌───────────────┐\n\t\t\t\t//                │               │\n\t\t\t\t//                └──────┬────┬───┘\n\t\t\t\t//                       ┼    │\n\t\t\t\t//                 ┌─────┴┐   │\n\t\t\t\t//                 │      │   ┼\n\t\t\t\t//                 └─────┬┘   │\n\t\t\t\t//                       ┼    │\n\t\t\t\t//                   ┌───┴────┴───────┐\n\t\t\t\t//                   │                │  ◄────  i'm dragging this one\n\t\t\t\t//                   └───┬────┬───────┘\n\t\t\t\t//            ─────►     ┼    │\n\t\t\t\t//                 ┌─────┴┐   │                don't show these\n\t\t\t\t// show these      │      │   ┼                larger gaps since\n\t\t\t\t// smaller         └─────┬┘   │ ◄───────────── the smaller ones\n\t\t\t\t// gaps                  ┼    │                cover the same\n\t\t\t\t//              ─────►  ┌┴────┴─────┐          information\n\t\t\t\t//                      │           │\n\t\t\t\t//                      └───────────┘\n\t\t\t\t//\n\t\t\t\t// but we want to show all of these ones since the gap breadths don't overlap\n\t\t\t\t//            ┌─────────────┐\n\t\t\t\t//            │             │\n\t\t\t\t// ┌────┐     └───┬─────────┘\n\t\t\t\t// │    │         │\n\t\t\t\t// └──┬─┘         ┼\n\t\t\t\t//    ┼           │\n\t\t\t\t// ┌──┴───────────┴─┐\n\t\t\t\t// │                │ ◄───── i'm dragging this one\n\t\t\t\t// └──┬───────────┬─┘\n\t\t\t\t//    ┼           │\n\t\t\t\t// ┌──┴────┐      ┼\n\t\t\t\t// │       │      │\n\t\t\t\t// └───────┘    ┌─┴───────┐\n\t\t\t\t//              │         │\n\t\t\t\t//              └─────────┘\n\n\t\t\t\tconst otherCenterSnap = nearestSnapsX.find(({ type }) => type === 'gap_center') as\n\t\t\t\t\t| Extract<NearestSnap, { type: 'gap_center' }>\n\t\t\t\t\t| undefined\n\n\t\t\t\tconst gapBreadthsOverlap =\n\t\t\t\t\totherCenterSnap &&\n\t\t\t\t\trangeIntersection(\n\t\t\t\t\t\tgap.breadthIntersection[0],\n\t\t\t\t\t\tgap.breadthIntersection[1],\n\t\t\t\t\t\totherCenterSnap.gap.breadthIntersection[0],\n\t\t\t\t\t\totherCenterSnap.gap.breadthIntersection[1]\n\t\t\t\t\t)\n\n\t\t\t\t// if there is another center snap and it's bigger than this one, and it overlaps with this one, replace it\n\t\t\t\tif (otherCenterSnap && otherCenterSnap.gap.length > gap.length && gapBreadthsOverlap) {\n\t\t\t\t\tnearestSnapsX[nearestSnapsX.indexOf(otherCenterSnap)] = snap\n\t\t\t\t} else if (!otherCenterSnap || !gapBreadthsOverlap) {\n\t\t\t\t\tnearestSnapsX.push(snap)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// check for duplication left match\n\t\t\tconst duplicationLeftX = gap.startNode.pageBounds.minX - gap.length\n\t\t\tconst selectionRightX = selectionPageBounds.maxX\n\n\t\t\tconst duplicationLeftNudge = duplicationLeftX - selectionRightX\n\t\t\tif (round(Math.abs(duplicationLeftNudge)) <= round(minOffset.x)) {\n\t\t\t\tif (round(Math.abs(duplicationLeftNudge)) < round(minOffset.x)) {\n\t\t\t\t\t// reset if we found a closer snap\n\t\t\t\t\tnearestSnapsX.length = 0\n\t\t\t\t}\n\t\t\t\tminOffset.x = Math.abs(duplicationLeftNudge)\n\n\t\t\t\tnearestSnapsX.push({\n\t\t\t\t\ttype: 'gap_duplicate',\n\t\t\t\t\tgap,\n\t\t\t\t\tprotrusionDirection: 'left',\n\t\t\t\t\tnudge: duplicationLeftNudge,\n\t\t\t\t})\n\t\t\t}\n\n\t\t\t// check for duplication right match\n\t\t\tconst duplicationRightX = gap.endNode.pageBounds.maxX + gap.length\n\t\t\tconst selectionLeftX = selectionPageBounds.minX\n\n\t\t\tconst duplicationRightNudge = duplicationRightX - selectionLeftX\n\t\t\tif (round(Math.abs(duplicationRightNudge)) <= round(minOffset.x)) {\n\t\t\t\tif (round(Math.abs(duplicationRightNudge)) < round(minOffset.x)) {\n\t\t\t\t\t// reset if we found a closer snap\n\t\t\t\t\tnearestSnapsX.length = 0\n\t\t\t\t}\n\t\t\t\tminOffset.x = Math.abs(duplicationRightNudge)\n\n\t\t\t\tnearestSnapsX.push({\n\t\t\t\t\ttype: 'gap_duplicate',\n\t\t\t\t\tgap,\n\t\t\t\t\tprotrusionDirection: 'right',\n\t\t\t\t\tnudge: duplicationRightNudge,\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\n\t\tfor (const gap of vertical) {\n\t\t\t// ignore this gap if the selection doesn't overlap with it in the y axis\n\t\t\tif (\n\t\t\t\t!rangesOverlap(\n\t\t\t\t\tgap.breadthIntersection[0],\n\t\t\t\t\tgap.breadthIntersection[1],\n\t\t\t\t\tselectionPageBounds.minX,\n\t\t\t\t\tselectionPageBounds.maxX\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// check for center match\n\t\t\tconst gapMidY = gap.startEdge[0].y + gap.length / 2\n\t\t\tconst centerNudge = gapMidY - selectionPageBounds.center.y\n\n\t\t\tconst gapIsLargerThanSelection = gap.length > selectionPageBounds.height\n\n\t\t\tif (gapIsLargerThanSelection && round(Math.abs(centerNudge)) <= round(minOffset.y)) {\n\t\t\t\tif (round(Math.abs(centerNudge)) < round(minOffset.y)) {\n\t\t\t\t\t// reset if we found a closer snap\n\t\t\t\t\tnearestSnapsY.length = 0\n\t\t\t\t}\n\t\t\t\tminOffset.y = Math.abs(centerNudge)\n\n\t\t\t\tconst snap: NearestSnap = {\n\t\t\t\t\ttype: 'gap_center',\n\t\t\t\t\tgap,\n\t\t\t\t\tnudge: centerNudge,\n\t\t\t\t}\n\n\t\t\t\t// we need to avoid creating visual noise with too many center snaps in situations\n\t\t\t\t// where there are lots of adjacent items with even spacing\n\t\t\t\t// so let's only show other center snaps where the gap's breadth does not overlap with this one\n\t\t\t\t// i.e.\n\t\t\t\t//                ┌───────────────┐\n\t\t\t\t//                │               │\n\t\t\t\t//                └──────┬────┬───┘\n\t\t\t\t//                       ┼    │\n\t\t\t\t//                 ┌─────┴┐   │\n\t\t\t\t//                 │      │   ┼\n\t\t\t\t//                 └─────┬┘   │\n\t\t\t\t//                       ┼    │\n\t\t\t\t//                   ┌───┴────┴───────┐\n\t\t\t\t//                   │                │  ◄────  i'm dragging this one\n\t\t\t\t//                   └───┬────┬───────┘\n\t\t\t\t//            ─────►     ┼    │\n\t\t\t\t//                 ┌─────┴┐   │                don't show these\n\t\t\t\t// show these      │      │   ┼                larger gaps since\n\t\t\t\t// smaller         └─────┬┘   │ ◄───────────── the smaller ones\n\t\t\t\t// gaps                  ┼    │                cover the same\n\t\t\t\t//              ─────►  ┌┴────┴─────┐          information\n\t\t\t\t//                      │           │\n\t\t\t\t//                      └───────────┘\n\t\t\t\t//\n\t\t\t\t// but we want to show all of these ones since the gap breadths don't overlap\n\t\t\t\t//            ┌─────────────┐\n\t\t\t\t//            │             │\n\t\t\t\t// ┌────┐     └───┬─────────┘\n\t\t\t\t// │    │         │\n\t\t\t\t// └──┬─┘         ┼\n\t\t\t\t//    ┼           │\n\t\t\t\t// ┌──┴───────────┴─┐\n\t\t\t\t// │                │ ◄───── i'm dragging this one\n\t\t\t\t// └──┬───────────┬─┘\n\t\t\t\t//    ┼           │\n\t\t\t\t// ┌──┴────┐      ┼\n\t\t\t\t// │       │      │\n\t\t\t\t// └───────┘    ┌─┴───────┐\n\t\t\t\t//              │         │\n\t\t\t\t//              └─────────┘\n\n\t\t\t\tconst otherCenterSnap = nearestSnapsY.find(({ type }) => type === 'gap_center') as\n\t\t\t\t\t| Extract<NearestSnap, { type: 'gap_center' }>\n\t\t\t\t\t| undefined\n\n\t\t\t\tconst gapBreadthsOverlap =\n\t\t\t\t\totherCenterSnap &&\n\t\t\t\t\trangesOverlap(\n\t\t\t\t\t\totherCenterSnap.gap.breadthIntersection[0],\n\t\t\t\t\t\totherCenterSnap.gap.breadthIntersection[1],\n\t\t\t\t\t\tgap.breadthIntersection[0],\n\t\t\t\t\t\tgap.breadthIntersection[1]\n\t\t\t\t\t)\n\n\t\t\t\t// if there is another center snap and it's bigger than this one, and it overlaps with this one, replace it\n\t\t\t\tif (otherCenterSnap && otherCenterSnap.gap.length > gap.length && gapBreadthsOverlap) {\n\t\t\t\t\tnearestSnapsY[nearestSnapsY.indexOf(otherCenterSnap)] = snap\n\t\t\t\t} else if (!otherCenterSnap || !gapBreadthsOverlap) {\n\t\t\t\t\tnearestSnapsY.push(snap)\n\t\t\t\t}\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// check for duplication top match\n\t\t\tconst duplicationTopY = gap.startNode.pageBounds.minY - gap.length\n\t\t\tconst selectionBottomY = selectionPageBounds.maxY\n\n\t\t\tconst duplicationTopNudge = duplicationTopY - selectionBottomY\n\t\t\tif (round(Math.abs(duplicationTopNudge)) <= round(minOffset.y)) {\n\t\t\t\tif (round(Math.abs(duplicationTopNudge)) < round(minOffset.y)) {\n\t\t\t\t\t// reset if we found a closer snap\n\t\t\t\t\tnearestSnapsY.length = 0\n\t\t\t\t}\n\t\t\t\tminOffset.y = Math.abs(duplicationTopNudge)\n\n\t\t\t\tnearestSnapsY.push({\n\t\t\t\t\ttype: 'gap_duplicate',\n\t\t\t\t\tgap,\n\t\t\t\t\tprotrusionDirection: 'top',\n\t\t\t\t\tnudge: duplicationTopNudge,\n\t\t\t\t})\n\t\t\t}\n\n\t\t\t// check for duplication bottom match\n\t\t\tconst duplicationBottomY = gap.endNode.pageBounds.maxY + gap.length\n\t\t\tconst selectionTopY = selectionPageBounds.minY\n\n\t\t\tconst duplicationBottomNudge = duplicationBottomY - selectionTopY\n\t\t\tif (round(Math.abs(duplicationBottomNudge)) <= round(minOffset.y)) {\n\t\t\t\tif (round(Math.abs(duplicationBottomNudge)) < round(minOffset.y)) {\n\t\t\t\t\t// reset if we found a closer snap\n\t\t\t\t\tnearestSnapsY.length = 0\n\t\t\t\t}\n\t\t\t\tminOffset.y = Math.abs(duplicationBottomNudge)\n\n\t\t\t\tnearestSnapsY.push({\n\t\t\t\t\ttype: 'gap_duplicate',\n\t\t\t\t\tgap,\n\t\t\t\t\tprotrusionDirection: 'bottom',\n\t\t\t\t\tnudge: duplicationBottomNudge,\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate getPointSnapLines({\n\t\tnearestSnapsX,\n\t\tnearestSnapsY,\n\t}: {\n\t\tnearestSnapsX: NearestSnap[]\n\t\tnearestSnapsY: NearestSnap[]\n\t}): PointsSnapLine[] {\n\t\t// point snaps may align on multiple parallel lines so we need to split the pairs\n\t\t// into groups based on where they are in their their snap axes\n\t\tconst snapGroupsX = {} as { [key: string]: SnapPair[] }\n\t\tconst snapGroupsY = {} as { [key: string]: SnapPair[] }\n\n\t\tif (nearestSnapsX.length > 0) {\n\t\t\tfor (const snap of nearestSnapsX) {\n\t\t\t\tif (snap.type === 'points') {\n\t\t\t\t\tconst key = round(snap.points.otherPoint.x)\n\t\t\t\t\tif (!snapGroupsX[key]) {\n\t\t\t\t\t\tsnapGroupsX[key] = []\n\t\t\t\t\t}\n\t\t\t\t\tsnapGroupsX[key].push(snap.points)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (nearestSnapsY.length > 0) {\n\t\t\tfor (const snap of nearestSnapsY) {\n\t\t\t\tif (snap.type === 'points') {\n\t\t\t\t\tconst key = round(snap.points.otherPoint.y)\n\t\t\t\t\tif (!snapGroupsY[key]) {\n\t\t\t\t\t\tsnapGroupsY[key] = []\n\t\t\t\t\t}\n\t\t\t\t\tsnapGroupsY[key].push(snap.points)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// and finally create all the snap lines for the UI to render\n\t\treturn Object.values(snapGroupsX)\n\t\t\t.concat(Object.values(snapGroupsY))\n\t\t\t.map((snapGroup) => ({\n\t\t\t\tid: uniqueId(),\n\t\t\t\ttype: 'points',\n\t\t\t\tpoints: dedupe(\n\t\t\t\t\tsnapGroup\n\t\t\t\t\t\t.map((snap) => Vec2d.From(snap.otherPoint))\n\t\t\t\t\t\t// be sure to nudge over the selection snap points\n\t\t\t\t\t\t.concat(snapGroup.map((snap) => Vec2d.From(snap.thisPoint))),\n\t\t\t\t\t(a: Vec2d, b: Vec2d) => a.equals(b)\n\t\t\t\t),\n\t\t\t}))\n\t}\n\n\tprivate getGapSnapLines({\n\t\tselectionPageBounds,\n\t\tnearestSnapsX,\n\t\tnearestSnapsY,\n\t}: {\n\t\tselectionPageBounds: Box2d\n\t\tnearestSnapsX: NearestSnap[]\n\t\tnearestSnapsY: NearestSnap[]\n\t}): GapsSnapLine[] {\n\t\tconst { vertical, horizontal } = this.visibleGaps\n\n\t\tconst selectionSides: Record<SelectionEdge, [Vec2d, Vec2d]> = {\n\t\t\ttop: selectionPageBounds.sides[0],\n\t\t\tright: selectionPageBounds.sides[1],\n\t\t\t// need bottom and left to be sorted asc, which .sides is not.\n\t\t\tbottom: [selectionPageBounds.corners[3], selectionPageBounds.corners[2]],\n\t\t\tleft: [selectionPageBounds.corners[0], selectionPageBounds.corners[3]],\n\t\t}\n\n\t\tconst result: GapsSnapLine[] = []\n\n\t\tif (nearestSnapsX.length > 0) {\n\t\t\tfor (const snap of nearestSnapsX) {\n\t\t\t\tif (snap.type === 'points') continue\n\n\t\t\t\tconst {\n\t\t\t\t\tgap: { breadthIntersection, startEdge, startNode, endNode, length, endEdge },\n\t\t\t\t} = snap\n\n\t\t\t\tswitch (snap.type) {\n\t\t\t\t\tcase 'gap_center': {\n\t\t\t\t\t\t// create\n\t\t\t\t\t\tconst newGapsLength = (length - selectionPageBounds.width) / 2\n\t\t\t\t\t\tconst gapBreadthIntersection = rangeIntersection(\n\t\t\t\t\t\t\tbreadthIntersection[0],\n\t\t\t\t\t\t\tbreadthIntersection[1],\n\t\t\t\t\t\t\tselectionPageBounds.minY,\n\t\t\t\t\t\t\tselectionPageBounds.maxY\n\t\t\t\t\t\t)!\n\t\t\t\t\t\tresult.push({\n\t\t\t\t\t\t\ttype: 'gaps',\n\t\t\t\t\t\t\tdirection: 'horizontal',\n\t\t\t\t\t\t\tid: uniqueId(),\n\t\t\t\t\t\t\tgaps: [\n\t\t\t\t\t\t\t\t...findAdjacentGaps(\n\t\t\t\t\t\t\t\t\thorizontal,\n\t\t\t\t\t\t\t\t\tstartNode.id,\n\t\t\t\t\t\t\t\t\tnewGapsLength,\n\t\t\t\t\t\t\t\t\t'backward',\n\t\t\t\t\t\t\t\t\tgapBreadthIntersection,\n\t\t\t\t\t\t\t\t\t0\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tstartEdge,\n\t\t\t\t\t\t\t\t\tendEdge: selectionSides.left,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tstartEdge: selectionSides.right,\n\t\t\t\t\t\t\t\t\tendEdge,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t...findAdjacentGaps(\n\t\t\t\t\t\t\t\t\thorizontal,\n\t\t\t\t\t\t\t\t\tendNode.id,\n\t\t\t\t\t\t\t\t\tnewGapsLength,\n\t\t\t\t\t\t\t\t\t'forward',\n\t\t\t\t\t\t\t\t\tgapBreadthIntersection,\n\t\t\t\t\t\t\t\t\t0\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t],\n\t\t\t\t\t\t})\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t\tcase 'gap_duplicate': {\n\t\t\t\t\t\t// create\n\t\t\t\t\t\tconst gapBreadthIntersection = rangeIntersection(\n\t\t\t\t\t\t\tbreadthIntersection[0],\n\t\t\t\t\t\t\tbreadthIntersection[1],\n\t\t\t\t\t\t\tselectionPageBounds.minY,\n\t\t\t\t\t\t\tselectionPageBounds.maxY\n\t\t\t\t\t\t)!\n\t\t\t\t\t\tresult.push({\n\t\t\t\t\t\t\ttype: 'gaps',\n\t\t\t\t\t\t\tdirection: 'horizontal',\n\t\t\t\t\t\t\tid: uniqueId(),\n\t\t\t\t\t\t\tgaps:\n\t\t\t\t\t\t\t\tsnap.protrusionDirection === 'left'\n\t\t\t\t\t\t\t\t\t? [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tstartEdge: selectionSides.right,\n\t\t\t\t\t\t\t\t\t\t\t\tendEdge: startEdge.map((v) =>\n\t\t\t\t\t\t\t\t\t\t\t\t\tv.clone().addXY(-startNode.pageBounds.width, 0)\n\t\t\t\t\t\t\t\t\t\t\t\t) as [Vec2d, Vec2d],\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t{ startEdge, endEdge },\n\t\t\t\t\t\t\t\t\t\t\t...findAdjacentGaps(\n\t\t\t\t\t\t\t\t\t\t\t\thorizontal,\n\t\t\t\t\t\t\t\t\t\t\t\tendNode.id,\n\t\t\t\t\t\t\t\t\t\t\t\tlength,\n\t\t\t\t\t\t\t\t\t\t\t\t'forward',\n\t\t\t\t\t\t\t\t\t\t\t\tgapBreadthIntersection,\n\t\t\t\t\t\t\t\t\t\t\t\t0\n\t\t\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t\t  ]\n\t\t\t\t\t\t\t\t\t: [\n\t\t\t\t\t\t\t\t\t\t\t...findAdjacentGaps(\n\t\t\t\t\t\t\t\t\t\t\t\thorizontal,\n\t\t\t\t\t\t\t\t\t\t\t\tstartNode.id,\n\t\t\t\t\t\t\t\t\t\t\t\tlength,\n\t\t\t\t\t\t\t\t\t\t\t\t'backward',\n\t\t\t\t\t\t\t\t\t\t\t\tgapBreadthIntersection,\n\t\t\t\t\t\t\t\t\t\t\t\t0\n\t\t\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t\t\t\t{ startEdge, endEdge },\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tstartEdge: endEdge.map((v) =>\n\t\t\t\t\t\t\t\t\t\t\t\t\tv.clone().addXY(snap.gap.endNode.pageBounds.width, 0)\n\t\t\t\t\t\t\t\t\t\t\t\t) as [Vec2d, Vec2d],\n\t\t\t\t\t\t\t\t\t\t\t\tendEdge: selectionSides.left,\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t  ],\n\t\t\t\t\t\t})\n\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (nearestSnapsY.length > 0) {\n\t\t\tfor (const snap of nearestSnapsY) {\n\t\t\t\tif (snap.type === 'points') continue\n\n\t\t\t\tconst {\n\t\t\t\t\tgap: { breadthIntersection, startEdge, startNode, endNode, length, endEdge },\n\t\t\t\t} = snap\n\n\t\t\t\tswitch (snap.type) {\n\t\t\t\t\tcase 'gap_center': {\n\t\t\t\t\t\tconst newGapsLength = (length - selectionPageBounds.height) / 2\n\t\t\t\t\t\tconst gapBreadthIntersection = rangeIntersection(\n\t\t\t\t\t\t\tbreadthIntersection[0],\n\t\t\t\t\t\t\tbreadthIntersection[1],\n\t\t\t\t\t\t\tselectionPageBounds.minX,\n\t\t\t\t\t\t\tselectionPageBounds.maxX\n\t\t\t\t\t\t)!\n\n\t\t\t\t\t\tresult.push({\n\t\t\t\t\t\t\ttype: 'gaps',\n\t\t\t\t\t\t\tdirection: 'vertical',\n\t\t\t\t\t\t\tid: uniqueId(),\n\t\t\t\t\t\t\tgaps: [\n\t\t\t\t\t\t\t\t...findAdjacentGaps(\n\t\t\t\t\t\t\t\t\tvertical,\n\t\t\t\t\t\t\t\t\tstartNode.id,\n\t\t\t\t\t\t\t\t\tnewGapsLength,\n\t\t\t\t\t\t\t\t\t'backward',\n\t\t\t\t\t\t\t\t\tgapBreadthIntersection,\n\t\t\t\t\t\t\t\t\t0\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tstartEdge,\n\t\t\t\t\t\t\t\t\tendEdge: selectionSides.top,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tstartEdge: selectionSides.bottom,\n\t\t\t\t\t\t\t\t\tendEdge,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t...findAdjacentGaps(\n\t\t\t\t\t\t\t\t\tvertical,\n\t\t\t\t\t\t\t\t\tsnap.gap.endNode.id,\n\t\t\t\t\t\t\t\t\tnewGapsLength,\n\t\t\t\t\t\t\t\t\t'forward',\n\t\t\t\t\t\t\t\t\tgapBreadthIntersection,\n\t\t\t\t\t\t\t\t\t0\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t],\n\t\t\t\t\t\t})\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t\tcase 'gap_duplicate':\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tconst gapBreadthIntersection = rangeIntersection(\n\t\t\t\t\t\t\t\tbreadthIntersection[0],\n\t\t\t\t\t\t\t\tbreadthIntersection[1],\n\t\t\t\t\t\t\t\tselectionPageBounds.minX,\n\t\t\t\t\t\t\t\tselectionPageBounds.maxX\n\t\t\t\t\t\t\t)!\n\n\t\t\t\t\t\t\tresult.push({\n\t\t\t\t\t\t\t\ttype: 'gaps',\n\t\t\t\t\t\t\t\tdirection: 'vertical',\n\t\t\t\t\t\t\t\tid: uniqueId(),\n\t\t\t\t\t\t\t\tgaps:\n\t\t\t\t\t\t\t\t\tsnap.protrusionDirection === 'top'\n\t\t\t\t\t\t\t\t\t\t? [\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\tstartEdge: selectionSides.bottom,\n\t\t\t\t\t\t\t\t\t\t\t\t\tendEdge: startEdge.map((v) =>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tv.clone().addXY(0, -startNode.pageBounds.height)\n\t\t\t\t\t\t\t\t\t\t\t\t\t) as [Vec2d, Vec2d],\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t{ startEdge, endEdge },\n\t\t\t\t\t\t\t\t\t\t\t\t...findAdjacentGaps(\n\t\t\t\t\t\t\t\t\t\t\t\t\tvertical,\n\t\t\t\t\t\t\t\t\t\t\t\t\tendNode.id,\n\t\t\t\t\t\t\t\t\t\t\t\t\tlength,\n\t\t\t\t\t\t\t\t\t\t\t\t\t'forward',\n\t\t\t\t\t\t\t\t\t\t\t\t\tgapBreadthIntersection,\n\t\t\t\t\t\t\t\t\t\t\t\t\t0\n\t\t\t\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t\t\t  ]\n\t\t\t\t\t\t\t\t\t\t: [\n\t\t\t\t\t\t\t\t\t\t\t\t...findAdjacentGaps(\n\t\t\t\t\t\t\t\t\t\t\t\t\tvertical,\n\t\t\t\t\t\t\t\t\t\t\t\t\tstartNode.id,\n\t\t\t\t\t\t\t\t\t\t\t\t\tlength,\n\t\t\t\t\t\t\t\t\t\t\t\t\t'backward',\n\t\t\t\t\t\t\t\t\t\t\t\t\tgapBreadthIntersection,\n\t\t\t\t\t\t\t\t\t\t\t\t\t0\n\t\t\t\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t\t\t\t\t{ startEdge, endEdge },\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\tstartEdge: endEdge.map((v) =>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tv.clone().addXY(0, endNode.pageBounds.height)\n\t\t\t\t\t\t\t\t\t\t\t\t\t) as [Vec2d, Vec2d],\n\t\t\t\t\t\t\t\t\t\t\t\t\tendEdge: selectionSides.top,\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t  ],\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdedupeGapSnaps(result)\n\t\treturn result\n\t}\n}\n\nfunction getResizeSnapPointsForHandle(\n\thandle: SelectionCorner | SelectionEdge | 'any',\n\tselectionPageBounds: Box2d\n): SnapPoint[] {\n\tconst { minX, maxX, minY, maxY } = selectionPageBounds\n\tconst result: SnapPoint[] = []\n\n\t// top left corner\n\tswitch (handle) {\n\t\tcase 'top':\n\t\tcase 'left':\n\t\tcase 'top_left':\n\t\tcase 'any':\n\t\t\tresult.push({\n\t\t\t\tid: 'top_left',\n\t\t\t\thandle: 'top_left',\n\t\t\t\tx: minX,\n\t\t\t\ty: minY,\n\t\t\t})\n\t}\n\n\t// top right corner\n\tswitch (handle) {\n\t\tcase 'top':\n\t\tcase 'right':\n\t\tcase 'top_right':\n\t\tcase 'any':\n\t\t\tresult.push({\n\t\t\t\tid: 'top_right',\n\t\t\t\thandle: 'top_right',\n\t\t\t\tx: maxX,\n\t\t\t\ty: minY,\n\t\t\t})\n\t}\n\n\t// bottom right corner\n\tswitch (handle) {\n\t\tcase 'bottom':\n\t\tcase 'right':\n\t\tcase 'bottom_right':\n\t\tcase 'any':\n\t\t\tresult.push({\n\t\t\t\tid: 'bottom_right',\n\t\t\t\thandle: 'bottom_right',\n\t\t\t\tx: maxX,\n\t\t\t\ty: maxY,\n\t\t\t})\n\t}\n\n\t// bottom left corner\n\tswitch (handle) {\n\t\tcase 'bottom':\n\t\tcase 'left':\n\t\tcase 'bottom_left':\n\t\tcase 'any':\n\t\t\tresult.push({\n\t\t\t\tid: 'bottom_left',\n\t\t\t\thandle: 'bottom_left',\n\t\t\t\tx: minX,\n\t\t\t\ty: maxY,\n\t\t\t})\n\t}\n\n\treturn result\n}\n"],"mappings":";;;;;;;;;;;;;AAAA,SACCA,KAAA,EACAC,oBAAA,EACAC,oBAAA,EACAC,iBAAA,EACAC,QAAA,EACAC,iBAAA,EACAC,aAAA,EAGAC,KAAA,QAEM;AAEP,SAASC,MAAA,EAAQC,QAAA,QAAgB;AACjC,SAASC,IAAA,EAAMC,QAAA,EAAUC,WAAA,QAAmB;AAC5C,SAASC,QAAA,QAAgB;AAEzB,SAASC,cAAA,QAAsB;AAmG/B,IAAMC,KAAA,GAAQ,SAARA,MAASC,CAAA,EAAc;EAE5B,IAAMC,sBAAA,GAAyB;EAC/B,OAAOC,IAAA,CAAKH,KAAA,CAAMC,CAAA,GAAAE,IAAA,CAAAC,GAAA,CAAI,IAAMF,sBAAsB,KAAAC,IAAA,CAAAC,GAAA,CAAI,IAAMF,sBAAA;AAC7D;AAEA,SAASG,iBACRC,IAAA,EACAC,OAAA,EACAC,SAAA,EACAC,SAAA,EACAC,YAAA,EACAC,KAAA,EACQ;EACR,IAAIA,KAAA,GAAQ,IAAI,OAAO,EAAC;EAGxB,IAAMC,OAAA,GAAUN,IAAA,CAAKO,MAAA,CACpB,UAACC,GAAA;IAAA,QACCL,SAAA,KAAc,YAAYK,GAAA,CAAIC,SAAA,CAAUC,EAAA,KAAOT,OAAA,GAAUO,GAAA,CAAIG,OAAA,CAAQD,EAAA,KAAOT,OAAA,KAC7EP,KAAA,CAAMc,GAAA,CAAII,MAAM,MAAMlB,KAAA,CAAMQ,SAAS,KACrClB,iBAAA,CACCwB,GAAA,CAAIK,mBAAA,CAAoB,CAAC,GACzBL,GAAA,CAAIK,mBAAA,CAAoB,CAAC,GACzBT,YAAA,CAAa,CAAC,GACdA,YAAA,CAAa,CAAC,CACf;EAAA,CACF;EAEA,IAAIE,OAAA,CAAQM,MAAA,KAAW,GAAG,OAAO,EAAC;EAElC,IAAME,SAAA,GAAY,mBAAIC,GAAA,CAAe;EAAA,IAAAC,SAAA,GAAAC,0BAAA,CAEjBX,OAAA;IAAAY,KAAA;EAAA;IAApB,KAAAF,SAAA,CAAAG,CAAA,MAAAD,KAAA,GAAAF,SAAA,CAAAI,CAAA,IAAAC,IAAA,GAA6B;MAAA,IAAlBC,KAAA,GAAAJ,KAAA,CAAAK,KAAA;MACV,IAAMC,IAAA,GAAOrB,SAAA,KAAc,YAAYmB,KAAA,CAAMX,OAAA,CAAQD,EAAA,GAAKY,KAAA,CAAMb,SAAA,CAAUC,EAAA;MAC1E,IAAI,CAACI,SAAA,CAAUW,GAAA,CAAID,IAAI,GAAG;QACzBV,SAAA,CAAUY,GAAA,CAAIF,IAAI;QAClBlB,OAAA,CAAQqB,IAAA,CAAAC,KAAA,CAARtB,OAAA,EAAAuB,kBAAA,CACI9B,gBAAA,CACFC,IAAA,EACAwB,IAAA,EACAtB,SAAA,EACAC,SAAA,EACAnB,iBAAA,CACCsC,KAAA,CAAMT,mBAAA,CAAoB,CAAC,GAC3BS,KAAA,CAAMT,mBAAA,CAAoB,CAAC,GAC3BT,YAAA,CAAa,CAAC,GACdA,YAAA,CAAa,CAAC,CACf,GACAC,KAAA,GAAQ,CACT,EACD;MACD;IACD;EAAA,SAAAyB,GAAA;IAAAd,SAAA,CAAAe,CAAA,CAAAD,GAAA;EAAA;IAAAd,SAAA,CAAAgB,CAAA;EAAA;EAEA,OAAO1B,OAAA;AACR;AAEA,SAAS2B,eAAeC,KAAA,EAAmD;EAE1EA,KAAA,CAAMC,IAAA,CAAK,UAACC,CAAA,EAAGC,CAAA;IAAA,OAAMA,CAAA,CAAErC,IAAA,CAAKY,MAAA,GAASwB,CAAA,CAAEpC,IAAA,CAAKY,MAAM;EAAA;EAElD,SAAS0B,CAAA,GAAIJ,KAAA,CAAMtB,MAAA,GAAS,GAAG0B,CAAA,GAAI,GAAGA,CAAA,IAAK;IAC1C,IAAMC,IAAA,GAAOL,KAAA,CAAMI,CAAC;IAAA,IAAAE,KAAA,YAAAA,MAAA,EACa;MAChC,IAAMC,SAAA,GAAYP,KAAA,CAAMQ,CAAC;MAEzB,IACCD,SAAA,CAAUtC,SAAA,KAAcoC,IAAA,CAAKpC,SAAA,IAC7BoC,IAAA,CAAKvC,IAAA,CAAK2C,KAAA,CACT,UAACnC,GAAA;QAAA,OACAiC,SAAA,CAAUzC,IAAA,CAAK4C,IAAA,CACd,UAACC,QAAA;UAAA,OACAnD,KAAA,CAAMc,GAAA,CAAIsC,SAAA,CAAU,CAAC,EAAEnD,CAAC,MAAMD,KAAA,CAAMmD,QAAA,CAASC,SAAA,CAAU,CAAC,EAAEnD,CAAC,KAC3DD,KAAA,CAAMc,GAAA,CAAIsC,SAAA,CAAU,CAAC,EAAEC,CAAC,MAAMrD,KAAA,CAAMmD,QAAA,CAASC,SAAA,CAAU,CAAC,EAAEC,CAAC,KAC3DrD,KAAA,CAAMc,GAAA,CAAIsC,SAAA,CAAU,CAAC,EAAEnD,CAAC,MAAMD,KAAA,CAAMmD,QAAA,CAASC,SAAA,CAAU,CAAC,EAAEnD,CAAC,KAC3DD,KAAA,CAAMc,GAAA,CAAIsC,SAAA,CAAU,CAAC,EAAEC,CAAC,MAAMrD,KAAA,CAAMmD,QAAA,CAASC,SAAA,CAAU,CAAC,EAAEC,CAAC;QAAA,CAC7D,KACAN,SAAA,CAAUzC,IAAA,CAAK4C,IAAA,CACd,UAACC,QAAA;UAAA,OACAnD,KAAA,CAAMc,GAAA,CAAIwC,OAAA,CAAQ,CAAC,EAAErD,CAAC,MAAMD,KAAA,CAAMmD,QAAA,CAASG,OAAA,CAAQ,CAAC,EAAErD,CAAC,KACvDD,KAAA,CAAMc,GAAA,CAAIwC,OAAA,CAAQ,CAAC,EAAED,CAAC,MAAMrD,KAAA,CAAMmD,QAAA,CAASG,OAAA,CAAQ,CAAC,EAAED,CAAC,KACvDrD,KAAA,CAAMc,GAAA,CAAIwC,OAAA,CAAQ,CAAC,EAAErD,CAAC,MAAMD,KAAA,CAAMmD,QAAA,CAASG,OAAA,CAAQ,CAAC,EAAErD,CAAC,KACvDD,KAAA,CAAMc,GAAA,CAAIwC,OAAA,CAAQ,CAAC,EAAED,CAAC,MAAMrD,KAAA,CAAMmD,QAAA,CAASG,OAAA,CAAQ,CAAC,EAAED,CAAC;QAAA,CACzD;MAAA,CACF,GACC;QACDb,KAAA,CAAMe,MAAA,CAAOX,CAAA,EAAG,CAAC;QAAA;MAElB;IACD;IA1BA,SAASI,CAAA,GAAIJ,CAAA,GAAI,GAAGI,CAAA,IAAK,GAAGA,CAAA;MAAA,IAAAF,KAAA,IAwB1B;IAAA;EAGH;AACD;AAAA,IAEaU,WAAA;EAiBZ,SAAAA,YAA4BC,MAAA,EAAgB;IAAAC,eAAA,OAAAF,WAAA;IAAAG,eAAA,qBAhBvBhE,IAAA,CAA6B,aAAa,MAAS;IAgB5C,KAAA8D,MAAA,GAAAA,MAAA;EAAiB;EAAAG,YAAA,CAAAJ,WAAA;IAAAK,GAAA;IAAAC,GAAA,EAd7C,SAAAA,IAAA,EAAY;MAAA,IAAAC,qBAAA;MACX,QAAAA,qBAAA,GAAO,KAAKC,UAAA,CAAWnC,KAAA,cAAAkC,qBAAA,cAAAA,qBAAA,GAAUlE,WAAA;IAClC;EAAA;IAAAgE,GAAA;IAAAhC,KAAA,EAEA,SAAAoC,MAAA,EAAQ;MACP,IAAI,KAAKC,KAAA,CAAMhD,MAAA,EAAQ;QACtB,KAAK8C,UAAA,CAAWG,GAAA,CAAI,MAAS;MAC9B;IACD;EAAA;IAAAN,GAAA;IAAAhC,KAAA,EAEA,SAAAuC,SAASF,KAAA,EAAmB;MAC3B,KAAKF,UAAA,CAAWG,GAAA,CAAID,KAAK;IAC1B;EAAA;IAAAL,GAAA;IAAAC,GAAA,EAIU,SAAAA,IAAA,EAAsB;MAAA,IAAAO,KAAA;MAC/B,OAAO,KAAKZ,MAAA,CAAOa,KAAA,CAAMC,mBAAA,CAA0C,cAAc,UAACC,KAAA,EAAU;QAC3F,IAAMC,cAAA,GAAiBJ,KAAA,CAAKZ,MAAA,CAAOiB,oBAAA,CAAqBF,KAAA,CAAMxD,EAAE;QAChE,IAAI,CAACyD,cAAA,EAAgB,OAAO;QAC5B,IAAME,IAAA,GAAON,KAAA,CAAKZ,MAAA,CAAOmB,YAAA,CAAaJ,KAAK;QAC3C,IAAMK,UAAA,GAAaF,IAAA,CAAKE,UAAA,CAAWL,KAAK;QACxC,OAAOK,UAAA,CAAWC,GAAA,CAAI,UAACC,KAAA,EAAOnC,CAAA,EAAM;UACnC,IAAAoC,qBAAA,GAAiB3F,QAAA,CAAS4F,YAAA,CAAaR,cAAA,EAAgBM,KAAK;YAApD9E,CAAA,GAAA+E,qBAAA,CAAA/E,CAAA;YAAGoD,CAAA,GAAA2B,qBAAA,CAAA3B,CAAA;UACX,OAAO;YAAEpD,CAAA,EAAAA,CAAA;YAAGoD,CAAA,EAAAA,CAAA;YAAGrC,EAAA,KAAAkE,MAAA,CAAOV,KAAA,CAAMxD,EAAA,OAAAkE,MAAA,CAAMtC,CAAA;UAAI;QACvC,CAAC;MACF,CAAC;IACF;EAAA;IAAAiB,GAAA;IAAAC,GAAA,EAEU,SAAAA,IAAA,EAAoB;MAC7B,OAAO,IAAI,KAAKL,MAAA,CAAO0B,SAAA;IACxB;EAAA;IAAAtB,GAAA;IAAAC,GAAA,EAGU,SAAAA,IAAA,EAAiC;MAAA,IAAAsB,qBAAA;MAC1C,IAAQ3B,MAAA,GAAW,KAAXA,MAAA;MACR,IAAQ4B,WAAA,GAAkD5B,MAAA,CAAlD4B,WAAA;QAAaC,eAAA,GAAqC7B,MAAA,CAArC6B,eAAA;MAErB,IAAMC,eAAA,GAA6B,EAAC;MAEpC,IAAMC,gCAAA,GAAmC,SAAnCA,iCAAoCC,QAAA,EAAyB;QAClE,IAAMC,cAAA,GAAiBjC,MAAA,CAAOkC,iBAAA,CAAkBF,QAAQ;QAAA,IAAAG,UAAA,GAAArE,0BAAA,CAClCmE,cAAA;UAAAG,MAAA;QAAA;UAAtB,KAAAD,UAAA,CAAAnE,CAAA,MAAAoE,MAAA,GAAAD,UAAA,CAAAlE,CAAA,IAAAC,IAAA,GAAsC;YAAA,IAA3BmE,OAAA,GAAAD,MAAA,CAAAhE,KAAA;YAEV,IAAIwD,WAAA,CAAYU,QAAA,CAASD,OAAO,GAAG;YACnC,IAAME,UAAA,GAAavC,MAAA,CAAOwC,YAAA,CAAaH,OAAO;YAC9C,IAAI,CAACE,UAAA,EAAY;YACjB,IAAMrB,IAAA,GAAOlB,MAAA,CAAOmB,YAAA,CAAaoB,UAAU;YAE3C,IAAI,CAACrB,IAAA,CAAKuB,OAAA,CAAQF,UAAU,GAAG;YAE/B,IAAMG,UAAA,GAAa1C,MAAA,CAAO2C,iBAAA,CAAkBN,OAAO;YACnD,IAAI,EAAEK,UAAA,IAAcb,eAAA,CAAgBS,QAAA,CAASI,UAAU,IAAI;YAE3D,IAAI1C,MAAA,CAAO4C,aAAA,CAAcL,UAAA,EAAYjG,cAAc,GAAG;cACrDyF,gCAAA,CAAiCM,OAAO;cACxC;YACD;YACAP,eAAA,CAAgBtD,IAAA,CAAK;cAAEjB,EAAA,EAAI8E,OAAA;cAASK,UAAA,EAAAA,UAAA;cAAYG,QAAA,EAAU3B,IAAA,CAAK2B,QAAA,CAASN,UAAU;YAAE,CAAC;UACtF;QAAA,SAAA5D,GAAA;UAAAwD,UAAA,CAAAvD,CAAA,CAAAD,GAAA;QAAA;UAAAwD,UAAA,CAAAtD,CAAA;QAAA;MACD;MAEAkD,gCAAA,EAAAJ,qBAAA,GAAiC,KAAKmB,qBAAA,cAAAnB,qBAAA,cAAAA,qBAAA,GAAyB3B,MAAA,CAAO+C,aAAa;MAEnF,OAAOjB,eAAA;IACR;EAAA;IAAA1B,GAAA;IAAAC,GAAA,EAGU,SAAAA,IAAA,EAA4B;MACrC,OAAO,KAAKL,MAAA,CAAOgD,kBAAA,CAAmB,KAAKhD,MAAA,CAAOiD,cAAc;IACjE;EAAA;IAAA7C,GAAA;IAAAC,GAAA,EAGU,SAAAA,IAAA,EAAsB;MAC/B,IAAQyB,eAAA,GAAqC,KAArCA,eAAA;QAAiBoB,eAAA,GAAoB,KAApBA,eAAA;MACzB,IAAMC,MAAA,GAAsB,EAAC;MAE7BrB,eAAA,CAAgBsB,OAAA,CAAQ,UAACrC,KAAA,EAAU;QAClC,IAAMK,UAAA,GAAa8B,eAAA,CAAgB7C,GAAA,CAAIU,KAAA,CAAMxD,EAAE;QAC/C,IAAI6D,UAAA,EAAY;UACf+B,MAAA,CAAO3E,IAAA,CAAAC,KAAA,CAAP0E,MAAA,EAAAzE,kBAAA,CAAe0C,UAAU;QAC1B;MACD,CAAC;MAED,OAAO+B,MAAA;IACR;EAAA;IAAA/C,GAAA;IAAAC,GAAA,EAEU,SAAAA,IAAA,EAA0D;MACnE,IAAMgD,UAAA,GAAoB,EAAC;MAC3B,IAAMC,QAAA,GAAkB,EAAC;MAEzB,IAAIhG,SAAA,EAAoBE,OAAA;MAExB,IAAM+F,sBAAA,GAAyB,KAAKzB,eAAA,CAAgB9C,IAAA,CAAK,UAACC,CAAA,EAAGC,CAAA,EAAM;QAClE,OAAOD,CAAA,CAAEyD,UAAA,CAAWc,IAAA,GAAOtE,CAAA,CAAEwD,UAAA,CAAWc,IAAA;MACzC,CAAC;MAGD,SAASrE,CAAA,GAAI,GAAGA,CAAA,GAAIoE,sBAAA,CAAuB9F,MAAA,EAAQ0B,CAAA,IAAK;QACvD7B,SAAA,GAAYiG,sBAAA,CAAuBpE,CAAC;QACpC,SAASI,CAAA,GAAIJ,CAAA,GAAI,GAAGI,CAAA,GAAIgE,sBAAA,CAAuB9F,MAAA,EAAQ8B,CAAA,IAAK;UAC3D/B,OAAA,GAAU+F,sBAAA,CAAuBhE,CAAC;UAElC;UAAA;UAECjC,SAAA,CAAUoF,UAAA,CAAWe,IAAA,GAAOjG,OAAA,CAAQkF,UAAA,CAAWc,IAAA;UAAA;UAE/C1H,aAAA,CACCwB,SAAA,CAAUoF,UAAA,CAAWgB,IAAA,EACrBpG,SAAA,CAAUoF,UAAA,CAAWiB,IAAA,EACrBnG,OAAA,CAAQkF,UAAA,CAAWgB,IAAA,EACnBlG,OAAA,CAAQkF,UAAA,CAAWiB,IACpB,GACC;YACDN,UAAA,CAAW7E,IAAA,CAAK;cACflB,SAAA,EAAAA,SAAA;cACAE,OAAA,EAAAA,OAAA;cACAmC,SAAA,EAAW,CACV,IAAI5D,KAAA,CAAMuB,SAAA,CAAUoF,UAAA,CAAWe,IAAA,EAAMnG,SAAA,CAAUoF,UAAA,CAAWgB,IAAI,GAC9D,IAAI3H,KAAA,CAAMuB,SAAA,CAAUoF,UAAA,CAAWe,IAAA,EAAMnG,SAAA,CAAUoF,UAAA,CAAWiB,IAAI,EAC/D;cACA9D,OAAA,EAAS,CACR,IAAI9D,KAAA,CAAMyB,OAAA,CAAQkF,UAAA,CAAWc,IAAA,EAAMhG,OAAA,CAAQkF,UAAA,CAAWgB,IAAI,GAC1D,IAAI3H,KAAA,CAAMyB,OAAA,CAAQkF,UAAA,CAAWc,IAAA,EAAMhG,OAAA,CAAQkF,UAAA,CAAWiB,IAAI,EAC3D;cACAlG,MAAA,EAAQD,OAAA,CAAQkF,UAAA,CAAWc,IAAA,GAAOlG,SAAA,CAAUoF,UAAA,CAAWe,IAAA;cACvD/F,mBAAA,EAAqB7B,iBAAA,CACpByB,SAAA,CAAUoF,UAAA,CAAWgB,IAAA,EACrBpG,SAAA,CAAUoF,UAAA,CAAWiB,IAAA,EACrBnG,OAAA,CAAQkF,UAAA,CAAWgB,IAAA,EACnBlG,OAAA,CAAQkF,UAAA,CAAWiB,IACpB;YACD,CAAC;UACF;QACD;MACD;MAGA,IAAMC,oBAAA,GAAuBL,sBAAA,CAAuBvE,IAAA,CAAK,UAACC,CAAA,EAAGC,CAAA,EAAM;QAClE,OAAOD,CAAA,CAAEyD,UAAA,CAAWgB,IAAA,GAAOxE,CAAA,CAAEwD,UAAA,CAAWgB,IAAA;MACzC,CAAC;MAED,SAASvE,EAAA,GAAI,GAAGA,EAAA,GAAIyE,oBAAA,CAAqBnG,MAAA,EAAQ0B,EAAA,IAAK;QACrD7B,SAAA,GAAYsG,oBAAA,CAAqBzE,EAAC;QAClC,SAASI,EAAA,GAAIJ,EAAA,GAAI,GAAGI,EAAA,GAAIqE,oBAAA,CAAqBnG,MAAA,EAAQ8B,EAAA,IAAK;UACzD/B,OAAA,GAAUoG,oBAAA,CAAqBrE,EAAC;UAEhC;UAAA;UAECjC,SAAA,CAAUoF,UAAA,CAAWiB,IAAA,GAAOnG,OAAA,CAAQkF,UAAA,CAAWgB,IAAA;UAAA;UAE/C5H,aAAA,CACCwB,SAAA,CAAUoF,UAAA,CAAWc,IAAA,EACrBlG,SAAA,CAAUoF,UAAA,CAAWe,IAAA,EACrBjG,OAAA,CAAQkF,UAAA,CAAWc,IAAA,EACnBhG,OAAA,CAAQkF,UAAA,CAAWe,IACpB,GACC;YACDH,QAAA,CAAS9E,IAAA,CAAK;cACblB,SAAA,EAAAA,SAAA;cACAE,OAAA,EAAAA,OAAA;cACAmC,SAAA,EAAW,CACV,IAAI5D,KAAA,CAAMuB,SAAA,CAAUoF,UAAA,CAAWc,IAAA,EAAMlG,SAAA,CAAUoF,UAAA,CAAWiB,IAAI,GAC9D,IAAI5H,KAAA,CAAMuB,SAAA,CAAUoF,UAAA,CAAWe,IAAA,EAAMnG,SAAA,CAAUoF,UAAA,CAAWiB,IAAI,EAC/D;cACA9D,OAAA,EAAS,CACR,IAAI9D,KAAA,CAAMyB,OAAA,CAAQkF,UAAA,CAAWc,IAAA,EAAMhG,OAAA,CAAQkF,UAAA,CAAWgB,IAAI,GAC1D,IAAI3H,KAAA,CAAMyB,OAAA,CAAQkF,UAAA,CAAWe,IAAA,EAAMjG,OAAA,CAAQkF,UAAA,CAAWgB,IAAI,EAC3D;cACAjG,MAAA,EAAQD,OAAA,CAAQkF,UAAA,CAAWgB,IAAA,GAAOpG,SAAA,CAAUoF,UAAA,CAAWiB,IAAA;cACvDjG,mBAAA,EAAqB7B,iBAAA,CACpByB,SAAA,CAAUoF,UAAA,CAAWc,IAAA,EACrBlG,SAAA,CAAUoF,UAAA,CAAWe,IAAA,EACrBjG,OAAA,CAAQkF,UAAA,CAAWc,IAAA,EACnBhG,OAAA,CAAQkF,UAAA,CAAWe,IACpB;YACD,CAAC;UACF;QACD;MACD;MAEA,OAAO;QAAEJ,UAAA,EAAAA,UAAA;QAAYC,QAAA,EAAAA;MAAS;IAC/B;EAAA;IAAAlD,GAAA;IAAAhC,KAAA,EAEA,SAAAyF,cAAAC,IAAA,EAUa;MAAA,IAAAC,qBAAA,EAAAC,eAAA,EAAAC,qBAAA,EAAAC,eAAA;MAAA,IATZC,UAAA,GAAAL,IAAA,CAAAK,UAAA;QACAC,0BAAA,GAAAN,IAAA,CAAAM,0BAAA;QACAC,0BAAA,GAAAP,IAAA,CAAAO,0BAAA;QACAC,SAAA,GAAAR,IAAA,CAAAQ,SAAA;MAOA,IAAyBC,+BAAA,GAAmD,KAApEC,eAAA;QAAkDC,aAAA,GAAkB,KAAlBA,aAAA;MAE1D,IAAMC,mBAAA,GAAsBN,0BAAA,CAA2BO,KAAA,CAAM,EAAEC,SAAA,CAAUN,SAAS;MAElF,IAAMO,mBAAA,GAAmCR,0BAAA,CAA2BhD,GAAA,CAAI,UAAAyD,KAAA,EAAW3F,CAAA;QAAA,IAAR3C,CAAA,GAAAsI,KAAA,CAAAtI,CAAA;UAAGoD,CAAA,GAAAkF,KAAA,CAAAlF,CAAA;QAAA,OAAY;UACzFrC,EAAA,EAAI,eAAe4B,CAAA;UACnB3C,CAAA,EAAGA,CAAA,GAAI8H,SAAA,CAAU9H,CAAA;UACjBoD,CAAA,EAAGA,CAAA,GAAI0E,SAAA,CAAU1E;QAClB;MAAA,CAAE;MAEF,IAAMmF,mBAAA,GAAsBR,+BAAA;MAE5B,IAAMS,aAAA,GAA+B,EAAC;MACtC,IAAMC,aAAA,GAA+B,EAAC;MACtC,IAAMC,SAAA,GAAY,IAAInJ,KAAA,CAAM0I,aAAA,EAAeA,aAAa;MAExD,KAAKU,iBAAA,CAAkB;QACtBD,SAAA,EAAAA,SAAA;QACAF,aAAA,EAAAA,aAAA;QACAC,aAAA,EAAAA,aAAA;QACAF,mBAAA,EAAAA,mBAAA;QACAF,mBAAA,EAAAA;MACD,CAAC;MAED,KAAKO,eAAA,CAAgB;QACpBV,mBAAA,EAAAA,mBAAA;QACAM,aAAA,EAAAA,aAAA;QACAC,aAAA,EAAAA,aAAA;QACAC,SAAA,EAAAA;MACD,CAAC;MAGD,IAAMG,KAAA,GAAQ,IAAItJ,KAAA,CACjBoI,UAAA,KAAe,MAAM,KAAAJ,qBAAA,IAAAC,eAAA,GAAIgB,aAAA,CAAc,CAAC,eAAAhB,eAAA,uBAAfA,eAAA,CAAkBqB,KAAA,cAAAtB,qBAAA,cAAAA,qBAAA,GAAS,GACpDI,UAAA,KAAe,MAAM,KAAAF,qBAAA,IAAAC,eAAA,GAAIe,aAAA,CAAc,CAAC,eAAAf,eAAA,uBAAfA,eAAA,CAAkBmB,KAAA,cAAApB,qBAAA,cAAAA,qBAAA,GAAS,CACrD;MAKAiB,SAAA,CAAU1I,CAAA,GAAI;MACd0I,SAAA,CAAUtF,CAAA,GAAI;MACdoF,aAAA,CAAcvH,MAAA,GAAS;MACvBwH,aAAA,CAAcxH,MAAA,GAAS;MACvBoH,mBAAA,CAAoBzB,OAAA,CAAQ,UAACpF,CAAA,EAAM;QAClCA,CAAA,CAAExB,CAAA,IAAK6I,KAAA,CAAM7I,CAAA;QACbwB,CAAA,CAAE4B,CAAA,IAAKyF,KAAA,CAAMzF,CAAA;MACd,CAAC;MACD8E,mBAAA,CAAoBE,SAAA,CAAUS,KAAK;MAEnC,KAAKF,iBAAA,CAAkB;QACtBD,SAAA,EAAAA,SAAA;QACAF,aAAA,EAAAA,aAAA;QACAC,aAAA,EAAAA,aAAA;QACAF,mBAAA,EAAAA,mBAAA;QACAF,mBAAA,EAAAA;MACD,CAAC;MAED,KAAKO,eAAA,CAAgB;QACpBV,mBAAA,EAAAA,mBAAA;QACAM,aAAA,EAAAA,aAAA;QACAC,aAAA,EAAAA,aAAA;QACAC,SAAA,EAAAA;MACD,CAAC;MAED,IAAMI,eAAA,GAAkB,KAAKC,iBAAA,CAAkB;QAC9CP,aAAA,EAAAA,aAAA;QACAC,aAAA,EAAAA;MACD,CAAC;MAED,IAAMO,YAAA,GAAe,KAAKC,eAAA,CAAgB;QACzCf,mBAAA,EAAAA,mBAAA;QACAM,aAAA,EAAAA,aAAA;QACAC,aAAA,EAAAA;MACD,CAAC;MAED,KAAK1E,UAAA,CAAWG,GAAA,IAAAe,MAAA,CAAA/C,kBAAA,CAAQ8G,YAAA,GAAA9G,kBAAA,CAAiB4G,eAAe,EAAC;MAEzD,OAAO;QAAED,KAAA,EAAAA;MAAM;IAChB;EAAA;IAAAjF,GAAA;IAAAC,GAAA,EAEU,SAAAA,IAAA,EAA0B;MAAA,IAAAqF,MAAA;MACnC,OAAO,KAAK5D,eAAA,CAAgBT,GAAA,CAAI,UAAAsE,KAAA,EAAsB;QAAA,IAAnBpI,EAAA,GAAAoI,KAAA,CAAApI,EAAA;UAAIsF,QAAA,GAAA8C,KAAA,CAAA9C,QAAA;QACtC,IAAM+C,OAAA,GAAU3J,QAAA,CAASyJ,MAAA,CAAK1F,MAAA,CAAO6F,cAAA,CAAetI,EAAE,CAAC;QACvD,IAAIsF,QAAA,EAAU+C,OAAA,CAAQpH,IAAA,CAAKoH,OAAA,CAAQ,CAAC,CAAC;QACrC,IAAME,aAAA,GAAgBJ,MAAA,CAAK1F,MAAA,CAAOiB,oBAAA,CAAqB1D,EAAE;QACzD,IAAI,CAACuI,aAAA,EAAe,MAAMC,KAAA,CAAM,mBAAmB;QACnD,OAAOnK,QAAA,CAASoK,aAAA,CAAcF,aAAA,EAAeF,OAAO;MACrD,CAAC;IACF;EAAA;IAAAxF,GAAA;IAAAhC,KAAA,EAEA,SAAA6H,uBAAAC,KAAA,EAMiB;MAAA,IALhBC,WAAA,GAAAD,KAAA,CAAAC,WAAA;QACAC,kBAAA,GAAAF,KAAA,CAAAE,kBAAA;MAKA,IAAQC,mBAAA,GAAuC,KAAvCA,mBAAA;QAAqB5B,aAAA,GAAkB,KAAlBA,aAAA;MAG7B,IAAI6B,WAAA,GAAc7B,aAAA;MAClB,IAAI8B,YAAA,GAA6B;MACjC,IAAIC,CAAA,EAAeC,CAAA,EAAeC,OAAA,EAAgBC,QAAA;MAElD,IAAMC,WAAA,MAAAnF,MAAA,CAAA/C,kBAAA,CAAkB2H,mBAAA,GAAA3H,kBAAA,CAAwB0H,kBAAkB;MAAA,IAAAS,UAAA,GAAA/I,0BAAA,CAC5C8I,WAAA;QAAAE,MAAA;MAAA;QAAtB,KAAAD,UAAA,CAAA7I,CAAA,MAAA8I,MAAA,GAAAD,UAAA,CAAA5I,CAAA,IAAAC,IAAA,GAAmC;UAAA,IAAxB0H,OAAA,GAAAkB,MAAA,CAAA1I,KAAA;UACV,SAASe,CAAA,GAAI,GAAGA,CAAA,GAAIyG,OAAA,CAAQnI,MAAA,GAAS,GAAG0B,CAAA,IAAK;YAC5CqH,CAAA,GAAIZ,OAAA,CAAQzG,CAAC;YACbsH,CAAA,GAAIb,OAAA,CAAQzG,CAAA,GAAI,CAAC;YAEjBuH,OAAA,GAAU3K,KAAA,CAAMgL,yBAAA,CAA0BP,CAAA,EAAGC,CAAA,EAAGN,WAAW;YAC3DQ,QAAA,GAAW5K,KAAA,CAAMiL,IAAA,CAAKb,WAAA,EAAaO,OAAO;YAE1C,IAAIO,KAAA,CAAMN,QAAQ,GAAG;YACrB,IAAIA,QAAA,GAAWL,WAAA,EAAa;cAC3BA,WAAA,GAAcK,QAAA;cACdJ,YAAA,GAAeG,OAAA;YAChB;UACD;QACD;MAAA,SAAA/H,GAAA;QAAAkI,UAAA,CAAAjI,CAAA,CAAAD,GAAA;MAAA;QAAAkI,UAAA,CAAAhI,CAAA;MAAA;MAGA,IAAI0H,YAAA,EAAc;QACjB,KAAKhG,UAAA,CAAWG,GAAA,CAAI,CACnB;UACCnD,EAAA,EAAIlB,QAAA,CAAS;UACb6K,IAAA,EAAM;UACNC,MAAA,EAAQ,CAACZ,YAAY;QACtB,EACA;QAED,OAAOxK,KAAA,CAAMqL,GAAA,CAAIb,YAAA,EAAcJ,WAAW;MAC3C;MAEA,OAAO;IACR;EAAA;IAAA/F,GAAA;IAAAhC,KAAA,EAEA,SAAAiJ,WAAAC,KAAA,EAea;MAAA,IAAAC,sBAAA,EAAAC,gBAAA,EAAAC,sBAAA,EAAAC,gBAAA;MAAA,IAdZtD,0BAAA,GAAAkD,KAAA,CAAAlD,0BAAA;QACAE,SAAA,GAAAgD,KAAA,CAAAhD,SAAA;QACQqD,cAAA,GAAAL,KAAA,CAARM,MAAA;QACAC,mBAAA,GAAAP,KAAA,CAAAO,mBAAA;QACAC,oBAAA,GAAAR,KAAA,CAAAQ,oBAAA;MAWA,IAAQrD,aAAA,GAAkB,KAAlBA,aAAA;MAGR,IAAAsD,aAAA,GAIIvM,KAAA,CAAMwM,MAAA,CACT5D,0BAAA,EACAuD,cAAA,EACAG,oBAAA,GAAuBxD,SAAA,CAAU9H,CAAA,GAAI,IAAI8H,SAAA,CAAU9H,CAAA,EACnDsL,oBAAA,GAAuBxD,SAAA,CAAU1E,CAAA,GAAI,IAAI0E,SAAA,CAAU1E,CAAA,EACnDiI,mBACD;QATMI,0BAAA,GAAAF,aAAA,CAALG,GAAA;QACAC,MAAA,GAAAJ,aAAA,CAAAI,MAAA;QACAC,MAAA,GAAAL,aAAA,CAAAK,MAAA;MASD,IAAIR,MAAA,GAASD,cAAA;MAEb,IAAIQ,MAAA,GAAS,GAAG;QACfP,MAAA,GAASnM,oBAAA,CAAqBmM,MAAM;MACrC;MACA,IAAIQ,MAAA,GAAS,GAAG;QACfR,MAAA,GAASlM,oBAAA,CAAqBkM,MAAM;MACrC;MAEA,IAAIE,oBAAA,EAAsB;QAEzBG,0BAAA,CAA2BI,MAAA,GAASjE,0BAAA,CAA2BiE,MAAA;MAChE;MAEA,IAAMC,SAAA,GAAYV,MAAA,KAAW,SAASA,MAAA,KAAW;MACjD,IAAMW,SAAA,GAAYX,MAAA,KAAW,UAAUA,MAAA,KAAW;MAElD,IAAM/C,mBAAA,GAAsB2D,4BAAA,CAA6BZ,MAAA,EAAQK,0BAA0B;MAE3F,IAAMlD,mBAAA,GAAsB,KAAKP,eAAA;MAEjC,IAAMQ,aAAA,GAAqC,EAAC;MAC5C,IAAMC,aAAA,GAAqC,EAAC;MAC5C,IAAMC,SAAA,GAAY,IAAInJ,KAAA,CAAM0I,aAAA,EAAeA,aAAa;MAExD,KAAKU,iBAAA,CAAkB;QACtBD,SAAA,EAAAA,SAAA;QACAF,aAAA,EAAAA,aAAA;QACAC,aAAA,EAAAA,aAAA;QACAF,mBAAA,EAAAA,mBAAA;QACAF,mBAAA,EAAAA;MACD,CAAC;MAGD,IAAMQ,KAAA,GAAQ,IAAItJ,KAAA,CACjBuM,SAAA,GAAY,KAAAf,sBAAA,IAAAC,gBAAA,GAAIxC,aAAA,CAAc,CAAC,eAAAwC,gBAAA,uBAAfA,gBAAA,CAAkBnC,KAAA,cAAAkC,sBAAA,cAAAA,sBAAA,GAAS,GAC3CgB,SAAA,GAAY,KAAAd,sBAAA,IAAAC,gBAAA,GAAIzC,aAAA,CAAc,CAAC,eAAAyC,gBAAA,uBAAfA,gBAAA,CAAkBrC,KAAA,cAAAoC,sBAAA,cAAAA,sBAAA,GAAS,CAC5C;MAEA,IAAII,mBAAA,IAAuBlM,iBAAA,CAAkBiM,MAAM,KAAKvC,KAAA,CAAMoD,GAAA,CAAI,MAAM,GAAG;QAM1E,IAAMC,gBAAA,GACL1D,aAAA,CAAcvH,MAAA,IAAUwH,aAAA,CAAcxH,MAAA,GACnCf,IAAA,CAAKiM,GAAA,CAAItD,KAAA,CAAM7I,CAAC,IAAIE,IAAA,CAAKiM,GAAA,CAAItD,KAAA,CAAMzF,CAAC,IACnC,MACA,MACDoF,aAAA,CAAcvH,MAAA,GACd,MACA;QAEJ,IAAMmL,KAAA,GAAQxE,0BAAA,CAA2ByE,WAAA;QAEzC,IAAIH,gBAAA,KAAqB,KAAK;UAC7BzD,aAAA,CAAcxH,MAAA,GAAS;UACvB4H,KAAA,CAAMzF,CAAA,GAAIyF,KAAA,CAAM7I,CAAA,GAAIoM,KAAA;UACpB,IAAIhB,MAAA,KAAW,iBAAiBA,MAAA,KAAW,aAAa;YACvDvC,KAAA,CAAMzF,CAAA,GAAI,CAACyF,KAAA,CAAMzF,CAAA;UAClB;QACD,OAAO;UACNoF,aAAA,CAAcvH,MAAA,GAAS;UACvB4H,KAAA,CAAM7I,CAAA,GAAI6I,KAAA,CAAMzF,CAAA,GAAIgJ,KAAA;UACpB,IAAIhB,MAAA,KAAW,iBAAiBA,MAAA,KAAW,aAAa;YACvDvC,KAAA,CAAM7I,CAAA,GAAI,CAAC6I,KAAA,CAAM7I,CAAA;UAClB;QACD;MACD;MAIA,IAAMsM,YAAA,GAAe/M,KAAA,CAAMgN,GAAA,CAAIzE,SAAA,EAAWe,KAAK;MAG/C,IAAA2D,cAAA,GAA0CxN,KAAA,CAAMwM,MAAA,CAC/C5D,0BAAA,EACAuD,cAAA,EACAG,oBAAA,GAAuBgB,YAAA,CAAatM,CAAA,GAAI,IAAIsM,YAAA,CAAatM,CAAA,EACzDsL,oBAAA,GAAuBgB,YAAA,CAAalJ,CAAA,GAAI,IAAIkJ,YAAA,CAAalJ,CAAA,EACzDiI,mBACD;QANaoB,wBAAA,GAAAD,cAAA,CAALd,GAAA;MAQR,IAAIJ,oBAAA,EAAsB;QAEzBmB,wBAAA,CAAyBZ,MAAA,GAASjE,0BAAA,CAA2BiE,MAAA;MAC9D;MAEA,IAAMa,sBAAA,GAAyBV,4BAAA,CAA6B,OAAOS,wBAAwB;MAE3FjE,aAAA,CAAcvH,MAAA,GAAS;MACvBwH,aAAA,CAAcxH,MAAA,GAAS;MACvByH,SAAA,CAAU1I,CAAA,GAAI;MACd0I,SAAA,CAAUtF,CAAA,GAAI;MAEd,KAAKuF,iBAAA,CAAkB;QACtBD,SAAA,EAAAA,SAAA;QACAF,aAAA,EAAAA,aAAA;QACAC,aAAA,EAAAA,aAAA;QACAF,mBAAA,EAAAA,mBAAA;QACAF,mBAAA,EAAqBqE;MACtB,CAAC;MACD,IAAMC,UAAA,GAAa,KAAK5D,iBAAA,CAAkB;QACzCP,aAAA,EAAAA,aAAA;QACAC,aAAA,EAAAA;MACD,CAAC;MAED,KAAK1E,UAAA,CAAWG,GAAA,CAAAhC,kBAAA,CAAQyK,UAAU,CAAC;MAEnC,OAAO;QAAE9D,KAAA,EAAAA;MAAM;IAChB;EAAA;IAAAjF,GAAA;IAAAhC,KAAA,EAEQ,SAAA+G,kBAAAiE,KAAA,EAYL;MAAA,IAXFvE,mBAAA,GAAAuE,KAAA,CAAAvE,mBAAA;QACAE,mBAAA,GAAAqE,KAAA,CAAArE,mBAAA;QACAG,SAAA,GAAAkE,KAAA,CAAAlE,SAAA;QACAF,aAAA,GAAAoE,KAAA,CAAApE,aAAA;QACAC,aAAA,GAAAmE,KAAA,CAAAnE,aAAA;MAAA,IAAAoE,UAAA,GAAAvL,0BAAA,CAU4B+G,mBAAA;QAAAyE,MAAA;MAAA;QAA5B,KAAAD,UAAA,CAAArL,CAAA,MAAAsL,MAAA,GAAAD,UAAA,CAAApL,CAAA,IAAAC,IAAA,GAAiD;UAAA,IAAtCqL,aAAA,GAAAD,MAAA,CAAAlL,KAAA;UAAA,IAAAoL,UAAA,GAAA1L,0BAAA,CACmBiH,mBAAA;YAAA0E,MAAA;UAAA;YAA7B,KAAAD,UAAA,CAAAxL,CAAA,MAAAyL,MAAA,GAAAD,UAAA,CAAAvL,CAAA,IAAAC,IAAA,GAAkD;cAAA,IAAvCwL,cAAA,GAAAD,MAAA,CAAArL,KAAA;cACV,IAAMuL,MAAA,GAAS5N,KAAA,CAAMqL,GAAA,CAAImC,aAAA,EAAeG,cAAc;cACtD,IAAME,OAAA,GAAUlN,IAAA,CAAKiM,GAAA,CAAIgB,MAAA,CAAOnN,CAAC;cACjC,IAAMqN,OAAA,GAAUnN,IAAA,CAAKiM,GAAA,CAAIgB,MAAA,CAAO/J,CAAC;cAEjC,IAAIrD,KAAA,CAAMqN,OAAO,KAAKrN,KAAA,CAAM2I,SAAA,CAAU1I,CAAC,GAAG;gBACzC,IAAID,KAAA,CAAMqN,OAAO,IAAIrN,KAAA,CAAM2I,SAAA,CAAU1I,CAAC,GAAG;kBAGxCwI,aAAA,CAAcvH,MAAA,GAAS;gBACxB;gBAEAuH,aAAA,CAAcxG,IAAA,CAAK;kBAClB0I,IAAA,EAAM;kBACNC,MAAA,EAAQ;oBAAE2C,SAAA,EAAWP,aAAA;oBAAeQ,UAAA,EAAYL;kBAAe;kBAC/DrE,KAAA,EAAOqE,cAAA,CAAelN,CAAA,GAAI+M,aAAA,CAAc/M;gBACzC,CAAC;gBACD0I,SAAA,CAAU1I,CAAA,GAAIoN,OAAA;cACf;cAEA,IAAIrN,KAAA,CAAMsN,OAAO,KAAKtN,KAAA,CAAM2I,SAAA,CAAUtF,CAAC,GAAG;gBACzC,IAAIrD,KAAA,CAAMsN,OAAO,IAAItN,KAAA,CAAM2I,SAAA,CAAUtF,CAAC,GAAG;kBAGxCqF,aAAA,CAAcxH,MAAA,GAAS;gBACxB;gBACAwH,aAAA,CAAczG,IAAA,CAAK;kBAClB0I,IAAA,EAAM;kBACNC,MAAA,EAAQ;oBAAE2C,SAAA,EAAWP,aAAA;oBAAeQ,UAAA,EAAYL;kBAAe;kBAC/DrE,KAAA,EAAOqE,cAAA,CAAe9J,CAAA,GAAI2J,aAAA,CAAc3J;gBACzC,CAAC;gBACDsF,SAAA,CAAUtF,CAAA,GAAIiK,OAAA;cACf;YACD;UAAA,SAAAlL,GAAA;YAAA6K,UAAA,CAAA5K,CAAA,CAAAD,GAAA;UAAA;YAAA6K,UAAA,CAAA3K,CAAA;UAAA;QACD;MAAA,SAAAF,GAAA;QAAA0K,UAAA,CAAAzK,CAAA,CAAAD,GAAA;MAAA;QAAA0K,UAAA,CAAAxK,CAAA;MAAA;IACD;EAAA;IAAAuB,GAAA;IAAAhC,KAAA,EAEQ,SAAAgH,gBAAA4E,KAAA,EAUL;MAAA,IATFtF,mBAAA,GAAAsF,KAAA,CAAAtF,mBAAA;QACAQ,SAAA,GAAA8E,KAAA,CAAA9E,SAAA;QACAF,aAAA,GAAAgF,KAAA,CAAAhF,aAAA;QACAC,aAAA,GAAA+E,KAAA,CAAA/E,aAAA;MAOA,IAAAgF,iBAAA,GAAiC,KAAKC,WAAA;QAA9B7G,UAAA,GAAA4G,iBAAA,CAAA5G,UAAA;QAAYC,QAAA,GAAA2G,iBAAA,CAAA3G,QAAA;MAAkB,IAAA6G,UAAA,GAAArM,0BAAA,CAEpBuF,UAAA;QAAA+G,MAAA;MAAA;QAAlB,KAAAD,UAAA,CAAAnM,CAAA,MAAAoM,MAAA,GAAAD,UAAA,CAAAlM,CAAA,IAAAC,IAAA,GAA8B;UAAA,IAAnBb,GAAA,GAAA+M,MAAA,CAAAhM,KAAA;UAEV,IACC,CAACtC,aAAA,CACAuB,GAAA,CAAIK,mBAAA,CAAoB,CAAC,GACzBL,GAAA,CAAIK,mBAAA,CAAoB,CAAC,GACzBgH,mBAAA,CAAoBhB,IAAA,EACpBgB,mBAAA,CAAoBf,IACrB,GACC;YACD;UACD;UAGA,IAAM0G,OAAA,GAAUhN,GAAA,CAAIsC,SAAA,CAAU,CAAC,EAAEnD,CAAA,GAAIa,GAAA,CAAII,MAAA,GAAS;UAClD,IAAM6M,WAAA,GAAcD,OAAA,GAAU3F,mBAAA,CAAoB2D,MAAA,CAAO7L,CAAA;UACzD,IAAM+N,wBAAA,GAA2BlN,GAAA,CAAII,MAAA,GAASiH,mBAAA,CAAoB8F,KAAA;UAElE,IAAID,wBAAA,IAA4BhO,KAAA,CAAMG,IAAA,CAAKiM,GAAA,CAAI2B,WAAW,CAAC,KAAK/N,KAAA,CAAM2I,SAAA,CAAU1I,CAAC,GAAG;YACnF,IAAID,KAAA,CAAMG,IAAA,CAAKiM,GAAA,CAAI2B,WAAW,CAAC,IAAI/N,KAAA,CAAM2I,SAAA,CAAU1I,CAAC,GAAG;cAEtDwI,aAAA,CAAcvH,MAAA,GAAS;YACxB;YACAyH,SAAA,CAAU1I,CAAA,GAAIE,IAAA,CAAKiM,GAAA,CAAI2B,WAAW;YAElC,IAAMlL,IAAA,GAAoB;cACzB8H,IAAA,EAAM;cACN7J,GAAA,EAAAA,GAAA;cACAgI,KAAA,EAAOiF;YACR;YA2CA,IAAMG,eAAA,GAAkBzF,aAAA,CAAc0F,IAAA,CAAK,UAAAC,KAAA;cAAA,IAAGzD,IAAA,GAAAyD,KAAA,CAAAzD,IAAA;cAAA,OAAWA,IAAA,KAAS,YAAY;YAAA;YAI9E,IAAM0D,kBAAA,GACLH,eAAA,IACA5O,iBAAA,CACCwB,GAAA,CAAIK,mBAAA,CAAoB,CAAC,GACzBL,GAAA,CAAIK,mBAAA,CAAoB,CAAC,GACzB+M,eAAA,CAAgBpN,GAAA,CAAIK,mBAAA,CAAoB,CAAC,GACzC+M,eAAA,CAAgBpN,GAAA,CAAIK,mBAAA,CAAoB,CAAC,CAC1C;YAGD,IAAI+M,eAAA,IAAmBA,eAAA,CAAgBpN,GAAA,CAAII,MAAA,GAASJ,GAAA,CAAII,MAAA,IAAUmN,kBAAA,EAAoB;cACrF5F,aAAA,CAAcA,aAAA,CAAc6F,OAAA,CAAQJ,eAAe,CAAC,IAAIrL,IAAA;YACzD,WAAW,CAACqL,eAAA,IAAmB,CAACG,kBAAA,EAAoB;cACnD5F,aAAA,CAAcxG,IAAA,CAAKY,IAAI;YACxB;UACD;UAGA,IAAM0L,gBAAA,GAAmBzN,GAAA,CAAIC,SAAA,CAAUoF,UAAA,CAAWc,IAAA,GAAOnG,GAAA,CAAII,MAAA;UAC7D,IAAMsN,eAAA,GAAkBrG,mBAAA,CAAoBjB,IAAA;UAE5C,IAAMuH,oBAAA,GAAuBF,gBAAA,GAAmBC,eAAA;UAChD,IAAIxO,KAAA,CAAMG,IAAA,CAAKiM,GAAA,CAAIqC,oBAAoB,CAAC,KAAKzO,KAAA,CAAM2I,SAAA,CAAU1I,CAAC,GAAG;YAChE,IAAID,KAAA,CAAMG,IAAA,CAAKiM,GAAA,CAAIqC,oBAAoB,CAAC,IAAIzO,KAAA,CAAM2I,SAAA,CAAU1I,CAAC,GAAG;cAE/DwI,aAAA,CAAcvH,MAAA,GAAS;YACxB;YACAyH,SAAA,CAAU1I,CAAA,GAAIE,IAAA,CAAKiM,GAAA,CAAIqC,oBAAoB;YAE3ChG,aAAA,CAAcxG,IAAA,CAAK;cAClB0I,IAAA,EAAM;cACN7J,GAAA,EAAAA,GAAA;cACA4N,mBAAA,EAAqB;cACrB5F,KAAA,EAAO2F;YACR,CAAC;UACF;UAGA,IAAME,iBAAA,GAAoB7N,GAAA,CAAIG,OAAA,CAAQkF,UAAA,CAAWe,IAAA,GAAOpG,GAAA,CAAII,MAAA;UAC5D,IAAM0N,cAAA,GAAiBzG,mBAAA,CAAoBlB,IAAA;UAE3C,IAAM4H,qBAAA,GAAwBF,iBAAA,GAAoBC,cAAA;UAClD,IAAI5O,KAAA,CAAMG,IAAA,CAAKiM,GAAA,CAAIyC,qBAAqB,CAAC,KAAK7O,KAAA,CAAM2I,SAAA,CAAU1I,CAAC,GAAG;YACjE,IAAID,KAAA,CAAMG,IAAA,CAAKiM,GAAA,CAAIyC,qBAAqB,CAAC,IAAI7O,KAAA,CAAM2I,SAAA,CAAU1I,CAAC,GAAG;cAEhEwI,aAAA,CAAcvH,MAAA,GAAS;YACxB;YACAyH,SAAA,CAAU1I,CAAA,GAAIE,IAAA,CAAKiM,GAAA,CAAIyC,qBAAqB;YAE5CpG,aAAA,CAAcxG,IAAA,CAAK;cAClB0I,IAAA,EAAM;cACN7J,GAAA,EAAAA,GAAA;cACA4N,mBAAA,EAAqB;cACrB5F,KAAA,EAAO+F;YACR,CAAC;UACF;QACD;MAAA,SAAAzM,GAAA;QAAAwL,UAAA,CAAAvL,CAAA,CAAAD,GAAA;MAAA;QAAAwL,UAAA,CAAAtL,CAAA;MAAA;MAAA,IAAAwM,UAAA,GAAAvN,0BAAA,CAEkBwF,QAAA;QAAAgI,MAAA;MAAA;QAAlB,KAAAD,UAAA,CAAArN,CAAA,MAAAsN,MAAA,GAAAD,UAAA,CAAApN,CAAA,IAAAC,IAAA,GAA4B;UAAA,IAAjBb,IAAA,GAAAiO,MAAA,CAAAlN,KAAA;UAEV,IACC,CAACtC,aAAA,CACAuB,IAAA,CAAIK,mBAAA,CAAoB,CAAC,GACzBL,IAAA,CAAIK,mBAAA,CAAoB,CAAC,GACzBgH,mBAAA,CAAoBlB,IAAA,EACpBkB,mBAAA,CAAoBjB,IACrB,GACC;YACD;UACD;UAGA,IAAM8H,OAAA,GAAUlO,IAAA,CAAIsC,SAAA,CAAU,CAAC,EAAEC,CAAA,GAAIvC,IAAA,CAAII,MAAA,GAAS;UAClD,IAAM6M,YAAA,GAAciB,OAAA,GAAU7G,mBAAA,CAAoB2D,MAAA,CAAOzI,CAAA;UAEzD,IAAM2K,yBAAA,GAA2BlN,IAAA,CAAII,MAAA,GAASiH,mBAAA,CAAoB8G,MAAA;UAElE,IAAIjB,yBAAA,IAA4BhO,KAAA,CAAMG,IAAA,CAAKiM,GAAA,CAAI2B,YAAW,CAAC,KAAK/N,KAAA,CAAM2I,SAAA,CAAUtF,CAAC,GAAG;YACnF,IAAIrD,KAAA,CAAMG,IAAA,CAAKiM,GAAA,CAAI2B,YAAW,CAAC,IAAI/N,KAAA,CAAM2I,SAAA,CAAUtF,CAAC,GAAG;cAEtDqF,aAAA,CAAcxH,MAAA,GAAS;YACxB;YACAyH,SAAA,CAAUtF,CAAA,GAAIlD,IAAA,CAAKiM,GAAA,CAAI2B,YAAW;YAElC,IAAMlL,KAAA,GAAoB;cACzB8H,IAAA,EAAM;cACN7J,GAAA,EAAAA,IAAA;cACAgI,KAAA,EAAOiF;YACR;YA2CA,IAAMG,gBAAA,GAAkBxF,aAAA,CAAcyF,IAAA,CAAK,UAAAe,KAAA;cAAA,IAAGvE,IAAA,GAAAuE,KAAA,CAAAvE,IAAA;cAAA,OAAWA,IAAA,KAAS,YAAY;YAAA;YAI9E,IAAM0D,mBAAA,GACLH,gBAAA,IACA3O,aAAA,CACC2O,gBAAA,CAAgBpN,GAAA,CAAIK,mBAAA,CAAoB,CAAC,GACzC+M,gBAAA,CAAgBpN,GAAA,CAAIK,mBAAA,CAAoB,CAAC,GACzCL,IAAA,CAAIK,mBAAA,CAAoB,CAAC,GACzBL,IAAA,CAAIK,mBAAA,CAAoB,CAAC,CAC1B;YAGD,IAAI+M,gBAAA,IAAmBA,gBAAA,CAAgBpN,GAAA,CAAII,MAAA,GAASJ,IAAA,CAAII,MAAA,IAAUmN,mBAAA,EAAoB;cACrF3F,aAAA,CAAcA,aAAA,CAAc4F,OAAA,CAAQJ,gBAAe,CAAC,IAAIrL,KAAA;YACzD,WAAW,CAACqL,gBAAA,IAAmB,CAACG,mBAAA,EAAoB;cACnD3F,aAAA,CAAczG,IAAA,CAAKY,KAAI;YACxB;YACA;UACD;UAGA,IAAMsM,eAAA,GAAkBrO,IAAA,CAAIC,SAAA,CAAUoF,UAAA,CAAWgB,IAAA,GAAOrG,IAAA,CAAII,MAAA;UAC5D,IAAMkO,gBAAA,GAAmBjH,mBAAA,CAAoBf,IAAA;UAE7C,IAAMiI,mBAAA,GAAsBF,eAAA,GAAkBC,gBAAA;UAC9C,IAAIpP,KAAA,CAAMG,IAAA,CAAKiM,GAAA,CAAIiD,mBAAmB,CAAC,KAAKrP,KAAA,CAAM2I,SAAA,CAAUtF,CAAC,GAAG;YAC/D,IAAIrD,KAAA,CAAMG,IAAA,CAAKiM,GAAA,CAAIiD,mBAAmB,CAAC,IAAIrP,KAAA,CAAM2I,SAAA,CAAUtF,CAAC,GAAG;cAE9DqF,aAAA,CAAcxH,MAAA,GAAS;YACxB;YACAyH,SAAA,CAAUtF,CAAA,GAAIlD,IAAA,CAAKiM,GAAA,CAAIiD,mBAAmB;YAE1C3G,aAAA,CAAczG,IAAA,CAAK;cAClB0I,IAAA,EAAM;cACN7J,GAAA,EAAAA,IAAA;cACA4N,mBAAA,EAAqB;cACrB5F,KAAA,EAAOuG;YACR,CAAC;UACF;UAGA,IAAMC,kBAAA,GAAqBxO,IAAA,CAAIG,OAAA,CAAQkF,UAAA,CAAWiB,IAAA,GAAOtG,IAAA,CAAII,MAAA;UAC7D,IAAMqO,aAAA,GAAgBpH,mBAAA,CAAoBhB,IAAA;UAE1C,IAAMqI,sBAAA,GAAyBF,kBAAA,GAAqBC,aAAA;UACpD,IAAIvP,KAAA,CAAMG,IAAA,CAAKiM,GAAA,CAAIoD,sBAAsB,CAAC,KAAKxP,KAAA,CAAM2I,SAAA,CAAUtF,CAAC,GAAG;YAClE,IAAIrD,KAAA,CAAMG,IAAA,CAAKiM,GAAA,CAAIoD,sBAAsB,CAAC,IAAIxP,KAAA,CAAM2I,SAAA,CAAUtF,CAAC,GAAG;cAEjEqF,aAAA,CAAcxH,MAAA,GAAS;YACxB;YACAyH,SAAA,CAAUtF,CAAA,GAAIlD,IAAA,CAAKiM,GAAA,CAAIoD,sBAAsB;YAE7C9G,aAAA,CAAczG,IAAA,CAAK;cAClB0I,IAAA,EAAM;cACN7J,GAAA,EAAAA,IAAA;cACA4N,mBAAA,EAAqB;cACrB5F,KAAA,EAAO0G;YACR,CAAC;UACF;QACD;MAAA,SAAApN,GAAA;QAAA0M,UAAA,CAAAzM,CAAA,CAAAD,GAAA;MAAA;QAAA0M,UAAA,CAAAxM,CAAA;MAAA;IACD;EAAA;IAAAuB,GAAA;IAAAhC,KAAA,EAEQ,SAAAmH,kBAAAyG,MAAA,EAMa;MAAA,IALpBhH,aAAA,GAAAgH,MAAA,CAAAhH,aAAA;QACAC,aAAA,GAAA+G,MAAA,CAAA/G,aAAA;MAOA,IAAMgH,WAAA,GAAc,CAAC;MACrB,IAAMC,WAAA,GAAc,CAAC;MAErB,IAAIlH,aAAA,CAAcvH,MAAA,GAAS,GAAG;QAAA,IAAA0O,UAAA,GAAArO,0BAAA,CACVkH,aAAA;UAAAoH,MAAA;QAAA;UAAnB,KAAAD,UAAA,CAAAnO,CAAA,MAAAoO,MAAA,GAAAD,UAAA,CAAAlO,CAAA,IAAAC,IAAA,GAAkC;YAAA,IAAvBkB,IAAA,GAAAgN,MAAA,CAAAhO,KAAA;YACV,IAAIgB,IAAA,CAAK8H,IAAA,KAAS,UAAU;cAC3B,IAAM9G,GAAA,GAAM7D,KAAA,CAAM6C,IAAA,CAAK+H,MAAA,CAAO4C,UAAA,CAAWvN,CAAC;cAC1C,IAAI,CAACyP,WAAA,CAAY7L,GAAG,GAAG;gBACtB6L,WAAA,CAAY7L,GAAG,IAAI,EAAC;cACrB;cACA6L,WAAA,CAAY7L,GAAG,EAAE5B,IAAA,CAAKY,IAAA,CAAK+H,MAAM;YAClC;UACD;QAAA,SAAAxI,GAAA;UAAAwN,UAAA,CAAAvN,CAAA,CAAAD,GAAA;QAAA;UAAAwN,UAAA,CAAAtN,CAAA;QAAA;MACD;MAEA,IAAIoG,aAAA,CAAcxH,MAAA,GAAS,GAAG;QAAA,IAAA4O,UAAA,GAAAvO,0BAAA,CACVmH,aAAA;UAAAqH,MAAA;QAAA;UAAnB,KAAAD,UAAA,CAAArO,CAAA,MAAAsO,MAAA,GAAAD,UAAA,CAAApO,CAAA,IAAAC,IAAA,GAAkC;YAAA,IAAvBkB,MAAA,GAAAkN,MAAA,CAAAlO,KAAA;YACV,IAAIgB,MAAA,CAAK8H,IAAA,KAAS,UAAU;cAC3B,IAAM9G,IAAA,GAAM7D,KAAA,CAAM6C,MAAA,CAAK+H,MAAA,CAAO4C,UAAA,CAAWnK,CAAC;cAC1C,IAAI,CAACsM,WAAA,CAAY9L,IAAG,GAAG;gBACtB8L,WAAA,CAAY9L,IAAG,IAAI,EAAC;cACrB;cACA8L,WAAA,CAAY9L,IAAG,EAAE5B,IAAA,CAAKY,MAAA,CAAK+H,MAAM;YAClC;UACD;QAAA,SAAAxI,GAAA;UAAA0N,UAAA,CAAAzN,CAAA,CAAAD,GAAA;QAAA;UAAA0N,UAAA,CAAAxN,CAAA;QAAA;MACD;MAGA,OAAO0N,MAAA,CAAOC,MAAA,CAAOP,WAAW,EAC9BxK,MAAA,CAAO8K,MAAA,CAAOC,MAAA,CAAON,WAAW,CAAC,EACjC7K,GAAA,CAAI,UAACoL,SAAA;QAAA,OAAe;UACpBlP,EAAA,EAAIlB,QAAA,CAAS;UACb6K,IAAA,EAAM;UACNC,MAAA,EAAQnL,MAAA,CACPyQ,SAAA,CACEpL,GAAA,CAAI,UAACjC,IAAA;YAAA,OAASrD,KAAA,CAAM2Q,IAAA,CAAKtN,IAAA,CAAK2K,UAAU,CAAC;UAAA,GAEzCtI,MAAA,CAAOgL,SAAA,CAAUpL,GAAA,CAAI,UAACjC,IAAA;YAAA,OAASrD,KAAA,CAAM2Q,IAAA,CAAKtN,IAAA,CAAK0K,SAAS,CAAC;UAAA,EAAC,GAC5D,UAAC7K,CAAA,EAAUC,CAAA;YAAA,OAAaD,CAAA,CAAE0N,MAAA,CAAOzN,CAAC;UAAA,CACnC;QACD;MAAA,CAAE;IACJ;EAAA;IAAAkB,GAAA;IAAAhC,KAAA,EAEQ,SAAAqH,gBAAAmH,MAAA,EAQW;MAAA,IAPlBlI,mBAAA,GAAAkI,MAAA,CAAAlI,mBAAA;QACAM,aAAA,GAAA4H,MAAA,CAAA5H,aAAA;QACAC,aAAA,GAAA2H,MAAA,CAAA3H,aAAA;MAMA,IAAA4H,kBAAA,GAAiC,KAAK3C,WAAA;QAA9B5G,QAAA,GAAAuJ,kBAAA,CAAAvJ,QAAA;QAAUD,UAAA,GAAAwJ,kBAAA,CAAAxJ,UAAA;MAElB,IAAMyJ,cAAA,GAAwD;QAC7DC,GAAA,EAAKrI,mBAAA,CAAoBsI,KAAA,CAAM,CAAC;QAChCC,KAAA,EAAOvI,mBAAA,CAAoBsI,KAAA,CAAM,CAAC;QAAA;QAElCE,MAAA,EAAQ,CAACxI,mBAAA,CAAoByI,OAAA,CAAQ,CAAC,GAAGzI,mBAAA,CAAoByI,OAAA,CAAQ,CAAC,CAAC;QACvEC,IAAA,EAAM,CAAC1I,mBAAA,CAAoByI,OAAA,CAAQ,CAAC,GAAGzI,mBAAA,CAAoByI,OAAA,CAAQ,CAAC,CAAC;MACtE;MAEA,IAAMhK,MAAA,GAAyB,EAAC;MAEhC,IAAI6B,aAAA,CAAcvH,MAAA,GAAS,GAAG;QAAA,IAAA4P,WAAA,GAAAvP,0BAAA,CACVkH,aAAA;UAAAsI,OAAA;QAAA;UAAA,IAAAC,MAAA,YAAAA,OAAA,EAAe;YAAA,IAAvBnO,IAAA,GAAAkO,OAAA,CAAAlP,KAAA;YACV,IAAIgB,IAAA,CAAK8H,IAAA,KAAS;YAElB,IAAAsG,SAAA,GAEIpO,IAAA,CADH/B,GAAA;cAAOK,mBAAA,GAAA8P,SAAA,CAAA9P,mBAAA;cAAqBiC,SAAA,GAAA6N,SAAA,CAAA7N,SAAA;cAAWrC,SAAA,GAAAkQ,SAAA,CAAAlQ,SAAA;cAAWE,OAAA,GAAAgQ,SAAA,CAAAhQ,OAAA;cAASC,MAAA,GAAA+P,SAAA,CAAA/P,MAAA;cAAQoC,OAAA,GAAA2N,SAAA,CAAA3N,OAAA;YAGpE,QAAQT,IAAA,CAAK8H,IAAA;cACZ,KAAK;gBAAc;kBAElB,IAAMuG,aAAA,IAAiBhQ,MAAA,GAASiH,mBAAA,CAAoB8F,KAAA,IAAS;kBAC7D,IAAMkD,sBAAA,GAAyB7R,iBAAA,CAC9B6B,mBAAA,CAAoB,CAAC,GACrBA,mBAAA,CAAoB,CAAC,GACrBgH,mBAAA,CAAoBhB,IAAA,EACpBgB,mBAAA,CAAoBf,IACrB;kBACAR,MAAA,CAAO3E,IAAA,CAAK;oBACX0I,IAAA,EAAM;oBACNlK,SAAA,EAAW;oBACXO,EAAA,EAAIlB,QAAA,CAAS;oBACbQ,IAAA,KAAA4E,MAAA,CAAA/C,kBAAA,CACI9B,gBAAA,CACFyG,UAAA,EACA/F,SAAA,CAAUC,EAAA,EACVkQ,aAAA,EACA,YACAC,sBAAA,EACA,CACD,KACA;sBACC/N,SAAA,EAAAA,SAAA;sBACAE,OAAA,EAASiN,cAAA,CAAeM;oBACzB,GACA;sBACCzN,SAAA,EAAWmN,cAAA,CAAeG,KAAA;sBAC1BpN,OAAA,EAAAA;oBACD,IAAAnB,kBAAA,CACG9B,gBAAA,CACFyG,UAAA,EACA7F,OAAA,CAAQD,EAAA,EACRkQ,aAAA,EACA,WACAC,sBAAA,EACA,CACD;kBAEF,CAAC;kBACD;gBACD;cACA,KAAK;gBAAiB;kBAErB,IAAMA,uBAAA,GAAyB7R,iBAAA,CAC9B6B,mBAAA,CAAoB,CAAC,GACrBA,mBAAA,CAAoB,CAAC,GACrBgH,mBAAA,CAAoBhB,IAAA,EACpBgB,mBAAA,CAAoBf,IACrB;kBACAR,MAAA,CAAO3E,IAAA,CAAK;oBACX0I,IAAA,EAAM;oBACNlK,SAAA,EAAW;oBACXO,EAAA,EAAIlB,QAAA,CAAS;oBACbQ,IAAA,EACCuC,IAAA,CAAK6L,mBAAA,KAAwB,UAE1B;sBACCtL,SAAA,EAAWmN,cAAA,CAAeG,KAAA;sBAC1BpN,OAAA,EAASF,SAAA,CAAU0B,GAAA,CAAI,UAACsM,CAAA;wBAAA,OACvBA,CAAA,CAAEhJ,KAAA,CAAM,EAAEiJ,KAAA,CAAM,CAACtQ,SAAA,CAAUoF,UAAA,CAAW8H,KAAA,EAAO,CAAC;sBAAA,CAC/C;oBACD,GACA;sBAAE7K,SAAA,EAAAA,SAAA;sBAAWE,OAAA,EAAAA;oBAAQ,GAAA4B,MAAA,CAAA/C,kBAAA,CAClB9B,gBAAA,CACFyG,UAAA,EACA7F,OAAA,CAAQD,EAAA,EACRE,MAAA,EACA,WACAiQ,uBAAA,EACA,CACD,SAAAjM,MAAA,CAAA/C,kBAAA,CAGG9B,gBAAA,CACFyG,UAAA,EACA/F,SAAA,CAAUC,EAAA,EACVE,MAAA,EACA,YACAiQ,uBAAA,EACA,CACD,KACA;sBAAE/N,SAAA,EAAAA,SAAA;sBAAWE,OAAA,EAAAA;oBAAQ,GACrB;sBACCF,SAAA,EAAWE,OAAA,CAAQwB,GAAA,CAAI,UAACsM,CAAA;wBAAA,OACvBA,CAAA,CAAEhJ,KAAA,CAAM,EAAEiJ,KAAA,CAAMxO,IAAA,CAAK/B,GAAA,CAAIG,OAAA,CAAQkF,UAAA,CAAW8H,KAAA,EAAO,CAAC;sBAAA,CACrD;sBACA3K,OAAA,EAASiN,cAAA,CAAeM;oBACzB;kBAEL,CAAC;kBAED;gBACD;YACD;UACD;UAvGA,KAAAC,WAAA,CAAArP,CAAA,MAAAsP,OAAA,GAAAD,WAAA,CAAApP,CAAA,IAAAC,IAAA;YAAA,IAAAqP,MAAA,IAC6B;UAAA;QAsG7B,SAAA5O,GAAA;UAAA0O,WAAA,CAAAzO,CAAA,CAAAD,GAAA;QAAA;UAAA0O,WAAA,CAAAxO,CAAA;QAAA;MACD;MAEA,IAAIoG,aAAA,CAAcxH,MAAA,GAAS,GAAG;QAAA,IAAAoQ,WAAA,GAAA/P,0BAAA,CACVmH,aAAA;UAAA6I,OAAA;QAAA;UAAA,IAAAC,MAAA,YAAAA,OAAA,EAAe;YAAA,IAAvB3O,IAAA,GAAA0O,OAAA,CAAA1P,KAAA;YACV,IAAIgB,IAAA,CAAK8H,IAAA,KAAS;YAElB,IAAA8G,UAAA,GAEI5O,IAAA,CADH/B,GAAA;cAAOK,mBAAA,GAAAsQ,UAAA,CAAAtQ,mBAAA;cAAqBiC,SAAA,GAAAqO,UAAA,CAAArO,SAAA;cAAWrC,SAAA,GAAA0Q,UAAA,CAAA1Q,SAAA;cAAWE,OAAA,GAAAwQ,UAAA,CAAAxQ,OAAA;cAASC,MAAA,GAAAuQ,UAAA,CAAAvQ,MAAA;cAAQoC,OAAA,GAAAmO,UAAA,CAAAnO,OAAA;YAGpE,QAAQT,IAAA,CAAK8H,IAAA;cACZ,KAAK;gBAAc;kBAClB,IAAMuG,aAAA,IAAiBhQ,MAAA,GAASiH,mBAAA,CAAoB8G,MAAA,IAAU;kBAC9D,IAAMkC,sBAAA,GAAyB7R,iBAAA,CAC9B6B,mBAAA,CAAoB,CAAC,GACrBA,mBAAA,CAAoB,CAAC,GACrBgH,mBAAA,CAAoBlB,IAAA,EACpBkB,mBAAA,CAAoBjB,IACrB;kBAEAN,MAAA,CAAO3E,IAAA,CAAK;oBACX0I,IAAA,EAAM;oBACNlK,SAAA,EAAW;oBACXO,EAAA,EAAIlB,QAAA,CAAS;oBACbQ,IAAA,KAAA4E,MAAA,CAAA/C,kBAAA,CACI9B,gBAAA,CACF0G,QAAA,EACAhG,SAAA,CAAUC,EAAA,EACVkQ,aAAA,EACA,YACAC,sBAAA,EACA,CACD,KACA;sBACC/N,SAAA,EAAAA,SAAA;sBACAE,OAAA,EAASiN,cAAA,CAAeC;oBACzB,GACA;sBACCpN,SAAA,EAAWmN,cAAA,CAAeI,MAAA;sBAC1BrN,OAAA,EAAAA;oBACD,IAAAnB,kBAAA,CACG9B,gBAAA,CACF0G,QAAA,EACAlE,IAAA,CAAK/B,GAAA,CAAIG,OAAA,CAAQD,EAAA,EACjBkQ,aAAA,EACA,WACAC,sBAAA,EACA,CACD;kBAEF,CAAC;kBACD;gBACD;cACA,KAAK;gBACJ;kBACC,IAAMA,wBAAA,GAAyB7R,iBAAA,CAC9B6B,mBAAA,CAAoB,CAAC,GACrBA,mBAAA,CAAoB,CAAC,GACrBgH,mBAAA,CAAoBlB,IAAA,EACpBkB,mBAAA,CAAoBjB,IACrB;kBAEAN,MAAA,CAAO3E,IAAA,CAAK;oBACX0I,IAAA,EAAM;oBACNlK,SAAA,EAAW;oBACXO,EAAA,EAAIlB,QAAA,CAAS;oBACbQ,IAAA,EACCuC,IAAA,CAAK6L,mBAAA,KAAwB,SAE1B;sBACCtL,SAAA,EAAWmN,cAAA,CAAeI,MAAA;sBAC1BrN,OAAA,EAASF,SAAA,CAAU0B,GAAA,CAAI,UAACsM,CAAA;wBAAA,OACvBA,CAAA,CAAEhJ,KAAA,CAAM,EAAEiJ,KAAA,CAAM,GAAG,CAACtQ,SAAA,CAAUoF,UAAA,CAAW8I,MAAM;sBAAA,CAChD;oBACD,GACA;sBAAE7L,SAAA,EAAAA,SAAA;sBAAWE,OAAA,EAAAA;oBAAQ,GAAA4B,MAAA,CAAA/C,kBAAA,CAClB9B,gBAAA,CACF0G,QAAA,EACA9F,OAAA,CAAQD,EAAA,EACRE,MAAA,EACA,WACAiQ,wBAAA,EACA,CACD,SAAAjM,MAAA,CAAA/C,kBAAA,CAGG9B,gBAAA,CACF0G,QAAA,EACAhG,SAAA,CAAUC,EAAA,EACVE,MAAA,EACA,YACAiQ,wBAAA,EACA,CACD,KACA;sBAAE/N,SAAA,EAAAA,SAAA;sBAAWE,OAAA,EAAAA;oBAAQ,GACrB;sBACCF,SAAA,EAAWE,OAAA,CAAQwB,GAAA,CAAI,UAACsM,CAAA;wBAAA,OACvBA,CAAA,CAAEhJ,KAAA,CAAM,EAAEiJ,KAAA,CAAM,GAAGpQ,OAAA,CAAQkF,UAAA,CAAW8I,MAAM;sBAAA,CAC7C;sBACA3L,OAAA,EAASiN,cAAA,CAAeC;oBACzB;kBAEL,CAAC;gBACF;gBACA;YACF;UACD;UAvGA,KAAAc,WAAA,CAAA7P,CAAA,MAAA8P,OAAA,GAAAD,WAAA,CAAA5P,CAAA,IAAAC,IAAA;YAAA,IAAA6P,MAAA,IAC6B;UAAA;QAsG7B,SAAApP,GAAA;UAAAkP,WAAA,CAAAjP,CAAA,CAAAD,GAAA;QAAA;UAAAkP,WAAA,CAAAhP,CAAA;QAAA;MACD;MAEAC,cAAA,CAAeqE,MAAM;MACrB,OAAOA,MAAA;IACR;EAAA;EAAA,OAAApD,WAAA;AAAA;AA/jCckO,eAAA,EAAb9R,QAAA,GAnBW4D,WAAA,CAmBEmO,SAAA;AAaAD,eAAA,EAAb9R,QAAA,GAhCW4D,WAAA,CAgCEmO,SAAA;AAKAD,eAAA,EAAb9R,QAAA,GArCW4D,WAAA,CAqCEmO,SAAA;AAkCAD,eAAA,EAAb9R,QAAA,GAvEW4D,WAAA,CAuEEmO,SAAA;AAKAD,eAAA,EAAb9R,QAAA,GA5EW4D,WAAA,CA4EEmO,SAAA;AAcAD,eAAA,EAAb9R,QAAA,GA1FW4D,WAAA,CA0FEmO,SAAA;AA6LAD,eAAA,EAAb9R,QAAA,GAvRW4D,WAAA,CAuREmO,SAAA;AA8zBf,SAAS1F,6BACRZ,MAAA,EACAlD,mBAAA,EACc;EACd,IAAQlB,IAAA,GAA2BkB,mBAAA,CAA3BlB,IAAA;IAAMC,IAAA,GAAqBiB,mBAAA,CAArBjB,IAAA;IAAMC,IAAA,GAAegB,mBAAA,CAAfhB,IAAA;IAAMC,IAAA,GAASe,mBAAA,CAATf,IAAA;EAC1B,IAAMR,MAAA,GAAsB,EAAC;EAG7B,QAAQyE,MAAA;IACP,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;MACJzE,MAAA,CAAO3E,IAAA,CAAK;QACXjB,EAAA,EAAI;QACJqK,MAAA,EAAQ;QACRpL,CAAA,EAAGgH,IAAA;QACH5D,CAAA,EAAG8D;MACJ,CAAC;EACH;EAGA,QAAQkE,MAAA;IACP,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;MACJzE,MAAA,CAAO3E,IAAA,CAAK;QACXjB,EAAA,EAAI;QACJqK,MAAA,EAAQ;QACRpL,CAAA,EAAGiH,IAAA;QACH7D,CAAA,EAAG8D;MACJ,CAAC;EACH;EAGA,QAAQkE,MAAA;IACP,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;MACJzE,MAAA,CAAO3E,IAAA,CAAK;QACXjB,EAAA,EAAI;QACJqK,MAAA,EAAQ;QACRpL,CAAA,EAAGiH,IAAA;QACH7D,CAAA,EAAG+D;MACJ,CAAC;EACH;EAGA,QAAQiE,MAAA;IACP,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;MACJzE,MAAA,CAAO3E,IAAA,CAAK;QACXjB,EAAA,EAAI;QACJqK,MAAA,EAAQ;QACRpL,CAAA,EAAGgH,IAAA;QACH5D,CAAA,EAAG+D;MACJ,CAAC;EACH;EAEA,OAAOR,MAAA;AACR"},"metadata":{},"sourceType":"module","externalDependencies":[]}