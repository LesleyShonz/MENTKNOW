{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _defineProperty from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\n// src/transactions.ts\nimport { GLOBAL_START_EPOCH } from \"./constants.mjs\";\nvar globalEpoch = GLOBAL_START_EPOCH + 1;\nvar globalIsReacting = false;\nfunction advanceGlobalEpoch() {\n  globalEpoch++;\n}\nvar Transaction = /*#__PURE__*/function () {\n  function Transaction(parent) {\n    _classCallCheck(this, Transaction);\n    _defineProperty(this, \"initialAtomValues\", /* @__PURE__ */new Map());\n    this.parent = parent;\n  }\n  _createClass(Transaction, [{\n    key: \"isRoot\",\n    get:\n    /**\n     * Get whether this transaction is a root (no parents).\n     *\n     * @public\n     */\n    function get() {\n      return this.parent === null;\n    }\n    /**\n     * Commit the transaction's changes.\n     *\n     * @public\n     */\n  }, {\n    key: \"commit\",\n    value: function commit() {\n      var _this = this;\n      if (this.isRoot) {\n        var atoms = this.initialAtomValues;\n        this.initialAtomValues = /* @__PURE__ */new Map();\n        flushChanges(atoms.keys());\n      } else {\n        this.initialAtomValues.forEach(function (value, atom) {\n          if (!_this.parent.initialAtomValues.has(atom)) {\n            _this.parent.initialAtomValues.set(atom, value);\n          }\n        });\n      }\n    }\n    /**\n     * Abort the transaction.\n     *\n     * @public\n     */\n  }, {\n    key: \"abort\",\n    value: function abort() {\n      globalEpoch++;\n      this.initialAtomValues.forEach(function (value, atom) {\n        var _atom$historyBuffer;\n        atom.set(value);\n        (_atom$historyBuffer = atom.historyBuffer) === null || _atom$historyBuffer === void 0 || _atom$historyBuffer.clear();\n      });\n      this.commit();\n    }\n  }]);\n  return Transaction;\n}();\nfunction flushChanges(atoms) {\n  if (globalIsReacting) {\n    throw new Error(\"cannot change atoms during reaction cycle\");\n  }\n  try {\n    globalIsReacting = true;\n    var reactors = /* @__PURE__ */new Set();\n    var traverse = function traverse(node) {\n      if (node.lastTraversedEpoch === globalEpoch) {\n        return;\n      }\n      node.lastTraversedEpoch = globalEpoch;\n      if (\"maybeScheduleEffect\" in node) {\n        reactors.add(node);\n      } else {\n        ;\n        node.children.visit(traverse);\n      }\n    };\n    var _iterator = _createForOfIteratorHelper(atoms),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var atom = _step.value;\n        atom.children.visit(traverse);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    var _iterator2 = _createForOfIteratorHelper(reactors),\n      _step2;\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var r = _step2.value;\n        r.maybeScheduleEffect();\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n  } finally {\n    globalIsReacting = false;\n  }\n}\nfunction atomDidChange(atom, previousValue) {\n  if (!currentTransaction) {\n    flushChanges([atom]);\n  } else if (!currentTransaction.initialAtomValues.has(atom)) {\n    currentTransaction.initialAtomValues.set(atom, previousValue);\n  }\n}\nvar currentTransaction = null;\nfunction transaction(fn) {\n  var txn = new Transaction(currentTransaction);\n  currentTransaction = txn;\n  try {\n    var rollback = false;\n    var result = fn(function () {\n      return rollback = true;\n    });\n    if (rollback) {\n      txn.abort();\n    } else {\n      txn.commit();\n    }\n    return result;\n  } catch (e) {\n    txn.abort();\n    throw e;\n  } finally {\n    currentTransaction = currentTransaction.parent;\n  }\n}\nfunction transact(fn) {\n  if (currentTransaction) {\n    return fn();\n  }\n  return transaction(fn);\n}\nexport { advanceGlobalEpoch, atomDidChange, currentTransaction, globalEpoch, transact, transaction };","map":{"version":3,"names":["GLOBAL_START_EPOCH","globalEpoch","globalIsReacting","advanceGlobalEpoch","Transaction","parent","_classCallCheck","_defineProperty","Map","_createClass","key","get","value","commit","_this","isRoot","atoms","initialAtomValues","flushChanges","keys","forEach","atom","has","set","abort","_atom$historyBuffer","historyBuffer","clear","Error","reactors","Set","traverse","node","lastTraversedEpoch","add","children","visit","_iterator","_createForOfIteratorHelper","_step","s","n","done","err","e","f","_iterator2","_step2","r","maybeScheduleEffect","atomDidChange","previousValue","currentTransaction","transaction","fn","txn","rollback","result","transact"],"sources":["/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/signia/src/transactions.ts"],"sourcesContent":["import { _Atom } from './Atom.js'\nimport { GLOBAL_START_EPOCH } from './constants.js'\nimport { EffectScheduler } from './EffectScheduler.js'\nimport { Child, Signal } from './types.js'\n\n// The current epoch (global to all atoms).\nexport let globalEpoch = GLOBAL_START_EPOCH + 1\n\n// Whether any transaction is reacting.\nlet globalIsReacting = false\n\nexport function advanceGlobalEpoch() {\n\tglobalEpoch++\n}\n\nclass Transaction {\n\tconstructor(public readonly parent: Transaction | null) {}\n\tinitialAtomValues = new Map<_Atom<any>, any>()\n\n\t/**\n\t * Get whether this transaction is a root (no parents).\n\t *\n\t * @public\n\t */\n\tget isRoot() {\n\t\treturn this.parent === null\n\t}\n\n\t/**\n\t * Commit the transaction's changes.\n\t *\n\t * @public\n\t */\n\tcommit() {\n\t\tif (this.isRoot) {\n\t\t\t// For root transactions, flush changes to each of the atom's initial values.\n\t\t\tconst atoms = this.initialAtomValues\n\t\t\tthis.initialAtomValues = new Map()\n\t\t\tflushChanges(atoms.keys())\n\t\t} else {\n\t\t\t// For transaction's with parents, add the transaction's initial values to the parent's.\n\t\t\tthis.initialAtomValues.forEach((value, atom) => {\n\t\t\t\tif (!this.parent!.initialAtomValues.has(atom)) {\n\t\t\t\t\tthis.parent!.initialAtomValues.set(atom, value)\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t}\n\n\t/**\n\t * Abort the transaction.\n\t *\n\t * @public\n\t */\n\tabort() {\n\t\tglobalEpoch++\n\n\t\t// Reset each of the transaction's atoms to its initial value.\n\t\tthis.initialAtomValues.forEach((value, atom) => {\n\t\t\tatom.set(value)\n\t\t\tatom.historyBuffer?.clear()\n\t\t})\n\n\t\t// Commit the changes.\n\t\tthis.commit()\n\t}\n}\n\n/**\n * Collect all of the reactors that need to run for an atom and run them.\n *\n * @param atom The atom to flush changes for.\n */\nfunction flushChanges(atoms: Iterable<_Atom<any>>) {\n\tif (globalIsReacting) {\n\t\tthrow new Error('cannot change atoms during reaction cycle')\n\t}\n\n\ttry {\n\t\tglobalIsReacting = true\n\n\t\t// Collect all of the visited reactors.\n\t\tconst reactors = new Set<EffectScheduler<unknown>>()\n\n\t\t// Visit each descendant of the atom, collecting reactors.\n\t\tconst traverse = (node: Child) => {\n\t\t\tif (node.lastTraversedEpoch === globalEpoch) {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tnode.lastTraversedEpoch = globalEpoch\n\n\t\t\tif ('maybeScheduleEffect' in node) {\n\t\t\t\treactors.add(node)\n\t\t\t} else {\n\t\t\t\t;(node as any as Signal<any>).children.visit(traverse)\n\t\t\t}\n\t\t}\n\n\t\tfor (const atom of atoms) {\n\t\t\tatom.children.visit(traverse)\n\t\t}\n\n\t\t// Run each reactor.\n\t\tfor (const r of reactors) {\n\t\t\tr.maybeScheduleEffect()\n\t\t}\n\t} finally {\n\t\tglobalIsReacting = false\n\t}\n}\n\n/**\n * Handle a change to an atom.\n *\n * @param atom The atom that changed.\n * @param previousValue The atom's previous value.\n *\n * @internal\n */\nexport function atomDidChange(atom: _Atom<any>, previousValue: any) {\n\tif (!currentTransaction) {\n\t\tflushChanges([atom])\n\t} else if (!currentTransaction.initialAtomValues.has(atom)) {\n\t\tcurrentTransaction.initialAtomValues.set(atom, previousValue)\n\t}\n}\n\n/**\n * The current transaction, if there is one.\n *\n * @global\n * @public\n */\nexport let currentTransaction = null as Transaction | null\n\n/**\n * Batches state updates, deferring side effects until after the transaction completes.\n *\n * @example\n * ```ts\n * const firstName = atom('John')\n * const lastName = atom('Doe')\n *\n * react('greet', () => {\n *   console.log(`Hello, ${firstName.value} ${lastName.value}!`)\n * })\n *\n * // Logs \"Hello, John Doe!\"\n *\n * transaction(() => {\n *  firstName.set('Jane')\n *  lastName.set('Smith')\n * })\n *\n * // Logs \"Hello, Jane Smith!\"\n * ```\n *\n * If the function throws, the transaction is aborted and any signals that were updated during the transaction revert to their state before the transaction began.\n *\n * @example\n * ```ts\n * const firstName = atom('John')\n * const lastName = atom('Doe')\n *\n * react('greet', () => {\n *   console.log(`Hello, ${firstName.value} ${lastName.value}!`)\n * })\n *\n * // Logs \"Hello, John Doe!\"\n *\n * transaction(() => {\n *  firstName.set('Jane')\n *  throw new Error('oops')\n * })\n *\n * // Does not log\n * // firstName.value === 'John'\n * ```\n *\n * A `rollback` callback is passed into the function.\n * Calling this will prevent the transaction from committing and will revert any signals that were updated during the transaction to their state before the transaction began.\n *\n *  * @example\n * ```ts\n * const firstName = atom('John')\n * const lastName = atom('Doe')\n *\n * react('greet', () => {\n *   console.log(`Hello, ${firstName.value} ${lastName.value}!`)\n * })\n *\n * // Logs \"Hello, John Doe!\"\n *\n * transaction((rollback) => {\n *  firstName.set('Jane')\n *  lastName.set('Smith')\n *  rollback()\n * })\n *\n * // Does not log\n * // firstName.value === 'John'\n * // lastName.value === 'Doe'\n * ```\n *\n * @param fn The function to run in a transaction, called with a function to roll back the change.\n * @public\n */\nexport function transaction<T>(fn: (rollback: () => void) => T) {\n\tconst txn = new Transaction(currentTransaction)\n\n\t// Set the current transaction to the transaction\n\tcurrentTransaction = txn\n\n\ttry {\n\t\tlet rollback = false\n\n\t\t// Run the function.\n\t\tconst result = fn(() => (rollback = true))\n\n\t\tif (rollback) {\n\t\t\t// If the rollback was triggered, abort the transaction.\n\t\t\ttxn.abort()\n\t\t} else {\n\t\t\t// Otherwise, commit the transaction.\n\t\t\ttxn.commit()\n\t\t}\n\n\t\treturn result\n\t} catch (e) {\n\t\t// Abort the transaction if the function throws.\n\t\ttxn.abort()\n\t\tthrow e\n\t} finally {\n\t\t// Set the current transaction to the transaction's parent.\n\t\tcurrentTransaction = currentTransaction.parent\n\t}\n}\n\n/**\n * Like [transaction](#transaction), but does not create a new transaction if there is already one in progress.\n *\n * @param fn\n * @public\n */\nexport function transact<T>(fn: () => T): T {\n\tif (currentTransaction) {\n\t\treturn fn()\n\t}\n\treturn transaction(fn)\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}