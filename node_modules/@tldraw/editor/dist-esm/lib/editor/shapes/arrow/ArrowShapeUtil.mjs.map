{
  "version": 3,
  "sources": ["../../../../../src/lib/editor/shapes/arrow/ArrowShapeUtil.tsx"],
  "sourcesContent": ["import {\n\tBox2d,\n\tgetPointOnCircle,\n\tlinesIntersect,\n\tlongAngleDist,\n\tMatrix2d,\n\tpointInPolygon,\n\tshortAngleDist,\n\ttoDomPrecision,\n\tVec2d,\n\tVecLike,\n} from '@tldraw/primitives'\nimport { ComputedCache } from '@tldraw/store'\nimport {\n\tTLArrowShape,\n\tTLArrowShapeArrowheadStyle,\n\tTLDefaultColorStyle,\n\tTLDefaultFillStyle,\n\tTLHandle,\n\tTLShapeId,\n\tTLShapePartial,\n\tVec2dModel,\n} from '@tldraw/tlschema'\nimport { deepCopy, last, minBy } from '@tldraw/utils'\nimport * as React from 'react'\nimport { computed, EMPTY_ARRAY } from 'signia'\nimport { SVGContainer } from '../../../components/SVGContainer'\nimport {\n\tShapeUtil,\n\tTLOnEditEndHandler,\n\tTLOnHandleChangeHandler,\n\tTLOnResizeHandler,\n\tTLOnTranslateStartHandler,\n\tTLShapeUtilFlag,\n} from '../ShapeUtil'\nimport { createTextSvgElementFromSpans } from '../shared/createTextSvgElementFromSpans'\nimport {\n\tARROW_LABEL_FONT_SIZES,\n\tFONT_FAMILIES,\n\tSTROKE_SIZES,\n\tTEXT_PROPS,\n} from '../shared/default-shape-constants'\nimport { getPerfectDashProps } from '../shared/getPerfectDashProps'\nimport { getShapeFillSvg, ShapeFill } from '../shared/ShapeFill'\nimport { TLExportColors } from '../shared/TLExportColors'\nimport { ArrowInfo } from './arrow/arrow-types'\nimport { getArrowheadPathForType } from './arrow/arrowheads'\nimport {\n\tgetCurvedArrowHandlePath,\n\tgetCurvedArrowInfo,\n\tgetSolidCurvedArrowPath,\n} from './arrow/curved-arrow'\nimport { getArrowTerminalsInArrowSpace, getIsArrowStraight } from './arrow/shared'\nimport {\n\tgetSolidStraightArrowPath,\n\tgetStraightArrowHandlePath,\n\tgetStraightArrowInfo,\n} from './arrow/straight-arrow'\nimport { ArrowTextLabel } from './components/ArrowTextLabel'\n\nlet globalRenderIndex = 0\n\n/** @public */\nexport class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {\n\tstatic override type = 'arrow' as const\n\n\toverride canEdit = () => true\n\toverride canBind = () => false\n\toverride isClosed = () => false\n\toverride canSnap = () => true\n\toverride hideResizeHandles: TLShapeUtilFlag<TLArrowShape> = () => true\n\toverride hideRotateHandle: TLShapeUtilFlag<TLArrowShape> = () => true\n\toverride hideSelectionBoundsFg: TLShapeUtilFlag<TLArrowShape> = () => true\n\toverride hideSelectionBoundsBg: TLShapeUtilFlag<TLArrowShape> = () => true\n\n\toverride defaultProps(): TLArrowShape['props'] {\n\t\treturn {\n\t\t\tdash: 'draw',\n\t\t\tsize: 'm',\n\t\t\tfill: 'none',\n\t\t\tcolor: 'black',\n\t\t\tlabelColor: 'black',\n\t\t\tbend: 0,\n\t\t\tstart: { type: 'point', x: 0, y: 0 },\n\t\t\tend: { type: 'point', x: 0, y: 0 },\n\t\t\tarrowheadStart: 'none',\n\t\t\tarrowheadEnd: 'arrow',\n\t\t\ttext: '',\n\t\t\tfont: 'draw',\n\t\t}\n\t}\n\n\tgetCenter(shape: TLArrowShape): Vec2d {\n\t\treturn this.bounds(shape).center\n\t}\n\n\tgetBounds(shape: TLArrowShape) {\n\t\treturn Box2d.FromPoints(this.getOutlineWithoutLabel(shape))\n\t}\n\n\tgetOutlineWithoutLabel(shape: TLArrowShape): Vec2d[] {\n\t\tconst info = this.getArrowInfo(shape)\n\n\t\tif (!info) {\n\t\t\treturn []\n\t\t}\n\n\t\tif (info.isStraight) {\n\t\t\tif (info.isValid) {\n\t\t\t\treturn [Vec2d.From(info.start.point), Vec2d.From(info.end.point)]\n\t\t\t} else {\n\t\t\t\treturn [new Vec2d(0, 0), new Vec2d(1, 1)]\n\t\t\t}\n\t\t}\n\n\t\tif (!info.isValid) {\n\t\t\treturn [new Vec2d(0, 0), new Vec2d(1, 1)]\n\t\t}\n\n\t\tconst pointsToPush = Math.max(5, Math.ceil(Math.abs(info.bodyArc.length) / 16))\n\n\t\tif (pointsToPush <= 0 && !isFinite(pointsToPush)) {\n\t\t\treturn [new Vec2d(0, 0), new Vec2d(1, 1)]\n\t\t}\n\n\t\tconst results: Vec2d[] = Array(pointsToPush)\n\n\t\tconst startAngle = Vec2d.Angle(info.bodyArc.center, info.start.point)\n\t\tconst endAngle = Vec2d.Angle(info.bodyArc.center, info.end.point)\n\n\t\tconst a = info.bodyArc.sweepFlag ? endAngle : startAngle\n\t\tconst b = info.bodyArc.sweepFlag ? startAngle : endAngle\n\t\tconst l = info.bodyArc.largeArcFlag ? -longAngleDist(a, b) : shortAngleDist(a, b)\n\n\t\tconst r = Math.max(1, info.bodyArc.radius)\n\n\t\tfor (let i = 0; i < pointsToPush; i++) {\n\t\t\tconst t = i / (pointsToPush - 1)\n\t\t\tconst angle = a + l * t\n\t\t\tconst point = getPointOnCircle(info.bodyArc.center.x, info.bodyArc.center.y, r, angle)\n\t\t\tresults[i] = point\n\t\t}\n\n\t\treturn results\n\t}\n\n\tgetOutline(shape: TLArrowShape): Vec2d[] {\n\t\tconst outlineWithoutLabel = this.getOutlineWithoutLabel(shape)\n\n\t\tconst labelBounds = this.getLabelBounds(shape)\n\t\tif (!labelBounds) {\n\t\t\treturn outlineWithoutLabel\n\t\t}\n\n\t\tconst sides = labelBounds.sides\n\t\tconst sideIndexes = [0, 1, 2, 3]\n\n\t\t// start with the first point...\n\t\tlet prevPoint = outlineWithoutLabel[0]\n\t\tlet didAddLabel = false\n\t\tconst result = [prevPoint]\n\t\tfor (let i = 1; i < outlineWithoutLabel.length; i++) {\n\t\t\t// ...and use the next point to form a line segment for the outline.\n\t\t\tconst nextPoint = outlineWithoutLabel[i]\n\n\t\t\tif (!didAddLabel) {\n\t\t\t\t// find the index of the side of the label bounds that intersects the line segment\n\t\t\t\tconst nearestIntersectingSideIndex = minBy(\n\t\t\t\t\tsideIndexes.filter((sideIndex) =>\n\t\t\t\t\t\tlinesIntersect(sides[sideIndex][0], sides[sideIndex][1], prevPoint, nextPoint)\n\t\t\t\t\t),\n\t\t\t\t\t(sideIndex) =>\n\t\t\t\t\t\tVec2d.DistanceToLineSegment(sides[sideIndex][0], sides[sideIndex][1], prevPoint)\n\t\t\t\t)\n\n\t\t\t\t// if we've found one, start at that index and trace around all four corners of the label bounds\n\t\t\t\tif (nearestIntersectingSideIndex !== undefined) {\n\t\t\t\t\tconst intersectingPoint = Vec2d.NearestPointOnLineSegment(\n\t\t\t\t\t\tsides[nearestIntersectingSideIndex][0],\n\t\t\t\t\t\tsides[nearestIntersectingSideIndex][1],\n\t\t\t\t\t\tprevPoint\n\t\t\t\t\t)\n\n\t\t\t\t\tresult.push(intersectingPoint)\n\t\t\t\t\tfor (let j = 0; j < 4; j++) {\n\t\t\t\t\t\tconst sideIndex = (nearestIntersectingSideIndex + j) % 4\n\t\t\t\t\t\tresult.push(sides[sideIndex][1])\n\t\t\t\t\t}\n\t\t\t\t\tresult.push(intersectingPoint)\n\n\t\t\t\t\t// we've added the label, so we can just continue with the rest of the outline as normal\n\t\t\t\t\tdidAddLabel = true\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tresult.push(nextPoint)\n\t\t\tprevPoint = nextPoint\n\t\t}\n\n\t\treturn result\n\t}\n\n\tsnapPoints(_shape: TLArrowShape): Vec2d[] {\n\t\treturn EMPTY_ARRAY\n\t}\n\n\t@computed\n\tprivate get infoCache() {\n\t\treturn this.editor.store.createComputedCache<ArrowInfo, TLArrowShape>(\n\t\t\t'arrow infoCache',\n\t\t\t(shape) => {\n\t\t\t\treturn getIsArrowStraight(shape)\n\t\t\t\t\t? getStraightArrowInfo(this.editor, shape)\n\t\t\t\t\t: getCurvedArrowInfo(this.editor, shape)\n\t\t\t}\n\t\t)\n\t}\n\n\tgetArrowInfo(shape: TLArrowShape) {\n\t\treturn this.infoCache.get(shape.id)\n\t}\n\n\tgetHandles(shape: TLArrowShape): TLHandle[] {\n\t\tconst info = this.infoCache.get(shape.id)!\n\t\treturn [\n\t\t\t{\n\t\t\t\tid: 'start',\n\t\t\t\ttype: 'vertex',\n\t\t\t\tindex: 'a0',\n\t\t\t\tx: info.start.handle.x,\n\t\t\t\ty: info.start.handle.y,\n\t\t\t\tcanBind: true,\n\t\t\t},\n\t\t\t{\n\t\t\t\tid: 'middle',\n\t\t\t\ttype: 'vertex',\n\t\t\t\tindex: 'a2',\n\t\t\t\tx: info.middle.x,\n\t\t\t\ty: info.middle.y,\n\t\t\t\tcanBind: false,\n\t\t\t},\n\t\t\t{\n\t\t\t\tid: 'end',\n\t\t\t\ttype: 'vertex',\n\t\t\t\tindex: 'a3',\n\t\t\t\tx: info.end.handle.x,\n\t\t\t\ty: info.end.handle.y,\n\t\t\t\tcanBind: true,\n\t\t\t},\n\t\t]\n\t}\n\n\tonHandleChange: TLOnHandleChangeHandler<TLArrowShape> = (shape, { handle, isPrecise }) => {\n\t\tconst next = deepCopy(shape)\n\n\t\tswitch (handle.id) {\n\t\t\tcase 'start':\n\t\t\tcase 'end': {\n\t\t\t\tconst pageTransform = this.editor.getPageTransformById(next.id)!\n\t\t\t\tconst pointInPageSpace = Matrix2d.applyToPoint(pageTransform, handle)\n\n\t\t\t\tif (this.editor.inputs.ctrlKey) {\n\t\t\t\t\tnext.props[handle.id] = {\n\t\t\t\t\t\ttype: 'point',\n\t\t\t\t\t\tx: handle.x,\n\t\t\t\t\t\ty: handle.y,\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tconst target = last(\n\t\t\t\t\t\tthis.editor.sortedShapesArray.filter((hitShape) => {\n\t\t\t\t\t\t\tif (hitShape.id === shape.id) {\n\t\t\t\t\t\t\t\t// We're testing against the arrow\n\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tconst util = this.editor.getShapeUtil(hitShape)\n\t\t\t\t\t\t\tif (!util.canBind(hitShape)) {\n\t\t\t\t\t\t\t\t// The shape can't be bound to\n\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Check the page mask\n\t\t\t\t\t\t\tconst pageMask = this.editor.getPageMaskById(hitShape.id)\n\t\t\t\t\t\t\tif (pageMask) {\n\t\t\t\t\t\t\t\tif (!pointInPolygon(pointInPageSpace, pageMask)) return\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tconst pointInTargetSpace = this.editor.getPointInShapeSpace(\n\t\t\t\t\t\t\t\thitShape,\n\t\t\t\t\t\t\t\tpointInPageSpace\n\t\t\t\t\t\t\t)\n\n\t\t\t\t\t\t\tif (util.isClosed(hitShape)) {\n\t\t\t\t\t\t\t\t// Test the polygon\n\t\t\t\t\t\t\t\treturn pointInPolygon(pointInTargetSpace, util.outline(hitShape))\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Test the point using the shape's idea of what a hit is\n\t\t\t\t\t\t\treturn util.hitTestPoint(hitShape, pointInTargetSpace)\n\t\t\t\t\t\t})\n\t\t\t\t\t)\n\n\t\t\t\t\tif (target) {\n\t\t\t\t\t\tconst targetBounds = this.editor.getBounds(target)\n\t\t\t\t\t\tconst pointInTargetSpace = this.editor.getPointInShapeSpace(target, pointInPageSpace)\n\n\t\t\t\t\t\tconst prevHandle = next.props[handle.id]\n\n\t\t\t\t\t\tconst startBindingId =\n\t\t\t\t\t\t\tshape.props.start.type === 'binding' && shape.props.start.boundShapeId\n\t\t\t\t\t\tconst endBindingId = shape.props.end.type === 'binding' && shape.props.end.boundShapeId\n\n\t\t\t\t\t\tlet precise =\n\t\t\t\t\t\t\t// If externally precise, then always precise\n\t\t\t\t\t\t\tisPrecise ||\n\t\t\t\t\t\t\t// If the other handle is bound to the same shape, then precise\n\t\t\t\t\t\t\t((startBindingId || endBindingId) && startBindingId === endBindingId) ||\n\t\t\t\t\t\t\t// If the other shape is not closed, then precise\n\t\t\t\t\t\t\t!this.editor.getShapeUtil(target).isClosed(next)\n\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t// If we're switching to a new bound shape, then precise only if moving slowly\n\t\t\t\t\t\t\tprevHandle.type === 'point' ||\n\t\t\t\t\t\t\t(prevHandle.type === 'binding' && target.id !== prevHandle.boundShapeId)\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tprecise = this.editor.inputs.pointerVelocity.len() < 0.5\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (precise) {\n\t\t\t\t\t\t\t// Funky math but we want the snap distance to be 4 at the minimum and either\n\t\t\t\t\t\t\t// 16 or 15% of the smaller dimension of the target shape, whichever is smaller\n\t\t\t\t\t\t\tprecise =\n\t\t\t\t\t\t\t\tVec2d.Dist(pointInTargetSpace, targetBounds.center) >\n\t\t\t\t\t\t\t\tMath.max(\n\t\t\t\t\t\t\t\t\t4,\n\t\t\t\t\t\t\t\t\tMath.min(Math.min(targetBounds.width, targetBounds.height) * 0.15, 16)\n\t\t\t\t\t\t\t\t) /\n\t\t\t\t\t\t\t\t\tthis.editor.zoomLevel\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tnext.props[handle.id] = {\n\t\t\t\t\t\t\ttype: 'binding',\n\t\t\t\t\t\t\tboundShapeId: target.id,\n\t\t\t\t\t\t\tnormalizedAnchor: precise\n\t\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t\tx: (pointInTargetSpace.x - targetBounds.minX) / targetBounds.width,\n\t\t\t\t\t\t\t\t\t\ty: (pointInTargetSpace.y - targetBounds.minY) / targetBounds.height,\n\t\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t\t: { x: 0.5, y: 0.5 },\n\t\t\t\t\t\t\tisExact: this.editor.inputs.altKey,\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnext.props[handle.id] = {\n\t\t\t\t\t\t\ttype: 'point',\n\t\t\t\t\t\t\tx: handle.x,\n\t\t\t\t\t\t\ty: handle.y,\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tcase 'middle': {\n\t\t\t\tconst { start, end } = getArrowTerminalsInArrowSpace(this.editor, next)\n\n\t\t\t\tconst delta = Vec2d.Sub(end, start)\n\t\t\t\tconst v = Vec2d.Per(delta)\n\n\t\t\t\tconst med = Vec2d.Med(end, start)\n\t\t\t\tconst A = Vec2d.Sub(med, v)\n\t\t\t\tconst B = Vec2d.Add(med, v)\n\n\t\t\t\tconst point = Vec2d.NearestPointOnLineSegment(A, B, handle, false)\n\t\t\t\tlet bend = Vec2d.Dist(point, med)\n\t\t\t\tif (Vec2d.Clockwise(point, end, med)) bend *= -1\n\t\t\t\tnext.props.bend = bend\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\treturn next\n\t}\n\n\tonTranslateStart: TLOnTranslateStartHandler<TLArrowShape> = (shape) => {\n\t\tlet startBinding: TLShapeId | null =\n\t\t\tshape.props.start.type === 'binding' ? shape.props.start.boundShapeId : null\n\t\tlet endBinding: TLShapeId | null =\n\t\t\tshape.props.end.type === 'binding' ? shape.props.end.boundShapeId : null\n\n\t\t// If at least one bound shape is in the selection, do nothing;\n\t\t// If no bound shapes are in the selection, unbind any bound shapes\n\n\t\tif (\n\t\t\t(startBinding && this.editor.isWithinSelection(startBinding)) ||\n\t\t\t(endBinding && this.editor.isWithinSelection(endBinding))\n\t\t) {\n\t\t\treturn\n\t\t}\n\n\t\tstartBinding = null\n\t\tendBinding = null\n\n\t\tconst { start, end } = getArrowTerminalsInArrowSpace(this.editor, shape)\n\n\t\treturn {\n\t\t\tid: shape.id,\n\t\t\ttype: shape.type,\n\t\t\tprops: {\n\t\t\t\t...shape.props,\n\t\t\t\tstart: {\n\t\t\t\t\ttype: 'point',\n\t\t\t\t\tx: start.x,\n\t\t\t\t\ty: start.y,\n\t\t\t\t},\n\t\t\t\tend: {\n\t\t\t\t\ttype: 'point',\n\t\t\t\t\tx: end.x,\n\t\t\t\t\ty: end.y,\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\t}\n\n\tonResize: TLOnResizeHandler<TLArrowShape> = (shape, info) => {\n\t\tconst { scaleX, scaleY } = info\n\n\t\tconst terminals = getArrowTerminalsInArrowSpace(this.editor, shape)\n\n\t\tconst { start, end } = deepCopy<TLArrowShape['props']>(shape.props)\n\t\tlet { bend } = shape.props\n\n\t\t// Rescale start handle if it's not bound to a shape\n\t\tif (start.type === 'point') {\n\t\t\tstart.x = terminals.start.x * scaleX\n\t\t\tstart.y = terminals.start.y * scaleY\n\t\t}\n\n\t\t// Rescale end handle if it's not bound to a shape\n\t\tif (end.type === 'point') {\n\t\t\tend.x = terminals.end.x * scaleX\n\t\t\tend.y = terminals.end.y * scaleY\n\t\t}\n\n\t\t// todo: we should only change the normalized anchor positions\n\t\t// of the shape's handles if the bound shape is also being resized\n\n\t\tconst mx = Math.abs(scaleX)\n\t\tconst my = Math.abs(scaleY)\n\n\t\tif (scaleX < 0 && scaleY >= 0) {\n\t\t\tif (bend !== 0) {\n\t\t\t\tbend *= -1\n\t\t\t\tbend *= Math.max(mx, my)\n\t\t\t}\n\n\t\t\tif (start.type === 'binding') {\n\t\t\t\tstart.normalizedAnchor.x = 1 - start.normalizedAnchor.x\n\t\t\t}\n\n\t\t\tif (end.type === 'binding') {\n\t\t\t\tend.normalizedAnchor.x = 1 - end.normalizedAnchor.x\n\t\t\t}\n\t\t} else if (scaleX >= 0 && scaleY < 0) {\n\t\t\tif (bend !== 0) {\n\t\t\t\tbend *= -1\n\t\t\t\tbend *= Math.max(mx, my)\n\t\t\t}\n\n\t\t\tif (start.type === 'binding') {\n\t\t\t\tstart.normalizedAnchor.y = 1 - start.normalizedAnchor.y\n\t\t\t}\n\n\t\t\tif (end.type === 'binding') {\n\t\t\t\tend.normalizedAnchor.y = 1 - end.normalizedAnchor.y\n\t\t\t}\n\t\t} else if (scaleX >= 0 && scaleY >= 0) {\n\t\t\tif (bend !== 0) {\n\t\t\t\tbend *= Math.max(mx, my)\n\t\t\t}\n\t\t} else if (scaleX < 0 && scaleY < 0) {\n\t\t\tif (bend !== 0) {\n\t\t\t\tbend *= Math.max(mx, my)\n\t\t\t}\n\n\t\t\tif (start.type === 'binding') {\n\t\t\t\tstart.normalizedAnchor.x = 1 - start.normalizedAnchor.x\n\t\t\t\tstart.normalizedAnchor.y = 1 - start.normalizedAnchor.y\n\t\t\t}\n\n\t\t\tif (end.type === 'binding') {\n\t\t\t\tend.normalizedAnchor.x = 1 - end.normalizedAnchor.x\n\t\t\t\tend.normalizedAnchor.y = 1 - end.normalizedAnchor.y\n\t\t\t}\n\t\t}\n\n\t\tconst next = {\n\t\t\tprops: {\n\t\t\t\tstart,\n\t\t\t\tend,\n\t\t\t\tbend,\n\t\t\t},\n\t\t}\n\n\t\treturn next\n\t}\n\n\tonDoubleClickHandle = (\n\t\tshape: TLArrowShape,\n\t\thandle: TLHandle\n\t): TLShapePartial<TLArrowShape> | void => {\n\t\tswitch (handle.id) {\n\t\t\tcase 'start': {\n\t\t\t\treturn {\n\t\t\t\t\tid: shape.id,\n\t\t\t\t\ttype: shape.type,\n\t\t\t\t\tprops: {\n\t\t\t\t\t\t...shape.props,\n\t\t\t\t\t\tarrowheadStart: shape.props.arrowheadStart === 'none' ? 'arrow' : 'none',\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t}\n\t\t\tcase 'end': {\n\t\t\t\treturn {\n\t\t\t\t\tid: shape.id,\n\t\t\t\t\ttype: shape.type,\n\t\t\t\t\tprops: {\n\t\t\t\t\t\t...shape.props,\n\t\t\t\t\t\tarrowheadEnd: shape.props.arrowheadEnd === 'none' ? 'arrow' : 'none',\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\thitTestPoint(shape: TLArrowShape, point: VecLike): boolean {\n\t\tconst outline = this.outline(shape)\n\t\tconst zoomLevel = this.editor.zoomLevel\n\t\tconst offsetDist = STROKE_SIZES[shape.props.size] / zoomLevel\n\n\t\tfor (let i = 0; i < outline.length - 1; i++) {\n\t\t\tconst C = outline[i]\n\t\t\tconst D = outline[i + 1]\n\n\t\t\tif (Vec2d.DistanceToLineSegment(C, D, point) < offsetDist) return true\n\t\t}\n\n\t\treturn false\n\t}\n\n\thitTestLineSegment(shape: TLArrowShape, A: VecLike, B: VecLike): boolean {\n\t\tconst outline = this.outline(shape)\n\n\t\tfor (let i = 0; i < outline.length - 1; i++) {\n\t\t\tconst C = outline[i]\n\t\t\tconst D = outline[i + 1]\n\t\t\tif (linesIntersect(A, B, C, D)) return true\n\t\t}\n\n\t\treturn false\n\t}\n\n\tcomponent(shape: TLArrowShape) {\n\t\t// Not a class component, but eslint can't tell that :(\n\t\tconst onlySelectedShape = this.editor.onlySelectedShape\n\t\tconst shouldDisplayHandles =\n\t\t\tthis.editor.isInAny(\n\t\t\t\t'select.idle',\n\t\t\t\t'select.pointing_handle',\n\t\t\t\t'select.dragging_handle',\n\t\t\t\t'arrow.dragging'\n\t\t\t) && !this.editor.isReadOnly\n\n\t\tconst info = this.getArrowInfo(shape)\n\t\tconst bounds = this.bounds(shape)\n\t\tconst labelSize = this.getLabelBounds(shape)\n\n\t\t// eslint-disable-next-line react-hooks/rules-of-hooks\n\t\tconst changeIndex = React.useMemo<number>(() => {\n\t\t\treturn this.editor.isSafari ? (globalRenderIndex += 1) : 0\n\t\t\t// eslint-disable-next-line react-hooks/exhaustive-deps\n\t\t}, [shape])\n\n\t\tif (!info?.isValid) return null\n\n\t\tconst strokeWidth = STROKE_SIZES[shape.props.size]\n\n\t\tconst as = info.start.arrowhead && getArrowheadPathForType(info, 'start', strokeWidth)\n\t\tconst ae = info.end.arrowhead && getArrowheadPathForType(info, 'end', strokeWidth)\n\n\t\tconst path = info.isStraight ? getSolidStraightArrowPath(info) : getSolidCurvedArrowPath(info)\n\n\t\tlet handlePath: null | JSX.Element = null\n\n\t\tif (onlySelectedShape === shape && shouldDisplayHandles) {\n\t\t\tconst sw = 2\n\t\t\tconst { strokeDasharray, strokeDashoffset } = getPerfectDashProps(\n\t\t\t\tinfo.isStraight\n\t\t\t\t\t? Vec2d.Dist(info.start.handle, info.end.handle)\n\t\t\t\t\t: Math.abs(info.handleArc.length),\n\t\t\t\tsw,\n\t\t\t\t{\n\t\t\t\t\tend: 'skip',\n\t\t\t\t\tstart: 'skip',\n\t\t\t\t\tlengthRatio: 2.5,\n\t\t\t\t}\n\t\t\t)\n\n\t\t\thandlePath =\n\t\t\t\tshape.props.start.type === 'binding' || shape.props.end.type === 'binding' ? (\n\t\t\t\t\t<path\n\t\t\t\t\t\tclassName=\"tl-arrow-hint\"\n\t\t\t\t\t\td={info.isStraight ? getStraightArrowHandlePath(info) : getCurvedArrowHandlePath(info)}\n\t\t\t\t\t\tstrokeDasharray={strokeDasharray}\n\t\t\t\t\t\tstrokeDashoffset={strokeDashoffset}\n\t\t\t\t\t\tstrokeWidth={sw}\n\t\t\t\t\t\tmarkerStart={\n\t\t\t\t\t\t\tshape.props.start.type === 'binding'\n\t\t\t\t\t\t\t\t? shape.props.start.isExact\n\t\t\t\t\t\t\t\t\t? ''\n\t\t\t\t\t\t\t\t\t: isPrecise(shape.props.start.normalizedAnchor)\n\t\t\t\t\t\t\t\t\t? 'url(#arrowhead-cross)'\n\t\t\t\t\t\t\t\t\t: 'url(#arrowhead-dot)'\n\t\t\t\t\t\t\t\t: ''\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmarkerEnd={\n\t\t\t\t\t\t\tshape.props.end.type === 'binding'\n\t\t\t\t\t\t\t\t? shape.props.end.isExact\n\t\t\t\t\t\t\t\t\t? ''\n\t\t\t\t\t\t\t\t\t: isPrecise(shape.props.end.normalizedAnchor)\n\t\t\t\t\t\t\t\t\t? 'url(#arrowhead-cross)'\n\t\t\t\t\t\t\t\t\t: 'url(#arrowhead-dot)'\n\t\t\t\t\t\t\t\t: ''\n\t\t\t\t\t\t}\n\t\t\t\t\t\topacity={0.16}\n\t\t\t\t\t/>\n\t\t\t\t) : null\n\t\t}\n\n\t\tconst { strokeDasharray, strokeDashoffset } = getPerfectDashProps(\n\t\t\tinfo.isStraight ? info.length : Math.abs(info.bodyArc.length),\n\t\t\tstrokeWidth,\n\t\t\t{\n\t\t\t\tstyle: shape.props.dash,\n\t\t\t}\n\t\t)\n\n\t\tconst maskStartArrowhead = !(\n\t\t\tinfo.start.arrowhead === 'none' || info.start.arrowhead === 'arrow'\n\t\t)\n\t\tconst maskEndArrowhead = !(info.end.arrowhead === 'none' || info.end.arrowhead === 'arrow')\n\t\tconst includeMask = maskStartArrowhead || maskEndArrowhead || labelSize\n\n\t\t// NOTE: I know right setting `changeIndex` hacky-as right! But we need this because otherwise safari loses\n\t\t// the mask, see <https://linear.app/tldraw/issue/TLD-1500/changing-arrow-color-makes-line-pass-through-text>\n\t\tconst maskId = (shape.id + '_clip_' + changeIndex).replace(':', '_')\n\n\t\treturn (\n\t\t\t<>\n\t\t\t\t<SVGContainer id={shape.id} style={{ minWidth: 50, minHeight: 50 }}>\n\t\t\t\t\t{includeMask && (\n\t\t\t\t\t\t<defs>\n\t\t\t\t\t\t\t<mask id={maskId}>\n\t\t\t\t\t\t\t\t<rect\n\t\t\t\t\t\t\t\t\tx={toDomPrecision(-100 + bounds.minX)}\n\t\t\t\t\t\t\t\t\ty={toDomPrecision(-100 + bounds.minY)}\n\t\t\t\t\t\t\t\t\twidth={toDomPrecision(bounds.width + 200)}\n\t\t\t\t\t\t\t\t\theight={toDomPrecision(bounds.height + 200)}\n\t\t\t\t\t\t\t\t\tfill=\"white\"\n\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t\t{labelSize && (\n\t\t\t\t\t\t\t\t\t<rect\n\t\t\t\t\t\t\t\t\t\tx={toDomPrecision(labelSize.x)}\n\t\t\t\t\t\t\t\t\t\ty={toDomPrecision(labelSize.y)}\n\t\t\t\t\t\t\t\t\t\twidth={toDomPrecision(labelSize.w)}\n\t\t\t\t\t\t\t\t\t\theight={toDomPrecision(labelSize.h)}\n\t\t\t\t\t\t\t\t\t\tfill=\"black\"\n\t\t\t\t\t\t\t\t\t\trx={4}\n\t\t\t\t\t\t\t\t\t\try={4}\n\t\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t\t{as && maskStartArrowhead && (\n\t\t\t\t\t\t\t\t\t<path\n\t\t\t\t\t\t\t\t\t\td={as}\n\t\t\t\t\t\t\t\t\t\tfill={info.start.arrowhead === 'arrow' ? 'none' : 'black'}\n\t\t\t\t\t\t\t\t\t\tstroke=\"none\"\n\t\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t\t{ae && maskEndArrowhead && (\n\t\t\t\t\t\t\t\t\t<path\n\t\t\t\t\t\t\t\t\t\td={ae}\n\t\t\t\t\t\t\t\t\t\tfill={info.end.arrowhead === 'arrow' ? 'none' : 'black'}\n\t\t\t\t\t\t\t\t\t\tstroke=\"none\"\n\t\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t</mask>\n\t\t\t\t\t\t</defs>\n\t\t\t\t\t)}\n\t\t\t\t\t<g\n\t\t\t\t\t\tfill=\"none\"\n\t\t\t\t\t\tstroke={`var(--palette-${shape.props.color})`}\n\t\t\t\t\t\tstrokeWidth={strokeWidth}\n\t\t\t\t\t\tstrokeLinejoin=\"round\"\n\t\t\t\t\t\tstrokeLinecap=\"round\"\n\t\t\t\t\t\tpointerEvents=\"none\"\n\t\t\t\t\t>\n\t\t\t\t\t\t{handlePath}\n\t\t\t\t\t\t{/* firefox will clip if you provide a maskURL even if there is no mask matching that URL in the DOM */}\n\t\t\t\t\t\t<g {...(includeMask ? { mask: `url(#${maskId})` } : undefined)}>\n\t\t\t\t\t\t\t{/* This rect needs to be here if we're creating a mask due to an svg quirk on Chrome */}\n\t\t\t\t\t\t\t{includeMask && (\n\t\t\t\t\t\t\t\t<rect\n\t\t\t\t\t\t\t\t\tx={toDomPrecision(bounds.minX - 100)}\n\t\t\t\t\t\t\t\t\ty={toDomPrecision(bounds.minY - 100)}\n\t\t\t\t\t\t\t\t\twidth={toDomPrecision(bounds.width + 200)}\n\t\t\t\t\t\t\t\t\theight={toDomPrecision(bounds.height + 200)}\n\t\t\t\t\t\t\t\t\topacity={0}\n\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t<path\n\t\t\t\t\t\t\t\td={path}\n\t\t\t\t\t\t\t\tstrokeDasharray={strokeDasharray}\n\t\t\t\t\t\t\t\tstrokeDashoffset={strokeDashoffset}\n\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t</g>\n\t\t\t\t\t\t{as && maskStartArrowhead && shape.props.fill !== 'none' && (\n\t\t\t\t\t\t\t<ShapeFill d={as} color={shape.props.color} fill={shape.props.fill} />\n\t\t\t\t\t\t)}\n\t\t\t\t\t\t{ae && maskEndArrowhead && shape.props.fill !== 'none' && (\n\t\t\t\t\t\t\t<ShapeFill d={ae} color={shape.props.color} fill={shape.props.fill} />\n\t\t\t\t\t\t)}\n\t\t\t\t\t\t{as && <path d={as} />}\n\t\t\t\t\t\t{ae && <path d={ae} />}\n\t\t\t\t\t</g>\n\t\t\t\t\t<path d={path} className=\"tl-hitarea-stroke\" />\n\t\t\t\t</SVGContainer>\n\t\t\t\t<ArrowTextLabel\n\t\t\t\t\tid={shape.id}\n\t\t\t\t\ttext={shape.props.text}\n\t\t\t\t\tfont={shape.props.font}\n\t\t\t\t\tsize={shape.props.size}\n\t\t\t\t\tposition={info.middle}\n\t\t\t\t\twidth={labelSize?.w ?? 0}\n\t\t\t\t\tlabelColor={shape.props.labelColor}\n\t\t\t\t/>\n\t\t\t</>\n\t\t)\n\t}\n\n\tindicator(shape: TLArrowShape) {\n\t\tconst { start, end } = getArrowTerminalsInArrowSpace(this.editor, shape)\n\n\t\tconst info = this.getArrowInfo(shape)\n\t\tconst bounds = this.bounds(shape)\n\t\tconst labelSize = this.getLabelBounds(shape)\n\n\t\tif (!info) return null\n\t\tif (Vec2d.Equals(start, end)) return null\n\n\t\tconst strokeWidth = STROKE_SIZES[shape.props.size]\n\n\t\tconst as = info.start.arrowhead && getArrowheadPathForType(info, 'start', strokeWidth)\n\t\tconst ae = info.end.arrowhead && getArrowheadPathForType(info, 'end', strokeWidth)\n\n\t\tconst path = info.isStraight ? getSolidStraightArrowPath(info) : getSolidCurvedArrowPath(info)\n\n\t\tconst includeMask =\n\t\t\t(as && info.start.arrowhead !== 'arrow') ||\n\t\t\t(ae && info.end.arrowhead !== 'arrow') ||\n\t\t\tlabelSize !== null\n\n\t\tconst maskId = (shape.id + '_clip').replace(':', '_')\n\n\t\treturn (\n\t\t\t<g>\n\t\t\t\t{includeMask && (\n\t\t\t\t\t<defs>\n\t\t\t\t\t\t<mask id={maskId}>\n\t\t\t\t\t\t\t<rect\n\t\t\t\t\t\t\t\tx={bounds.minX - 100}\n\t\t\t\t\t\t\t\ty={bounds.minY - 100}\n\t\t\t\t\t\t\t\twidth={bounds.w + 200}\n\t\t\t\t\t\t\t\theight={bounds.h + 200}\n\t\t\t\t\t\t\t\tfill=\"white\"\n\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t{labelSize && (\n\t\t\t\t\t\t\t\t<rect\n\t\t\t\t\t\t\t\t\tx={labelSize.x}\n\t\t\t\t\t\t\t\t\ty={labelSize.y}\n\t\t\t\t\t\t\t\t\twidth={labelSize.w}\n\t\t\t\t\t\t\t\t\theight={labelSize.h}\n\t\t\t\t\t\t\t\t\tfill=\"black\"\n\t\t\t\t\t\t\t\t\trx={4}\n\t\t\t\t\t\t\t\t\try={4}\n\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t{as && (\n\t\t\t\t\t\t\t\t<path\n\t\t\t\t\t\t\t\t\td={as}\n\t\t\t\t\t\t\t\t\tfill={info.start.arrowhead === 'arrow' ? 'none' : 'black'}\n\t\t\t\t\t\t\t\t\tstroke=\"none\"\n\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t{ae && (\n\t\t\t\t\t\t\t\t<path\n\t\t\t\t\t\t\t\t\td={ae}\n\t\t\t\t\t\t\t\t\tfill={info.end.arrowhead === 'arrow' ? 'none' : 'black'}\n\t\t\t\t\t\t\t\t\tstroke=\"none\"\n\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t</mask>\n\t\t\t\t\t</defs>\n\t\t\t\t)}\n\t\t\t\t{/* firefox will clip if you provide a maskURL even if there is no mask matching that URL in the DOM */}\n\t\t\t\t<g {...(includeMask ? { mask: `url(#${maskId})` } : undefined)}>\n\t\t\t\t\t{/* This rect needs to be here if we're creating a mask due to an svg quirk on Chrome */}\n\t\t\t\t\t{includeMask && (\n\t\t\t\t\t\t<rect\n\t\t\t\t\t\t\tx={bounds.minX - 100}\n\t\t\t\t\t\t\ty={bounds.minY - 100}\n\t\t\t\t\t\t\twidth={bounds.width + 200}\n\t\t\t\t\t\t\theight={bounds.height + 200}\n\t\t\t\t\t\t\topacity={0}\n\t\t\t\t\t\t/>\n\t\t\t\t\t)}\n\n\t\t\t\t\t<path d={path} />\n\t\t\t\t</g>\n\t\t\t\t{as && <path d={as} />}\n\t\t\t\t{ae && <path d={ae} />}\n\t\t\t\t{labelSize && (\n\t\t\t\t\t<rect\n\t\t\t\t\t\tx={labelSize.x}\n\t\t\t\t\t\ty={labelSize.y}\n\t\t\t\t\t\twidth={labelSize.w}\n\t\t\t\t\t\theight={labelSize.h}\n\t\t\t\t\t\trx={4}\n\t\t\t\t\t\try={4}\n\t\t\t\t\t/>\n\t\t\t\t)}\n\t\t\t</g>\n\t\t)\n\t}\n\n\t@computed get labelBoundsCache(): ComputedCache<Box2d | null, TLArrowShape> {\n\t\treturn this.editor.store.createComputedCache('labelBoundsCache', (shape) => {\n\t\t\tconst info = this.getArrowInfo(shape)\n\t\t\tconst bounds = this.bounds(shape)\n\t\t\tconst { text, font, size } = shape.props\n\n\t\t\tif (!info) return null\n\t\t\tif (!text.trim()) return null\n\n\t\t\tconst { w, h } = this.editor.textMeasure.measureText(text, {\n\t\t\t\t...TEXT_PROPS,\n\t\t\t\tfontFamily: FONT_FAMILIES[font],\n\t\t\t\tfontSize: ARROW_LABEL_FONT_SIZES[size],\n\t\t\t\twidth: 'fit-content',\n\t\t\t})\n\n\t\t\tlet width = w\n\t\t\tlet height = h\n\n\t\t\tif (bounds.width > bounds.height) {\n\t\t\t\twidth = Math.max(Math.min(w, 64), Math.min(bounds.width - 64, w))\n\n\t\t\t\tconst { w: squishedWidth, h: squishedHeight } = this.editor.textMeasure.measureText(text, {\n\t\t\t\t\t...TEXT_PROPS,\n\t\t\t\t\tfontFamily: FONT_FAMILIES[font],\n\t\t\t\t\tfontSize: ARROW_LABEL_FONT_SIZES[size],\n\t\t\t\t\twidth: width + 'px',\n\t\t\t\t})\n\n\t\t\t\twidth = squishedWidth\n\t\t\t\theight = squishedHeight\n\t\t\t}\n\n\t\t\tif (width > 16 * ARROW_LABEL_FONT_SIZES[size]) {\n\t\t\t\twidth = 16 * ARROW_LABEL_FONT_SIZES[size]\n\n\t\t\t\tconst { w: squishedWidth, h: squishedHeight } = this.editor.textMeasure.measureText(text, {\n\t\t\t\t\t...TEXT_PROPS,\n\t\t\t\t\tfontFamily: FONT_FAMILIES[font],\n\t\t\t\t\tfontSize: ARROW_LABEL_FONT_SIZES[size],\n\t\t\t\t\twidth: width + 'px',\n\t\t\t\t})\n\n\t\t\t\twidth = squishedWidth\n\t\t\t\theight = squishedHeight\n\t\t\t}\n\n\t\t\treturn new Box2d(\n\t\t\t\tinfo.middle.x - (width + 8) / 2,\n\t\t\t\tinfo.middle.y - (height + 8) / 2,\n\t\t\t\twidth + 8,\n\t\t\t\theight + 8\n\t\t\t)\n\t\t})\n\t}\n\n\tgetLabelBounds(shape: TLArrowShape): Box2d | null {\n\t\treturn this.labelBoundsCache.get(shape.id) || null\n\t}\n\n\tgetEditingBounds = (shape: TLArrowShape): Box2d => {\n\t\treturn this.getLabelBounds(shape) ?? new Box2d()\n\t}\n\n\tonEditEnd: TLOnEditEndHandler<TLArrowShape> = (shape) => {\n\t\tconst {\n\t\t\tid,\n\t\t\ttype,\n\t\t\tprops: { text },\n\t\t} = shape\n\n\t\tif (text.trimEnd() !== shape.props.text) {\n\t\t\tthis.editor.updateShapes<TLArrowShape>([\n\t\t\t\t{\n\t\t\t\t\tid,\n\t\t\t\t\ttype,\n\t\t\t\t\tprops: {\n\t\t\t\t\t\ttext: text.trimEnd(),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t])\n\t\t}\n\t}\n\n\ttoSvg(shape: TLArrowShape, font: string, colors: TLExportColors) {\n\t\tconst color = colors.fill[shape.props.color]\n\n\t\tconst info = this.getArrowInfo(shape)\n\n\t\tconst strokeWidth = STROKE_SIZES[shape.props.size]\n\n\t\t// Group for arrow\n\t\tconst g = document.createElementNS('http://www.w3.org/2000/svg', 'g')\n\t\tif (!info) return g\n\n\t\t// Arrowhead start path\n\t\tconst as = info.start.arrowhead && getArrowheadPathForType(info, 'start', strokeWidth)\n\t\t// Arrowhead end path\n\t\tconst ae = info.end.arrowhead && getArrowheadPathForType(info, 'end', strokeWidth)\n\n\t\tconst bounds = this.bounds(shape)\n\t\tconst labelSize = this.getLabelBounds(shape)\n\n\t\tconst maskId = (shape.id + '_clip').replace(':', '_')\n\n\t\t// If we have any arrowheads, then mask the arrowheads\n\t\tif (as || ae || labelSize) {\n\t\t\t// Create mask for arrowheads\n\n\t\t\t// Create defs\n\t\t\tconst defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs')\n\n\t\t\t// Create mask\n\t\t\tconst mask = document.createElementNS('http://www.w3.org/2000/svg', 'mask')\n\t\t\tmask.id = maskId\n\n\t\t\t// Create large white shape for mask\n\t\t\tconst rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect')\n\t\t\trect.setAttribute('x', bounds.minX - 100 + '')\n\t\t\trect.setAttribute('y', bounds.minY - 100 + '')\n\t\t\trect.setAttribute('width', bounds.width + 200 + '')\n\t\t\trect.setAttribute('height', bounds.height + 200 + '')\n\t\t\trect.setAttribute('fill', 'white')\n\t\t\tmask.appendChild(rect)\n\n\t\t\t// add arrowhead start mask\n\t\t\tif (as) mask.appendChild(getArrowheadSvgMask(as, info.start.arrowhead))\n\n\t\t\t// add arrowhead end mask\n\t\t\tif (ae) mask.appendChild(getArrowheadSvgMask(ae, info.end.arrowhead))\n\n\t\t\t// Mask out text label if text is present\n\t\t\tif (labelSize) {\n\t\t\t\tconst labelMask = document.createElementNS('http://www.w3.org/2000/svg', 'rect')\n\t\t\t\tlabelMask.setAttribute('x', labelSize.x + '')\n\t\t\t\tlabelMask.setAttribute('y', labelSize.y + '')\n\t\t\t\tlabelMask.setAttribute('width', labelSize.w + '')\n\t\t\t\tlabelMask.setAttribute('height', labelSize.h + '')\n\t\t\t\tlabelMask.setAttribute('fill', 'black')\n\n\t\t\t\tmask.appendChild(labelMask)\n\t\t\t}\n\n\t\t\tdefs.appendChild(mask)\n\t\t\tg.appendChild(defs)\n\t\t}\n\n\t\tconst g2 = document.createElementNS('http://www.w3.org/2000/svg', 'g')\n\t\tg2.setAttribute('mask', `url(#${maskId})`)\n\t\tg.appendChild(g2)\n\n\t\t// Dumb mask fix thing\n\t\tconst rect2 = document.createElementNS('http://www.w3.org/2000/svg', 'rect')\n\t\trect2.setAttribute('x', '-100')\n\t\trect2.setAttribute('y', '-100')\n\t\trect2.setAttribute('width', bounds.width + 200 + '')\n\t\trect2.setAttribute('height', bounds.height + 200 + '')\n\t\trect2.setAttribute('fill', 'transparent')\n\t\trect2.setAttribute('stroke', 'none')\n\t\tg2.appendChild(rect2)\n\n\t\t// Arrowhead body path\n\t\tconst path = getArrowSvgPath(\n\t\t\tinfo.isStraight ? getSolidStraightArrowPath(info) : getSolidCurvedArrowPath(info),\n\t\t\tcolor,\n\t\t\tstrokeWidth\n\t\t)\n\n\t\tconst { strokeDasharray, strokeDashoffset } = getPerfectDashProps(\n\t\t\tinfo.isStraight ? info.length : Math.abs(info.bodyArc.length),\n\t\t\tstrokeWidth,\n\t\t\t{\n\t\t\t\tstyle: shape.props.dash,\n\t\t\t}\n\t\t)\n\n\t\tpath.setAttribute('stroke-dasharray', strokeDasharray)\n\t\tpath.setAttribute('stroke-dashoffset', strokeDashoffset)\n\n\t\tg2.appendChild(path)\n\n\t\t// Arrowhead start path\n\t\tif (as) {\n\t\t\tg.appendChild(\n\t\t\t\tgetArrowheadSvgPath(\n\t\t\t\t\tas,\n\t\t\t\t\tshape.props.color,\n\t\t\t\t\tstrokeWidth,\n\t\t\t\t\tshape.props.arrowheadStart === 'arrow' ? 'none' : shape.props.fill,\n\t\t\t\t\tcolors\n\t\t\t\t)\n\t\t\t)\n\t\t}\n\t\t// Arrowhead end path\n\t\tif (ae) {\n\t\t\tg.appendChild(\n\t\t\t\tgetArrowheadSvgPath(\n\t\t\t\t\tae,\n\t\t\t\t\tshape.props.color,\n\t\t\t\t\tstrokeWidth,\n\t\t\t\t\tshape.props.arrowheadEnd === 'arrow' ? 'none' : shape.props.fill,\n\t\t\t\t\tcolors\n\t\t\t\t)\n\t\t\t)\n\t\t}\n\n\t\t// Text Label\n\t\tif (labelSize) {\n\t\t\tconst opts = {\n\t\t\t\tfontSize: ARROW_LABEL_FONT_SIZES[shape.props.size],\n\t\t\t\tlineHeight: TEXT_PROPS.lineHeight,\n\t\t\t\tfontFamily: font,\n\t\t\t\tpadding: 0,\n\t\t\t\ttextAlign: 'middle' as const,\n\t\t\t\twidth: labelSize.w - 8,\n\t\t\t\tverticalTextAlign: 'middle' as const,\n\t\t\t\theight: labelSize.h,\n\t\t\t\tfontStyle: 'normal',\n\t\t\t\tfontWeight: 'normal',\n\t\t\t\toverflow: 'wrap' as const,\n\t\t\t}\n\n\t\t\tconst textElm = createTextSvgElementFromSpans(\n\t\t\t\tthis.editor,\n\t\t\t\tthis.editor.textMeasure.measureTextSpans(shape.props.text, opts),\n\t\t\t\topts\n\t\t\t)\n\t\t\ttextElm.setAttribute('fill', colors.fill[shape.props.labelColor])\n\n\t\t\tconst children = Array.from(textElm.children) as unknown as SVGTSpanElement[]\n\n\t\t\tchildren.forEach((child) => {\n\t\t\t\tconst x = parseFloat(child.getAttribute('x') || '0')\n\t\t\t\tconst y = parseFloat(child.getAttribute('y') || '0')\n\n\t\t\t\tchild.setAttribute('x', x + 4 + labelSize!.x + 'px')\n\t\t\t\tchild.setAttribute('y', y + labelSize!.y + 'px')\n\t\t\t})\n\n\t\t\tconst textBgEl = textElm.cloneNode(true) as SVGTextElement\n\t\t\ttextBgEl.setAttribute('stroke-width', '2')\n\t\t\ttextBgEl.setAttribute('fill', colors.background)\n\t\t\ttextBgEl.setAttribute('stroke', colors.background)\n\n\t\t\tg.appendChild(textBgEl)\n\t\t\tg.appendChild(textElm)\n\t\t}\n\n\t\treturn g\n\t}\n}\n\nfunction getArrowheadSvgMask(d: string, arrowhead: TLArrowShapeArrowheadStyle) {\n\tconst path = document.createElementNS('http://www.w3.org/2000/svg', 'path')\n\tpath.setAttribute('d', d)\n\tpath.setAttribute('fill', arrowhead === 'arrow' ? 'none' : 'black')\n\tpath.setAttribute('stroke', 'none')\n\treturn path\n}\n\nfunction getArrowSvgPath(d: string, color: string, strokeWidth: number) {\n\tconst path = document.createElementNS('http://www.w3.org/2000/svg', 'path')\n\tpath.setAttribute('d', d)\n\tpath.setAttribute('fill', 'none')\n\tpath.setAttribute('stroke', color)\n\tpath.setAttribute('stroke-width', strokeWidth + '')\n\treturn path\n}\n\nfunction getArrowheadSvgPath(\n\td: string,\n\tcolor: TLDefaultColorStyle,\n\tstrokeWidth: number,\n\tfill: TLDefaultFillStyle,\n\tcolors: TLExportColors\n) {\n\tconst path = document.createElementNS('http://www.w3.org/2000/svg', 'path')\n\tpath.setAttribute('d', d)\n\tpath.setAttribute('fill', 'none')\n\tpath.setAttribute('stroke', colors.fill[color])\n\tpath.setAttribute('stroke-width', strokeWidth + '')\n\n\t// Get the fill element, if any\n\tconst shapeFill = getShapeFillSvg({\n\t\td,\n\t\tfill,\n\t\tcolor,\n\t\tcolors,\n\t})\n\n\tif (shapeFill) {\n\t\t// If there is a fill element, return a group containing the fill and the path\n\t\tconst g = document.createElementNS('http://www.w3.org/2000/svg', 'g')\n\t\tg.appendChild(shapeFill)\n\t\tg.appendChild(path)\n\t\treturn g\n\t} else {\n\t\t// Otherwise, just return the path\n\t\treturn path\n\t}\n}\n\nfunction isPrecise(normalizedAnchor: Vec2dModel) {\n\treturn normalizedAnchor.x !== 0.5 || normalizedAnchor.y !== 0.5\n}\n"],
  "mappings": "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",
  "names": ["isPrecise", "strokeDasharray", "strokeDashoffset"]
}
