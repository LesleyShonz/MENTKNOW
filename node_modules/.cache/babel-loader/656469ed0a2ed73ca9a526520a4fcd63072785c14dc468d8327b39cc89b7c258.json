{"ast":null,"code":"import { Vec2d } from \"@tldraw/primitives\";\nimport { createUseGesture, pinchAction, wheelAction } from \"@use-gesture/react\";\nimport throttle from \"lodash.throttle\";\nimport * as React from \"react\";\nimport { preventDefault } from \"../utils/dom.mjs\";\nimport { normalizeWheel } from \"./shared.mjs\";\nimport { useEditor } from \"./useEditor.mjs\";\nvar useGesture = createUseGesture([wheelAction, pinchAction]);\nvar lastWheelTime = void 0;\nvar isWheelEndEvent = function isWheelEndEvent(time) {\n  if (lastWheelTime === void 0) {\n    lastWheelTime = time;\n    return false;\n  }\n  if (time - lastWheelTime > 120 && time - lastWheelTime < 160) {\n    lastWheelTime = time;\n    return true;\n  }\n  lastWheelTime = time;\n  return false;\n};\nfunction useGestureEvents(ref) {\n  var editor = useEditor();\n  var events = React.useMemo(function () {\n    var pinchState = null;\n    var onWheel = function onWheel(_ref) {\n      var event = _ref.event;\n      if (!editor.isFocused) {\n        return;\n      }\n      pinchState = null;\n      if (isWheelEndEvent(Date.now())) {\n        return;\n      }\n      if (editor.editingId) {\n        var shape = editor.getShapeById(editor.editingId);\n        if (shape) {\n          var util = editor.getShapeUtil(shape);\n          if (util.canScroll(shape)) {\n            var bounds = editor.getPageBoundsById(editor.editingId);\n            if (bounds !== null && bounds !== void 0 && bounds.containsPoint(editor.inputs.currentPagePoint)) {\n              return;\n            }\n          }\n        }\n      }\n      preventDefault(event);\n      var delta = normalizeWheel(event);\n      if (delta.x === 0 && delta.y === 0) return;\n      var info = {\n        type: \"wheel\",\n        name: \"wheel\",\n        delta: delta,\n        shiftKey: event.shiftKey,\n        altKey: event.altKey,\n        ctrlKey: event.metaKey || event.ctrlKey\n      };\n      editor.dispatch(info);\n    };\n    var initTouchDistance = 1;\n    var initZoom = 1;\n    var currentZoom = 1;\n    var currentTouchDistance = 0;\n    var initOrigin = new Vec2d();\n    var prevOrigin = new Vec2d();\n    var onPinchStart = function onPinchStart(gesture) {\n      var elm = ref.current;\n      pinchState = null;\n      var event = gesture.event,\n        origin = gesture.origin,\n        da = gesture.da;\n      if (event instanceof WheelEvent) return;\n      if (!(event.target === elm || elm !== null && elm !== void 0 && elm.contains(event.target))) return;\n      prevOrigin.x = origin[0];\n      prevOrigin.y = origin[1];\n      initOrigin.x = origin[0];\n      initOrigin.y = origin[1];\n      initTouchDistance = da[0];\n      initZoom = editor.zoomLevel;\n      editor.dispatch({\n        type: \"pinch\",\n        name: \"pinch_start\",\n        point: {\n          x: origin[0],\n          y: origin[1],\n          z: editor.zoomLevel\n        },\n        delta: {\n          x: 0,\n          y: 0\n        },\n        shiftKey: event.shiftKey,\n        altKey: event.altKey,\n        ctrlKey: event.metaKey || event.ctrlKey\n      });\n    };\n    var updatePinchState = throttle(function (type) {\n      if (pinchState === null) {\n        var touchDistance = Math.abs(currentTouchDistance - initTouchDistance);\n        var originDistance = Vec2d.Dist(initOrigin, prevOrigin);\n        if (type === \"gesture\" && touchDistance) {\n          pinchState = \"zooming\";\n        } else if (type === \"touch\" && touchDistance > 16) {\n          pinchState = \"zooming\";\n        } else if (originDistance > 16) {\n          pinchState = \"panning\";\n        }\n      }\n    }, 32);\n    var onPinch = function onPinch(gesture) {\n      var elm = ref.current;\n      var event = gesture.event,\n        origin = gesture.origin,\n        offset = gesture.offset,\n        da = gesture.da;\n      if (event instanceof WheelEvent) return;\n      if (!(event.target === elm || elm !== null && elm !== void 0 && elm.contains(event.target))) return;\n      var isGesture = \"touches\" in event ? false : true;\n      currentTouchDistance = da[0];\n      if (isGesture || currentTouchDistance > 64) {\n        currentZoom = offset[0];\n      }\n      var dx = origin[0] - prevOrigin.x;\n      var dy = origin[1] - prevOrigin.y;\n      prevOrigin.x = origin[0];\n      prevOrigin.y = origin[1];\n      updatePinchState(isGesture ? \"gesture\" : \"touch\");\n      switch (pinchState) {\n        case \"zooming\":\n          {\n            editor.dispatch({\n              type: \"pinch\",\n              name: \"pinch\",\n              point: {\n                x: origin[0],\n                y: origin[1],\n                z: currentZoom\n              },\n              delta: {\n                x: dx,\n                y: dy\n              },\n              shiftKey: event.shiftKey,\n              altKey: event.altKey,\n              ctrlKey: event.metaKey || event.ctrlKey\n            });\n            break;\n          }\n        case \"panning\":\n          {\n            editor.dispatch({\n              type: \"pinch\",\n              name: \"pinch\",\n              point: {\n                x: origin[0],\n                y: origin[1],\n                z: initZoom\n              },\n              delta: {\n                x: dx,\n                y: dy\n              },\n              shiftKey: event.shiftKey,\n              altKey: event.altKey,\n              ctrlKey: event.metaKey || event.ctrlKey\n            });\n            break;\n          }\n      }\n    };\n    var onPinchEnd = function onPinchEnd(gesture) {\n      var elm = ref.current;\n      var event = gesture.event,\n        origin = gesture.origin,\n        offset = gesture.offset;\n      if (event instanceof WheelEvent) return;\n      if (!(event.target === elm || elm !== null && elm !== void 0 && elm.contains(event.target))) return;\n      var scale = offset[0];\n      pinchState = null;\n      requestAnimationFrame(function () {\n        editor.dispatch({\n          type: \"pinch\",\n          name: \"pinch_end\",\n          point: {\n            x: origin[0],\n            y: origin[1],\n            z: scale\n          },\n          delta: {\n            x: origin[0],\n            y: origin[1]\n          },\n          shiftKey: event.shiftKey,\n          altKey: event.altKey,\n          ctrlKey: event.metaKey || event.ctrlKey\n        });\n      });\n    };\n    return {\n      onWheel: onWheel,\n      onPinchStart: onPinchStart,\n      onPinchEnd: onPinchEnd,\n      onPinch: onPinch\n    };\n  }, [editor, ref]);\n  useGesture(events, {\n    target: ref,\n    eventOptions: {\n      passive: false\n    },\n    pinch: {\n      from: function from() {\n        return [editor.zoomLevel, 0];\n      },\n      // Return the camera z to use when pinch starts\n      scaleBounds: function scaleBounds() {\n        return {\n          from: editor.zoomLevel,\n          max: 8,\n          min: 0.05\n        };\n      }\n    }\n  });\n}\nexport { useGestureEvents };","map":{"version":3,"names":["Vec2d","createUseGesture","pinchAction","wheelAction","throttle","React","preventDefault","normalizeWheel","useEditor","useGesture","lastWheelTime","isWheelEndEvent","time","useGestureEvents","ref","editor","events","useMemo","pinchState","onWheel","_ref","event","isFocused","Date","now","editingId","shape","getShapeById","util","getShapeUtil","canScroll","bounds","getPageBoundsById","containsPoint","inputs","currentPagePoint","delta","x","y","info","type","name","shiftKey","altKey","ctrlKey","metaKey","dispatch","initTouchDistance","initZoom","currentZoom","currentTouchDistance","initOrigin","prevOrigin","onPinchStart","gesture","elm","current","origin","da","WheelEvent","target","contains","zoomLevel","point","z","updatePinchState","touchDistance","Math","abs","originDistance","Dist","onPinch","offset","isGesture","dx","dy","onPinchEnd","scale","requestAnimationFrame","eventOptions","passive","pinch","from","scaleBounds","max","min"],"sources":["/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@tldraw/editor/src/lib/hooks/useGestureEvents.ts"],"sourcesContent":["import { Vec2d } from '@tldraw/primitives'\nimport type { AnyHandlerEventTypes, EventTypes, GestureKey, Handler } from '@use-gesture/core/types'\nimport { createUseGesture, pinchAction, wheelAction } from '@use-gesture/react'\nimport throttle from 'lodash.throttle'\nimport * as React from 'react'\nimport { TLWheelEventInfo } from '../editor/types/event-types'\nimport { preventDefault } from '../utils/dom'\nimport { normalizeWheel } from './shared'\nimport { useEditor } from './useEditor'\n\ntype check<T extends AnyHandlerEventTypes, Key extends GestureKey> = undefined extends T[Key]\n\t? EventTypes[Key]\n\t: T[Key]\ntype PinchHandler = Handler<'pinch', check<EventTypes, 'pinch'>>\n\nconst useGesture = createUseGesture([wheelAction, pinchAction])\n\n/**\n * GOTCHA\n *\n * UseGesture fires a wheel event 140ms after the gesture actually ends, with a momentum-adjusted\n * delta. This creates a messed up interaction where after you stop scrolling suddenly the dang page\n * jumps a tick. why do they do this? you are asking the wrong person. it seems intentional though.\n * anyway we want to ignore that last event, but there's no way to directly detect it so we need to\n * keep track of timestamps. Yes this is awful, I am sorry.\n */\nlet lastWheelTime = undefined as undefined | number\n\nconst isWheelEndEvent = (time: number) => {\n\tif (lastWheelTime === undefined) {\n\t\tlastWheelTime = time\n\t\treturn false\n\t}\n\n\tif (time - lastWheelTime > 120 && time - lastWheelTime < 160) {\n\t\tlastWheelTime = time\n\t\treturn true\n\t}\n\n\tlastWheelTime = time\n\treturn false\n}\n\nexport function useGestureEvents(ref: React.RefObject<HTMLDivElement>) {\n\tconst editor = useEditor()\n\n\tconst events = React.useMemo(() => {\n\t\tlet pinchState = null as null | 'zooming' | 'panning'\n\n\t\tconst onWheel: Handler<'wheel', WheelEvent> = ({ event }) => {\n\t\t\tif (!editor.isFocused) {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tpinchState = null\n\n\t\t\tif (isWheelEndEvent(Date.now())) {\n\t\t\t\t// ignore wheelEnd events\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// Awful tht we need to put this logic here, but basically\n\t\t\t// we don't want to handle the the wheel event (or call prevent\n\t\t\t// default on the evnet) if the user is wheeling over an a shape\n\t\t\t// that is scrollable which they're currently editing.\n\n\t\t\tif (editor.editingId) {\n\t\t\t\tconst shape = editor.getShapeById(editor.editingId)\n\t\t\t\tif (shape) {\n\t\t\t\t\tconst util = editor.getShapeUtil(shape)\n\t\t\t\t\tif (util.canScroll(shape)) {\n\t\t\t\t\t\tconst bounds = editor.getPageBoundsById(editor.editingId)\n\t\t\t\t\t\tif (bounds?.containsPoint(editor.inputs.currentPagePoint)) {\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpreventDefault(event)\n\t\t\tconst delta = normalizeWheel(event)\n\n\t\t\tif (delta.x === 0 && delta.y === 0) return\n\n\t\t\tconst info: TLWheelEventInfo = {\n\t\t\t\ttype: 'wheel',\n\t\t\t\tname: 'wheel',\n\t\t\t\tdelta,\n\t\t\t\tshiftKey: event.shiftKey,\n\t\t\t\taltKey: event.altKey,\n\t\t\t\tctrlKey: event.metaKey || event.ctrlKey,\n\t\t\t}\n\n\t\t\teditor.dispatch(info)\n\t\t}\n\n\t\tlet initTouchDistance = 1\n\t\tlet initZoom = 1\n\t\tlet currentZoom = 1\n\t\tlet currentTouchDistance = 0\n\t\tconst initOrigin = new Vec2d()\n\t\tconst prevOrigin = new Vec2d()\n\n\t\tconst onPinchStart: PinchHandler = (gesture) => {\n\t\t\tconst elm = ref.current\n\t\t\tpinchState = null\n\n\t\t\tconst { event, origin, da } = gesture\n\n\t\t\tif (event instanceof WheelEvent) return\n\t\t\tif (!(event.target === elm || elm?.contains(event.target as Node))) return\n\n\t\t\tprevOrigin.x = origin[0]\n\t\t\tprevOrigin.y = origin[1]\n\t\t\tinitOrigin.x = origin[0]\n\t\t\tinitOrigin.y = origin[1]\n\t\t\tinitTouchDistance = da[0]\n\t\t\tinitZoom = editor.zoomLevel\n\n\t\t\teditor.dispatch({\n\t\t\t\ttype: 'pinch',\n\t\t\t\tname: 'pinch_start',\n\t\t\t\tpoint: { x: origin[0], y: origin[1], z: editor.zoomLevel },\n\t\t\t\tdelta: { x: 0, y: 0 },\n\t\t\t\tshiftKey: event.shiftKey,\n\t\t\t\taltKey: event.altKey,\n\t\t\t\tctrlKey: event.metaKey || event.ctrlKey,\n\t\t\t})\n\t\t}\n\n\t\tconst updatePinchState = throttle((type: 'gesture' | 'touch') => {\n\t\t\tif (pinchState === null) {\n\t\t\t\tconst touchDistance = Math.abs(currentTouchDistance - initTouchDistance)\n\t\t\t\tconst originDistance = Vec2d.Dist(initOrigin, prevOrigin)\n\n\t\t\t\tif (type === 'gesture' && touchDistance) {\n\t\t\t\t\tpinchState = 'zooming'\n\t\t\t\t} else if (type === 'touch' && touchDistance > 16) {\n\t\t\t\t\tpinchState = 'zooming'\n\t\t\t\t} else if (originDistance > 16) {\n\t\t\t\t\tpinchState = 'panning'\n\t\t\t\t}\n\t\t\t}\n\t\t}, 32)\n\n\t\tconst onPinch: PinchHandler = (gesture) => {\n\t\t\tconst elm = ref.current\n\t\t\tconst { event, origin, offset, da } = gesture\n\n\t\t\tif (event instanceof WheelEvent) return\n\t\t\tif (!(event.target === elm || elm?.contains(event.target as Node))) return\n\n\t\t\t// Determine if the event is a gesture or a touch event.\n\t\t\t// This affects how we calculate the touch distance.\n\t\t\t// Because: When trackpad zooming on safari, a different unit is used.\n\t\t\t// By the way, Safari doesn't have TouchEvent...\n\t\t\t// ... so we have to manually check if the event is a TouchEvent.\n\t\t\tconst isGesture = 'touches' in event ? false : true\n\n\t\t\t// The distance between the two touch points\n\t\t\tcurrentTouchDistance = da[0]\n\n\t\t\t// Only update the zoom if the pointers are far enough apart;\n\t\t\t// a very small touchDistance means that the user has probably\n\t\t\t// pinched out and their fingers are touching; this produces\n\t\t\t// very unstable zooming behavior.\n\t\t\tif (isGesture || currentTouchDistance > 64) {\n\t\t\t\tcurrentZoom = offset[0]\n\t\t\t}\n\n\t\t\tconst dx = origin[0] - prevOrigin.x\n\t\t\tconst dy = origin[1] - prevOrigin.y\n\n\t\t\tprevOrigin.x = origin[0]\n\t\t\tprevOrigin.y = origin[1]\n\n\t\t\tupdatePinchState(isGesture ? 'gesture' : 'touch')\n\n\t\t\tswitch (pinchState) {\n\t\t\t\tcase 'zooming': {\n\t\t\t\t\teditor.dispatch({\n\t\t\t\t\t\ttype: 'pinch',\n\t\t\t\t\t\tname: 'pinch',\n\t\t\t\t\t\tpoint: { x: origin[0], y: origin[1], z: currentZoom },\n\t\t\t\t\t\tdelta: { x: dx, y: dy },\n\t\t\t\t\t\tshiftKey: event.shiftKey,\n\t\t\t\t\t\taltKey: event.altKey,\n\t\t\t\t\t\tctrlKey: event.metaKey || event.ctrlKey,\n\t\t\t\t\t})\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tcase 'panning': {\n\t\t\t\t\teditor.dispatch({\n\t\t\t\t\t\ttype: 'pinch',\n\t\t\t\t\t\tname: 'pinch',\n\t\t\t\t\t\tpoint: { x: origin[0], y: origin[1], z: initZoom },\n\t\t\t\t\t\tdelta: { x: dx, y: dy },\n\t\t\t\t\t\tshiftKey: event.shiftKey,\n\t\t\t\t\t\taltKey: event.altKey,\n\t\t\t\t\t\tctrlKey: event.metaKey || event.ctrlKey,\n\t\t\t\t\t})\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst onPinchEnd: PinchHandler = (gesture) => {\n\t\t\tconst elm = ref.current\n\t\t\tconst { event, origin, offset } = gesture\n\n\t\t\tif (event instanceof WheelEvent) return\n\t\t\tif (!(event.target === elm || elm?.contains(event.target as Node))) return\n\n\t\t\tconst scale = offset[0]\n\n\t\t\tpinchState = null\n\n\t\t\trequestAnimationFrame(() => {\n\t\t\t\teditor.dispatch({\n\t\t\t\t\ttype: 'pinch',\n\t\t\t\t\tname: 'pinch_end',\n\t\t\t\t\tpoint: { x: origin[0], y: origin[1], z: scale },\n\t\t\t\t\tdelta: { x: origin[0], y: origin[1] },\n\t\t\t\t\tshiftKey: event.shiftKey,\n\t\t\t\t\taltKey: event.altKey,\n\t\t\t\t\tctrlKey: event.metaKey || event.ctrlKey,\n\t\t\t\t})\n\t\t\t})\n\t\t}\n\n\t\treturn {\n\t\t\tonWheel,\n\t\t\tonPinchStart,\n\t\t\tonPinchEnd,\n\t\t\tonPinch,\n\t\t}\n\t}, [editor, ref])\n\n\tuseGesture(events, {\n\t\ttarget: ref,\n\t\teventOptions: { passive: false },\n\t\tpinch: {\n\t\t\tfrom: () => [editor.zoomLevel, 0], // Return the camera z to use when pinch starts\n\t\t\tscaleBounds: () => {\n\t\t\t\treturn { from: editor.zoomLevel, max: 8, min: 0.05 }\n\t\t\t},\n\t\t},\n\t})\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}