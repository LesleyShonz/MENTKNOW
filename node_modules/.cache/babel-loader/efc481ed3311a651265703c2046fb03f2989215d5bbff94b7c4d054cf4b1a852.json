{"ast":null,"code":"import _objectSpread from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _classCallCheck from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _inherits from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _defineProperty from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport { Box2d, Matrix2d, pointInPolygon, polygonsIntersect } from \"@tldraw/primitives\";\nimport { FrameShapeUtil } from \"../../../shapes/frame/FrameShapeUtil.mjs\";\nimport { GroupShapeUtil } from \"../../../shapes/group/GroupShapeUtil.mjs\";\nimport { StateNode } from \"../../StateNode.mjs\";\nvar Brushing = /*#__PURE__*/function (_StateNode) {\n  _inherits(Brushing, _StateNode);\n  var _super = _createSuper(Brushing);\n  function Brushing() {\n    var _this;\n    _classCallCheck(this, Brushing);\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    _this = _super.call.apply(_super, [this].concat(args));\n    _defineProperty(_assertThisInitialized(_this), \"info\", {});\n    _defineProperty(_assertThisInitialized(_this), \"brush\", new Box2d());\n    _defineProperty(_assertThisInitialized(_this), \"initialSelectedIds\", []);\n    _defineProperty(_assertThisInitialized(_this), \"excludedShapeIds\", /* @__PURE__ */new Set());\n    // The shape that the brush started on\n    _defineProperty(_assertThisInitialized(_this), \"initialStartShape\", null);\n    _defineProperty(_assertThisInitialized(_this), \"onEnter\", function (info) {\n      var _this$editor$inputs = _this.editor.inputs,\n        altKey = _this$editor$inputs.altKey,\n        currentPagePoint = _this$editor$inputs.currentPagePoint;\n      if (altKey) {\n        _this.parent.transition(\"scribble_brushing\", info);\n        return;\n      }\n      _this.excludedShapeIds = new Set(_this.editor.shapesArray.filter(function (shape) {\n        return _this.editor.isShapeOfType(shape, GroupShapeUtil) || _this.editor.isShapeOrAncestorLocked(shape);\n      }).map(function (shape) {\n        return shape.id;\n      }));\n      _this.info = info;\n      _this.initialSelectedIds = _this.editor.selectedIds.slice();\n      _this.initialStartShape = _this.editor.getShapesAtPoint(currentPagePoint)[0];\n      _this.onPointerMove();\n    });\n    _defineProperty(_assertThisInitialized(_this), \"onExit\", function () {\n      _this.initialSelectedIds = [];\n      _this.editor.setBrush(null);\n    });\n    _defineProperty(_assertThisInitialized(_this), \"onPointerMove\", function () {\n      _this.hitTestShapes();\n    });\n    _defineProperty(_assertThisInitialized(_this), \"onPointerUp\", function () {\n      _this.complete();\n    });\n    _defineProperty(_assertThisInitialized(_this), \"onComplete\", function () {\n      _this.complete();\n    });\n    _defineProperty(_assertThisInitialized(_this), \"onCancel\", function (info) {\n      _this.editor.setSelectedIds(_this.initialSelectedIds, true);\n      _this.parent.transition(\"idle\", info);\n    });\n    _defineProperty(_assertThisInitialized(_this), \"onKeyDown\", function (info) {\n      if (_this.editor.inputs.altKey) {\n        _this.parent.transition(\"scribble_brushing\", info);\n      } else {\n        _this.hitTestShapes();\n      }\n    });\n    _defineProperty(_assertThisInitialized(_this), \"onKeyUp\", function () {\n      _this.hitTestShapes();\n    });\n    _defineProperty(_assertThisInitialized(_this), \"onInterrupt\", function () {\n      _this.editor.setBrush(null);\n    });\n    return _this;\n  }\n  _createClass(Brushing, [{\n    key: \"complete\",\n    value: function complete() {\n      this.parent.transition(\"idle\", {});\n    }\n  }, {\n    key: \"hitTestShapes\",\n    value: function hitTestShapes() {\n      var _this$editor = this.editor,\n        currentPageId = _this$editor.currentPageId,\n        shapesArray = _this$editor.shapesArray,\n        _this$editor$inputs2 = _this$editor.inputs,\n        originPagePoint = _this$editor$inputs2.originPagePoint,\n        currentPagePoint = _this$editor$inputs2.currentPagePoint,\n        shiftKey = _this$editor$inputs2.shiftKey,\n        ctrlKey = _this$editor$inputs2.ctrlKey;\n      this.brush.setTo(Box2d.FromPoints([originPagePoint, currentPagePoint]));\n      var results = new Set(shiftKey ? this.initialSelectedIds : []);\n      var A, B, shape, util, pageBounds, pageTransform, localCorners;\n      var corners = this.brush.corners;\n      var excludedShapeIds = this.excludedShapeIds;\n      testAllShapes: for (var i = 0, n = shapesArray.length; i < n; i++) {\n        shape = shapesArray[i];\n        if (excludedShapeIds.has(shape.id)) continue testAllShapes;\n        if (results.has(shape.id)) continue testAllShapes;\n        pageBounds = this.editor.getPageBounds(shape);\n        if (!pageBounds) continue testAllShapes;\n        if (this.brush.contains(pageBounds)) {\n          this.handleHit(shape, currentPagePoint, currentPageId, results, corners);\n          continue testAllShapes;\n        }\n        if (ctrlKey || this.editor.isShapeOfType(shape, FrameShapeUtil)) {\n          continue testAllShapes;\n        }\n        if (this.brush.collides(pageBounds)) {\n          util = this.editor.getShapeUtil(shape);\n          pageTransform = this.editor.getPageTransform(shape);\n          if (!pageTransform) {\n            continue testAllShapes;\n          }\n          localCorners = Matrix2d.applyToPoints(Matrix2d.Inverse(pageTransform), corners);\n          hitTestBrushEdges: for (var i2 = 0; i2 < localCorners.length; i2++) {\n            A = localCorners[i2];\n            B = localCorners[(i2 + 1) % localCorners.length];\n            if (util.hitTestLineSegment(shape, A, B)) {\n              this.handleHit(shape, currentPagePoint, currentPageId, results, corners);\n              break hitTestBrushEdges;\n            }\n          }\n        }\n      }\n      this.editor.setBrush(_objectSpread({}, this.brush.toJson()));\n      this.editor.setSelectedIds(Array.from(results), true);\n    }\n  }, {\n    key: \"handleHit\",\n    value: function handleHit(shape, currentPagePoint, currentPageId, results, corners) {\n      if (shape.parentId === currentPageId) {\n        results.add(shape.id);\n        return;\n      }\n      var selectedShape = this.editor.getOutermostSelectableShape(shape);\n      var pageMask = this.editor.getPageMaskById(selectedShape.id);\n      if (pageMask && polygonsIntersect(pageMask, corners) !== null && !pointInPolygon(currentPagePoint, pageMask)) {\n        return;\n      }\n      results.add(selectedShape.id);\n    }\n  }]);\n  return Brushing;\n}(StateNode);\n_defineProperty(Brushing, \"id\", \"brushing\");\nexport { Brushing };","map":{"version":3,"names":["Box2d","Matrix2d","pointInPolygon","polygonsIntersect","FrameShapeUtil","GroupShapeUtil","StateNode","Brushing","_StateNode","_inherits","_super","_createSuper","_this","_classCallCheck","_len","arguments","length","args","Array","_key","call","apply","concat","_defineProperty","_assertThisInitialized","Set","info","_this$editor$inputs","editor","inputs","altKey","currentPagePoint","parent","transition","excludedShapeIds","shapesArray","filter","shape","isShapeOfType","isShapeOrAncestorLocked","map","id","initialSelectedIds","selectedIds","slice","initialStartShape","getShapesAtPoint","onPointerMove","setBrush","hitTestShapes","complete","setSelectedIds","_createClass","key","value","_this$editor","currentPageId","_this$editor$inputs2","originPagePoint","shiftKey","ctrlKey","brush","setTo","FromPoints","results","A","B","util","pageBounds","pageTransform","localCorners","corners","testAllShapes","i","n","has","getPageBounds","contains","handleHit","collides","getShapeUtil","getPageTransform","applyToPoints","Inverse","hitTestBrushEdges","i2","hitTestLineSegment","_objectSpread","toJson","from","parentId","add","selectedShape","getOutermostSelectableShape","pageMask","getPageMaskById"],"sources":["/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@tldraw/editor/src/lib/editor/tools/SelectTool/children/Brushing.ts"],"sourcesContent":["import {\n\tBox2d,\n\tMatrix2d,\n\tpointInPolygon,\n\tpolygonsIntersect,\n\tVec2d,\n\tVecLike,\n} from '@tldraw/primitives'\nimport { TLPageId, TLShape, TLShapeId } from '@tldraw/tlschema'\nimport { FrameShapeUtil } from '../../../shapes/frame/FrameShapeUtil'\nimport { GroupShapeUtil } from '../../../shapes/group/GroupShapeUtil'\nimport { ShapeUtil } from '../../../shapes/ShapeUtil'\nimport {\n\tTLCancelEvent,\n\tTLEventHandlers,\n\tTLInterruptEvent,\n\tTLKeyboardEvent,\n\tTLPointerEventInfo,\n} from '../../../types/event-types'\nimport { StateNode } from '../../StateNode'\n\nexport class Brushing extends StateNode {\n\tstatic override id = 'brushing'\n\n\tinfo = {} as TLPointerEventInfo & { target: 'canvas' }\n\n\tbrush = new Box2d()\n\tinitialSelectedIds: TLShapeId[] = []\n\texcludedShapeIds = new Set<TLShapeId>()\n\n\t// The shape that the brush started on\n\tinitialStartShape: TLShape | null = null\n\n\tonEnter = (info: TLPointerEventInfo & { target: 'canvas' }) => {\n\t\tconst { altKey, currentPagePoint } = this.editor.inputs\n\n\t\tif (altKey) {\n\t\t\tthis.parent.transition('scribble_brushing', info)\n\t\t\treturn\n\t\t}\n\n\t\tthis.excludedShapeIds = new Set(\n\t\t\tthis.editor.shapesArray\n\t\t\t\t.filter(\n\t\t\t\t\t(shape) =>\n\t\t\t\t\t\tthis.editor.isShapeOfType(shape, GroupShapeUtil) ||\n\t\t\t\t\t\tthis.editor.isShapeOrAncestorLocked(shape)\n\t\t\t\t)\n\t\t\t\t.map((shape) => shape.id)\n\t\t)\n\n\t\tthis.info = info\n\t\tthis.initialSelectedIds = this.editor.selectedIds.slice()\n\t\tthis.initialStartShape = this.editor.getShapesAtPoint(currentPagePoint)[0]\n\t\tthis.onPointerMove()\n\t}\n\n\tonExit = () => {\n\t\tthis.initialSelectedIds = []\n\t\tthis.editor.setBrush(null)\n\t}\n\n\tonPointerMove = () => {\n\t\tthis.hitTestShapes()\n\t}\n\n\tonPointerUp: TLEventHandlers['onPointerUp'] = () => {\n\t\tthis.complete()\n\t}\n\n\tonComplete: TLEventHandlers['onComplete'] = () => {\n\t\tthis.complete()\n\t}\n\n\tonCancel?: TLCancelEvent | undefined = (info) => {\n\t\tthis.editor.setSelectedIds(this.initialSelectedIds, true)\n\t\tthis.parent.transition('idle', info)\n\t}\n\n\tonKeyDown: TLEventHandlers['onKeyDown'] = (info) => {\n\t\tif (this.editor.inputs.altKey) {\n\t\t\tthis.parent.transition('scribble_brushing', info)\n\t\t} else {\n\t\t\tthis.hitTestShapes()\n\t\t}\n\t}\n\n\tonKeyUp?: TLKeyboardEvent | undefined = () => {\n\t\tthis.hitTestShapes()\n\t}\n\n\tprivate complete() {\n\t\tthis.parent.transition('idle', {})\n\t}\n\n\tprivate hitTestShapes() {\n\t\tconst {\n\t\t\tcurrentPageId,\n\t\t\tshapesArray,\n\t\t\tinputs: { originPagePoint, currentPagePoint, shiftKey, ctrlKey },\n\t\t} = this.editor\n\n\t\t// Set the brush to contain the current and origin points\n\t\tthis.brush.setTo(Box2d.FromPoints([originPagePoint, currentPagePoint]))\n\n\t\t// We'll be collecting shape ids\n\t\tconst results = new Set(shiftKey ? this.initialSelectedIds : [])\n\n\t\tlet A: VecLike,\n\t\t\tB: VecLike,\n\t\t\tshape: TLShape,\n\t\t\tutil: ShapeUtil<TLShape>,\n\t\t\tpageBounds: Box2d | undefined,\n\t\t\tpageTransform: Matrix2d | undefined,\n\t\t\tlocalCorners: VecLike[]\n\n\t\t// We'll be testing the corners of the brush against the shapes\n\t\tconst { corners } = this.brush\n\n\t\tconst { excludedShapeIds } = this\n\n\t\ttestAllShapes: for (let i = 0, n = shapesArray.length; i < n; i++) {\n\t\t\tshape = shapesArray[i]\n\t\t\tif (excludedShapeIds.has(shape.id)) continue testAllShapes\n\t\t\tif (results.has(shape.id)) continue testAllShapes\n\n\t\t\tpageBounds = this.editor.getPageBounds(shape)\n\t\t\tif (!pageBounds) continue testAllShapes\n\n\t\t\t// If the brush fully wraps a shape, it's almost certainly a hit\n\t\t\tif (this.brush.contains(pageBounds)) {\n\t\t\t\tthis.handleHit(shape, currentPagePoint, currentPageId, results, corners)\n\t\t\t\tcontinue testAllShapes\n\t\t\t}\n\n\t\t\t// Should we even test for a single segment intersections? Only if\n\t\t\t// we're not holding the ctrl key for alternate selection mode\n\t\t\t// (only wraps count!), or if the shape is a frame.\n\t\t\tif (ctrlKey || this.editor.isShapeOfType(shape, FrameShapeUtil)) {\n\t\t\t\tcontinue testAllShapes\n\t\t\t}\n\n\t\t\t// If the brush collides the page bounds, then do hit tests against\n\t\t\t// each of the brush's four sides.\n\t\t\tif (this.brush.collides(pageBounds)) {\n\t\t\t\t// Shapes expect to hit test line segments in their own coordinate system,\n\t\t\t\t// so we first need to get the brush corners in the shape's local space.\n\t\t\t\tutil = this.editor.getShapeUtil(shape)\n\n\t\t\t\tpageTransform = this.editor.getPageTransform(shape)\n\n\t\t\t\tif (!pageTransform) {\n\t\t\t\t\tcontinue testAllShapes\n\t\t\t\t}\n\n\t\t\t\t// Check whether any of the the brush edges intersect the shape\n\t\t\t\tlocalCorners = Matrix2d.applyToPoints(Matrix2d.Inverse(pageTransform), corners)\n\n\t\t\t\thitTestBrushEdges: for (let i = 0; i < localCorners.length; i++) {\n\t\t\t\t\tA = localCorners[i]\n\t\t\t\t\tB = localCorners[(i + 1) % localCorners.length]\n\n\t\t\t\t\tif (util.hitTestLineSegment(shape, A, B)) {\n\t\t\t\t\t\tthis.handleHit(shape, currentPagePoint, currentPageId, results, corners)\n\t\t\t\t\t\tbreak hitTestBrushEdges\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.editor.setBrush({ ...this.brush.toJson() })\n\t\tthis.editor.setSelectedIds(Array.from(results), true)\n\t}\n\n\tonInterrupt: TLInterruptEvent = () => {\n\t\tthis.editor.setBrush(null)\n\t}\n\n\tprivate handleHit(\n\t\tshape: TLShape,\n\t\tcurrentPagePoint: Vec2d,\n\t\tcurrentPageId: TLPageId,\n\t\tresults: Set<TLShapeId>,\n\t\tcorners: Vec2d[]\n\t) {\n\t\tif (shape.parentId === currentPageId) {\n\t\t\tresults.add(shape.id)\n\t\t\treturn\n\t\t}\n\n\t\t// Find the outermost selectable shape, check to see if it has a\n\t\t// page mask; and if so, check to see if the brush intersects it\n\t\tconst selectedShape = this.editor.getOutermostSelectableShape(shape)\n\t\tconst pageMask = this.editor.getPageMaskById(selectedShape.id)\n\n\t\tif (\n\t\t\tpageMask &&\n\t\t\tpolygonsIntersect(pageMask, corners) !== null &&\n\t\t\t!pointInPolygon(currentPagePoint, pageMask)\n\t\t) {\n\t\t\treturn\n\t\t}\n\n\t\tresults.add(selectedShape.id)\n\t}\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}