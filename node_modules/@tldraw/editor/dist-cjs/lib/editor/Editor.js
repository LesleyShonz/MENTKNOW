"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp(target, key, result);
  return result;
};
var Editor_exports = {};
__export(Editor_exports, {
  Editor: () => Editor
});
module.exports = __toCommonJS(Editor_exports);
var import_indices = require("@tldraw/indices");
var import_primitives = require("@tldraw/primitives");
var import_tlschema = require("@tldraw/tlschema");
var import_utils = require("@tldraw/utils");
var import_eventemitter3 = require("eventemitter3");
var import_nanoid = require("nanoid");
var import_signia = require("signia");
var import_createTLUser = require("../config/createTLUser");
var import_defaultShapes = require("../config/defaultShapes");
var import_constants = require("../constants");
var import_usePattern = require("../hooks/usePattern");
var import_SharedStylesMap = require("../utils/SharedStylesMap");
var import_WeakMapCache = require("../utils/WeakMapCache");
var import_assets = require("../utils/assets");
var import_data = require("../utils/data");
var import_rotation = require("../utils/rotation");
var import_arrowBindingsIndex = require("./derivations/arrowBindingsIndex");
var import_parentsToChildrenWithIndexes = require("./derivations/parentsToChildrenWithIndexes");
var import_shapeIdsInCurrentPage = require("./derivations/shapeIdsInCurrentPage");
var import_ActiveAreaManager = require("./managers/ActiveAreaManager");
var import_ClickManager = require("./managers/ClickManager");
var import_DprManager = require("./managers/DprManager");
var import_ExternalContentManager = require("./managers/ExternalContentManager");
var import_HistoryManager = require("./managers/HistoryManager");
var import_SnapManager = require("./managers/SnapManager");
var import_TextManager = require("./managers/TextManager");
var import_TickManager = require("./managers/TickManager");
var import_UserPreferencesManager = require("./managers/UserPreferencesManager");
var import_ShapeUtil = require("./shapes/ShapeUtil");
var import_ArrowShapeUtil = require("./shapes/arrow/ArrowShapeUtil");
var import_curved_arrow = require("./shapes/arrow/arrow/curved-arrow");
var import_shared = require("./shapes/arrow/arrow/shared");
var import_straight_arrow = require("./shapes/arrow/arrow/straight-arrow");
var import_FrameShapeUtil = require("./shapes/frame/FrameShapeUtil");
var import_GroupShapeUtil = require("./shapes/group/GroupShapeUtil");
var import_TextShapeUtil = require("./shapes/text/TextShapeUtil");
var import_RootState = require("./tools/RootState");
class Editor extends import_eventemitter3.EventEmitter {
  constructor({ store, user, shapes, tools, getContainer }) {
    super();
    this.store = store;
    this.user = new import_UserPreferencesManager.UserPreferencesManager(user ?? (0, import_createTLUser.createTLUser)());
    this.getContainer = getContainer ?? (() => document.body);
    this.textMeasure = new import_TextManager.TextManager(this);
    this.root = new import_RootState.RootState(this);
    const allShapes = (0, import_defaultShapes.checkShapesAndAddCore)(shapes);
    const shapeTypesInSchema = new Set(
      Object.keys(store.schema.types.shape.migrations.subTypeMigrations)
    );
    for (const shape of allShapes) {
      if (!shapeTypesInSchema.has(shape.type)) {
        throw Error(
          `Editor and store have different shapes: "${shape.type}" was passed into the editor but not the schema`
        );
      }
      shapeTypesInSchema.delete(shape.type);
    }
    if (shapeTypesInSchema.size > 0) {
      throw Error(
        `Editor and store have different shapes: "${[...shapeTypesInSchema][0]}" is present in the store schema but not provided to the editor`
      );
    }
    const shapeUtils = {};
    const allStylesById = /* @__PURE__ */ new Map();
    for (const { util: Util, props } of allShapes) {
      const propKeysByStyle = (0, import_tlschema.getShapePropKeysByStyle)(props ?? {});
      shapeUtils[Util.type] = new Util(this, Util.type, propKeysByStyle);
      for (const style of propKeysByStyle.keys()) {
        if (!allStylesById.has(style.id)) {
          allStylesById.set(style.id, style);
        } else if (allStylesById.get(style.id) !== style) {
          throw Error(
            `Multiple style props with id "${style.id}" in use. Style prop IDs must be unique.`
          );
        }
      }
    }
    this.shapeUtils = shapeUtils;
    for (const { tool: Tool } of allShapes) {
      if (Tool) {
        if ((0, import_utils.hasOwnProperty)(this.root.children, Tool.id)) {
          throw Error(`Can't override tool with id "${Tool.id}"`);
        }
        this.root.children[Tool.id] = new Tool(this);
      }
    }
    for (const Tool of tools) {
      if ((0, import_utils.hasOwnProperty)(this.root.children, Tool.id)) {
        throw Error(`Can't override tool with id "${Tool.id}"`);
      }
      this.root.children[Tool.id] = new Tool(this);
    }
    if (typeof window !== "undefined" && "navigator" in window) {
      this.isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
      this.isIos = !!navigator.userAgent.match(/iPad/i) || !!navigator.userAgent.match(/iPhone/i);
      this.isChromeForIos = /crios.*safari/i.test(navigator.userAgent);
    } else {
      this.isSafari = false;
      this.isIos = false;
      this.isChromeForIos = false;
    }
    this.store.onBeforeDelete = (record) => {
      if (record.typeName === "shape") {
        this._shapeWillBeDeleted(record);
      } else if (record.typeName === "page") {
        this._pageWillBeDeleted(record);
      }
    };
    this.store.onAfterChange = (prev, next) => {
      this._updateDepth++;
      if (this._updateDepth > 1e3) {
        console.error("[onAfterChange] Maximum update depth exceeded, bailing out.");
      }
      if (prev.typeName === "shape" && next.typeName === "shape") {
        this._shapeDidChange(prev, next);
      } else if (prev.typeName === "instance_page_state" && next.typeName === "instance_page_state") {
        this._pageStateDidChange(prev, next);
      }
      this._updateDepth--;
    };
    this.store.onAfterCreate = (record) => {
      if (record.typeName === "shape" && this.isShapeOfType(record, import_ArrowShapeUtil.ArrowShapeUtil)) {
        this._arrowDidUpdate(record);
      }
      if (record.typeName === "page") {
        const cameraId = import_tlschema.CameraRecordType.createId(record.id);
        const pageStateId = import_tlschema.InstancePageStateRecordType.createId(record.id);
        if (!this.store.has(cameraId)) {
          this.store.put([import_tlschema.CameraRecordType.create({ id: cameraId })]);
        }
        if (!this.store.has(pageStateId)) {
          this.store.put([
            import_tlschema.InstancePageStateRecordType.create({ id: pageStateId, pageId: record.id })
          ]);
        }
      }
    };
    this._currentPageShapeIds = (0, import_shapeIdsInCurrentPage.deriveShapeIdsInCurrentPage)(this.store, () => this.currentPageId);
    this._parentIdsToChildIds = (0, import_parentsToChildrenWithIndexes.parentsToChildrenWithIndexes)(this.store);
    this.disposables.add(
      this.store.listen((changes) => {
        this.emit("change", changes);
      })
    );
    const container = this.getContainer();
    const focusin = () => {
      this._isFocused.set(true);
    };
    const focusout = () => {
      this._isFocused.set(false);
    };
    container.addEventListener("focusin", focusin);
    container.addEventListener("focus", focusin);
    container.addEventListener("focusout", focusout);
    container.addEventListener("blur", focusout);
    this.disposables.add(() => {
      container.removeEventListener("focusin", focusin);
      container.removeEventListener("focus", focusin);
      container.removeEventListener("focusout", focusout);
      container.removeEventListener("blur", focusout);
    });
    this.store.ensureStoreIsUsable();
    this.setInstancePageState(
      {
        editingId: null,
        hoveredId: null,
        erasingIds: []
      },
      true
    );
    this.root.enter(void 0, "initial");
    if (this.instanceState.followingUserId) {
      this.stopFollowingUser();
    }
    this.updateRenderingBounds();
    requestAnimationFrame(() => {
      this._tickManager.start();
    });
  }
  /**
   * The editor's store
   *
   * @public
   */
  store;
  /**
   * The root state of the statechart.
   *
   * @public
   */
  root;
  /**
   * A set of functions to call when the app is disposed.
   *
   * @public
   */
  disposables = /* @__PURE__ */ new Set();
  /** @internal */
  _dprManager = new import_DprManager.DprManager(this);
  /** @internal */
  _activeAreaManager = new import_ActiveAreaManager.ActiveAreaManager(this);
  /** @internal */
  _tickManager = new import_TickManager.TickManager(this);
  /** @internal */
  _updateDepth = 0;
  /** @public */
  externalContentManager = new import_ExternalContentManager.ExternalContentManager(this);
  /**
   * A manager for the app's snapping feature.
   *
   * @public
   */
  snaps = new import_SnapManager.SnapManager(this);
  /**
   * A manager for the user and their preferences.
   *
   * @public
   */
  user;
  /**
   * Whether the editor is running in Safari.
   *
   * @public
   */
  isSafari;
  /**
   * Whether the editor is running on iOS.
   *
   * @public
   */
  isIos;
  /**
   * Whether the editor is running on iOS.
   *
   * @public
   */
  isChromeForIos;
  /**
   * The current HTML element containing the editor.
   *
   * @example
   * ```ts
   * const container = editor.getContainer()
   * ```
   *
   * @public
   */
  getContainer;
  get _pageTransformCache() {
    return this.store.createComputedCache("pageTransformCache", (shape) => {
      if ((0, import_tlschema.isPageId)(shape.parentId)) {
        return this.getTransform(shape);
      }
      const parent = this._pageTransformCache.get(shape.parentId) ?? import_primitives.Matrix2d.Identity();
      return import_primitives.Matrix2d.Compose(parent, this.getTransform(shape));
    });
  }
  get _pageBoundsCache() {
    return this.store.createComputedCache("pageBoundsCache", (shape) => {
      const pageTransform = this._pageTransformCache.get(shape.id);
      if (!pageTransform)
        return new import_primitives.Box2d();
      const result = import_primitives.Box2d.FromPoints(
        import_primitives.Matrix2d.applyToPoints(pageTransform, this.getShapeUtil(shape).outline(shape))
      );
      return result;
    });
  }
  /**
   * Dispose the editor.
   *
   * @public
   */
  dispose() {
    this.disposables.forEach((dispose) => dispose());
    this.disposables.clear();
  }
  /**
   * A manager for the app's history.
   *
   * @readonly
   */
  history = new import_HistoryManager.HistoryManager(
    this,
    () => this._complete(),
    (error) => {
      this.annotateError(error, { origin: "history.batch", willCrashApp: true });
      this.crash(error);
    }
  );
  /**
   * Undo to the last mark.
   *
   * @example
   * ```ts
   * editor.undo()
   * ```
   *
   * @public
   */
  undo() {
    return this.history.undo();
  }
  get canUndo() {
    return this.history.numUndos > 0;
  }
  /**
   * Redo to the next mark.
   *
   * @example
   * ```ts
   * editor.redo()
   * ```
   *
   * @public
   */
  redo() {
    this.history.redo();
    return this;
  }
  get canRedo() {
    return this.history.numRedos > 0;
  }
  /**
   * Create a new "mark", or stopping point, in the undo redo history. Creating a mark will clear
   * any redos.
   *
   * @example
   * ```ts
   * editor.mark()
   * editor.mark('flip shapes')
   * ```
   *
   * @param reason - The reason for the mark.
   * @param onUndo - Whether to stop at the mark when undoing.
   * @param onRedo - Whether to stop at the mark when redoing.
   *
   * @public
   */
  mark(reason, onUndo, onRedo) {
    return this.history.mark(reason, onUndo, onRedo);
  }
  /**
   * Clear all marks in the undo stack back to the next mark.
   *
   * @example
   * ```ts
   * editor.bail()
   * ```
   *
   * @public
   */
  bail() {
    this.history.bail();
    return this;
  }
  /**
   * Clear all marks in the undo stack back to the mark with the provided mark id.
   *
   * @example
   * ```ts
   * editor.bailToMark('creating')
   * ```
   *
   * @public
   */
  bailToMark(id) {
    this.history.bailToMark(id);
    return this;
  }
  /**
   * Run a function in a batch, which will be undone/redone as a single action.
   *
   * @example
   * ```ts
   * editor.batch(() => {
   * 	editor.selectAll()
   * 	editor.deleteShapes()
   * 	editor.createShapes(myShapes)
   * 	editor.selectNone()
   * })
   *
   * editor.undo() // will undo all of the above
   * ```
   *
   * @public
   */
  batch(fn) {
    this.history.batch(fn);
    return this;
  }
  /**
   * A map of shape utility classes (TLShapeUtils) by shape type.
   *
   * @public
   */
  shapeUtils;
  getShapeUtil(shapeUtilConstructor) {
    const shapeUtil = (0, import_utils.getOwnProperty)(this.shapeUtils, shapeUtilConstructor.type);
    (0, import_utils.assert)(shapeUtil, `No shape util found for type "${shapeUtilConstructor.type}"`);
    if ("prototype" in shapeUtilConstructor && shapeUtilConstructor.prototype instanceof import_ShapeUtil.ShapeUtil) {
      (0, import_utils.assert)(
        shapeUtil instanceof shapeUtilConstructor,
        `Shape util found for type "${shapeUtilConstructor.type}" is not an instance of the provided constructor`
      );
    }
    return shapeUtil;
  }
  /* ---------------------- Props --------------------- */
  /**
   * Get all the current styles among the users selected shapes
   *
   * @internal
   */
  _extractSharedStyles(shape, sharedStyleMap) {
    if (this.isShapeOfType(shape, import_GroupShapeUtil.GroupShapeUtil)) {
      const childIds = this._parentIdsToChildIds.value[shape.id];
      if (!childIds)
        return;
      for (let i = 0, n = childIds.length; i < n; i++) {
        this._extractSharedStyles(this.getShapeById(childIds[i][0]), sharedStyleMap);
      }
    } else {
      const util = this.getShapeUtil(shape);
      for (const [style, value] of util.iterateStyles(shape)) {
        sharedStyleMap.applyValue(style, value);
      }
    }
  }
  /**
   * A derived map containing all current styles among the user's selected shapes.
   *
   * @internal
   */
  _selectionSharedStyles = (0, import_signia.computed)(
    "_selectionSharedStyles",
    () => {
      const { selectedShapes } = this;
      const sharedStyles = new import_SharedStylesMap.SharedStyleMap();
      for (const selectedShape of selectedShapes) {
        this._extractSharedStyles(selectedShape, sharedStyles);
      }
      return sharedStyles;
    }
  );
  get _stylesForNextShape() {
    return this.instanceState.stylesForNextShape;
  }
  /** @internal */
  getStyleForNextShape(style) {
    const value = this._stylesForNextShape[style.id];
    return value === void 0 ? style.defaultValue : value;
  }
  get sharedStyles() {
    if (this.isIn("select") && this.selectedIds.length > 0) {
      return this._selectionSharedStyles.value;
    }
    const currentTool = this.root.current.value;
    const styles = new import_SharedStylesMap.SharedStyleMap();
    if (currentTool.shapeType) {
      for (const style of this.getShapeUtil(currentTool.shapeType).styleProps.keys()) {
        styles.applyValue(style, this.getStyleForNextShape(style));
      }
    }
    return styles;
  }
  get sharedOpacity() {
    if (this.isIn("select") && this.selectedIds.length > 0) {
      const shapesToCheck = [];
      const addShape = (shapeId) => {
        const shape = this.getShapeById(shapeId);
        if (!shape)
          return;
        if (this.isShapeOfType(shape, import_GroupShapeUtil.GroupShapeUtil)) {
          for (const childId of this.getSortedChildIds(shape.id)) {
            addShape(childId);
          }
        } else {
          shapesToCheck.push(shape);
        }
      };
      for (const shapeId of this.selectedIds) {
        addShape(shapeId);
      }
      let opacity = null;
      for (const shape of shapesToCheck) {
        if (opacity === null) {
          opacity = shape.opacity;
        } else if (opacity !== shape.opacity) {
          return { type: "mixed" };
        }
      }
      if (opacity !== null)
        return { type: "shared", value: opacity };
    }
    return { type: "shared", value: this.instanceState.opacityForNextShape };
  }
  get _arrowBindingsIndex() {
    return (0, import_arrowBindingsIndex.arrowBindingsIndex)(this);
  }
  /**
   * Get all arrows bound to a shape.
   *
   * @param shapeId - The id of the shape.
   *
   * @public
   */
  getArrowsBoundTo(shapeId) {
    return this._arrowBindingsIndex.value[shapeId] || import_signia.EMPTY_ARRAY;
  }
  /** @internal */
  _reparentArrow(arrowId) {
    const arrow = this.getShapeById(arrowId);
    if (!arrow)
      return;
    const { start, end } = arrow.props;
    const startShape = start.type === "binding" ? this.getShapeById(start.boundShapeId) : void 0;
    const endShape = end.type === "binding" ? this.getShapeById(end.boundShapeId) : void 0;
    const parentPageId = this.getAncestorPageId(arrow);
    if (!parentPageId)
      return;
    let nextParentId;
    if (startShape && endShape) {
      nextParentId = this.findCommonAncestor([startShape, endShape]) ?? parentPageId;
    } else if (startShape || endShape) {
      nextParentId = parentPageId;
    } else {
      return;
    }
    if (nextParentId && nextParentId !== arrow.parentId) {
      this.reparentShapesById([arrowId], nextParentId);
    }
    const reparentedArrow = this.getShapeById(arrowId);
    if (!reparentedArrow)
      throw Error("no reparented arrow");
    const startSibling = this.getShapeNearestSibling(reparentedArrow, startShape);
    const endSibling = this.getShapeNearestSibling(reparentedArrow, endShape);
    let highestSibling;
    if (startSibling && endSibling) {
      highestSibling = startSibling.index > endSibling.index ? startSibling : endSibling;
    } else if (startSibling && !endSibling) {
      highestSibling = startSibling;
    } else if (endSibling && !startSibling) {
      highestSibling = endSibling;
    } else {
      return;
    }
    let finalIndex;
    const higherSiblings = this.getSortedChildIds(highestSibling.parentId).map((id) => this.getShapeById(id)).filter((sibling) => sibling.index > highestSibling.index);
    if (higherSiblings.length) {
      const nextHighestNonArrowSibling = higherSiblings.find((sibling) => sibling.type !== "arrow");
      if (
        // ...then, if we're above the last shape we want to be above...
        reparentedArrow.index > highestSibling.index && // ...but below the next non-arrow sibling...
        (!nextHighestNonArrowSibling || reparentedArrow.index < nextHighestNonArrowSibling.index)
      ) {
        return;
      }
      finalIndex = (0, import_indices.getIndexBetween)(highestSibling.index, higherSiblings[0].index);
    } else {
      finalIndex = (0, import_indices.getIndexAbove)(highestSibling.index);
    }
    if (finalIndex !== reparentedArrow.index) {
      this.updateShapes([{ id: arrowId, type: "arrow", index: finalIndex }]);
    }
  }
  /** @internal */
  _unbindArrowTerminal(arrow, handleId) {
    const { x, y } = (0, import_shared.getArrowTerminalsInArrowSpace)(this, arrow)[handleId];
    this.store.put([{ ...arrow, props: { ...arrow.props, [handleId]: { type: "point", x, y } } }]);
  }
  get _allPageStates() {
    return this.store.query.records("instance_page_state");
  }
  /** @internal */
  _shapeWillBeDeleted(deletedShape) {
    if (deletedShape.parentId && (0, import_tlschema.isShapeId)(deletedShape.parentId)) {
      this._invalidParents.add(deletedShape.parentId);
    }
    const bindings = this._arrowBindingsIndex.value[deletedShape.id];
    if (bindings?.length) {
      for (const { arrowId, handleId } of bindings) {
        const arrow = this.getShapeById(arrowId);
        if (!arrow)
          continue;
        this._unbindArrowTerminal(arrow, handleId);
      }
    }
    const pageStates = this._allPageStates.value;
    const deletedIds = /* @__PURE__ */ new Set([deletedShape.id]);
    const updates = (0, import_utils.compact)(
      pageStates.map((pageState) => {
        return this._cleanupInstancePageState(pageState, deletedIds);
      })
    );
    if (updates.length) {
      this.store.put(updates);
    }
  }
  /** @internal */
  _arrowDidUpdate(arrow) {
    for (const handle of ["start", "end"]) {
      const terminal = arrow.props[handle];
      if (terminal.type !== "binding")
        continue;
      const boundShape = this.getShapeById(terminal.boundShapeId);
      const isShapeInSamePageAsArrow = this.getAncestorPageId(arrow) === this.getAncestorPageId(boundShape);
      if (!boundShape || !isShapeInSamePageAsArrow) {
        this._unbindArrowTerminal(arrow, handle);
      }
    }
    this._reparentArrow(arrow.id);
  }
  /**
   * _invalidParents is used to trigger the 'onChildrenChange' callback that shapes can have.
   *
   * @internal
   */
  _invalidParents = /* @__PURE__ */ new Set();
  /** @internal */
  _complete() {
    for (const parentId of this._invalidParents) {
      this._invalidParents.delete(parentId);
      const parent = this.getShapeById(parentId);
      if (!parent)
        continue;
      const util = this.getShapeUtil(parent);
      const changes = util.onChildrenChange?.(parent);
      if (changes?.length) {
        this.updateShapes(changes, true);
      }
    }
    this.emit("update");
  }
  /** @internal */
  _cleanupInstancePageState(prevPageState, shapesNoLongerInPage) {
    let nextPageState = null;
    const selectedIds = prevPageState.selectedIds.filter((id) => !shapesNoLongerInPage.has(id));
    if (selectedIds.length !== prevPageState.selectedIds.length) {
      if (!nextPageState)
        nextPageState = { ...prevPageState };
      nextPageState.selectedIds = selectedIds;
    }
    const erasingIds = prevPageState.erasingIds.filter((id) => !shapesNoLongerInPage.has(id));
    if (erasingIds.length !== prevPageState.erasingIds.length) {
      if (!nextPageState)
        nextPageState = { ...prevPageState };
      nextPageState.erasingIds = erasingIds;
    }
    if (prevPageState.hoveredId && shapesNoLongerInPage.has(prevPageState.hoveredId)) {
      if (!nextPageState)
        nextPageState = { ...prevPageState };
      nextPageState.hoveredId = null;
    }
    if (prevPageState.editingId && shapesNoLongerInPage.has(prevPageState.editingId)) {
      if (!nextPageState)
        nextPageState = { ...prevPageState };
      nextPageState.editingId = null;
    }
    const hintingIds = prevPageState.hintingIds.filter((id) => !shapesNoLongerInPage.has(id));
    if (hintingIds.length !== prevPageState.hintingIds.length) {
      if (!nextPageState)
        nextPageState = { ...prevPageState };
      nextPageState.hintingIds = hintingIds;
    }
    if (prevPageState.focusLayerId && shapesNoLongerInPage.has(prevPageState.focusLayerId)) {
      if (!nextPageState)
        nextPageState = { ...prevPageState };
      nextPageState.focusLayerId = null;
    }
    return nextPageState;
  }
  /** @internal */
  _shapeDidChange(prev, next) {
    if (this.isShapeOfType(next, import_ArrowShapeUtil.ArrowShapeUtil)) {
      this._arrowDidUpdate(next);
    }
    if (prev.parentId !== next.parentId) {
      const reparentBoundArrows = (id) => {
        const boundArrows = this._arrowBindingsIndex.value[id];
        if (boundArrows?.length) {
          for (const arrow of boundArrows) {
            this._reparentArrow(arrow.arrowId);
          }
        }
      };
      reparentBoundArrows(next.id);
      this.visitDescendants(next.id, reparentBoundArrows);
    }
    if (prev.parentId !== next.parentId && (0, import_tlschema.isPageId)(next.parentId)) {
      const allMovingIds = /* @__PURE__ */ new Set([prev.id]);
      this.visitDescendants(prev.id, (id) => {
        allMovingIds.add(id);
      });
      for (const instancePageState of this._allPageStates.value) {
        if (instancePageState.pageId === next.parentId)
          continue;
        const nextPageState = this._cleanupInstancePageState(instancePageState, allMovingIds);
        if (nextPageState) {
          this.store.put([nextPageState]);
        }
      }
    }
    if (prev.parentId && (0, import_tlschema.isShapeId)(prev.parentId)) {
      this._invalidParents.add(prev.parentId);
    }
    if (next.parentId !== prev.parentId && (0, import_tlschema.isShapeId)(next.parentId)) {
      this._invalidParents.add(next.parentId);
    }
  }
  /** @internal */
  _pageStateDidChange(prev, next) {
    if (prev?.selectedIds !== next?.selectedIds) {
      const filtered = next.selectedIds.filter((id) => {
        let parentId = this.getShapeById(id)?.parentId;
        while ((0, import_tlschema.isShapeId)(parentId)) {
          if (next.selectedIds.includes(parentId)) {
            return false;
          }
          parentId = this.getShapeById(parentId)?.parentId;
        }
        return true;
      });
      const nextFocusLayerId = filtered.length === 0 ? next?.focusLayerId : this.findCommonAncestor(
        (0, import_utils.compact)(filtered.map((id) => this.getShapeById(id))),
        (shape) => this.isShapeOfType(shape, import_GroupShapeUtil.GroupShapeUtil)
      );
      if (filtered.length !== next.selectedIds.length || nextFocusLayerId != next.focusLayerId) {
        this.store.put([{ ...next, selectedIds: filtered, focusLayerId: nextFocusLayerId ?? null }]);
      }
    }
  }
  /** @internal */
  _pageWillBeDeleted(page) {
    if (this.instanceState.currentPageId !== page.id)
      return;
    const backupPageId = this.pages.find((p) => p.id !== page.id)?.id;
    if (!backupPageId)
      return;
    this.store.put([{ ...this.instanceState, currentPageId: backupPageId }]);
    const cameraId = import_tlschema.CameraRecordType.createId(page.id);
    const instancePageStateId = import_tlschema.InstancePageStateRecordType.createId(page.id);
    this.store.remove([cameraId, instancePageStateId]);
  }
  /* --------------------- Errors --------------------- */
  /** @internal */
  annotateError(error, {
    origin,
    willCrashApp,
    tags,
    extras
  }) {
    const defaultAnnotations = this.createErrorAnnotations(origin, willCrashApp);
    (0, import_utils.annotateError)(error, {
      tags: { ...defaultAnnotations.tags, ...tags },
      extras: { ...defaultAnnotations.extras, ...extras }
    });
    if (willCrashApp) {
      this.store.markAsPossiblyCorrupted();
    }
  }
  /** @internal */
  createErrorAnnotations(origin, willCrashApp) {
    try {
      return {
        tags: {
          origin,
          willCrashApp
        },
        extras: {
          activeStateNode: this.root.path.value,
          selectedShapes: this.selectedShapes,
          editingShape: this.editingId ? this.getShapeById(this.editingId) : void 0,
          inputs: this.inputs
        }
      };
    } catch {
      return {
        tags: {
          origin,
          willCrashApp
        },
        extras: {}
      };
    }
  }
  /** @internal */
  _crashingError = null;
  /**
   * We can't use an `atom` here because there's a chance that when `crashAndReportError` is called,
   * we're in a transaction that's about to be rolled back due to the same error we're currently
   * reporting.
   *
   * Instead, to listen to changes to this value, you need to listen to app's `crash` event.
   *
   * @internal
   */
  get crashingError() {
    return this._crashingError;
  }
  /** @internal */
  crash(error) {
    this._crashingError = error;
    this.store.markAsPossiblyCorrupted();
    this.emit("crash", { error });
  }
  /* ----------------- Internal State ----------------- */
  _canMoveCamera = (0, import_signia.atom)("can move camera", true);
  /**
   * Whether the editor's camera can move.
   *
   * @example
   * ```ts
   * editor.canMoveCamera = false
   * ```
   *
   * @param canMove - Whether the camera can move.
   *
   * @public
   */
  get canMoveCamera() {
    return this._canMoveCamera.value;
  }
  set canMoveCamera(canMove) {
    this._canMoveCamera.set(canMove);
  }
  _isFocused = (0, import_signia.atom)("_isFocused", false);
  /**
   * Whether or not the editor is focused.
   *
   * @public
   */
  get isFocused() {
    return this._isFocused.value;
  }
  /**
   * The window's device pixel ratio.
   *
   * @public
   */
  get devicePixelRatio() {
    return this._dprManager.dpr.value;
  }
  // Coarse Pointer
  /** @internal */
  _isCoarsePointer = (0, import_signia.atom)("isCoarsePointer", false);
  /**
   * Whether the user is using a "coarse" pointer, such as on a touch screen. This is automatically set by the canvas.
   *
   * @public
   **/
  get isCoarsePointer() {
    return this._isCoarsePointer.value;
  }
  set isCoarsePointer(v) {
    this._isCoarsePointer.set(v);
  }
  // Menus
  _openMenus = (0, import_signia.atom)("open-menus", []);
  get openMenus() {
    return this._openMenus.value;
  }
  /**
   * Add an open menu.
   *
   * @example
   * ```ts
   * editor.addOpenMenu('menu-id')
   * ```
   *
   * @public
   */
  addOpenMenu(id) {
    const menus = new Set(this.openMenus);
    if (!menus.has(id)) {
      menus.add(id);
      this._openMenus.set([...menus]);
    }
    return this;
  }
  /**
   * Delete an open menu.
   *
   * @example
   * ```ts
   * editor.deleteOpenMenu('menu-id')
   * ```
   *
   * @public
   */
  deleteOpenMenu(id) {
    const menus = new Set(this.openMenus);
    if (menus.has(id)) {
      menus.delete(id);
      this._openMenus.set([...menus]);
    }
    return this;
  }
  get isMenuOpen() {
    return this.openMenus.length > 0;
  }
  // Changing style
  /** @internal */
  _isChangingStyle = (0, import_signia.atom)("isChangingStyle", false);
  /** @internal */
  _isChangingStyleTimeout = -1;
  /**
   * Whether the user is currently changing the style of a shape. This may cause the UI to change.
   *
   * @example
   * ```ts
   * editor.isChangingStyle = true
   * ```
   *
   * @public
   */
  get isChangingStyle() {
    return this._isChangingStyle.value;
  }
  set isChangingStyle(v) {
    this._isChangingStyle.set(v);
    clearTimeout(this._isChangingStyleTimeout);
    if (v) {
      this._isChangingStyleTimeout = setTimeout(() => this.isChangingStyle = false, 2e3);
    }
  }
  // Pen Mode
  /** @internal */
  _isPenMode = (0, import_signia.atom)("isPenMode", false);
  /** @internal */
  _touchEventsRemainingBeforeExitingPenMode = 0;
  /**
   * Whether the editor is in pen mode or not.
   *
   * @public
   **/
  get isPenMode() {
    return this._isPenMode.value;
  }
  /**
   * Set whether the editor is in pen mode or not.
   *
   * @public
   **/
  setPenMode(isPenMode) {
    if (isPenMode)
      this._touchEventsRemainingBeforeExitingPenMode = 3;
    if (isPenMode !== this.isPenMode) {
      this._isPenMode.set(isPenMode);
    }
    return this;
  }
  // Read only
  _isReadOnly = (0, import_signia.atom)("isReadOnly", false);
  /**
   * Set whether the editor is in read-only mode or not.
   *
   * @public
   **/
  setReadOnly(isReadOnly) {
    this._isReadOnly.set(isReadOnly);
    if (isReadOnly) {
      this.setSelectedTool("hand");
    }
    return this;
  }
  /**
   * Whether the editor is in read-only mode or not.
   *
   * @public
   **/
  get isReadOnly() {
    return this._isReadOnly.value;
  }
  get documentSettings() {
    return this.store.get(import_tlschema.TLDOCUMENT_ID);
  }
  /**
   * Update the global document settings that apply to all users.
   *
   * @public
   **/
  updateDocumentSettings(settings) {
    this.store.put([{ ...this.documentSettings, ...settings }]);
  }
  /**
   * The document's grid size.
   *
   * @public
   **/
  get gridSize() {
    return this.documentSettings.gridSize;
  }
  /** @internal */
  get projectName() {
    return this.documentSettings.name;
  }
  /** @internal */
  setProjectName(name) {
    this.updateDocumentSettings({ name });
  }
  /* ---------------------- User ---------------------- */
  /**
   * Whether the user has "always snap" mode enabled.
   *
   * @public
   **/
  get isSnapMode() {
    return this.user.isSnapMode;
  }
  /**
   * Set whether the user has "always snap" mode enabled.
   *
   * @public
   **/
  setSnapMode(isSnapMode) {
    if (isSnapMode !== this.isSnapMode) {
      this.user.updateUserPreferences({ isSnapMode });
    }
    return this;
  }
  /**
   * Whether the user has dark mode enabled.
   *
   * @public
   **/
  get isDarkMode() {
    return this.user.isDarkMode;
  }
  /**
   * Set whether the user has dark mode enabled.
   *
   * @public
   **/
  setDarkMode(isDarkMode) {
    if (isDarkMode !== this.isDarkMode) {
      this.user.updateUserPreferences({ isDarkMode });
    }
    return this;
  }
  /**
   * The user's chosen animation speed.
   *
   * @public
   */
  get animationSpeed() {
    return this.user.animationSpeed;
  }
  /**
   * Set the user's chosen animation speed.
   * Set to 0.0 to disable animations.
   * Set to 1.0 for full speed.
   *
   * @public
   */
  setAnimationSpeed(animationSpeed) {
    if (animationSpeed !== this.animationSpeed) {
      this.user.updateUserPreferences({ animationSpeed });
    }
    return this;
  }
  /* ----------------- Instance State ----------------- */
  /**
   * The current instance's state.
   *
   * @public
   */
  get instanceState() {
    return this.store.get(import_tlschema.TLINSTANCE_ID);
  }
  /**
   * The instance's cursor state.
   *
   * @public
   **/
  get cursor() {
    return this.instanceState.cursor;
  }
  /**
   * The instance's brush state.
   *
   * @public
   **/
  get brush() {
    return this.instanceState.brush;
  }
  /**
   * The instance's zoom brush state.
   *
   * @public
   **/
  get zoomBrush() {
    return this.instanceState.zoomBrush;
  }
  /**
   * The instance's scribble state.
   *
   * @public
   **/
  get scribble() {
    return this.instanceState.scribble;
  }
  // Focus Mode
  /**
   * Whether the instance is in focus mode or not.
   *
   * @public
   **/
  get isFocusMode() {
    return this.instanceState.isFocusMode;
  }
  /**
   * Set whether the instance is in focus mode or not.
   *
   * @public
   **/
  setFocusMode(isFocusMode) {
    if (isFocusMode !== this.isFocusMode) {
      this.updateInstanceState({ isFocusMode }, true);
    }
    return this;
  }
  // Tool Locked
  /**
   * Whether the instance has "tool lock" mode enabled.
   *
   * @public
   **/
  get isToolLocked() {
    return this.instanceState.isToolLocked;
  }
  /**
   * Set whether the instance has "tool lock" mode enabled.
   *
   * @public
   **/
  setToolLocked(isToolLocked) {
    if (isToolLocked !== this.isToolLocked) {
      this.updateInstanceState({ isToolLocked }, true);
    }
    return this;
  }
  // Grid Mode
  /**
   * Whether the instance's grid is enabled.
   *
   * @public
   **/
  get isGridMode() {
    return this.instanceState.isGridMode;
  }
  /**
   * Set whether the instance's grid is enabled.
   *
   * @public
   **/
  setGridMode(isGridMode) {
    if (isGridMode !== this.isGridMode) {
      this.updateInstanceState({ isGridMode }, true);
    }
    return this;
  }
  get _pages() {
    return this.store.query.records("page");
  }
  get pages() {
    return this._pages.value.sort(import_indices.sortByIndex);
  }
  /**
   * The current page.
   *
   * @public
   */
  get currentPage() {
    const page = this.getPageById(this.currentPageId);
    if (!page)
      throw Error(`No current page (id ${this.currentPageId}, ${this.pages.length} pages))`);
    return page;
  }
  /**
   * The current page id.
   *
   * @public
   */
  get currentPageId() {
    return this.instanceState.currentPageId;
  }
  /**
   * Get a page by its ID.
   *
   * @example
   * ```ts
   * editor.getPageById(myPage.id)
   * ```
   *
   * @public
   */
  getPageById(id) {
    return this.store.get(id);
  }
  /**
   * Get a page by its ID.
   *
   * @example
   * ```ts
   * editor.getPageById(myPage.id)
   * ```
   *
   * @public
   */
  getPageInfoById(id) {
    return this.store.get(id);
  }
  /**
   * A cache of shape ids in the current page.
   *
   * @internal
   */
  _currentPageShapeIds;
  /**
   * An array of all of the shapes on the current page.
   *
   * @public
   */
  get currentPageShapeIds() {
    return this._currentPageShapeIds.value;
  }
  /**
   * Get the ids of shapes on a page.
   *
   * @example
   * ```ts
   * const idsOnPage1 = editor.getShapeIdsInPage('page1')
   * const idsOnPage2 = editor.getShapeIdsInPage('page2')
   * ```
   *
   * @param pageId - The id of the page.
   *
   * @public
   **/
  getShapeIdsInPage(pageId) {
    const result = this.store.query.exec("shape", { parentId: { eq: pageId } });
    return this.getShapeAndDescendantIds(result.map((s) => s.id));
  }
  get _pageStates() {
    return this.store.query.records("instance_page_state");
  }
  /**
   * Get a page state by its id.
   *
   * @example
   * ```ts
   * editor.getPageStateByPageId('page1')
   * ```
   *
   * @public
   */
  getPageStateByPageId(id) {
    return this._pageStates.value.find((p) => p.pageId === id);
  }
  get pageStateId() {
    return import_tlschema.InstancePageStateRecordType.createId(this.currentPageId);
  }
  get pageState() {
    return this.store.get(this.pageStateId);
  }
  /**
   * Update a page state.
   *
   * @example
   * ```ts
   * editor.setInstancePageState({ id: 'page1', editingId: 'shape:123' })
   * editor.setInstancePageState({ id: 'page1', editingId: 'shape:123' }, true)
   * ```
   *
   * @param partial - The partial of the page state object containing the changes.
   * @param ephemeral - Whether the command is ephemeral.
   *
   * @public
   */
  setInstancePageState(partial, ephemeral = false) {
    this._setInstancePageState(partial, ephemeral);
  }
  get selectedIds() {
    return this.pageState.selectedIds;
  }
  get selectedIdsSet() {
    return new Set(this.selectedIds);
  }
  /**
   * Select one or more shapes.
   *
   * @example
   * ```ts
   * editor.setSelectedIds(['id1'])
   * editor.setSelectedIds(['id1', 'id2'])
   * ```
   *
   * @param ids - The ids to select.
   * @param squashing - Whether the change should create a new history entry or combine with the
   *   previous (if the previous is the same type).
   *
   * @public
   */
  setSelectedIds(ids, squashing = false) {
    this._setSelectedIds(ids, squashing);
    return this;
  }
  /** @internal */
  _setSelectedIds = this.history.createCommand(
    "setSelectedIds",
    (ids, squashing = false) => {
      const prevSelectedIds = this.pageState.selectedIds;
      const prevSet = new Set(this.pageState.selectedIds);
      if (ids.length === prevSet.size && ids.every((id) => prevSet.has(id)))
        return null;
      return { data: { ids, prevSelectedIds }, squashing, preservesRedoStack: true };
    },
    {
      do: ({ ids }) => {
        this.store.update(this.pageState.id, (state) => ({ ...state, selectedIds: ids }));
      },
      undo: ({ prevSelectedIds }) => {
        this.store.update(this.pageState.id, () => ({
          ...this.pageState,
          selectedIds: prevSelectedIds
        }));
      },
      squash(prev, next) {
        return { ids: next.ids, prevSelectedIds: prev.prevSelectedIds };
      }
    }
  );
  /**
   * Determine whether or not a shape is selected
   *
   * @example
   * ```ts
   * editor.isSelected('id1')
   * ```
   *
   * @param id - The id of the shape to check.
   *
   * @public
   */
  isSelected(id) {
    return this.selectedIdsSet.has(id);
  }
  /**
   * Determine whether a not a shape is within the current selection. A shape is within the
   * selection if it or any of its parents is selected.
   *
   * @param id - The id of the shape to check.
   *
   * @public
   */
  isWithinSelection(id) {
    const shape = this.getShapeById(id);
    if (!shape)
      return false;
    if (this.isSelected(id))
      return true;
    return !!this.findAncestor(shape, (parent) => this.isSelected(parent.id));
  }
  /**
   * Select one or more shapes.
   *
   * @example
   * ```ts
   * editor.select('id1')
   * editor.select('id1', 'id2')
   * ```
   *
   * @param ids - The ids to select.
   *
   * @public
   */
  select(...ids) {
    this.setSelectedIds(ids);
    return this;
  }
  /**
   * Remove a shape from the existing set of selected shapes.
   *
   * @example
   * ```ts
   * editor.deselect(shape.id)
   * ```
   *
   * @public
   */
  deselect(...ids) {
    const { selectedIds } = this;
    if (selectedIds.length > 0 && ids.length > 0) {
      this.setSelectedIds(selectedIds.filter((id) => !ids.includes(id)));
    }
    return this;
  }
  /**
   * Select all direct children of the current page.
   *
   * @example
   * ```ts
   * editor.selectAll()
   * ```
   *
   * @public
   */
  selectAll() {
    const ids = this.getSortedChildIds(this.currentPageId);
    if (ids.length <= 0)
      return this;
    this.setSelectedIds(this._getUnlockedShapeIds(ids));
    return this;
  }
  /**
   * Clear the selection.
   *
   * @example
   * ```ts
   * editor.selectNone()
   * ```
   *
   * @public
   */
  selectNone() {
    if (this.selectedIds.length > 0) {
      this.setSelectedIds([]);
    }
    return this;
  }
  // Focus Layer Id
  /**
   * The shape id of the current focus layer.
   *
   * @public
   */
  get focusLayerId() {
    return this.pageState.focusLayerId ?? this.currentPageId;
  }
  /**
   * The shape of the current focus layer.
   *
   * @public
   */
  get focusLayerShape() {
    const id = this.pageState.focusLayerId;
    if (!id) {
      return;
    }
    return this.getShapeById(id);
  }
  /**
   * Exit the current focus layer, moving up to the next group if there is one.
   *
   * @public
   */
  popFocusLayer() {
    const current = this.pageState.focusLayerId;
    const focusedShape = current && this.getShapeById(current);
    if (focusedShape) {
      const match = this.findAncestor(
        focusedShape,
        (shape) => this.isShapeOfType(shape, import_GroupShapeUtil.GroupShapeUtil)
      );
      this.setFocusLayer(match?.id ?? null);
      this.select(focusedShape.id);
    } else {
      this.setFocusLayer(null);
      this.selectNone();
    }
    return this;
  }
  /**
   * Set the focus layer to the given shape id.
   *
   * @param next - The next focus layer id or null to reset the focus layer to the page
   *
   * @public
   */
  setFocusLayer(next) {
    this._setFocusLayer(next);
    return this;
  }
  /** @internal */
  _setFocusLayer = this.history.createCommand(
    "setFocusLayer",
    (next) => {
      if (next === null && !this.canUndo) {
        return;
      }
      const prev = this.pageState.focusLayerId;
      return { data: { prev, next }, preservesRedoStack: true, squashing: true };
    },
    {
      do: ({ next }) => {
        this.store.update(this.pageState.id, (s) => ({ ...s, focusLayerId: next }));
      },
      undo: ({ prev }) => {
        this.store.update(this.pageState.id, (s) => ({ ...s, focusLayerId: prev }));
      },
      squash({ prev }, { next }) {
        return { prev, next };
      }
    }
  );
  // Editing Id
  /**
   * The current editing shape's id.
   *
   * @public
   */
  get editingId() {
    return this.pageState.editingId;
  }
  /**
   * Set the current editing id.
   *
   * @param id - The id of the shape to edit or null to clear the editing id.
   *
   * @public
   */
  setEditingId(id) {
    if (!id) {
      this.setInstancePageState({ editingId: null });
    } else {
      if (id !== this.editingId) {
        const shape = this.getShapeById(id);
        const util = this.getShapeUtil(shape);
        if (shape && util.canEdit(shape)) {
          this.setInstancePageState({ editingId: id, hoveredId: null }, false);
          const { viewportPageBounds } = this;
          const localEditingBounds = util.getEditingBounds(shape);
          const pageTransform = this.getPageTransformById(id);
          const pageEditingBounds = import_primitives.Box2d.FromPoints(
            import_primitives.Matrix2d.applyToPoints(pageTransform, localEditingBounds.corners)
          );
          if (!viewportPageBounds.contains(pageEditingBounds)) {
            if (pageEditingBounds.width > viewportPageBounds.width || pageEditingBounds.height > viewportPageBounds.height) {
              this.zoomToBounds(
                pageEditingBounds.minX,
                pageEditingBounds.minY,
                pageEditingBounds.width,
                pageEditingBounds.height
              );
            } else {
              this.centerOnPoint(pageEditingBounds.midX, pageEditingBounds.midY);
            }
          }
        }
      }
    }
    return this;
  }
  get editingShape() {
    if (!this.editingId)
      return null;
    return this.getShapeById(this.editingId) ?? null;
  }
  get hoveredId() {
    return this.pageState.hoveredId;
  }
  /**
   * Set the current hovered shape.
   *
   * @example
   * ```ts
   * editor.setHoveredId('box1')
   * editor.setHoveredId() // Clears the hovered shape.
   * ```
   *
   * @param id - The id of the page to set as the current page
   *
   * @public
   */
  setHoveredId(id = null) {
    if (id === this.pageState.hoveredId)
      return this;
    this.setInstancePageState({ hoveredId: id }, true);
    return this;
  }
  get hoveredShape() {
    if (!this.hoveredId)
      return null;
    return this.getShapeById(this.hoveredId) ?? null;
  }
  get hintingIds() {
    return this.pageState.hintingIds;
  }
  /**
   * Set the hinted shape ids.
   *
   * @param ids - The ids to set as hinted.
   *
   * @public
   */
  setHintingIds(ids) {
    this.store.update(this.pageState.id, (s) => ({ ...s, hintingIds: (0, import_utils.dedupe)(ids) }));
    return this;
  }
  get erasingIds() {
    return this.pageState.erasingIds;
  }
  get erasingIdsSet() {
    return new Set(this.erasingIds);
  }
  /**
   * Set the current erasing shapes.
   *
   * @example
   * ```ts
   * editor.setErasingIds(['box1', 'box2'])
   * editor.setErasingIds() // Clears the erasing set
   * ```
   *
   * @param ids - The ids of shapes to set as erasing.
   *
   * @public
   */
  setErasingIds(ids = []) {
    const erasingIds = this.erasingIdsSet;
    if (ids.length === erasingIds.size && ids.every((id) => erasingIds.has(id)))
      return this;
    this.setInstancePageState({ erasingIds: ids }, true);
    return this;
  }
  // Cropping Id
  /**
   * The current cropping shape's id.
   *
   * @public
   */
  get croppingId() {
    return this.pageState.croppingId;
  }
  /**
   * Set the current cropping shape's id.
   *
   * @param id - The id of the shape to crop or null to clear the cropping id.
   *
   * @public
   */
  setCroppingId(id) {
    if (id !== this.croppingId) {
      if (!id) {
        this.setInstancePageState({ croppingId: null });
        if (this.isInAny("select.crop", "select.pointing_crop_handle", "select.cropping")) {
          this.setSelectedTool("select.idle");
        }
      } else {
        const shape = this.getShapeById(id);
        const util = this.getShapeUtil(shape);
        if (shape && util.canCrop(shape)) {
          this.setInstancePageState({ croppingId: id, hoveredId: null });
        }
      }
    }
    return this;
  }
  get cameraId() {
    return import_tlschema.CameraRecordType.createId(this.currentPageId);
  }
  get camera() {
    return this.store.get(this.cameraId);
  }
  get zoomLevel() {
    return this.camera.z;
  }
  /* -------------------- Viewport -------------------- */
  /**
   * Update the viewport. The viewport will measure the size and screen position of its container
   * element. This should be done whenever the container's position on the screen changes.
   *
   * @example
   * ```ts
   * editor.updateViewportScreenBounds()
   * editor.updateViewportScreenBounds(true)
   * ```
   *
   * @param center - (optional) Whether to preserve the viewport page center as the viewport changes.
   *
   * @public
   */
  updateViewportScreenBounds(center = false) {
    const container = this.getContainer();
    if (!container)
      return this;
    const rect = container.getBoundingClientRect();
    const screenBounds = new import_primitives.Box2d(0, 0, Math.max(rect.width, 1), Math.max(rect.height, 1));
    const boundsAreEqual = screenBounds.equals(this.viewportScreenBounds);
    const { _willSetInitialBounds } = this;
    if (boundsAreEqual) {
      this._willSetInitialBounds = false;
    } else {
      if (_willSetInitialBounds) {
        this._willSetInitialBounds = false;
        this.updateInstanceState({ screenBounds: screenBounds.toJson() }, true, true);
      } else {
        const { zoomLevel } = this;
        if (center) {
          const before = this.viewportPageCenter;
          this.updateInstanceState({ screenBounds: screenBounds.toJson() }, true, true);
          const after = this.viewportPageCenter;
          if (!this.instanceState.followingUserId) {
            this.pan((after.x - before.x) * zoomLevel, (after.y - before.y) * zoomLevel);
          }
        } else {
          const before = this.screenToPage(0, 0);
          this.updateInstanceState({ screenBounds: screenBounds.toJson() }, true, true);
          const after = this.screenToPage(0, 0);
          if (!this.instanceState.followingUserId) {
            this.pan((after.x - before.x) * zoomLevel, (after.y - before.y) * zoomLevel);
          }
        }
      }
    }
    this._tickCameraState();
    this.updateRenderingBounds();
    const { editingId } = this;
    if (editingId) {
      this.panZoomIntoView([editingId]);
    }
    return this;
  }
  get viewportScreenBounds() {
    const { x, y, w, h } = this.instanceState.screenBounds;
    return new import_primitives.Box2d(x, y, w, h);
  }
  get viewportScreenCenter() {
    return this.viewportScreenBounds.center;
  }
  get viewportPageBounds() {
    const { x, y, w, h } = this.viewportScreenBounds;
    const tl = this.screenToPage(x, y);
    const br = this.screenToPage(x + w, y + h);
    return new import_primitives.Box2d(tl.x, tl.y, br.x - tl.x, br.y - tl.y);
  }
  get viewportPageCenter() {
    return this.viewportPageBounds.center;
  }
  /**
   * Convert a point in screen space to a point in page space.
   *
   * @example
   * ```ts
   * editor.screenToPage(100, 100)
   * ```
   *
   * @param x - The x coordinate of the point in screen space.
   * @param y - The y coordinate of the point in screen space.
   * @param camera - The camera to use. Defaults to the current camera.
   *
   * @public
   */
  screenToPage(x, y, z = 0.5, camera = this.camera) {
    const { screenBounds } = this.store.unsafeGetWithoutCapture(import_tlschema.TLINSTANCE_ID);
    const { x: cx, y: cy, z: cz = 1 } = camera;
    return {
      x: (x - screenBounds.x) / cz - cx,
      y: (y - screenBounds.y) / cz - cy,
      z
    };
  }
  /**
   * Convert a point in page space to a point in screen space.
   *
   * @example
   * ```ts
   * editor.pageToScreen(100, 100)
   * ```
   *
   * @param x - The x coordinate of the point in screen space.
   * @param y - The y coordinate of the point in screen space.
   * @param camera - The camera to use. Defaults to the current camera.
   *
   * @public
   */
  pageToScreen(x, y, z = 0.5, camera = this.camera) {
    const { x: cx, y: cy, z: cz = 1 } = camera;
    return {
      x: x + cx * cz,
      y: y + cy * cz,
      z
    };
  }
  /* -------- Rendering Shapes / rendering Bounds ------- */
  _cameraState = (0, import_signia.atom)("camera state", "idle");
  get cameraState() {
    return this._cameraState.value;
  }
  // Camera state does two things: first, it allows us to subscribe to whether
  // the camera is moving or not; and second, it allows us to update the rendering
  // shapes on the canvas. Changing the rendering shapes may cause shapes to
  // unmount / remount in the DOM, which is expensive; and computing visibility is
  // also expensive in large projects. For this reason, we use a second bounding
  // box just for rendering, and we only update after the camera stops moving.
  _cameraStateTimeoutRemaining = 0;
  _lastUpdateRenderingBoundsTimestamp = Date.now();
  _decayCameraStateTimeout = (elapsed) => {
    this._cameraStateTimeoutRemaining -= elapsed;
    if (this._cameraStateTimeoutRemaining <= 0) {
      this.off("tick", this._decayCameraStateTimeout);
      this._cameraState.set("idle");
      this.updateRenderingBounds();
    }
  };
  _tickCameraState = () => {
    this._cameraStateTimeoutRemaining = import_constants.CAMERA_MOVING_TIMEOUT;
    const now = Date.now();
    if (this._cameraState.__unsafe__getWithoutCapture() === "idle") {
      this._lastUpdateRenderingBoundsTimestamp = now;
      this._cameraState.set("moving");
      this.on("tick", this._decayCameraStateTimeout);
    } else {
      if (now - this._lastUpdateRenderingBoundsTimestamp > import_constants.CAMERA_MAX_RENDERING_INTERVAL) {
        this.updateRenderingBounds();
      }
    }
  };
  computeUnorderedRenderingShapes(ids, {
    renderingBounds,
    renderingBoundsExpanded,
    erasingIdsSet,
    editingId
  } = {}) {
    const renderingShapes = [];
    let nextIndex = import_constants.MAX_SHAPES_PER_PAGE;
    let nextBackgroundIndex = 0;
    const addShapeById = (id, parentOpacity, isAncestorErasing) => {
      if (import_tlschema.PageRecordType.isId(id)) {
        for (const childId of this.getSortedChildIds(id)) {
          addShapeById(childId, parentOpacity, isAncestorErasing);
        }
        return;
      }
      const shape = this.getShapeById(id);
      if (!shape)
        return;
      let opacity = shape.opacity * parentOpacity;
      let isShapeErasing = false;
      if (!isAncestorErasing && erasingIdsSet?.has(id)) {
        isShapeErasing = true;
        opacity *= 0.32;
      }
      const maskedPageBounds = this.getMaskedPageBoundsById(id);
      const isInViewport = maskedPageBounds ? renderingBounds?.includes(maskedPageBounds) ?? true : false;
      const isCulled = maskedPageBounds ? (editingId !== id && !renderingBoundsExpanded?.includes(maskedPageBounds)) ?? true : true;
      renderingShapes.push({
        id,
        index: nextIndex,
        backgroundIndex: nextBackgroundIndex,
        opacity,
        isCulled,
        isInViewport,
        maskedPageBounds
      });
      nextIndex += 1;
      nextBackgroundIndex += 1;
      const childIds = this.getSortedChildIds(id);
      if (!childIds.length)
        return;
      let backgroundIndexToRestore = null;
      if (this.getShapeUtil(shape).providesBackgroundForChildren(shape)) {
        backgroundIndexToRestore = nextBackgroundIndex;
        nextBackgroundIndex = nextIndex;
        nextIndex += import_constants.MAX_SHAPES_PER_PAGE;
      }
      for (const childId of childIds) {
        addShapeById(childId, opacity, isAncestorErasing || isShapeErasing);
      }
      if (backgroundIndexToRestore !== null) {
        nextBackgroundIndex = backgroundIndexToRestore;
      }
    };
    for (const id of ids) {
      addShapeById(id, 1, false);
    }
    return renderingShapes;
  }
  get renderingShapes() {
    const renderingShapes = this.computeUnorderedRenderingShapes([this.currentPageId], {
      renderingBounds: this.renderingBounds,
      renderingBoundsExpanded: this.renderingBoundsExpanded,
      erasingIdsSet: this.erasingIdsSet,
      editingId: this.editingId
    });
    return renderingShapes.sort(import_utils.sortById);
  }
  get renderingBounds() {
    return this._renderingBounds.value;
  }
  /** @internal */
  _renderingBounds = (0, import_signia.atom)("rendering viewport", new import_primitives.Box2d());
  get renderingBoundsExpanded() {
    return this._renderingBoundsExpanded.value;
  }
  /** @internal */
  _renderingBoundsExpanded = (0, import_signia.atom)("rendering viewport expanded", new import_primitives.Box2d());
  /**
   * Update the rendering bounds. This should be called when the viewport has stopped changing, such
   * as at the end of a pan, zoom, or animation.
   *
   * @example
   * ```ts
   * editor.updateRenderingBounds()
   * ```
   *
   *
   * @internal
   */
  updateRenderingBounds() {
    const { viewportPageBounds } = this;
    if (viewportPageBounds.equals(this._renderingBounds.__unsafe__getWithoutCapture()))
      return this;
    this._renderingBounds.set(viewportPageBounds.clone());
    this._renderingBoundsExpanded.set(viewportPageBounds.clone().expandBy(100 / this.zoomLevel));
    return this;
  }
  /* --------------------- Shapes --------------------- */
  /**
   * Get the local transform for a shape as a matrix model. This transform reflects both its
   * translation (x, y) from from either its parent's top left corner, if the shape's parent is
   * another shape, or else from the 0,0 of the page, if the shape's parent is the page; and the
   * shape's rotation.
   *
   * @example
   * ```ts
   * editor.getTransform(myShape)
   * ```
   *
   * @param shape - The shape to get the local transform for.
   *
   * @public
   */
  getTransform(shape) {
    return import_primitives.Matrix2d.Compose(import_primitives.Matrix2d.Translate(shape.x, shape.y), import_primitives.Matrix2d.Rotate(shape.rotation));
  }
  /**
   * Get the local transform of a shape's parent as a matrix model.
   *
   * @example
   * ```ts
   * editor.getParentTransform(myShape)
   * ```
   *
   * @param shape - The shape to get the parent transform for.
   *
   * @public
   */
  getParentTransform(shape) {
    if ((0, import_tlschema.isPageId)(shape.parentId)) {
      return import_primitives.Matrix2d.Identity();
    }
    return this._pageTransformCache.get(shape.parentId) ?? import_primitives.Matrix2d.Identity();
  }
  /**
   * Get the page transform (or absolute transform) of a shape.
   *
   * @example
   * ```ts
   * editor.getPageTransform(myShape)
   * ```
   *
   * @param shape - The shape to get the page transform for.
   *
   * @public
   */
  getPageTransform(shape) {
    return this.getPageTransformById(shape.id);
  }
  /**
   * Get the page transform (or absolute transform) of a shape by its id.
   *
   * @example
   * ```ts
   * editor.getPageTransformById(myShape)
   * ```
   *
   * @param id - The if of the shape to get the page transform for.
   *
   * @public
   */
  getPageTransformById(id) {
    return this._pageTransformCache.get(id);
  }
  /**
   * Get the page point (or absolute point) of a shape.
   *
   * @example
   * ```ts
   * editor.getPagePoint(myShape)
   * ```
   *
   * @param shape - The shape to get the page point for.
   *
   * @public
   */
  getPagePointById(id) {
    const pageTransform = this.getPageTransformById(id);
    if (!pageTransform)
      return;
    return import_primitives.Matrix2d.applyToPoint(pageTransform, new import_primitives.Vec2d());
  }
  /**
   * Get the page point (or absolute point) of a shape.
   *
   * @example
   * ```ts
   * editor.getPagePoint(myShape)
   * ```
   *
   * @param shape - The shape to get the page point for.
   *
   * @public
   */
  getPageCenter(shape) {
    const pageTransform = this.getPageTransformById(shape.id);
    if (!pageTransform)
      return null;
    const util = this.getShapeUtil(shape);
    const center = util.center(shape);
    return import_primitives.Matrix2d.applyToPoint(pageTransform, center);
  }
  /**
   * Get the page point (or absolute point) of a shape by its id.
   *
   * @example
   * ```ts
   * editor.getPagePoint(myShape)
   * ```
   *
   * @param id - The shape id to get the page point for.
   *
   * @public
   */
  getPageCenterById(id) {
    const shape = this.getShapeById(id);
    return this.getPageCenter(shape);
  }
  /**
   * Get the page rotation (or absolute rotation) of a shape.
   *
   * @example
   * ```ts
   * editor.getPageRotation(myShape)
   * ```
   *
   * @param shape - The shape to get the page rotation for.
   *
   * @public
   */
  getPageRotation(shape) {
    return this.getPageRotationById(shape.id);
  }
  /**
   * Get the page rotation (or absolute rotation) of a shape by its id.
   *
   * @example
   * ```ts
   * editor.getPageRotationById(myShapeId)
   * ```
   *
   * @param id - The id of the shape to get the page rotation for.
   */
  getPageRotationById(id) {
    const pageTransform = this.getPageTransformById(id);
    if (pageTransform) {
      return import_primitives.Matrix2d.Decompose(pageTransform).rotation;
    }
    return 0;
  }
  /**
   * Get the local bounds of a shape.
   *
   * @example
   * ```ts
   * editor.getBounds(myShape)
   * ```
   *
   * @param shape - The shape to get the bounds for.
   *
   * @public
   */
  getBounds(shape) {
    return this.getShapeUtil(shape).bounds(shape);
  }
  /**
   * Get the local bounds of a shape by its id.
   *
   * @example
   * ```ts
   * editor.getBoundsById(myShape)
   * ```
   *
   * @param id - The id of the shape to get the bounds for.
   *
   * @public
   */
  getBoundsById(id) {
    const shape = this.getShapeById(id);
    if (!shape)
      return void 0;
    return this.getBounds(shape);
  }
  /**
   * Get the page (or absolute) bounds of a shape.
   *
   * @example
   * ```ts
   * editor.getPageBounds(myShape)
   * ```
   *
   * @param shape - The shape to get the bounds for.
   *
   * @public
   */
  getPageBounds(shape) {
    return this.getPageBoundsById(shape.id);
  }
  /**
   * Get the page (or absolute) bounds of a shape by its id.
   *
   * @example
   * ```ts
   * editor.getPageBoundsById(myShape)
   * ```
   *
   * @param id - The id of the shape to get the page bounds for.
   *
   * @public
   */
  getPageBoundsById(id) {
    return this._pageBoundsCache.get(id);
  }
  get _clipPathCache() {
    return this.store.createComputedCache("clipPathCache", (shape) => {
      const pageMask = this._pageMaskCache.get(shape.id);
      if (!pageMask)
        return void 0;
      const pageTransform = this._pageTransformCache.get(shape.id);
      if (!pageTransform)
        return void 0;
      if (pageMask.length === 0) {
        return `polygon(0px 0px, 0px 0px, 0px 0px)`;
      }
      const localMask = import_primitives.Matrix2d.applyToPoints(import_primitives.Matrix2d.Inverse(pageTransform), pageMask);
      return `polygon(${localMask.map((p) => `${p.x}px ${p.y}px`).join(",")})`;
    });
  }
  /**
   * Get the clip path for a shape.
   *
   * @example
   * ```ts
   * const clipPath = editor.getClipPathById(shape.id)
   * ```
   *
   * @param id - The shape id.
   *
   * @returns The clip path or undefined.
   *
   * @public
   */
  getClipPathById(id) {
    return this._clipPathCache.get(id);
  }
  get _pageMaskCache() {
    return this.store.createComputedCache("pageMaskCache", (shape) => {
      if ((0, import_tlschema.isPageId)(shape.parentId)) {
        return void 0;
      }
      const frameAncestors = this.getAncestorsById(shape.id).filter(
        (shape2) => this.isShapeOfType(shape2, import_FrameShapeUtil.FrameShapeUtil)
      );
      if (frameAncestors.length === 0)
        return void 0;
      const pageMask = frameAncestors.map(
        (s) => (
          // Apply the frame transform to the frame outline to get the frame outline in page space
          import_primitives.Matrix2d.applyToPoints(this._pageTransformCache.get(s.id), this.getOutline(s))
        )
      ).reduce((acc, b) => b && acc ? (0, import_primitives.intersectPolygonPolygon)(acc, b) ?? void 0 : void 0);
      return pageMask;
    });
  }
  /**
   * Get the page mask for a shape.
   *
   * @example
   * ```ts
   * const pageMask = editor.getPageMaskById(shape.id)
   * ```
   *
   * @param id - The id of the shape to get the page mask for.
   *
   * @returns The page mask for the shape.
   *
   * @public
   */
  getPageMaskById(id) {
    return this._pageMaskCache.get(id);
  }
  /**
   * Get the page (or absolute) bounds of a shape, incorporating any masks. For example, if the
   * shape were the child of a frame and was half way out of the frame, the bounds would be the half
   * of the shape that was in the frame.
   *
   * @example
   * ```ts
   * editor.getMaskedPageBounds(myShape)
   * ```
   *
   * @param shape - The shape to get the masked bounds for.
   *
   * @public
   */
  getMaskedPageBounds(shape) {
    return this.getMaskedPageBoundsById(shape.id);
  }
  /**
   * Get the page (or absolute) bounds of a shape by its id, incorporating any masks. For example,
   * if the shape were the child of a frame and was half way out of the frame, the bounds would be
   * the half of the shape that was in the frame.
   *
   * @example
   * ```ts
   * editor.getMaskedPageBoundsById(myShape)
   * ```
   *
   * @param id - The id of the shape to get the masked page bounds for.
   *
   * @public
   */
  getMaskedPageBoundsById(id) {
    const pageBounds = this._pageBoundsCache.get(id);
    if (!pageBounds)
      return;
    const pageMask = this._pageMaskCache.get(id);
    if (pageMask) {
      const intersection = (0, import_primitives.intersectPolygonPolygon)(pageMask, pageBounds.corners);
      if (!intersection)
        return;
      return import_primitives.Box2d.FromPoints(intersection);
    }
    return pageBounds;
  }
  /**
   * Get the local outline of a shape.
   *
   * @example
   * ```ts
   * editor.getOutline(myShape)
   * ```
   *
   * @param shape - The shape to get the outline for.
   *
   * @public
   */
  getOutline(shape) {
    return this.getShapeUtil(shape).outline(shape);
  }
  /**
   * Get the local outline of a shape.
   *
   * @example
   * ```ts
   * editor.getOutlineById(myShape)
   * ```
   *
   * @param id - The shape id to get the outline for.
   *
   * @public
   */
  getOutlineById(id) {
    return this.getOutline(this.getShapeById(id));
  }
  /**
   * Get the ancestors of a shape.
   *
   * @example
   * ```ts
   * const ancestors = editor.getAncestors(myShape)
   * ```
   *
   * @param shape - The shape to get the ancestors for.
   *
   * @public
   */
  getAncestors(shape, acc = []) {
    const parentId = shape.parentId;
    if ((0, import_tlschema.isPageId)(parentId)) {
      acc.reverse();
      return acc;
    }
    const parent = this.store.get(parentId);
    if (!parent)
      return acc;
    acc.push(parent);
    return this.getAncestors(parent, acc);
  }
  /**
   * Get the ancestors of a shape by its id.
   *
   * @example
   * ```ts
   * const ancestors = editor.getAncestorsById(myShape)
   * ```
   *
   * @param id - The id of the shape to get the ancestors for.
   *
   * @public
   */
  getAncestorsById(id, acc = []) {
    const shape = this.getShapeById(id);
    if (!shape)
      return acc;
    return this.getAncestors(shape, acc);
  }
  /**
   * Find the first ancestor matching the given predicate
   *
   * @example
   * ```ts
   * const ancestor = editor.findAncestor(myShape)
   * ```
   *
   * @param shape - The shape to check the ancestors for.
   *
   * @public
   */
  findAncestor(shape, predicate) {
    const parentId = shape.parentId;
    if ((0, import_tlschema.isPageId)(parentId)) {
      return void 0;
    }
    const parent = this.getShapeById(parentId);
    if (parent) {
      if (predicate(parent)) {
        return parent;
      }
      return this.findAncestor(parent, predicate);
    }
    return void 0;
  }
  /**
   * Returns true if the the given shape has the given ancestor.
   *
   * @param shape - The shape.
   * @param ancestorId - The id of the ancestor.
   *
   * @public
   */
  hasAncestor(shape, ancestorId) {
    if (!shape)
      return false;
    if (shape.parentId === ancestorId)
      return true;
    return this.hasAncestor(this.getParentShape(shape), ancestorId);
  }
  /**
   * Get the common ancestor of two or more shapes that matches a predicate.
   *
   * @param shapes - The shapes to check.
   * @param predicate - The predicate to match.
   */
  findCommonAncestor(shapes, predicate) {
    if (shapes.length === 0) {
      return;
    }
    if (shapes.length === 1) {
      const parentId = shapes[0].parentId;
      if ((0, import_tlschema.isPageId)(parentId)) {
        return;
      }
      return predicate ? this.findAncestor(shapes[0], predicate)?.id : parentId;
    }
    const [nodeA, ...others] = shapes;
    let ancestor = this.getParentShape(nodeA);
    while (ancestor) {
      if (predicate && !predicate(ancestor)) {
        ancestor = this.getParentShape(ancestor);
        continue;
      }
      if (others.every((shape) => this.hasAncestor(shape, ancestor.id))) {
        return ancestor.id;
      }
      ancestor = this.getParentShape(ancestor);
    }
    return void 0;
  }
  /**
   * Check whether a shape or its parent is locked.
   *
   * @param id - The id of the shape to check.
   *
   * @public
   */
  isShapeOrAncestorLocked(shape) {
    if (shape === void 0)
      return false;
    if (shape.isLocked)
      return true;
    return this.isShapeOrAncestorLocked(this.getParentShape(shape));
  }
  get allShapesCommonBounds() {
    let commonBounds = null;
    this.currentPageShapeIds.forEach((shapeId) => {
      const bounds = this.getMaskedPageBoundsById(shapeId);
      if (bounds) {
        if (commonBounds) {
          commonBounds.expand(bounds);
        } else {
          commonBounds = bounds.clone();
        }
      }
    });
    return commonBounds;
  }
  /**
   * Get the corners of a shape in page space.
   *
   * @example
   * ```ts
   * const corners = editor.getPageCorners(myShape)
   * ```
   *
   * @param shape - The shape to get the corners for.
   *
   * @public
   */
  getPageCorners(shape) {
    const ancestors = this.getAncestors(shape);
    const corners = this.getBounds(shape).corners;
    const transform = import_primitives.Matrix2d.Compose(
      ...ancestors.flatMap((s) => [import_primitives.Matrix2d.Translate(s.x, s.y), import_primitives.Matrix2d.Rotate(s.rotation)]),
      import_primitives.Matrix2d.Translate(shape.x, shape.y),
      import_primitives.Matrix2d.Rotate(shape.rotation, 0, 0)
    );
    return import_primitives.Matrix2d.applyToPoints(transform, corners);
  }
  /**
   * Test whether a point (in page space) will will a shape. This method takes into account masks,
   * such as when a shape is the child of a frame and is partially clipped by the frame.
   *
   * @example
   * ```ts
   * editor.isPointInShape({ x: 100, y: 100 }, myShape)
   * ```
   *
   * @param point - The page point to test.
   * @param shape - The shape to test against.
   *
   * @public
   */
  isPointInShape(point, shape) {
    const util = this.getShapeUtil(shape);
    const pageMask = this._pageMaskCache.get(shape.id);
    if (pageMask) {
      const hit = (0, import_primitives.pointInPolygon)(point, pageMask);
      if (!hit)
        return false;
    }
    return util.hitTestPoint(shape, this.getPointInShapeSpace(shape, point));
  }
  /**
   * Get the shapes, if any, at a given page point.
   *
   * @example
   * ```ts
   * editor.getShapesAtPoint({ x: 100, y: 100 })
   * ```
   *
   * @param point - The page point to test.
   *
   * @public
   */
  getShapesAtPoint(point) {
    return this.shapesArray.filter((shape) => {
      const pageMask = this._pageMaskCache.get(shape.id);
      if (pageMask) {
        return (0, import_primitives.pointInPolygon)(point, pageMask);
      }
      return this.getShapeUtil(shape).hitTestPoint(shape, this.getPointInShapeSpace(shape, point));
    });
  }
  /**
   * Convert a point in page space to a point in the local space of a shape. For example, if a
   * shape's page point were `{ x: 100, y: 100 }`, a page point at `{ x: 110, y: 110 }` would be at
   * `{ x: 10, y: 10 }` in the shape's local space.
   *
   * @example
   * ```ts
   * editor.getPointInShapeSpace(myShape, { x: 100, y: 100 })
   * ```
   *
   * @param shape - The shape to get the point in the local space of.
   * @param point - The page point to get in the local space of the shape.
   *
   * @public
   */
  getPointInShapeSpace(shape, point) {
    return import_primitives.Matrix2d.applyToPoint(import_primitives.Matrix2d.Inverse(this.getPageTransform(shape)), point);
  }
  /**
   * Convert a delta in page space to a point in the local space of a shape. For example, if a
   * shape's page point were `{ x: 100, y: 100 }`, a page point at `{ x: 110, y: 110 }` would be at
   * `{ x: 10, y: 10 }` in the shape's local space.
   *
   * @example
   * ```ts
   * editor.getPointInShapeSpace(myShape.id, { x: 100, y: 100 })
   * ```
   *
   * @param shape - The shape to get the point in the local space of.
   * @param point - The page point to get in the local space of the shape.
   *
   * @public
   */
  getPointInParentSpace(shapeId, point) {
    const shape = this.getShapeById(shapeId);
    if (!shape) {
      return new import_primitives.Vec2d(0, 0);
    }
    if ((0, import_tlschema.isPageId)(shape.parentId))
      return import_primitives.Vec2d.From(point);
    const parentTransform = this.getPageTransformById(shape.parentId);
    if (!parentTransform)
      return import_primitives.Vec2d.From(point);
    return import_primitives.Matrix2d.applyToPoint(import_primitives.Matrix2d.Inverse(parentTransform), point);
  }
  /**
   * Convert a delta in page space to a delta in the local space of a shape.
   *
   * @example
   * ```ts
   * editor.getDeltaInShapeSpace(myShape, { x: 100, y: 100 })
   * ```
   *
   * @param shape - The shape to get the delta in the local space of.
   * @param delta - The page delta to convert.
   *
   * @public
   */
  getDeltaInShapeSpace(shape, delta) {
    const pageTransform = this.getPageTransform(shape);
    if (!pageTransform)
      return import_primitives.Vec2d.From(delta);
    return import_primitives.Vec2d.Rot(delta, -import_primitives.Matrix2d.Decompose(pageTransform).rotation);
  }
  /**
   * Convert a delta in page space to a delta in the parent space of a shape.
   *
   * @example
   * ```ts
   * editor.getDeltaInParentSpace(myShape, { x: 100, y: 100 })
   * ```
   *
   * @param shape - The shape to get the delta in the parent space of.
   * @param delta - The page delta to convert.
   *
   * @public
   */
  getDeltaInParentSpace(shape, delta) {
    if ((0, import_tlschema.isPageId)(shape.parentId))
      return import_primitives.Vec2d.From(delta);
    const parent = this.getShapeById(shape.parentId);
    if (!parent)
      return import_primitives.Vec2d.From(delta);
    return this.getDeltaInShapeSpace(parent, delta);
  }
  /**
   * For a given set of ids, get a map containing the ids of their parents and the children of those
   * parents.
   *
   * @example
   * ```ts
   * editor.getParentsMappedToChildren(['id1', 'id2', 'id3'])
   * ```
   *
   * @param ids - The ids to get the parents and children of.
   *
   * @public
   */
  getParentsMappedToChildren(ids) {
    const shapes = ids.map((id) => this.store.get(id));
    const parents = /* @__PURE__ */ new Map();
    shapes.forEach((shape) => {
      if (!parents.has(shape.parentId)) {
        parents.set(shape.parentId, /* @__PURE__ */ new Set());
      }
      parents.get(shape.parentId)?.add(shape);
    });
    return parents;
  }
  get selectedPageBounds() {
    const {
      pageState: { selectedIds }
    } = this;
    if (selectedIds.length === 0)
      return null;
    return import_primitives.Box2d.Common((0, import_utils.compact)(selectedIds.map((id) => this.getPageBoundsById(id))));
  }
  get selectionRotation() {
    const { selectedIds } = this;
    if (selectedIds.length === 0) {
      return 0;
    }
    if (selectedIds.length === 1) {
      return this.getPageRotationById(this.selectedIds[0]);
    }
    const allRotations = selectedIds.map((id) => this.getPageRotationById(id) % (Math.PI / 2));
    if (allRotations.every((rotation) => Math.abs(rotation - allRotations[0]) < Math.PI / 180)) {
      return this.getPageRotationById(selectedIds[0]);
    }
    return 0;
  }
  get selectionBounds() {
    const { selectedIds } = this;
    if (selectedIds.length === 0) {
      return void 0;
    }
    const { selectionRotation } = this;
    if (selectionRotation === 0) {
      return this.selectedPageBounds;
    }
    if (selectedIds.length === 1) {
      const bounds = this.getBounds(this.getShapeById(selectedIds[0])).clone();
      bounds.point = import_primitives.Matrix2d.applyToPoint(this.getPageTransformById(selectedIds[0]), bounds.point);
      return bounds;
    }
    const allPoints = this.selectedIds.flatMap((id) => {
      const pageTransform = this.getPageTransformById(id);
      if (!pageTransform)
        return [];
      return this.getOutlineById(id).map((point) => import_primitives.Matrix2d.applyToPoint(pageTransform, point));
    }).map((p) => import_primitives.Vec2d.Rot(p, -selectionRotation));
    const box = import_primitives.Box2d.FromPoints(allPoints);
    box.point = box.point.rot(selectionRotation);
    return box;
  }
  get selectionPageCenter() {
    const { selectionBounds, selectionRotation } = this;
    if (!selectionBounds)
      return null;
    return import_primitives.Vec2d.RotWith(selectionBounds.center, selectionBounds.point, selectionRotation);
  }
  /* ------------------- Statechart ------------------- */
  /**
   * The id of the current selected tool.
   *
   * @public
   */
  get currentToolId() {
    const activeTool = this.root.current.value;
    let activeToolId = activeTool?.id;
    if (activeToolId === "select" || activeToolId === "zoom") {
      const currentChildState = activeTool?.current.value;
      activeToolId = currentChildState?.info?.onInteractionEnd ?? "select";
    }
    return activeToolId ?? "select";
  }
  /**
   * Set the selected tool.
   *
   * @example
   * ```ts
   * editor.setSelectedTool('hand')
   * editor.setSelectedTool('hand', { date: Date.now() })
   * ```
   *
   * @param id - The id of the tool to select.
   * @param info - Arbitrary data to pass along into the transition.
   *
   * @public
   */
  setSelectedTool(id, info = {}) {
    this.root.transition(id, info);
    return this;
  }
  /**
   * Get a descendant by its path.
   *
   * @example
   * ```ts
   * state.getStateDescendant('select')
   * state.getStateDescendant('select.brushing')
   * ```
   *
   * @param path - The descendant's path of state ids, separated by periods.
   *
   * @public
   */
  getStateDescendant(path) {
    const ids = path.split(".").reverse();
    let state = this.root;
    while (ids.length > 0) {
      const id = ids.pop();
      if (!id)
        return state;
      const childState = state.children?.[id];
      if (!childState)
        return void 0;
      state = childState;
    }
    return state;
  }
  /**
   * Get whether a certain tool (or other state node) is currently active.
   *
   * @example
   * ```ts
   * editor.isIn('select')
   * editor.isIn('select.brushing')
   * ```
   *
   * @param path - The path of active states, separated by periods.
   *
   * @public
   */
  isIn(path) {
    const ids = path.split(".").reverse();
    let state = this.root;
    while (ids.length > 0) {
      const id = ids.pop();
      if (!id)
        return true;
      const current = state.current.value;
      if (current?.id === id) {
        if (ids.length === 0)
          return true;
        state = current;
        continue;
      } else
        return false;
    }
    return false;
  }
  /**
   * Get whether the state node is in any of the given active paths.
   *
   * @example
   * ```ts
   * state.isInAny('select', 'erase')
   * state.isInAny('select.brushing', 'erase.idle')
   * ```
   *
   * @public
   */
  isInAny(...paths) {
    return paths.some((path) => this.isIn(path));
  }
  /* --------------------- Inputs --------------------- */
  /**
   * The app's current input state.
   *
   * @public
   */
  inputs = {
    /** The most recent pointer down's position in page space. */
    originPagePoint: new import_primitives.Vec2d(),
    /** The most recent pointer down's position in screen space. */
    originScreenPoint: new import_primitives.Vec2d(),
    /** The previous pointer position in page space. */
    previousPagePoint: new import_primitives.Vec2d(),
    /** The previous pointer position in screen space. */
    previousScreenPoint: new import_primitives.Vec2d(),
    /** The most recent pointer position in page space. */
    currentPagePoint: new import_primitives.Vec2d(),
    /** The most recent pointer position in screen space. */
    currentScreenPoint: new import_primitives.Vec2d(),
    /** A set containing the currently pressed keys. */
    keys: /* @__PURE__ */ new Set(),
    /** A set containing the currently pressed buttons. */
    buttons: /* @__PURE__ */ new Set(),
    /** Whether the input is from a pe. */
    isPen: false,
    /** Whether the shift key is currently pressed. */
    shiftKey: false,
    /** Whether the control or command key is currently pressed. */
    ctrlKey: false,
    /** Whether the alt or option key is currently pressed. */
    altKey: false,
    /** Whether the user is dragging. */
    isDragging: false,
    /** Whether the user is pointing. */
    isPointing: false,
    /** Whether the user is pinching. */
    isPinching: false,
    /** Whether the user is editing. */
    isEditing: false,
    /** Whether the user is panning. */
    isPanning: false,
    /** Velocity of mouse pointer, in pixels per millisecond */
    pointerVelocity: new import_primitives.Vec2d()
  };
  /**
   * Update the input points from a pointer or pinch event.
   *
   * @param info - The event info.
   */
  _updateInputsFromEvent(info) {
    const { previousScreenPoint, previousPagePoint, currentScreenPoint, currentPagePoint } = this.inputs;
    const { screenBounds } = this.store.unsafeGetWithoutCapture(import_tlschema.TLINSTANCE_ID);
    const { x: sx, y: sy, z: sz } = info.point;
    const { x: cx, y: cy, z: cz } = this.camera;
    previousScreenPoint.setTo(currentScreenPoint);
    previousPagePoint.setTo(currentPagePoint);
    currentScreenPoint.set(sx, sy);
    currentPagePoint.set(
      (sx - screenBounds.x) / cz - cx,
      (sy - screenBounds.y) / cz - cy,
      sz ?? 0.5
    );
    this.inputs.isPen = info.type === "pointer" && info.isPen;
    if (info.name === "pointer_down") {
      this.inputs.pointerVelocity.set(0, 0);
    }
    this.store.put([
      {
        id: import_tlschema.TLPOINTER_ID,
        typeName: "pointer",
        x: currentPagePoint.x,
        y: currentPagePoint.y,
        lastActivityTimestamp: (
          // If our pointer moved only because we're following some other user, then don't
          // update our last activity timestamp; otherwise, update it to the current timestamp.
          info.type === "pointer" && info.pointerId === import_constants.INTERNAL_POINTER_IDS.CAMERA_MOVE ? this.store.get(import_tlschema.TLPOINTER_ID)?.lastActivityTimestamp ?? Date.now() : Date.now()
        )
      }
    ]);
  }
  /* --------------------- Events --------------------- */
  /**
   * A manager for recording multiple click events.
   *
   * @internal
   */
  _clickManager = new import_ClickManager.ClickManager(this);
  /**
   * Prevent a double click event from firing the next time the user clicks
   *
   * @public
   */
  cancelDoubleClick() {
    this._clickManager.cancelDoubleClickTimeout();
  }
  /**
   * The previous cursor. Used for restoring the cursor after pan events.
   *
   * @internal
   */
  _prevCursor = "default";
  /** @internal */
  _shiftKeyTimeout = -1;
  /** @internal */
  _setShiftKeyTimeout = () => {
    this.inputs.shiftKey = false;
    this.dispatch({
      type: "keyboard",
      name: "key_up",
      key: "Shift",
      shiftKey: this.inputs.shiftKey,
      ctrlKey: this.inputs.ctrlKey,
      altKey: this.inputs.altKey,
      code: "ShiftLeft"
    });
  };
  /** @internal */
  _altKeyTimeout = -1;
  /** @internal */
  _setAltKeyTimeout = () => {
    this.inputs.altKey = false;
    this.dispatch({
      type: "keyboard",
      name: "key_up",
      key: "Alt",
      shiftKey: this.inputs.shiftKey,
      ctrlKey: this.inputs.ctrlKey,
      altKey: this.inputs.altKey,
      code: "AltLeft"
    });
  };
  /** @internal */
  _ctrlKeyTimeout = -1;
  /** @internal */
  _setCtrlKeyTimeout = () => {
    this.inputs.ctrlKey = false;
    this.dispatch({
      type: "keyboard",
      name: "key_up",
      key: "Ctrl",
      shiftKey: this.inputs.shiftKey,
      ctrlKey: this.inputs.ctrlKey,
      altKey: this.inputs.altKey,
      code: "ControlLeft"
    });
  };
  /** @internal */
  _restoreToolId = "select";
  /** @internal */
  _pinchStart = 1;
  /** @internal */
  _didPinch = false;
  /** @internal */
  _selectedIdsAtPointerDown = [];
  /** @internal */
  capturedPointerId = null;
  /**
   * Dispatch an event to the editor.
   *
   * @example
   * ```ts
   * editor.dispatch(myPointerEvent)
   * ```
   *
   * @param info - The event info.
   *
   * @public
   */
  dispatch(info) {
    if (this.crashingError)
      return this;
    const { inputs } = this;
    const { type } = info;
    this.batch(() => {
      if (info.type === "misc") {
        if (info.name === "cancel" || info.name === "complete") {
          this.inputs.isDragging = false;
          if (this.inputs.isPanning) {
            this.inputs.isPanning = false;
            this.setCursor({
              type: this._prevCursor
            });
          }
        }
        this.root.handleEvent(info);
        return;
      }
      if (info.shiftKey) {
        clearInterval(this._shiftKeyTimeout);
        this._shiftKeyTimeout = -1;
        inputs.shiftKey = true;
      } else if (!info.shiftKey && inputs.shiftKey && this._shiftKeyTimeout === -1) {
        this._shiftKeyTimeout = setTimeout(this._setShiftKeyTimeout, 150);
      }
      if (info.altKey) {
        clearInterval(this._altKeyTimeout);
        this._altKeyTimeout = -1;
        inputs.altKey = true;
      } else if (!info.altKey && inputs.altKey && this._altKeyTimeout === -1) {
        this._altKeyTimeout = setTimeout(this._setAltKeyTimeout, 150);
      }
      if (info.ctrlKey) {
        clearInterval(this._ctrlKeyTimeout);
        this._ctrlKeyTimeout = -1;
        inputs.ctrlKey = true;
      } else if (!info.ctrlKey && inputs.ctrlKey && this._ctrlKeyTimeout === -1) {
        this._ctrlKeyTimeout = setTimeout(this._setCtrlKeyTimeout, 150);
      }
      const { originPagePoint, originScreenPoint, currentPagePoint, currentScreenPoint } = inputs;
      if (!inputs.isPointing) {
        inputs.isDragging = false;
      }
      switch (type) {
        case "pinch": {
          if (!this.canMoveCamera)
            return;
          this._updateInputsFromEvent(info);
          switch (info.name) {
            case "pinch_start": {
              if (inputs.isPinching)
                return;
              if (!inputs.isEditing) {
                this._pinchStart = this.camera.z;
                if (!this._selectedIdsAtPointerDown.length) {
                  this._selectedIdsAtPointerDown = this.selectedIds.slice();
                }
                this._didPinch = true;
                inputs.isPinching = true;
                this.interrupt();
              }
              return;
            }
            case "pinch": {
              if (!inputs.isPinching)
                return;
              const {
                point: { x, y, z = 1 },
                delta: { x: dx, y: dy }
              } = info;
              const {
                camera: { x: cx, y: cy, z: cz }
              } = this;
              const zoom = Math.min(import_constants.MAX_ZOOM, Math.max(import_constants.MIN_ZOOM, z));
              this.setCamera(
                cx + dx / cz - x / cz + x / zoom,
                cy + dy / cz - y / cz + y / zoom,
                zoom
              );
              return;
            }
            case "pinch_end": {
              if (!inputs.isPinching)
                return this;
              inputs.isPinching = false;
              const { _selectedIdsAtPointerDown } = this;
              this.setSelectedIds(this._selectedIdsAtPointerDown, true);
              this._selectedIdsAtPointerDown = [];
              const {
                camera: { x: cx, y: cy, z: cz }
              } = this;
              let zoom;
              if (cz > 0.9 && cz < 1.05) {
                zoom = 1;
              } else if (cz > 0.49 && cz < 0.505) {
                zoom = 0.5;
              }
              if (cz > this._pinchStart - 0.1 && cz < this._pinchStart + 0.05) {
                zoom = this._pinchStart;
              }
              if (zoom !== void 0) {
                const { x, y } = this.viewportScreenCenter;
                this.animateCamera(
                  cx + (x / zoom - x) - (x / cz - x),
                  cy + (y / zoom - y) - (y / cz - y),
                  zoom,
                  { duration: 100 }
                );
              }
              if (this._didPinch) {
                this._didPinch = false;
                requestAnimationFrame(() => {
                  if (!this._didPinch) {
                    this.setSelectedIds(_selectedIdsAtPointerDown, true);
                  }
                });
              }
              return;
            }
          }
        }
        case "wheel": {
          if (!this.canMoveCamera)
            return;
          if (this.isMenuOpen) {
          } else {
            if (inputs.ctrlKey) {
              const { x, y } = this.inputs.currentScreenPoint;
              const { x: cx, y: cy, z: cz } = this.camera;
              const zoom = Math.min(import_constants.MAX_ZOOM, Math.max(import_constants.MIN_ZOOM, cz + (info.delta.z ?? 0) * cz));
              this.setCamera(
                cx + (x / zoom - x) - (x / cz - x),
                cy + (y / zoom - y) - (y / cz - y),
                zoom
              );
              return;
            }
            this.pan(info.delta.x, info.delta.y);
            if (!inputs.isDragging && inputs.isPointing && originPagePoint.dist(currentPagePoint) > (this.isCoarsePointer ? import_constants.COARSE_DRAG_DISTANCE : import_constants.DRAG_DISTANCE) / this.zoomLevel) {
              inputs.isDragging = true;
            }
          }
          break;
        }
        case "pointer": {
          if (inputs.isPinching)
            return;
          this._updateInputsFromEvent(info);
          const { isPen } = info;
          switch (info.name) {
            case "pointer_down": {
              this._selectedIdsAtPointerDown = this.selectedIds.slice();
              if (info.button === 0) {
                this.capturedPointerId = info.pointerId;
              }
              inputs.buttons.add(info.button);
              inputs.isPointing = true;
              inputs.isDragging = false;
              if (this.isPenMode) {
                if (!isPen) {
                  this._touchEventsRemainingBeforeExitingPenMode--;
                  if (this._touchEventsRemainingBeforeExitingPenMode === 0) {
                    this.setPenMode(false);
                  } else {
                    return;
                  }
                } else {
                  this._touchEventsRemainingBeforeExitingPenMode = 3;
                }
              } else {
                if (isPen) {
                  this.setPenMode(true);
                }
              }
              if (info.button === 5) {
                this._restoreToolId = this.currentToolId;
                this.complete();
                this.setSelectedTool("eraser");
              } else if (info.button === 1) {
                if (!this.inputs.isPanning) {
                  this._prevCursor = this.instanceState.cursor.type;
                }
                this.inputs.isPanning = true;
              }
              if (this.inputs.isPanning) {
                this.stopCameraAnimation();
                this.setCursor({
                  type: "grabbing"
                });
                return this;
              }
              originScreenPoint.setTo(currentScreenPoint);
              originPagePoint.setTo(currentPagePoint);
              break;
            }
            case "pointer_move": {
              if (!isPen && this.isPenMode) {
                return;
              }
              if (this.inputs.isPanning && this.inputs.isPointing) {
                const { currentScreenPoint: currentScreenPoint2, previousScreenPoint } = this.inputs;
                const delta = import_primitives.Vec2d.Sub(currentScreenPoint2, previousScreenPoint);
                this.pan(delta.x, delta.y);
                return;
              }
              if (!inputs.isDragging && inputs.isPointing && originPagePoint.dist(currentPagePoint) > (this.isCoarsePointer ? import_constants.COARSE_DRAG_DISTANCE : import_constants.DRAG_DISTANCE) / this.zoomLevel) {
                inputs.isDragging = true;
              }
              break;
            }
            case "pointer_up": {
              inputs.buttons.delete(info.button);
              inputs.isPointing = false;
              inputs.isDragging = false;
              if (this.isMenuOpen) {
                return;
              }
              if (!isPen && this.isPenMode) {
                return;
              }
              if (this.capturedPointerId === info.pointerId) {
                this.capturedPointerId = null;
                info.button = 0;
              }
              if (inputs.isPanning) {
                if (info.button === 1) {
                  if (!this.inputs.keys.has(" ")) {
                    inputs.isPanning = false;
                    this.slideCamera({
                      speed: Math.min(2, this.inputs.pointerVelocity.len()),
                      direction: this.inputs.pointerVelocity,
                      friction: import_constants.HAND_TOOL_FRICTION
                    });
                    this.setCursor({
                      type: this._prevCursor
                    });
                  } else {
                    this.slideCamera({
                      speed: Math.min(2, this.inputs.pointerVelocity.len()),
                      direction: this.inputs.pointerVelocity,
                      friction: import_constants.HAND_TOOL_FRICTION
                    });
                    this.setCursor({
                      type: "grab"
                    });
                  }
                } else if (info.button === 0) {
                  this.slideCamera({
                    speed: Math.min(2, this.inputs.pointerVelocity.len()),
                    direction: this.inputs.pointerVelocity,
                    friction: import_constants.HAND_TOOL_FRICTION
                  });
                  this.setCursor({
                    type: "grab"
                  });
                }
              } else {
                if (info.button === 5) {
                  this.complete();
                  this.setSelectedTool(this._restoreToolId);
                }
              }
              break;
            }
          }
          break;
        }
        case "keyboard": {
          if (info.key === "ShiftRight")
            info.key = "ShiftLeft";
          if (info.key === "AltRight")
            info.key = "AltLeft";
          if (info.code === "ControlRight")
            info.code = "ControlLeft";
          switch (info.name) {
            case "key_down": {
              inputs.keys.add(info.code);
              if (!info.ctrlKey && info.code === "Space") {
                if (!this.inputs.isPanning) {
                  this._prevCursor = this.instanceState.cursor.type;
                }
                this.inputs.isPanning = true;
                this.setCursor({
                  type: this.inputs.isPointing ? "grabbing" : "grab"
                });
              }
              break;
            }
            case "key_up": {
              inputs.keys.delete(info.code);
              if (info.code === "Space" && !this.inputs.buttons.has(1)) {
                this.inputs.isPanning = false;
                this.setCursor({
                  type: this._prevCursor
                });
              }
              break;
            }
            case "key_repeat": {
              break;
            }
          }
          break;
        }
      }
      if (info.type === "pointer") {
        if (info.button === 1) {
          info.name = "middle_click";
        } else if (info.button === 2) {
          info.name = "right_click";
        }
        if (info.isPen === this.isPenMode) {
          switch (info.name) {
            case "pointer_down": {
              const otherEvent = this._clickManager.transformPointerDownEvent(info);
              if (info.name !== otherEvent.name) {
                this.root.handleEvent(info);
                this.emit("event", info);
                this.root.handleEvent(otherEvent);
                this.emit("event", otherEvent);
                return;
              }
              break;
            }
            case "pointer_up": {
              const otherEvent = this._clickManager.transformPointerUpEvent(info);
              if (info.name !== otherEvent.name) {
                this.root.handleEvent(info);
                this.emit("event", info);
                this.root.handleEvent(otherEvent);
                this.emit("event", otherEvent);
                return;
              }
              break;
            }
            case "pointer_move": {
              this._clickManager.handleMove();
              break;
            }
          }
        }
      }
      this.root.handleEvent(info);
      this.emit("event", info);
    });
    return this;
  }
  /**
   * Replace the store's contents with the given records.
   *
   * @param records - The records to replace the store's contents with.
   */
  replaceStoreContentsWithRecordsForOtherDocument(records) {
    (0, import_signia.transact)(() => {
      this.store.clear();
      const [shapes, nonShapes] = (0, import_utils.partition)(records, (record) => record.typeName === "shape");
      this.store.put(nonShapes, "initialize");
      this.store.ensureStoreIsUsable();
      this.store.put(shapes, "initialize");
      this.history.clear();
      this.updateViewportScreenBounds();
      this.updateRenderingBounds();
      const bounds = this.allShapesCommonBounds;
      if (bounds) {
        this.zoomToBounds(bounds.minX, bounds.minY, bounds.width, bounds.height, 1);
      }
    });
  }
  /**
   * Get content that can be exported for the given shape ids.
   *
   * @param ids - The ids of the shapes to get content for. Defaults to the selected shape ids.
   *
   * @returns The exported content.
   *
   * @public
   */
  getContent(ids = this.selectedIds) {
    if (!ids)
      return;
    if (ids.length === 0)
      return;
    const pageTransforms = {};
    let shapes = (0, import_utils.dedupe)(
      ids.map((id) => this.getShapeById(id)).sort(import_indices.sortByIndex).flatMap((shape) => {
        const allShapes = [shape];
        this.visitDescendants(shape.id, (descendant) => {
          allShapes.push(this.getShapeById(descendant));
        });
        return allShapes;
      })
    );
    shapes = shapes.map((shape) => {
      pageTransforms[shape.id] = this.getPageTransformById(shape.id);
      shape = (0, import_utils.structuredClone)(shape);
      if (this.isShapeOfType(shape, import_ArrowShapeUtil.ArrowShapeUtil)) {
        const startBindingId = shape.props.start.type === "binding" ? shape.props.start.boundShapeId : void 0;
        const endBindingId = shape.props.end.type === "binding" ? shape.props.end.boundShapeId : void 0;
        const info = this.getShapeUtil(import_ArrowShapeUtil.ArrowShapeUtil).getArrowInfo(shape);
        if (shape.props.start.type === "binding") {
          if (!shapes.some((s) => s.id === startBindingId)) {
            if (info?.isValid) {
              const { x, y } = info.start.point;
              shape.props.start = {
                type: "point",
                x,
                y
              };
            } else {
              const { start } = (0, import_shared.getArrowTerminalsInArrowSpace)(this, shape);
              shape.props.start = {
                type: "point",
                x: start.x,
                y: start.y
              };
            }
          }
        }
        if (shape.props.end.type === "binding") {
          if (!shapes.some((s) => s.id === endBindingId)) {
            if (info?.isValid) {
              const { x, y } = info.end.point;
              shape.props.end = {
                type: "point",
                x,
                y
              };
            } else {
              const { end } = (0, import_shared.getArrowTerminalsInArrowSpace)(this, shape);
              shape.props.end = {
                type: "point",
                x: end.x,
                y: end.y
              };
            }
          }
        }
        const infoAfter = (0, import_shared.getIsArrowStraight)(shape) ? (0, import_straight_arrow.getStraightArrowInfo)(this, shape) : (0, import_curved_arrow.getCurvedArrowInfo)(this, shape);
        if (info?.isValid && infoAfter?.isValid && !(0, import_shared.getIsArrowStraight)(shape)) {
          const mpA = import_primitives.Vec2d.Med(info.start.handle, info.end.handle);
          const distA = import_primitives.Vec2d.Dist(info.middle, mpA);
          const distB = import_primitives.Vec2d.Dist(infoAfter.middle, mpA);
          if (shape.props.bend < 0) {
            shape.props.bend += distB - distA;
          } else {
            shape.props.bend -= distB - distA;
          }
        }
        return shape;
      }
      return shape;
    });
    const rootShapeIds = [];
    shapes.forEach((shape) => {
      if (shapes.find((s) => s.id === shape.parentId) === void 0) {
        const pagePoint = this.getPagePointById(shape.id);
        const pageRotation = this.getPageRotationById(shape.id);
        shape.x = pagePoint.x;
        shape.y = pagePoint.y;
        shape.rotation = pageRotation;
        shape.parentId = this.currentPageId;
        rootShapeIds.push(shape.id);
      }
    });
    const assetsSet = /* @__PURE__ */ new Set();
    shapes.forEach((shape) => {
      if ("assetId" in shape.props) {
        if (shape.props.assetId !== null) {
          assetsSet.add(shape.props.assetId);
        }
      }
    });
    return {
      shapes,
      rootShapeIds,
      schema: this.store.schema.serialize(),
      assets: (0, import_utils.compact)(Array.from(assetsSet).map((id) => this.getAssetById(id)))
    };
  }
  /* --------------------- Commands --------------------- */
  /**
   * Place content into the editor.
   *
   * @param content - The content.
   * @param options - Options for placing the content.
   *
   * @public
   */
  putContent(content, options = {}) {
    if (this.isReadOnly)
      return this;
    if (!content.schema) {
      throw Error("Could not put content: content is missing a schema.");
    }
    const { select = false, preserveIds = false, preservePosition = false } = options;
    let { point = void 0 } = options;
    const { currentPageId } = this;
    const { assets, shapes, rootShapeIds } = content;
    const idMap = new Map(shapes.map((shape) => [shape.id, (0, import_tlschema.createShapeId)()]));
    let pasteParentId = this.currentPageId;
    let lowestDepth = Infinity;
    let lowestAncestors = [];
    for (const shape of this.selectedShapes) {
      if (lowestDepth === 0)
        break;
      const isFrame = this.isShapeOfType(shape, import_FrameShapeUtil.FrameShapeUtil);
      const ancestors = this.getAncestors(shape);
      if (isFrame)
        ancestors.push(shape);
      const depth = isFrame ? ancestors.length + 1 : ancestors.length;
      if (depth < lowestDepth) {
        lowestDepth = depth;
        lowestAncestors = ancestors;
        pasteParentId = isFrame ? shape.id : shape.parentId;
      } else if (depth === lowestDepth) {
        if (lowestAncestors.length !== ancestors.length) {
          throw Error(`Ancestors: ${lowestAncestors.length} !== ${ancestors.length}`);
        }
        if (lowestAncestors.length === 0) {
          pasteParentId = currentPageId;
          break;
        } else {
          pasteParentId = currentPageId;
          for (let i = 0; i < lowestAncestors.length; i++) {
            if (ancestors[i] !== lowestAncestors[i])
              break;
            pasteParentId = ancestors[i].id;
          }
        }
      }
    }
    let isDuplicating = false;
    if (!(0, import_tlschema.isPageId)(pasteParentId)) {
      const parent = this.getShapeById(pasteParentId);
      if (parent) {
        if (!this.viewportPageBounds.includes(this.getPageBounds(parent))) {
          pasteParentId = currentPageId;
        } else {
          if (rootShapeIds.length === 1) {
            const rootShape = shapes.find((s) => s.id === rootShapeIds[0]);
            if (this.isShapeOfType(parent, import_FrameShapeUtil.FrameShapeUtil) && this.isShapeOfType(rootShape, import_FrameShapeUtil.FrameShapeUtil) && rootShape.props.w === parent?.props.w && rootShape.props.h === parent?.props.h) {
              isDuplicating = true;
            }
          }
        }
      } else {
        pasteParentId = currentPageId;
      }
    }
    if (!isDuplicating) {
      isDuplicating = idMap.has(pasteParentId);
    }
    if (isDuplicating) {
      pasteParentId = this.getShapeById(pasteParentId).parentId;
    }
    let index = this.getHighestIndexForParent(pasteParentId);
    const rootShapes = [];
    const newShapes = shapes.map((shape) => {
      let newShape;
      if (preserveIds) {
        newShape = (0, import_utils.deepCopy)(shape);
        idMap.set(shape.id, shape.id);
      } else {
        const id = idMap.get(shape.id);
        newShape = (0, import_utils.deepCopy)({ ...shape, id });
      }
      if (rootShapeIds.includes(shape.id)) {
        newShape.parentId = currentPageId;
        rootShapes.push(newShape);
      }
      if (idMap.has(newShape.parentId)) {
        newShape.parentId = idMap.get(shape.parentId);
      } else {
        rootShapeIds.push(newShape.id);
        newShape.index = index;
        index = (0, import_indices.getIndexAbove)(index);
      }
      if (this.isShapeOfType(newShape, import_ArrowShapeUtil.ArrowShapeUtil)) {
        if (newShape.props.start.type === "binding") {
          const mappedId = idMap.get(newShape.props.start.boundShapeId);
          newShape.props.start = mappedId ? { ...newShape.props.start, boundShapeId: mappedId } : (
            // this shouldn't happen, if you copy an arrow but not it's bound shape it should
            // convert the binding to a point at the time of copying
            { type: "point", x: 0, y: 0 }
          );
        }
        if (newShape.props.end.type === "binding") {
          const mappedId = idMap.get(newShape.props.end.boundShapeId);
          newShape.props.end = mappedId ? { ...newShape.props.end, boundShapeId: mappedId } : (
            // this shouldn't happen, if you copy an arrow but not it's bound shape it should
            // convert the binding to a point at the time of copying
            { type: "point", x: 0, y: 0 }
          );
        }
      }
      return newShape;
    });
    if (newShapes.length + this.currentPageShapeIds.size > import_constants.MAX_SHAPES_PER_PAGE) {
      alertMaxShapes(this);
      return this;
    }
    let assetsToCreate = [];
    if (assets) {
      for (let i = 0; i < assets.length; i++) {
        const asset = assets[i];
        const result = this.store.schema.migratePersistedRecord(asset, content.schema);
        if (result.type === "success") {
          assets[i] = result.value;
        } else {
          throw Error(
            `Could not put content: could not migrate content for asset:
${JSON.stringify(
              asset,
              null,
              2
            )}`
          );
        }
      }
      const assetsToUpdate = [];
      assetsToCreate = assets.filter((asset) => !this.store.has(asset.id)).map((asset) => {
        if (asset.type === "image" || asset.type === "video") {
          if (asset.props.src && asset.props.src?.startsWith("data:image")) {
            assetsToUpdate.push((0, import_utils.structuredClone)(asset));
            asset.props.src = null;
          } else {
            assetsToUpdate.push((0, import_utils.structuredClone)(asset));
          }
        }
        return asset;
      });
      Promise.allSettled(
        assetsToUpdate.map(async (asset) => {
          const file = await (0, import_assets.dataUrlToFile)(
            asset.props.src,
            asset.props.name,
            asset.props.mimeType ?? "image/png"
          );
          const newAsset = await this.externalContentManager.createAssetFromFile(this, file);
          return [asset, newAsset];
        })
      ).then((assets2) => {
        this.updateAssets(
          (0, import_utils.compact)(
            assets2.map(
              (result) => result.status === "fulfilled" ? { ...result.value[1], id: result.value[0].id } : void 0
            )
          )
        );
      });
    }
    for (let i = 0; i < newShapes.length; i++) {
      const shape = newShapes[i];
      const result = this.store.schema.migratePersistedRecord(shape, content.schema);
      if (result.type === "success") {
        newShapes[i] = result.value;
      } else {
        throw Error(
          `Could not put content: could not migrate content for shape:
${JSON.stringify(
            shape,
            null,
            2
          )}`
        );
      }
    }
    this.batch(() => {
      if (assetsToCreate.length > 0) {
        this.createAssets(assetsToCreate);
      }
      this.createShapes(newShapes, select);
      if (pasteParentId !== currentPageId) {
        this.reparentShapesById(
          rootShapes.map((s) => s.id),
          pasteParentId
        );
      }
      const newCreatedShapes = newShapes.map((s) => this.getShapeById(s.id));
      const bounds = import_primitives.Box2d.Common(newCreatedShapes.map((s) => this.getPageBounds(s)));
      if (point === void 0) {
        if (!(0, import_tlschema.isPageId)(pasteParentId)) {
          const shape = this.getShapeById(pasteParentId);
          const util = this.getShapeUtil(shape);
          point = util.center(shape);
        } else {
          const { viewportPageBounds } = this;
          if (preservePosition || viewportPageBounds.includes(import_primitives.Box2d.From(bounds))) {
            point = bounds.center;
          } else {
            point = viewportPageBounds.center;
          }
        }
      }
      if (rootShapes.length === 1) {
        const onlyRoot = rootShapes[0];
        if (this.isShapeOfType(onlyRoot, import_FrameShapeUtil.FrameShapeUtil)) {
          while (this.getShapesAtPoint(point).some(
            (shape) => this.isShapeOfType(shape, import_FrameShapeUtil.FrameShapeUtil) && shape.props.w === onlyRoot.props.w && shape.props.h === onlyRoot.props.h
          )) {
            point.x += bounds.w + 16;
          }
        }
      }
      this.updateShapes(
        rootShapes.map((s) => {
          const delta = {
            x: (s.x ?? 0) - (bounds.x + bounds.w / 2),
            y: (s.y ?? 0) - (bounds.y + bounds.h / 2)
          };
          return { id: s.id, type: s.type, x: point.x + delta.x, y: point.y + delta.y };
        })
      );
    });
    return this;
  }
  /**
   * Create shapes.
   *
   * @example
   * ```ts
   * editor.createShapes([{ id: 'box1', type: 'text', props: { text: "ok" } }])
   * ```
   *
   * @param partials - The shape partials to create.
   * @param select - Whether to select the created shapes. Defaults to false.
   *
   * @public
   */
  createShapes(partials, select = false) {
    this._createShapes(partials, select);
    return this;
  }
  /** @internal */
  _createShapes = this.history.createCommand(
    "createShapes",
    (partials, select = false) => {
      if (this.isReadOnly)
        return null;
      if (partials.length <= 0)
        return null;
      const { currentPageShapeIds: shapeIds, selectedIds } = this;
      const prevSelectedIds = select ? selectedIds : void 0;
      const maxShapesReached = partials.length + shapeIds.size > import_constants.MAX_SHAPES_PER_PAGE;
      if (maxShapesReached) {
        alertMaxShapes(this);
      }
      const partialsToCreate = maxShapesReached ? partials.slice(0, import_constants.MAX_SHAPES_PER_PAGE - shapeIds.size) : partials;
      if (partialsToCreate.length === 0)
        return null;
      return {
        data: {
          currentPageId: this.currentPageId,
          createdIds: partials.map((p) => p.id),
          prevSelectedIds,
          partials: partialsToCreate,
          select
        }
      };
    },
    {
      do: ({ createdIds, partials, select }) => {
        const { focusLayerId } = this;
        partials = partials.map((partial) => {
          if (
            // No parentId provided
            !partial.parentId || // A parentId is proved but the parent is neither a) in the store
            // or b) among the other creating shape partials
            !this.store.get(partial.parentId) && !partials.find((p) => p.id === partial.parentId)
          ) {
            partial = { ...partial };
            const parentId = this.getParentIdForNewShapeAtPoint(
              { x: partial.x ?? 0, y: partial.y ?? 0 },
              partial.type
            );
            partial.parentId = parentId;
            if ((0, import_tlschema.isShapeId)(parentId)) {
              const point = this.getPointInShapeSpace(this.getShapeById(parentId), {
                x: partial.x ?? 0,
                y: partial.y ?? 0
              });
              partial.x = point.x;
              partial.y = point.y;
              partial.rotation = -this.getPageRotationById(parentId) + (partial.rotation ?? 0);
            }
            if (partial.parentId === partial.id) {
              partial.parentId = focusLayerId;
            }
            return partial;
          }
          return partial;
        });
        const parentIndices = /* @__PURE__ */ new Map();
        const shapeRecordsToCreate = [];
        for (const partial of partials) {
          const util = this.getShapeUtil(partial);
          let index = partial.index;
          if (!index) {
            const parentId = partial.parentId ?? focusLayerId;
            if (!parentIndices.has(parentId)) {
              parentIndices.set(parentId, this.getHighestIndexForParent(parentId));
            }
            index = parentIndices.get(parentId);
            parentIndices.set(parentId, (0, import_indices.getIndexAbove)(index));
          }
          const initialProps = util.defaultProps();
          for (const [style, propKey] of util.styleProps) {
            ;
            initialProps[propKey] = this.getStyleForNextShape(style);
          }
          let shapeRecordToCreate = this.store.schema.types.shape.create({
            ...partial,
            index,
            opacity: partial.opacity ?? this.instanceState.opacityForNextShape,
            parentId: partial.parentId ?? focusLayerId,
            props: "props" in partial ? { ...initialProps, ...partial.props } : initialProps
          });
          if (shapeRecordToCreate.index === void 0) {
            throw Error("no index!");
          }
          const next = this.getShapeUtil(shapeRecordToCreate).onBeforeCreate?.(shapeRecordToCreate);
          if (next) {
            shapeRecordToCreate = next;
          }
          shapeRecordsToCreate.push(shapeRecordToCreate);
        }
        this.store.put(shapeRecordsToCreate);
        if (select) {
          this.store.update(this.pageState.id, (state) => ({
            ...state,
            selectedIds: createdIds
          }));
        }
      },
      undo: ({ createdIds, prevSelectedIds }) => {
        this.store.remove(createdIds);
        if (prevSelectedIds) {
          this.store.update(this.pageState.id, (state) => ({
            ...state,
            selectedIds: prevSelectedIds
          }));
        }
      }
    }
  );
  animatingShapes = /* @__PURE__ */ new Map();
  /**
   * Animate shapes.
   *
   * @example
   * ```ts
   * editor.animateShapes([{ id: 'box1', type: 'box', x: 100, y: 100 }])
   * ```
   *
   * @param partials - The shape partials to update.
   *
   * @public
   */
  animateShapes(partials, options = {}) {
    const { duration = 500, ease = import_primitives.EASINGS.linear } = options;
    const animationId = (0, import_data.uniqueId)();
    let remaining = duration;
    let t;
    const animations = [];
    partials.forEach((partial) => {
      if (!partial)
        return;
      const result = {
        partial,
        values: []
      };
      const shape = this.getShapeById(partial.id);
      if (!shape)
        return;
      for (const key of ["x", "y", "rotation"]) {
        if (partial[key] !== void 0 && shape[key] !== partial[key]) {
          result.values.push({ prop: key, from: shape[key], to: partial[key] });
        }
      }
      animations.push(result);
      this.animatingShapes.set(shape.id, animationId);
    });
    let value;
    const handleTick = (elapsed) => {
      remaining -= elapsed;
      if (remaining < 0) {
        const { animatingShapes: animatingShapes2 } = this;
        const partialsToUpdate = partials.filter(
          (p) => p && animatingShapes2.get(p.id) === animationId
        );
        if (partialsToUpdate.length) {
          this.updateShapes(partialsToUpdate, false);
        }
        this.removeListener("tick", handleTick);
        return;
      }
      t = ease(1 - remaining / duration);
      const { animatingShapes } = this;
      try {
        const tPartials = [];
        for (let i = 0; i < animations.length; i++) {
          value = animations[i];
          if (animatingShapes.get(value.partial.id) === animationId) {
            tPartials.push({
              id: value.partial.id,
              type: value.partial.type,
              ...value.values.reduce((acc, { prop, from, to }) => {
                acc[prop] = from + (to - from) * t;
                return acc;
              }, {})
            });
          }
        }
        this._updateShapes(tPartials, true);
      } catch (e) {
      }
    };
    this.addListener("tick", handleTick);
    return this;
  }
  /**
   * Update shapes using partials of each shape.
   *
   * @example
   * ```ts
   * editor.updateShapes([{ id: 'box1', type: 'geo', props: { w: 100, h: 100 } }])
   * ```
   *
   * @param partials - The shape partials to update.
   * @param squashing - Whether the change is ephemeral.
   *
   * @public
   */
  updateShapes(partials, squashing = false) {
    let compactedPartials = (0, import_utils.compact)(partials);
    if (this.animatingShapes.size > 0) {
      compactedPartials.forEach((p) => this.animatingShapes.delete(p.id));
    }
    compactedPartials = compactedPartials.filter((p) => {
      const shape = this.getShapeById(p.id);
      if (!shape)
        return false;
      if (this.isShapeOrAncestorLocked(shape) && !Object.hasOwn(p, "isLocked"))
        return false;
      return true;
    });
    this._updateShapes(compactedPartials, squashing);
    return this;
  }
  /** @internal */
  _updateShapes = this.history.createCommand(
    "updateShapes",
    (_partials, squashing = false) => {
      if (this.isReadOnly)
        return null;
      const partials = (0, import_utils.compact)(_partials);
      const snapshots = Object.fromEntries(
        (0, import_utils.compact)(partials.map(({ id }) => this.getShapeById(id))).map((shape) => {
          return [shape.id, shape];
        })
      );
      if (partials.length <= 0)
        return null;
      const updated = (0, import_utils.compact)(
        partials.map((partial) => {
          const prev = snapshots[partial.id];
          if (!prev)
            return null;
          let newRecord = null;
          for (const [k, v] of Object.entries(partial)) {
            if (v === void 0)
              continue;
            switch (k) {
              case "id":
              case "type":
              case "typeName": {
                continue;
              }
              default: {
                if (v !== prev[k]) {
                  if (!newRecord) {
                    newRecord = { ...prev };
                  }
                  if (k === "props") {
                    const nextProps = { ...prev.props };
                    for (const [propKey, propValue] of Object.entries(v)) {
                      if (propValue === void 0)
                        continue;
                      nextProps[propKey] = propValue;
                    }
                    newRecord.props = nextProps;
                  } else {
                    ;
                    newRecord[k] = v;
                  }
                }
              }
            }
          }
          return newRecord ?? prev;
        })
      );
      const updates = Object.fromEntries(updated.map((shape) => [shape.id, shape]));
      return { data: { snapshots, updates }, squashing };
    },
    {
      do: ({ updates }) => {
        const result = Object.values(updates);
        for (let i = 0; i < result.length; i++) {
          const shape = result[i];
          const current = this.store.get(shape.id);
          if (!current)
            continue;
          const next = this.getShapeUtil(shape).onBeforeUpdate?.(current, shape);
          if (next) {
            result[i] = next;
          }
        }
        this.store.put(result);
      },
      undo: ({ snapshots }) => {
        this.store.put(Object.values(snapshots));
      },
      squash(prevData, nextData) {
        return {
          // keep the oldest snapshots
          snapshots: { ...nextData.snapshots, ...prevData.snapshots },
          // keep the newest updates
          updates: { ...prevData.updates, ...nextData.updates }
        };
      }
    }
  );
  /** @internal */
  _getUnlockedShapeIds(ids) {
    return ids.filter((id) => !this.getShapeById(id)?.isLocked);
  }
  /**
   * Delete shapes.
   *
   * @example
   * ```ts
   * editor.deleteShapes()
   * editor.deleteShapes(['box1', 'box2'])
   * ```
   *
   * @param ids - The ids of the shapes to delete. Defaults to the selected shapes.
   *
   * @public
   */
  deleteShapes(ids = this.selectedIds) {
    this._deleteShapes(this._getUnlockedShapeIds(ids));
    return this;
  }
  /** @internal */
  _deleteShapes = this.history.createCommand(
    "delete_shapes",
    (ids) => {
      if (this.isReadOnly)
        return null;
      if (ids.length === 0)
        return null;
      const prevSelectedIds = [...this.pageState.selectedIds];
      const allIds = new Set(ids);
      for (const id of ids) {
        this.visitDescendants(id, (childId) => {
          allIds.add(childId);
        });
      }
      const deletedIds = [...allIds];
      const arrowBindings = this._arrowBindingsIndex.value;
      const snapshots = (0, import_utils.compact)(
        deletedIds.flatMap((id) => {
          const shape = this.getShapeById(id);
          const bindings = arrowBindings[id];
          if (bindings && bindings.length > 0) {
            return bindings.map(({ arrowId }) => this.getShapeById(arrowId)).concat(shape);
          }
          return shape;
        })
      );
      const postSelectedIds = prevSelectedIds.filter((id) => !allIds.has(id));
      return { data: { deletedIds, snapshots, prevSelectedIds, postSelectedIds } };
    },
    {
      do: ({ deletedIds, postSelectedIds }) => {
        this.store.remove(deletedIds);
        this.store.update(this.pageState.id, (state) => ({
          ...state,
          selectedIds: postSelectedIds
        }));
      },
      undo: ({ snapshots, prevSelectedIds }) => {
        this.store.put(snapshots);
        this.store.update(this.pageState.id, (state) => ({
          ...state,
          selectedIds: prevSelectedIds
        }));
      }
    }
  );
  /**
   * Get the user's locale.
   *
   * @public
   */
  get locale() {
    return this.user.locale;
  }
  /**
   * Update the user's locale. This affects which translations are used when rendering UI elements.
   *
   * @example
   * ```ts
   * editor.setLocale('fr')
   * ```
   *
   * @public
   */
  setLocale(locale) {
    this.user.updateUserPreferences({ locale });
  }
  /**
   * Update a page.
   *
   * @example
   * ```ts
   * editor.updatePage({ id: 'page2', name: 'Page 2' })
   * ```
   *
   * @param partial - The partial of the shape to update.
   *
   * @public
   */
  updatePage(partial, squashing = false) {
    this._updatePage(partial, squashing);
    return this;
  }
  /** @internal */
  _updatePage = this.history.createCommand(
    "updatePage",
    (partial, squashing = false) => {
      if (this.isReadOnly)
        return null;
      const prev = this.getPageById(partial.id);
      if (!prev)
        return null;
      return { data: { prev, partial }, squashing };
    },
    {
      do: ({ partial }) => {
        this.store.update(partial.id, (page) => ({ ...page, ...partial }));
      },
      undo: ({ prev, partial }) => {
        this.store.update(partial.id, () => prev);
      },
      squash(prevData, nextData) {
        return {
          prev: { ...prevData.prev, ...nextData.prev },
          partial: nextData.partial
        };
      }
    }
  );
  /**
   * Create a page.
   *
   * @example
   * ```ts
   * editor.createPage('New Page')
   * editor.createPage('New Page', 'page1')
   * ```
   *
   * @param id - The new page's id.
   * @param title - The new page's title.
   *
   * @public
   */
  createPage(title, id = import_tlschema.PageRecordType.createId(), belowPageIndex) {
    this._createPage(title, id, belowPageIndex);
    return this;
  }
  /** @internal */
  _createPage = this.history.createCommand(
    "createPage",
    (title, id = import_tlschema.PageRecordType.createId(), belowPageIndex) => {
      if (this.isReadOnly)
        return null;
      if (this.pages.length >= import_constants.MAX_PAGES)
        return null;
      const pageInfo = this.pages;
      const topIndex = belowPageIndex ?? pageInfo[pageInfo.length - 1]?.index ?? "a1";
      const bottomIndex = pageInfo[pageInfo.findIndex((p) => p.index === topIndex) + 1]?.index;
      title = (0, import_data.getIncrementedName)(
        title,
        pageInfo.map((p) => p.name)
      );
      const newPage = import_tlschema.PageRecordType.create({
        id,
        name: title,
        index: bottomIndex && topIndex !== bottomIndex ? (0, import_indices.getIndexBetween)(topIndex, bottomIndex) : (0, import_indices.getIndexAbove)(topIndex)
      });
      const newCamera = import_tlschema.CameraRecordType.create({
        id: import_tlschema.CameraRecordType.createId(newPage.id)
      });
      const newTabPageState = import_tlschema.InstancePageStateRecordType.create({
        id: import_tlschema.InstancePageStateRecordType.createId(newPage.id),
        pageId: newPage.id
      });
      return {
        data: {
          prevSelectedPageId: this.currentPageId,
          newPage,
          newTabPageState,
          newCamera
        }
      };
    },
    {
      do: ({ newPage, newTabPageState, newCamera }) => {
        this.store.put([
          newPage,
          newCamera,
          newTabPageState,
          { ...this.instanceState, currentPageId: newPage.id }
        ]);
        this.updateRenderingBounds();
      },
      undo: ({ newPage, prevSelectedPageId, newTabPageState, newCamera }) => {
        if (this.pages.length === 1)
          return;
        this.store.remove([newTabPageState.id, newPage.id, newCamera.id]);
        if (this.store.has(prevSelectedPageId) && this.currentPageId !== prevSelectedPageId) {
          this.store.put([{ ...this.instanceState, currentPageId: prevSelectedPageId }]);
        }
        this.updateRenderingBounds();
      }
    }
  );
  /**
   * Duplicate a page.
   *
   * @param id - The id of the page to duplicate. Defaults to the current page.
   * @param createId - The id of the new page. Defaults to a new id.
   *
   * @public
   */
  duplicatePage(id = this.currentPageId, createId = import_tlschema.PageRecordType.createId()) {
    if (this.pages.length >= import_constants.MAX_PAGES)
      return this;
    const page = this.getPageById(id);
    if (!page)
      return this;
    const camera = { ...this.camera };
    const content = this.getContent(this.getSortedChildIds(page.id));
    this.batch(() => {
      this.createPage(page.name + " Copy", createId, page.index);
      this.setCurrentPageId(createId);
      this.setCamera(camera.x, camera.y, camera.z);
      if (content) {
        return this.putContent(content);
      }
    });
    return this;
  }
  /**
   * Delete a page.
   *
   * @example
   * ```ts
   * editor.deletePage('page1')
   * ```
   *
   * @param id - The id of the page to delete.
   *
   * @public
   */
  deletePage(id) {
    this._deletePage(id);
  }
  /** @internal */
  _deletePage = this.history.createCommand(
    "delete_page",
    (id) => {
      if (this.isReadOnly)
        return null;
      const { pages } = this;
      if (pages.length === 1)
        return null;
      const deletedPage = this.getPageById(id);
      const deletedPageStates = this._pageStates.value.filter((s) => s.pageId === id);
      if (!deletedPage)
        return null;
      if (id === this.currentPageId) {
        const index = pages.findIndex((page) => page.id === id);
        const next = pages[index - 1] ?? pages[index + 1];
        this.setCurrentPageId(next.id);
      }
      return { data: { id, deletedPage, deletedPageStates } };
    },
    {
      do: ({ deletedPage, deletedPageStates }) => {
        const { pages } = this;
        if (pages.length === 1)
          return;
        if (deletedPage.id === this.currentPageId) {
          const index = pages.findIndex((page) => page.id === deletedPage.id);
          const next = pages[index - 1] ?? pages[index + 1];
          this.setCurrentPageId(next.id);
        }
        this.store.remove(deletedPageStates.map((s) => s.id));
        this.store.remove([deletedPage.id]);
        this.updateRenderingBounds();
      },
      undo: ({ deletedPage, deletedPageStates }) => {
        this.store.put([deletedPage]);
        this.store.put(deletedPageStates);
        this.updateRenderingBounds();
      }
    }
  );
  /** @internal */
  _setInstancePageState = this.history.createCommand(
    "setInstancePageState",
    (partial, ephemeral = false) => {
      const prev = this.store.get(partial.id ?? this.pageState.id);
      return { data: { prev, partial }, ephemeral };
    },
    {
      do: ({ prev, partial }) => {
        this.store.update(prev.id, (state) => ({ ...state, ...partial }));
      },
      undo: ({ prev }) => {
        this.store.update(prev.id, () => prev);
      }
    }
  );
  get _assets() {
    return this.store.query.records("asset");
  }
  /**
   * Get all assets in the editor.
   *
   * @public
   */
  get assets() {
    return this._assets.value;
  }
  /**
   * Create one or more assets.
   *
   * @example
   * ```ts
   * editor.createAssets([...myAssets])
   * ```
   *
   * @param assets - The assets to create.
   *
   * @public
   */
  createAssets(assets) {
    this._createAssets(assets);
    return this;
  }
  /** @internal */
  _createAssets = this.history.createCommand(
    "createAssets",
    (assets) => {
      if (this.isReadOnly)
        return null;
      if (assets.length <= 0)
        return null;
      return { data: { assets } };
    },
    {
      do: ({ assets }) => {
        this.store.put(assets);
      },
      undo: ({ assets }) => {
        this.store.remove(assets.map((a) => a.id));
      }
    }
  );
  /**
   * Delete one or more assets.
   *
   * @example
   * ```ts
   * editor.deleteAssets(['asset1', 'asset2'])
   * ```
   *
   * @param ids - The assets to delete.
   *
   * @public
   */
  deleteAssets(ids) {
    this._deleteAssets(ids);
    return this;
  }
  /** @internal */
  _deleteAssets = this.history.createCommand(
    "deleteAssets",
    (ids) => {
      if (this.isReadOnly)
        return;
      if (ids.length <= 0)
        return;
      const prev = (0, import_utils.compact)(ids.map((id) => this.store.get(id)));
      return { data: { ids, prev } };
    },
    {
      do: ({ ids }) => {
        this.store.remove(ids);
      },
      undo: ({ prev }) => {
        this.store.put(prev);
      }
    }
  );
  /**
   * Update one or more assets.
   *
   * @example
   * ```ts
   * editor.updateAssets([{ id: 'asset1', name: 'New name' }])
   * ```
   *
   * @param assets - The assets to update.
   *
   * @public
   */
  updateAssets(assets) {
    this._updateAssets(assets);
    return this;
  }
  /** @internal */
  _updateAssets = this.history.createCommand(
    "updateAssets",
    (assets) => {
      if (this.isReadOnly)
        return;
      if (assets.length <= 0)
        return;
      const snapshots = {};
      return { data: { snapshots, assets } };
    },
    {
      do: ({ assets, snapshots }) => {
        this.store.put(
          assets.map((a) => {
            const asset = this.store.get(a.id);
            snapshots[a.id] = asset;
            return {
              ...asset,
              ...a
            };
          })
        );
      },
      undo: ({ snapshots }) => {
        this.store.put(Object.values(snapshots));
      }
    }
  );
  /**
   * Get an asset by its src property.
   *
   * @example
   * ```ts
   * editor.getAssetBySource('https://example.com/image.png')
   * ```
   *
   * @param src - The source value of the asset.
   *
   * @public
   */
  getAssetBySrc(src) {
    return this.assets.find((a) => a.props.src === src);
  }
  /**
   * Get an asset by its id.
   *
   * @example
   * ```ts
   * editor.getAssetById('asset1')
   * ```
   *
   * @param id - The id of the asset.
   *
   * @public
   */
  getAssetById(id) {
    return this.store.get(id);
  }
  /**
   * Rename a page.
   *
   * @example
   * ```ts
   * editor.renamePage('page1', 'My Page')
   * ```
   *
   * @param id - The id of the page to rename.
   * @param name - The new name.
   *
   * @public
   */
  renamePage(id, name, squashing = false) {
    if (this.isReadOnly)
      return this;
    this.updatePage({ id, name }, squashing);
    return this;
  }
  /**
   * Move shapes to page.
   *
   * @example
   * ```ts
   * editor.moveShapesToPage(['box1', 'box2'], 'page1')
   * ```
   *
   * @param ids - The ids of the shapes to move.
   * @param pageId - The id of the page where the shapes will be moved.
   *
   * @public
   */
  moveShapesToPage(ids, pageId) {
    if (ids.length === 0)
      return this;
    if (this.isReadOnly)
      return this;
    const { currentPageId } = this;
    if (pageId === currentPageId)
      return this;
    if (!this.store.has(pageId))
      return this;
    const content = this.getContent(ids);
    if (!content)
      return this;
    if (this.getShapeIdsInPage(pageId).size + content.shapes.length > import_constants.MAX_SHAPES_PER_PAGE) {
      alertMaxShapes(this, pageId);
      return this;
    }
    const fromPageZ = this.camera.z;
    this.history.batch(() => {
      this.deleteShapes(ids);
      this.setCurrentPageId(pageId);
      this.setFocusLayer(null);
      this.selectNone();
      this.putContent(content, { select: true, preserveIds: true, preservePosition: true });
      const {
        center: { x, y }
      } = this.selectionBounds;
      this.setCamera(this.camera.x, this.camera.y, fromPageZ);
      this.centerOnPoint(x, y);
    });
    return this;
  }
  /**
   * Toggle the lock state of one or more shapes. If there is a mix of locked and unlocked shapes, all shapes will be locked.
   *
   * @param ids - The ids of the shapes to toggle. Defaults to selected shapes.
   *
   * @public
   */
  toggleLock(ids = this.selectedIds) {
    if (this.isReadOnly || ids.length === 0)
      return this;
    let allLocked = true, allUnlocked = true;
    const shapes = [];
    for (const id of ids) {
      const shape = this.getShapeById(id);
      if (shape) {
        shapes.push(shape);
        if (shape.isLocked) {
          allUnlocked = false;
        } else {
          allLocked = false;
        }
      }
    }
    if (allUnlocked) {
      this.updateShapes(shapes.map((shape) => ({ id: shape.id, type: shape.type, isLocked: true })));
      this.setSelectedIds([]);
    } else if (allLocked) {
      this.updateShapes(
        shapes.map((shape) => ({ id: shape.id, type: shape.type, isLocked: false }))
      );
    } else {
      this.updateShapes(shapes.map((shape) => ({ id: shape.id, type: shape.type, isLocked: true })));
    }
    return this;
  }
  /**
   * Reorder shapes.
   *
   * @param operation - The operation to perform.
   * @param ids - The ids to reorder.
   *
   * @public
   */
  reorderShapes(operation, ids) {
    if (this.isReadOnly)
      return this;
    if (ids.length === 0)
      return this;
    const parents = this.getParentsMappedToChildren(ids);
    const changes = [];
    switch (operation) {
      case "toBack": {
        parents.forEach((movingSet, parentId) => {
          const siblings = (0, import_utils.compact)(
            this.getSortedChildIds(parentId).map((id) => this.getShapeById(id))
          );
          if (movingSet.size === siblings.length)
            return;
          let below;
          let above;
          for (const shape of siblings) {
            if (!movingSet.has(shape)) {
              above = shape.index;
              break;
            }
            movingSet.delete(shape);
            below = shape.index;
          }
          if (movingSet.size === 0)
            return;
          const indices = (0, import_indices.getIndicesBetween)(below, above, movingSet.size);
          Array.from(movingSet.values()).sort(import_indices.sortByIndex).forEach(
            (node, i) => changes.push({ id: node.id, type: node.type, index: indices[i] })
          );
        });
        break;
      }
      case "toFront": {
        parents.forEach((movingSet, parentId) => {
          const siblings = (0, import_utils.compact)(
            this.getSortedChildIds(parentId).map((id) => this.getShapeById(id))
          );
          const len = siblings.length;
          if (movingSet.size === len)
            return;
          let below;
          let above;
          for (let i = len - 1; i > -1; i--) {
            const shape = siblings[i];
            if (!movingSet.has(shape)) {
              below = shape.index;
              break;
            }
            movingSet.delete(shape);
            above = shape.index;
          }
          if (movingSet.size === 0)
            return;
          const indices = (0, import_indices.getIndicesBetween)(below, above, movingSet.size);
          Array.from(movingSet.values()).sort(import_indices.sortByIndex).forEach(
            (node, i) => changes.push({ id: node.id, type: node.type, index: indices[i] })
          );
        });
        break;
      }
      case "forward": {
        parents.forEach((movingSet, parentId) => {
          const siblings = (0, import_utils.compact)(
            this.getSortedChildIds(parentId).map((id) => this.getShapeById(id))
          );
          const len = siblings.length;
          if (movingSet.size === len)
            return;
          const movingIndices = new Set(Array.from(movingSet).map((n) => siblings.indexOf(n)));
          let selectIndex = -1;
          let isSelecting = false;
          let below;
          let above;
          let count;
          for (let i = 0; i < len; i++) {
            const isMoving = movingIndices.has(i);
            if (!isSelecting && isMoving) {
              isSelecting = true;
              selectIndex = i;
              above = void 0;
            } else if (isSelecting && !isMoving) {
              isSelecting = false;
              count = i - selectIndex;
              below = siblings[i].index;
              above = siblings[i + 1]?.index;
              const indices = (0, import_indices.getIndicesBetween)(below, above, count);
              for (let k = 0; k < count; k++) {
                const node = siblings[selectIndex + k];
                changes.push({ id: node.id, type: node.type, index: indices[k] });
              }
            }
          }
        });
        break;
      }
      case "backward": {
        parents.forEach((movingSet, parentId) => {
          const siblings = (0, import_utils.compact)(
            this.getSortedChildIds(parentId).map((id) => this.getShapeById(id))
          );
          const len = siblings.length;
          if (movingSet.size === len)
            return;
          const movingIndices = new Set(Array.from(movingSet).map((n) => siblings.indexOf(n)));
          let selectIndex = -1;
          let isSelecting = false;
          let count;
          for (let i = len - 1; i > -1; i--) {
            const isMoving = movingIndices.has(i);
            if (!isSelecting && isMoving) {
              isSelecting = true;
              selectIndex = i;
            } else if (isSelecting && !isMoving) {
              isSelecting = false;
              count = selectIndex - i;
              const indices = (0, import_indices.getIndicesBetween)(siblings[i - 1]?.index, siblings[i].index, count);
              for (let k = 0; k < count; k++) {
                const node = siblings[i + k + 1];
                changes.push({ id: node.id, type: node.type, index: indices[k] });
              }
            }
          }
        });
        break;
      }
    }
    this.updateShapes(changes);
    return this;
  }
  /**
   * Send shapes to the back of the page's object list.
   *
   * @example
   * ```ts
   * editor.sendToBack()
   * editor.sendToBack(['id1', 'id2'])
   * ```
   *
   * @param ids - The ids of the shapes to move. Defaults to the ids of the selected shapes.
   *
   * @public
   */
  sendToBack(ids = this.pageState.selectedIds) {
    this.reorderShapes("toBack", ids);
    return this;
  }
  /**
   * Send shapes backward in the page's object list.
   *
   * @example
   * ```ts
   * editor.sendBackward()
   * editor.sendBackward(['id1', 'id2'])
   * ```
   *
   * @param ids - The ids of the shapes to move. Defaults to the ids of the selected shapes.
   *
   * @public
   */
  sendBackward(ids = this.pageState.selectedIds) {
    this.reorderShapes("backward", ids);
    return this;
  }
  /**
   * Bring shapes forward in the page's object list.
   *
   * @example
   * ```ts
   * editor.bringForward()
   * editor.bringForward(['id1', 'id2'])
   * ```
   *
   * @param ids - The ids of the shapes to move. Defaults to the ids of the selected shapes.
   *
   * @public
   */
  bringForward(ids = this.pageState.selectedIds) {
    this.reorderShapes("forward", ids);
    return this;
  }
  /**
   * Bring shapes to the front of the page's object list.
   *
   * @example
   * ```ts
   * editor.bringToFront()
   * editor.bringToFront(['id1', 'id2'])
   * ```
   *
   * @param ids - The ids of the shapes to move. Defaults to the ids of the selected shapes.
   *
   * @public
   */
  bringToFront(ids = this.pageState.selectedIds) {
    this.reorderShapes("toFront", ids);
    return this;
  }
  /**
   * Flip shape positions.
   *
   * @example
   * ```ts
   * editor.flipShapes('horizontal')
   * editor.flipShapes('horizontal', ['box1', 'box2'])
   * ```
   *
   * @param operation - Whether to flip horizontally or vertically.
   * @param ids - The ids of the shapes to flip. Defaults to selected shapes.
   *
   * @public
   */
  flipShapes(operation, ids = this.selectedIds) {
    if (this.isReadOnly)
      return this;
    let shapes = (0, import_utils.compact)(ids.map((id) => this.getShapeById(id)));
    if (!shapes.length)
      return this;
    shapes = (0, import_utils.compact)(
      shapes.map((shape) => {
        if (this.isShapeOfType(shape, import_GroupShapeUtil.GroupShapeUtil)) {
          return this.getSortedChildIds(shape.id).map((id) => this.getShapeById(id));
        }
        return shape;
      }).flat()
    );
    const scaleOriginPage = import_primitives.Box2d.Common((0, import_utils.compact)(shapes.map((id) => this.getPageBounds(id)))).center;
    this.batch(() => {
      for (const shape of shapes) {
        const util = this.getShapeUtil(shape);
        const bounds = util.bounds(shape);
        const initialPageTransform = this.getPageTransformById(shape.id);
        if (!initialPageTransform)
          continue;
        this.resizeShape(
          shape.id,
          { x: operation === "horizontal" ? -1 : 1, y: operation === "vertical" ? -1 : 1 },
          {
            initialBounds: bounds,
            initialPageTransform,
            initialShape: shape,
            mode: "scale_shape",
            scaleOrigin: scaleOriginPage,
            scaleAxisRotation: 0
          }
        );
      }
    });
    return this;
  }
  /**
   * Stack shape.
   *
   * @example
   * ```ts
   * editor.stackShapes('horizontal')
   * editor.stackShapes('horizontal', ['box1', 'box2'])
   * editor.stackShapes('horizontal', ['box1', 'box2'], 20)
   * ```
   *
   * @param operation - Whether to stack horizontally or vertically.
   * @param ids - The ids of the shapes to stack. Defaults to selected shapes.
   * @param gap - A specific gap to use when stacking.
   *
   * @public
   */
  stackShapes(operation, ids = this.pageState.selectedIds, gap) {
    if (this.isReadOnly)
      return this;
    const shapes = (0, import_utils.compact)(ids.map((id) => this.getShapeById(id))).filter((shape) => {
      if (!shape)
        return false;
      if (this.isShapeOfType(shape, import_ArrowShapeUtil.ArrowShapeUtil)) {
        if (shape.props.start.type === "binding" || shape.props.end.type === "binding") {
          return false;
        }
      }
      return true;
    });
    const len = shapes.length;
    if (gap === void 0 && len < 3 || len < 2)
      return this;
    const pageBounds = Object.fromEntries(
      shapes.map((shape) => [shape.id, this.getPageBounds(shape)])
    );
    let val;
    let min;
    let max;
    let dim;
    if (operation === "horizontal") {
      val = "x";
      min = "minX";
      max = "maxX";
      dim = "width";
    } else {
      val = "y";
      min = "minY";
      max = "maxY";
      dim = "height";
    }
    let shapeGap;
    if (gap === void 0) {
      const gaps = [];
      shapes.sort((a, b) => pageBounds[a.id][min] - pageBounds[b.id][min]);
      for (let i = 0; i < len - 1; i++) {
        const shape = shapes[i];
        const nextShape = shapes[i + 1];
        const bounds = pageBounds[shape.id];
        const nextBounds = pageBounds[nextShape.id];
        const gap2 = nextBounds[min] - bounds[max];
        const current = gaps.find((g) => g.gap === gap2);
        if (current) {
          current.count++;
        } else {
          gaps.push({ gap: gap2, count: 1 });
        }
      }
      let maxCount = 0;
      gaps.forEach((g) => {
        if (g.count > maxCount) {
          maxCount = g.count;
          shapeGap = g.gap;
        }
      });
      if (maxCount === 1) {
        shapeGap = Math.max(0, gaps.reduce((a, c) => a + c.gap * c.count, 0) / (len - 1));
      }
    } else {
      shapeGap = gap;
    }
    const changes = [];
    let v = pageBounds[shapes[0].id][max];
    shapes.forEach((shape, i) => {
      if (i === 0)
        return;
      const delta = { x: 0, y: 0 };
      delta[val] = v + shapeGap - pageBounds[shape.id][val];
      const parent = this.getParentShape(shape);
      const localDelta = parent ? import_primitives.Vec2d.Rot(delta, -this.getPageRotation(parent)) : delta;
      const translateStartChanges = this.getShapeUtil(shape).onTranslateStart?.(shape);
      changes.push(
        translateStartChanges ? {
          ...translateStartChanges,
          [val]: shape[val] + localDelta[val]
        } : {
          id: shape.id,
          type: shape.type,
          [val]: shape[val] + localDelta[val]
        }
      );
      v += pageBounds[shape.id][dim] + shapeGap;
    });
    this.updateShapes(changes);
    return this;
  }
  /**
   * Pack shapes into a grid centered on their current position. Based on potpack
   * (https://github.com/mapbox/potpack)
   * @param ids - The ids of the shapes to pack. Defaults to selected shapes.
   * @param padding - The padding to apply to the packed shapes.
   */
  packShapes(ids = this.pageState.selectedIds, padding = 16) {
    if (this.isReadOnly)
      return this;
    if (ids.length < 2)
      return this;
    const shapes = (0, import_utils.compact)(
      ids.map((id) => this.getShapeById(id)).filter((shape2) => {
        if (!shape2)
          return false;
        if (this.isShapeOfType(shape2, import_ArrowShapeUtil.ArrowShapeUtil)) {
          if (shape2.props.start.type === "binding" || shape2.props.end.type === "binding") {
            return false;
          }
        }
        return true;
      })
    );
    const shapePageBounds = {};
    const nextShapePageBounds = {};
    let shape, bounds, area = 0;
    for (let i = 0; i < shapes.length; i++) {
      shape = shapes[i];
      bounds = this.getPageBounds(shape);
      shapePageBounds[shape.id] = bounds;
      nextShapePageBounds[shape.id] = bounds.clone();
      area += bounds.width * bounds.height;
    }
    const commonBounds = import_primitives.Box2d.Common((0, import_utils.compact)(Object.values(shapePageBounds)));
    const maxWidth = commonBounds.width;
    shapes.sort((a, b) => shapePageBounds[b.id].height - shapePageBounds[a.id].height);
    const startWidth = Math.max(Math.ceil(Math.sqrt(area / 0.95)), maxWidth);
    const spaces = [new import_primitives.Box2d(commonBounds.x, commonBounds.y, startWidth, Infinity)];
    let width = 0;
    let height = 0;
    let space;
    let last;
    for (let i = 0; i < shapes.length; i++) {
      shape = shapes[i];
      bounds = nextShapePageBounds[shape.id];
      for (let i2 = spaces.length - 1; i2 >= 0; i2--) {
        space = spaces[i2];
        if (bounds.width > space.width || bounds.height > space.height)
          continue;
        bounds.x = space.x;
        bounds.y = space.y;
        height = Math.max(height, bounds.maxY);
        width = Math.max(width, bounds.maxX);
        if (bounds.width === space.width && bounds.height === space.height) {
          last = spaces.pop();
          if (i2 < spaces.length)
            spaces[i2] = last;
        } else if (bounds.height === space.height) {
          space.x += bounds.width + padding;
          space.width -= bounds.width + padding;
        } else if (bounds.width === space.width) {
          space.y += bounds.height + padding;
          space.height -= bounds.height + padding;
        } else {
          spaces.push(
            new import_primitives.Box2d(
              space.x + (bounds.width + padding),
              space.y,
              space.width - (bounds.width + padding),
              bounds.height
            )
          );
          space.y += bounds.height + padding;
          space.height -= bounds.height + padding;
        }
        break;
      }
    }
    const commonAfter = import_primitives.Box2d.Common(Object.values(nextShapePageBounds));
    const centerDelta = import_primitives.Vec2d.Sub(commonBounds.center, commonAfter.center);
    let nextBounds;
    const changes = [];
    for (let i = 0; i < shapes.length; i++) {
      shape = shapes[i];
      bounds = shapePageBounds[shape.id];
      nextBounds = nextShapePageBounds[shape.id];
      const delta = this.getDeltaInParentSpace(
        shape,
        import_primitives.Vec2d.Sub(nextBounds.point, bounds.point).add(centerDelta)
      );
      const change = {
        id: shape.id,
        type: shape.type,
        x: shape.x + delta.x,
        y: shape.y + delta.y
      };
      const translateStartChange = this.getShapeUtil(shape).onTranslateStart?.({
        ...shape,
        ...change
      });
      if (translateStartChange) {
        changes.push({ ...change, ...translateStartChange });
      } else {
        changes.push(change);
      }
    }
    if (changes.length) {
      this.updateShapes(changes);
    }
    return this;
  }
  /**
   * Align shape positions.
   *
   * @example
   * ```ts
   * editor.alignShapes('left')
   * editor.alignShapes('left', ['box1', 'box2'])
   * ```
   *
   * @param operation - The align operation to apply.
   * @param ids - The ids of the shapes to align. Defaults to selected shapes.
   *
   * @public
   */
  alignShapes(operation, ids = this.pageState.selectedIds) {
    if (this.isReadOnly)
      return this;
    if (ids.length < 2)
      return this;
    const shapes = (0, import_utils.compact)(ids.map((id) => this.getShapeById(id)));
    const shapePageBounds = Object.fromEntries(
      shapes.map((shape) => [shape.id, this.getPageBounds(shape)])
    );
    const commonBounds = import_primitives.Box2d.Common((0, import_utils.compact)(Object.values(shapePageBounds)));
    const changes = [];
    shapes.forEach((shape) => {
      const pageBounds = shapePageBounds[shape.id];
      if (!pageBounds)
        return;
      const delta = { x: 0, y: 0 };
      switch (operation) {
        case "top": {
          delta.y = commonBounds.minY - pageBounds.minY;
          break;
        }
        case "center-vertical": {
          delta.y = commonBounds.midY - pageBounds.minY - pageBounds.height / 2;
          break;
        }
        case "bottom": {
          delta.y = commonBounds.maxY - pageBounds.minY - pageBounds.height;
          break;
        }
        case "left": {
          delta.x = commonBounds.minX - pageBounds.minX;
          break;
        }
        case "center-horizontal": {
          delta.x = commonBounds.midX - pageBounds.minX - pageBounds.width / 2;
          break;
        }
        case "right": {
          delta.x = commonBounds.maxX - pageBounds.minX - pageBounds.width;
          break;
        }
      }
      const parent = this.getParentShape(shape);
      const localDelta = parent ? import_primitives.Vec2d.Rot(delta, -this.getPageRotation(parent)) : delta;
      const translateChanges = this.getShapeUtil(shape).onTranslateStart?.(shape);
      changes.push(
        translateChanges ? {
          ...translateChanges,
          x: shape.x + localDelta.x,
          y: shape.y + localDelta.y
        } : {
          id: shape.id,
          type: shape.type,
          x: shape.x + localDelta.x,
          y: shape.y + localDelta.y
        }
      );
    });
    this.updateShapes(changes);
    return this;
  }
  /**
   * Distribute shape positions.
   *
   * @example
   * ```ts
   * editor.distributeShapes('left')
   * editor.distributeShapes('left', ['box1', 'box2'])
   * ```
   *
   * @param operation - Whether to distribute shapes horizontally or vertically.
   * @param ids - The ids of the shapes to distribute. Defaults to selected shapes.
   *
   * @public
   */
  distributeShapes(operation, ids = this.pageState.selectedIds) {
    if (this.isReadOnly)
      return this;
    if (ids.length < 3)
      return this;
    const len = ids.length;
    const shapes = (0, import_utils.compact)(ids.map((id) => this.getShapeById(id)));
    const pageBounds = Object.fromEntries(
      shapes.map((shape) => [shape.id, this.getPageBounds(shape)])
    );
    let val;
    let min;
    let max;
    let mid;
    let dim;
    if (operation === "horizontal") {
      val = "x";
      min = "minX";
      max = "maxX";
      mid = "midX";
      dim = "width";
    } else {
      val = "y";
      min = "minY";
      max = "maxY";
      mid = "midY";
      dim = "height";
    }
    const changes = [];
    const first = shapes.sort((a, b) => pageBounds[a.id][min] - pageBounds[b.id][min])[0];
    const last = shapes.sort((a, b) => pageBounds[b.id][max] - pageBounds[a.id][max])[0];
    const midFirst = pageBounds[first.id][mid];
    const step = (pageBounds[last.id][mid] - midFirst) / (len - 1);
    const v = midFirst + step;
    shapes.filter((shape) => shape !== first && shape !== last).sort((a, b) => pageBounds[a.id][mid] - pageBounds[b.id][mid]).forEach((shape, i) => {
      const delta = { x: 0, y: 0 };
      delta[val] = v + step * i - pageBounds[shape.id][dim] / 2 - pageBounds[shape.id][val];
      const parent = this.getParentShape(shape);
      const localDelta = parent ? import_primitives.Vec2d.Rot(delta, -this.getPageRotation(parent)) : delta;
      const translateStartChanges = this.getShapeUtil(shape).onTranslateStart?.(shape);
      changes.push(
        translateStartChanges ? {
          ...translateStartChanges,
          [val]: shape[val] + localDelta[val]
        } : {
          id: shape.id,
          type: shape.type,
          [val]: shape[val] + localDelta[val]
        }
      );
    });
    this.updateShapes(changes);
    return this;
  }
  /** @internal */
  _resizeUnalignedShape(id, scale, options) {
    const { type } = options.initialShape;
    const shapeScale = new import_primitives.Vec2d(scale.x, scale.y);
    if (Math.abs(scale.x) > Math.abs(scale.y)) {
      shapeScale.x = Math.sign(scale.x) * Math.abs(scale.y);
    } else {
      shapeScale.y = Math.sign(scale.y) * Math.abs(scale.x);
    }
    this.resizeShape(id, shapeScale, {
      initialShape: options.initialShape,
      initialBounds: options.initialBounds
    });
    if (Math.sign(scale.x) * Math.sign(scale.y) < 0) {
      let { rotation } = import_primitives.Matrix2d.Decompose(options.initialPageTransform);
      rotation -= 2 * rotation;
      this.updateShapes([{ id, type, rotation }], true);
    }
    const preScaleShapePageCenter = import_primitives.Matrix2d.applyToPoint(
      options.initialPageTransform,
      options.initialBounds.center
    );
    const postScaleShapePageCenter = this._scalePagePoint(
      preScaleShapePageCenter,
      options.scaleOrigin,
      scale,
      options.scaleAxisRotation
    );
    const currentPageCenter = this.getPageCenterById(id);
    const currentPagePoint = this.getPagePointById(id);
    if (!currentPageCenter || !currentPagePoint)
      return this;
    const pageDelta = import_primitives.Vec2d.Sub(postScaleShapePageCenter, currentPageCenter);
    const postScaleShapePagePoint = import_primitives.Vec2d.Add(currentPagePoint, pageDelta);
    const { x, y } = this.getPointInParentSpace(id, postScaleShapePagePoint);
    this.updateShapes([{ id, type, x, y }], true);
    return this;
  }
  /** @internal */
  _scalePagePoint(point, scaleOrigin, scale, scaleAxisRotation) {
    const relativePoint = import_primitives.Vec2d.RotWith(point, scaleOrigin, -scaleAxisRotation).sub(scaleOrigin);
    const newRelativePagePoint = import_primitives.Vec2d.MulV(relativePoint, scale);
    const destination = import_primitives.Vec2d.Add(newRelativePagePoint, scaleOrigin).rotWith(
      scaleOrigin,
      scaleAxisRotation
    );
    return destination;
  }
  /**
   * Resize a shape.
   *
   * @param id - The id of the shape to resize.
   * @param scale - The scale factor to apply to the shape.
   * @param options - Additional options.
   *
   * @public
   */
  resizeShape(id, scale, options = {}) {
    if (this.isReadOnly)
      return this;
    if (!Number.isFinite(scale.x))
      scale = new import_primitives.Vec2d(1, scale.y);
    if (!Number.isFinite(scale.y))
      scale = new import_primitives.Vec2d(scale.x, 1);
    const initialShape = options.initialShape ?? this.getShapeById(id);
    if (!initialShape)
      return this;
    const scaleOrigin = options.scaleOrigin ?? this.getPageBoundsById(id)?.center;
    if (!scaleOrigin)
      return this;
    const pageRotation = this.getPageRotationById(id);
    if (pageRotation == null)
      return this;
    const scaleAxisRotation = options.scaleAxisRotation ?? pageRotation;
    const pageTransform = options.initialPageTransform ?? this.getPageTransformById(id);
    if (!pageTransform)
      return this;
    const initialBounds = options.initialBounds ?? this.getBoundsById(id);
    if (!initialBounds)
      return this;
    if (!(0, import_primitives.areAnglesCompatible)(pageRotation, scaleAxisRotation)) {
      return this._resizeUnalignedShape(id, scale, {
        ...options,
        initialBounds,
        scaleOrigin,
        scaleAxisRotation,
        initialPageTransform: pageTransform,
        initialShape
      });
    }
    const util = this.getShapeUtil(initialShape);
    if (util.isAspectRatioLocked(initialShape)) {
      if (Math.abs(scale.x) > Math.abs(scale.y)) {
        scale = new import_primitives.Vec2d(scale.x, Math.sign(scale.y) * Math.abs(scale.x));
      } else {
        scale = new import_primitives.Vec2d(Math.sign(scale.x) * Math.abs(scale.y), scale.y);
      }
    }
    if (util.onResize && util.canResize(initialShape)) {
      const newPagePoint = this._scalePagePoint(
        import_primitives.Matrix2d.applyToPoint(pageTransform, new import_primitives.Vec2d(0, 0)),
        scaleOrigin,
        scale,
        scaleAxisRotation
      );
      const newLocalPoint = this.getPointInParentSpace(initialShape.id, newPagePoint);
      const myScale = new import_primitives.Vec2d(scale.x, scale.y);
      const areWidthAndHeightAlignedWithCorrectAxis = (0, import_primitives.approximately)(
        (pageRotation - scaleAxisRotation) % Math.PI,
        0
      );
      myScale.x = areWidthAndHeightAlignedWithCorrectAxis ? scale.x : scale.y;
      myScale.y = areWidthAndHeightAlignedWithCorrectAxis ? scale.y : scale.x;
      const initialPagePoint = import_primitives.Matrix2d.applyToPoint(pageTransform, new import_primitives.Vec2d());
      const { x, y } = this.getPointInParentSpace(initialShape.id, initialPagePoint);
      this.updateShapes(
        [
          {
            id,
            type: initialShape.type,
            x: newLocalPoint.x,
            y: newLocalPoint.y,
            ...util.onResize(
              { ...initialShape, x, y },
              {
                newPoint: newLocalPoint,
                handle: options.dragHandle ?? "bottom_right",
                // don't set isSingle to true for children
                mode: options.mode ?? "scale_shape",
                scaleX: myScale.x,
                scaleY: myScale.y,
                initialBounds,
                initialShape
              }
            )
          }
        ],
        true
      );
    } else {
      const initialPageCenter = import_primitives.Matrix2d.applyToPoint(pageTransform, initialBounds.center);
      const newPageCenter = this._scalePagePoint(
        initialPageCenter,
        scaleOrigin,
        scale,
        scaleAxisRotation
      );
      const initialPageCenterInParentSpace = this.getPointInParentSpace(
        initialShape.id,
        initialPageCenter
      );
      const newPageCenterInParentSpace = this.getPointInParentSpace(initialShape.id, newPageCenter);
      const delta = import_primitives.Vec2d.Sub(newPageCenterInParentSpace, initialPageCenterInParentSpace);
      this.updateShapes(
        [
          {
            id,
            type: initialShape.type,
            x: initialShape.x + delta.x,
            y: initialShape.y + delta.y
          }
        ],
        true
      );
    }
    return this;
  }
  /**
   * Stretch shape sizes and positions to fill their common bounding box.
   *
   * @example
   * ```ts
   * editor.stretchShapes('horizontal')
   * editor.stretchShapes('horizontal', ['box1', 'box2'])
   * ```
   *
   * @param operation - Whether to stretch shapes horizontally or vertically.
   * @param ids - The ids of the shapes to stretch. Defaults to selected shapes.
   *
   * @public
   */
  stretchShapes(operation, ids = this.pageState.selectedIds) {
    if (this.isReadOnly)
      return this;
    if (ids.length < 2)
      return this;
    const shapes = (0, import_utils.compact)(ids.map((id) => this.getShapeById(id)));
    const shapeBounds = Object.fromEntries(shapes.map((shape) => [shape.id, this.getBounds(shape)]));
    const shapePageBounds = Object.fromEntries(
      shapes.map((shape) => [shape.id, this.getPageBounds(shape)])
    );
    const commonBounds = import_primitives.Box2d.Common((0, import_utils.compact)(Object.values(shapePageBounds)));
    const changes = [];
    switch (operation) {
      case "vertical": {
        this.batch(() => {
          for (const shape of shapes) {
            const pageRotation = this.getPageRotation(shape);
            if (pageRotation % import_primitives.PI2)
              continue;
            const bounds = shapeBounds[shape.id];
            const pageBounds = shapePageBounds[shape.id];
            const localOffset = this.getDeltaInParentSpace(
              shape,
              new import_primitives.Vec2d(0, commonBounds.minY - pageBounds.minY)
            );
            const { x, y } = import_primitives.Vec2d.Add(localOffset, shape);
            this.updateShapes([{ id: shape.id, type: shape.type, x, y }], true);
            const scale = new import_primitives.Vec2d(1, commonBounds.height / pageBounds.height);
            this.resizeShape(shape.id, scale, {
              initialBounds: bounds,
              scaleOrigin: new import_primitives.Vec2d(pageBounds.center.x, commonBounds.minY),
              scaleAxisRotation: 0
            });
          }
        });
        break;
      }
      case "horizontal": {
        this.batch(() => {
          for (const shape of shapes) {
            const bounds = shapeBounds[shape.id];
            const pageBounds = shapePageBounds[shape.id];
            const pageRotation = this.getPageRotation(shape);
            if (pageRotation % import_primitives.PI2)
              continue;
            const localOffset = this.getDeltaInParentSpace(
              shape,
              new import_primitives.Vec2d(commonBounds.minX - pageBounds.minX, 0)
            );
            const { x, y } = import_primitives.Vec2d.Add(localOffset, shape);
            this.updateShapes([{ id: shape.id, type: shape.type, x, y }], true);
            const scale = new import_primitives.Vec2d(commonBounds.width / pageBounds.width, 1);
            this.resizeShape(shape.id, scale, {
              initialBounds: bounds,
              scaleOrigin: new import_primitives.Vec2d(commonBounds.minX, pageBounds.center.y),
              scaleAxisRotation: 0
            });
          }
        });
        break;
      }
    }
    this.updateShapes(changes);
    return this;
  }
  get shapesArray() {
    return Array.from(this.currentPageShapeIds, (id) => this.store.get(id));
  }
  get sortedShapesArray() {
    const shapes = new Set(this.shapesArray.sort(import_indices.sortByIndex));
    const results = [];
    function pushShapeWithDescendants(shape) {
      results.push(shape);
      shapes.delete(shape);
      shapes.forEach((otherShape) => {
        if (otherShape.parentId === shape.id) {
          pushShapeWithDescendants(otherShape);
        }
      });
    }
    shapes.forEach((shape) => {
      const parent = this.getShapeById(shape.parentId);
      if (!(0, import_tlschema.isShape)(parent)) {
        pushShapeWithDescendants(shape);
      }
    });
    return results;
  }
  get selectedShapes() {
    const { selectedIds } = this.pageState;
    return (0, import_utils.compact)(selectedIds.map((id) => this.store.get(id)));
  }
  get onlySelectedShape() {
    const { selectedShapes } = this;
    return selectedShapes.length === 1 ? selectedShapes[0] : null;
  }
  /**
   * Get whether a shape matches the type of a TLShapeUtil.
   *
   * @example
   * ```ts
   * const isArrowShape = isShapeOfType(someShape, ArrowShapeUtil)
   * ```
   *
   * @param util - the TLShapeUtil constructor to test against
   * @param shape - the shape to test
   *
   * @public
   */
  isShapeOfType(shape, util) {
    return shape.type === util.type;
  }
  /**
   * Get a shape by its id.
   *
   * @example
   * ```ts
   * editor.getShapeById('box1')
   * ```
   *
   * @param id - The id of the shape to get.
   *
   * @public
   */
  getShapeById(id) {
    if (!(0, import_tlschema.isShapeId)(id))
      return void 0;
    return this.store.get(id);
  }
  /**
   * Get the parent shape for a given shape. Returns undefined if the shape is the direct child of
   * the page.
   *
   * @example
   * ```ts
   * editor.getParentShape(myShape)
   * ```
   *
   * @public
   */
  getParentShape(shape) {
    if (shape === void 0 || !(0, import_tlschema.isShapeId)(shape.parentId))
      return void 0;
    return this.store.get(shape.parentId);
  }
  /**
   * If siblingShape and targetShape are siblings, this returns targetShape. If targetShape has an
   * ancestor who is a sibling of siblingShape, this returns that ancestor. Otherwise, this returns
   * undefined.
   *
   * @internal
   */
  getShapeNearestSibling(siblingShape, targetShape) {
    if (!targetShape) {
      return void 0;
    }
    if (targetShape.parentId === siblingShape.parentId) {
      return targetShape;
    }
    const ancestor = this.findAncestor(
      targetShape,
      (ancestor2) => ancestor2.parentId === siblingShape.parentId
    );
    return ancestor;
  }
  /**
   * Get whether the given shape is the descendant of the given page.
   *
   * @example
   * ```ts
   * editor.isShapeInPage(myShape)
   * editor.isShapeInPage(myShape, 'page1')
   * ```
   *
   * @param shape - The shape to check.
   * @param pageId - The id of the page to check against. Defaults to the current page.
   *
   * @public
   */
  isShapeInPage(shape, pageId = this.currentPageId) {
    let shapeIsInPage = false;
    if (shape.parentId === pageId) {
      shapeIsInPage = true;
    } else {
      let parent = this.getShapeById(shape.parentId);
      isInPageSearch:
        while (parent) {
          if (parent.parentId === pageId) {
            shapeIsInPage = true;
            break isInPageSearch;
          }
          parent = this.getShapeById(parent.parentId);
        }
    }
    return shapeIsInPage;
  }
  /**
   * Get the id of the containing page for a given shape.
   *
   * @param shape - The shape to get the page id for.
   *
   * @returns The id of the page that contains the shape, or undefined if the shape is undefined.
   *
   * @public
   */
  getAncestorPageId(shape) {
    if (shape === void 0)
      return void 0;
    if ((0, import_tlschema.isPageId)(shape.parentId)) {
      return shape.parentId;
    } else {
      return this.getAncestorPageId(this.getShapeById(shape.parentId));
    }
  }
  // Parents and children
  /**
   * A cache of parents to children.
   *
   * @internal
   */
  _parentIdsToChildIds;
  /**
   * Reparent shapes to a new parent. This operation preserves the shape's current page positions /
   * rotations.
   *
   * @example
   * ```ts
   * editor.reparentShapesById(['box1', 'box2'], 'frame1')
   * ```
   *
   * @param ids - The ids of the shapes to reparent.
   * @param parentId - The id of the new parent shape.
   * @param insertIndex - The index to insert the children.
   *
   * @public
   */
  reparentShapesById(ids, parentId, insertIndex) {
    const changes = [];
    const parentTransform = (0, import_tlschema.isPageId)(parentId) ? import_primitives.Matrix2d.Identity() : this.getPageTransformById(parentId);
    const parentPageRotation = parentTransform.decompose().rotation;
    let indices = [];
    const sibs = (0, import_utils.compact)(this.getSortedChildIds(parentId).map((id2) => this.getShapeById(id2)));
    if (insertIndex) {
      const sibWithInsertIndex = sibs.find((s) => s.index === insertIndex);
      if (sibWithInsertIndex) {
        const sibAbove = sibs[sibs.indexOf(sibWithInsertIndex) + 1];
        if (sibAbove) {
          indices = (0, import_indices.getIndicesBetween)(insertIndex, sibAbove.index, ids.length);
        } else {
          indices = (0, import_indices.getIndicesAbove)(insertIndex, ids.length);
        }
      } else {
        const sibAbove = sibs.sort(import_indices.sortByIndex).find((s) => s.index > insertIndex);
        if (sibAbove) {
          indices = (0, import_indices.getIndicesBetween)(insertIndex, sibAbove.index, ids.length);
        } else {
          indices = (0, import_indices.getIndicesAbove)(insertIndex, ids.length);
        }
      }
    } else {
      const sib = sibs.length && sibs[sibs.length - 1];
      indices = sib ? (0, import_indices.getIndicesAbove)(sib.index, ids.length) : (0, import_indices.getIndices)(ids.length);
    }
    let id;
    for (let i = 0; i < ids.length; i++) {
      id = ids[i];
      const shape = this.getShapeById(id);
      const pagePoint = this.getPagePointById(id);
      if (!shape || !pagePoint)
        continue;
      const newPoint = import_primitives.Matrix2d.applyToPoint(import_primitives.Matrix2d.Inverse(parentTransform), pagePoint);
      const newRotation = this.getPageRotation(shape) - parentPageRotation;
      changes.push({
        id: shape.id,
        type: shape.type,
        parentId,
        x: newPoint.x,
        y: newPoint.y,
        rotation: newRotation,
        index: indices[i]
      });
    }
    this.updateShapes(changes);
    return this;
  }
  /**
   * Get the index above the highest child of a given parent.
   *
   * @param parentId - The id of the parent.
   *
   * @returns The index.
   *
   * @public
   */
  getHighestIndexForParent(parentId) {
    const children = this._parentIdsToChildIds.value[parentId];
    if (!children || children.length === 0) {
      return "a1";
    }
    return (0, import_indices.getIndexAbove)(children[children.length - 1][1]);
  }
  /**
   * A cache of children for each parent.
   *
   * @internal
   */
  _childIdsCache = new import_WeakMapCache.WeakMapCache();
  /**
   * Get an array of all the children of a shape.
   *
   * @example
   * ```ts
   * editor.getSortedChildIds('frame1')
   * ```
   *
   * @param parentId - The id of the parent shape.
   *
   * @public
   */
  getSortedChildIds(parentId) {
    const withIndices = this._parentIdsToChildIds.value[parentId];
    if (!withIndices)
      return import_signia.EMPTY_ARRAY;
    return this._childIdsCache.get(withIndices, () => withIndices.map(([id]) => id));
  }
  /**
   * Run a visitor function for all descendants of a shape.
   *
   * @example
   * ```ts
   * editor.visitDescendants('frame1', myCallback)
   * ```
   *
   * @param parentId - The id of the parent shape.
   * @param visitor - The visitor function.
   *
   * @public
   */
  visitDescendants(parentId, visitor) {
    const children = this.getSortedChildIds(parentId);
    for (const id of children) {
      if (visitor(id) === false)
        continue;
      this.visitDescendants(id, visitor);
    }
  }
  /**
   * Get the shape ids of all descendants of the given shapes (including the shapes themselves).
   *
   * @param ids - The ids of the shapes to get descendants of.
   *
   * @returns The decscendant ids.
   *
   * @public
   */
  getShapeAndDescendantIds(ids) {
    const idsToInclude = /* @__PURE__ */ new Set();
    const idsToCheck = [...ids];
    while (idsToCheck.length > 0) {
      const id = idsToCheck.pop();
      if (!id)
        break;
      if (idsToInclude.has(id))
        continue;
      idsToInclude.add(id);
      this.getSortedChildIds(id).forEach((id2) => {
        idsToCheck.push(id2);
      });
    }
    return idsToInclude;
  }
  /**
   * Get the id of what should be the parent of a new shape at a given point. The parent can be a page or shape.
   *
   * @param point - The point to find the parent for.
   * @param shapeType - The type of shape that will be created.
   *
   * @returns The id of the parent.
   *
   * @public
   */
  getParentIdForNewShapeAtPoint(point, shapeType) {
    const shapes = this.sortedShapesArray;
    for (let i = shapes.length - 1; i >= 0; i--) {
      const shape = shapes[i];
      const util = this.getShapeUtil(shape);
      if (!util.canReceiveNewChildrenOfType(shape, shapeType))
        continue;
      const maskedPageBounds = this.getMaskedPageBoundsById(shape.id);
      if (maskedPageBounds && maskedPageBounds.containsPoint(point) && util.hitTestPoint(shape, this.getPointInShapeSpace(shape, point))) {
        return shape.id;
      }
    }
    return this.focusLayerId;
  }
  /**
   * Get the shape that some shapes should be dropped on at a given point.
   *
   * @param point - The point to find the parent for.
   * @param droppingShapes - The shapes that are being dropped.
   *
   * @returns The shape to drop on.
   *
   * @public
   */
  getDroppingShape(point, droppingShapes = []) {
    const shapes = this.sortedShapesArray;
    for (let i = shapes.length - 1; i >= 0; i--) {
      const shape = shapes[i];
      if (droppingShapes.find((s) => s.id === shape.id || this.hasAncestor(shape, s.id)))
        continue;
      const util = this.getShapeUtil(shape);
      if (!util.canDropShapes(shape, droppingShapes))
        continue;
      const maskedPageBounds = this.getMaskedPageBoundsById(shape.id);
      if (maskedPageBounds && maskedPageBounds.containsPoint(point) && util.hitTestPoint(shape, this.getPointInShapeSpace(shape, point))) {
        return shape;
      }
    }
    return void 0;
  }
  /**
   * Get the shape that should be selected when you click on a given shape, assuming there is
   * nothing already selected. It will not return anything higher than or including the current
   * focus layer.
   *
   * @param shape - The shape to get the outermost selectable shape for.
   * @param filter - A function to filter the selectable shapes.
   *
   * @returns The outermost selectable shape.
   *
   * @public
   */
  getOutermostSelectableShape(shape, filter) {
    let match = shape;
    let node = shape;
    while (node) {
      if (this.isShapeOfType(node, import_GroupShapeUtil.GroupShapeUtil) && this.focusLayerId !== node.id && !this.hasAncestor(this.focusLayerShape, node.id) && (filter?.(node) ?? true)) {
        match = node;
      } else if (this.focusLayerId === node.id) {
        break;
      }
      node = this.getParentShape(node);
    }
    return match;
  }
  /* -------------------- Commands -------------------- */
  /**
   * Set the current page.
   *
   * @example
   * ```ts
   * editor.setCurrentPageId('page1')
   * ```
   *
   * @param pageId - The id of the page to set as the current page.
   * @param options - Options for setting the current page.
   *
   * @public
   */
  setCurrentPageId(pageId, { stopFollowing = true } = {}) {
    this._setCurrentPageId(pageId, { stopFollowing });
    return this;
  }
  /** @internal */
  _setCurrentPageId = this.history.createCommand(
    "setCurrentPage",
    (pageId, { stopFollowing = true } = {}) => {
      if (!this.store.has(pageId)) {
        console.error("Tried to set the current page id to a page that doesn't exist.");
        return;
      }
      if (stopFollowing && this.instanceState.followingUserId) {
        this.stopFollowingUser();
      }
      return {
        data: { toId: pageId, fromId: this.currentPageId },
        squashing: true,
        preservesRedoStack: true
      };
    },
    {
      do: ({ toId }) => {
        if (!this.store.has(toId)) {
          return;
        }
        if (!this.getPageStateByPageId(toId)) {
          const camera = import_tlschema.CameraRecordType.create({
            id: import_tlschema.CameraRecordType.createId(toId)
          });
          this.store.put([
            camera,
            import_tlschema.InstancePageStateRecordType.create({
              id: import_tlschema.InstancePageStateRecordType.createId(toId),
              pageId: toId
            })
          ]);
        }
        this.store.put([{ ...this.instanceState, currentPageId: toId }]);
        this.updateRenderingBounds();
      },
      undo: ({ fromId }) => {
        if (!this.store.has(fromId)) {
          return;
        }
        this.store.put([{ ...this.instanceState, currentPageId: fromId }]);
        this.updateRenderingBounds();
      },
      squash: ({ fromId }, { toId }) => {
        return { toId, fromId };
      }
    }
  );
  /**
   * Update the instance's state.
   *
   * @param partial - A partial object to update the instance state with.
   * @param ephemeral - Whether the change is ephemeral. Ephemeral changes don't get added to the undo/redo stack. Defaults to false.
   * @param squashing - Whether the change will be squashed into the existing history entry rather than creating a new one. Defaults to false.
   *
   * @public
   */
  updateInstanceState(partial, ephemeral = false, squashing = false) {
    this._updateInstanceState(partial, ephemeral, squashing);
    return this;
  }
  /** @internal */
  _updateInstanceState = this.history.createCommand(
    "updateTabState",
    (partial, ephemeral = false, squashing = false) => {
      const prev = this.instanceState;
      const next = { ...prev, ...partial };
      return {
        data: { prev, next },
        squashing,
        ephemeral
      };
    },
    {
      do: ({ next }) => {
        this.store.put([next]);
      },
      undo: ({ prev }) => {
        this.store.put([prev]);
      },
      squash({ prev }, { next }) {
        return { prev, next };
      }
    }
  );
  /**
   * Set the current cursor.
   *
   * @example
   * ```ts
   * editor.setCursor({ type: 'default' })
   * editor.setCursor({ type: 'default', rotation: Math.PI / 2, color: 'red' })
   * ```
   *
   * @param cursor - A partial of the cursor object.
   *
   * @public
   */
  setCursor(cursor) {
    const current = this.cursor;
    const next = {
      ...current,
      rotation: 0,
      ...cursor
    };
    if (!(current.type === next.type && current.rotation === next.rotation && current.color === next.color)) {
      this.updateInstanceState({ cursor: next }, true);
    }
    return this;
  }
  /**
   * Set the current scribble.
   *
   * @example
   * ```ts
   * editor.setScribble(nextScribble)
   * editor.setScribble() // clears the scribble
   * ```
   *
   * @param scribble - The new scribble object.
   *
   * @public
   */
  setScribble(scribble = null) {
    this.updateInstanceState({ scribble }, true);
    return this;
  }
  /**
   * Set the current brush.
   *
   * @example
   * ```ts
   * editor.setBrush({ x: 0, y: 0, w: 100, h: 100 })
   * editor.setBrush() // Clears the brush
   * ```
   *
   * @param brush - The brush box model to set, or null for no brush model.
   *
   * @public
   */
  setBrush(brush = null) {
    if (!brush && !this.brush)
      return this;
    this.updateInstanceState({ brush }, true);
    return this;
  }
  /**
   * Set the current zoom brush.
   *
   * @example
   * ```ts
   * editor.setZoomBrush({ x: 0, y: 0, w: 100, h: 100 })
   * editor.setZoomBrush() // Clears the zoom
   * ```
   *
   * @param zoomBrush - The zoom box model to set, or null for no zoom model.
   *
   * @public
   */
  setZoomBrush(zoomBrush = null) {
    if (!zoomBrush && !this.zoomBrush)
      return this;
    this.updateInstanceState({ zoomBrush }, true);
    return this;
  }
  /**
   * Rotate shapes by a delta in radians.
   *
   * @example
   * ```ts
   * editor.rotateShapesBy(['box1', 'box2'], Math.PI)
   * editor.rotateShapesBy(['box1', 'box2'], Math.PI / 2)
   * ```
   *
   * @param ids - The ids of the shapes to move.
   * @param delta - The delta in radians to apply to the selection rotation.
   */
  rotateShapesBy(ids, delta) {
    if (ids.length <= 0)
      return this;
    const snapshot = (0, import_rotation.getRotationSnapshot)({ editor: this });
    (0, import_rotation.applyRotationToSnapshotShapes)({ delta, snapshot, editor: this, stage: "one-off" });
    return this;
  }
  /**
   * Move shapes by a delta.
   *
   * @example
   * ```ts
   * editor.nudgeShapes(['box1', 'box2'], { x: 0, y: 1 })
   * editor.nudgeShapes(['box1', 'box2'], { x: 0, y: 1 }, true)
   * ```
   *
   * @param ids - The ids of the shapes to move.
   * @param direction - The direction in which to move the shapes.
   * @param major - Whether this is a major nudge, e.g. a shift + arrow nudge.
   */
  nudgeShapes(ids, direction, major = false, ephemeral = false) {
    if (ids.length <= 0)
      return this;
    const step = this.isGridMode ? major ? this.gridSize * import_constants.GRID_INCREMENT : this.gridSize : major ? import_constants.MAJOR_NUDGE_FACTOR : import_constants.MINOR_NUDGE_FACTOR;
    const steppedDelta = import_primitives.Vec2d.Mul(direction, step);
    const changes = [];
    for (const id of ids) {
      const shape = this.getShapeById(id);
      if (!shape) {
        throw Error(`Could not find a shape with the id ${id}.`);
      }
      const localDelta = this.getDeltaInParentSpace(shape, steppedDelta);
      const translateStartChanges = this.getShapeUtil(shape).onTranslateStart?.(shape);
      changes.push(
        translateStartChanges ? {
          ...translateStartChanges,
          x: shape.x + localDelta.x,
          y: shape.y + localDelta.y
        } : {
          id,
          x: shape.x + localDelta.x,
          y: shape.y + localDelta.y,
          type: shape.type
        }
      );
    }
    this.updateShapes(changes, ephemeral);
    return this;
  }
  /**
   * Duplicate shapes.
   *
   * @example
   * ```ts
   * editor.duplicateShapes()
   * editor.duplicateShapes(['id1', 'id2'])
   * editor.duplicateShapes(['id1', 'id2'], { x: 8, y: 8 })
   * ```
   *
   * @param ids - The ids of the shapes to duplicate. Defaults to the ids of the selected shapes.
   * @param offset - The offset (in pixels) to apply to the duplicated shapes.
   *
   * @public
   */
  duplicateShapes(ids = this.selectedIds, offset) {
    if (ids.length <= 0)
      return this;
    const initialIds = new Set(ids);
    const idsToCreate = [];
    const idsToCheck = [...ids];
    while (idsToCheck.length > 0) {
      const id = idsToCheck.pop();
      if (!id)
        break;
      idsToCreate.push(id);
      this.getSortedChildIds(id).forEach((childId) => idsToCheck.push(childId));
    }
    idsToCreate.reverse();
    const idsMap = new Map(idsToCreate.map((id) => [id, (0, import_tlschema.createShapeId)()]));
    const shapesToCreate = (0, import_utils.compact)(
      idsToCreate.map((id) => {
        const shape = this.getShapeById(id);
        if (!shape) {
          return null;
        }
        const createId = idsMap.get(id);
        let ox = 0;
        let oy = 0;
        if (offset && initialIds.has(id)) {
          const parentTransform = this.getParentTransform(shape);
          const vec = new import_primitives.Vec2d(offset.x, offset.y).rot(
            -import_primitives.Matrix2d.Decompose(parentTransform).rotation
          );
          ox = vec.x;
          oy = vec.y;
        }
        const parentId = shape.parentId ?? this.currentPageId;
        const siblings = this.getSortedChildIds(parentId);
        const currentIndex = siblings.indexOf(shape.id);
        const siblingAboveId = siblings[currentIndex + 1];
        const siblingAbove = siblingAboveId ? this.getShapeById(siblingAboveId) : null;
        const index = siblingAbove ? (0, import_indices.getIndexBetween)(shape.index, siblingAbove.index) : (0, import_indices.getIndexAbove)(shape.index);
        let newShape = (0, import_utils.deepCopy)(shape);
        if (this.isShapeOfType(shape, import_ArrowShapeUtil.ArrowShapeUtil) && this.isShapeOfType(newShape, import_ArrowShapeUtil.ArrowShapeUtil)) {
          const info = this.getShapeUtil(import_ArrowShapeUtil.ArrowShapeUtil).getArrowInfo(shape);
          let newStartShapeId = void 0;
          let newEndShapeId = void 0;
          if (shape.props.start.type === "binding") {
            newStartShapeId = idsMap.get(shape.props.start.boundShapeId);
            if (!newStartShapeId) {
              if (info?.isValid) {
                const { x, y } = info.start.point;
                newShape.props.start = {
                  type: "point",
                  x,
                  y
                };
              } else {
                const { start } = (0, import_shared.getArrowTerminalsInArrowSpace)(this, shape);
                newShape.props.start = {
                  type: "point",
                  x: start.x,
                  y: start.y
                };
              }
            }
          }
          if (shape.props.end.type === "binding") {
            newEndShapeId = idsMap.get(shape.props.end.boundShapeId);
            if (!newEndShapeId) {
              if (info?.isValid) {
                const { x, y } = info.end.point;
                newShape.props.end = {
                  type: "point",
                  x,
                  y
                };
              } else {
                const { end } = (0, import_shared.getArrowTerminalsInArrowSpace)(this, shape);
                newShape.props.start = {
                  type: "point",
                  x: end.x,
                  y: end.y
                };
              }
            }
          }
          const infoAfter = (0, import_shared.getIsArrowStraight)(newShape) ? (0, import_straight_arrow.getStraightArrowInfo)(this, newShape) : (0, import_curved_arrow.getCurvedArrowInfo)(this, newShape);
          if (info?.isValid && infoAfter?.isValid && !(0, import_shared.getIsArrowStraight)(shape)) {
            const mpA = import_primitives.Vec2d.Med(info.start.handle, info.end.handle);
            const distA = import_primitives.Vec2d.Dist(info.middle, mpA);
            const distB = import_primitives.Vec2d.Dist(infoAfter.middle, mpA);
            if (newShape.props.bend < 0) {
              newShape.props.bend += distB - distA;
            } else {
              newShape.props.bend -= distB - distA;
            }
          }
          if (newShape.props.start.type === "binding" && newStartShapeId) {
            newShape.props.start.boundShapeId = newStartShapeId;
          }
          if (newShape.props.end.type === "binding" && newEndShapeId) {
            newShape.props.end.boundShapeId = newEndShapeId;
          }
        }
        newShape = { ...newShape, id: createId, x: shape.x + ox, y: shape.y + oy, index };
        return newShape;
      })
    );
    shapesToCreate.forEach((shape) => {
      if ((0, import_tlschema.isShapeId)(shape.parentId)) {
        if (idsMap.has(shape.parentId)) {
          shape.parentId = idsMap.get(shape.parentId);
        }
      }
    });
    this.history.batch(() => {
      const maxShapesReached = shapesToCreate.length + this.currentPageShapeIds.size > import_constants.MAX_SHAPES_PER_PAGE;
      if (maxShapesReached) {
        alertMaxShapes(this);
      }
      const newShapes = maxShapesReached ? shapesToCreate.slice(0, import_constants.MAX_SHAPES_PER_PAGE - this.currentPageShapeIds.size) : shapesToCreate;
      const ids2 = newShapes.map((s) => s.id);
      this.createShapes(newShapes);
      this.setSelectedIds(ids2);
      if (offset !== void 0) {
        const { viewportPageBounds, selectedPageBounds } = this;
        if (selectedPageBounds && !viewportPageBounds.contains(selectedPageBounds)) {
          this.centerOnPoint(selectedPageBounds.center.x, selectedPageBounds.center.y, {
            duration: import_constants.ANIMATION_MEDIUM_MS
          });
        }
      }
    });
    return this;
  }
  /**
   * Set the current opacity. This will effect any selected shapes, or the
   * next-created shape.
   *
   * @example
   * ```ts
   * editor.setOpacity(0.5)
   * editor.setOpacity(0.5, true)
   * ```
   *
   * @param opacity - The opacity to set. Must be a number between 0 and 1 inclusive.
   * @param ephemeral - Whether the opacity change is ephemeral. Ephemeral changes don't get added to the undo/redo stack. Defaults to false.
   * @param squashing - Whether the opacity change will be squashed into the existing history entry rather than creating a new one. Defaults to false.
   */
  setOpacity(opacity, ephemeral = false, squashing = false) {
    this.history.batch(() => {
      if (this.isIn("select")) {
        const {
          pageState: { selectedIds }
        } = this;
        const shapesToUpdate = [];
        const addShapeById = (id) => {
          const shape = this.getShapeById(id);
          if (!shape)
            return;
          if (this.isShapeOfType(shape, import_GroupShapeUtil.GroupShapeUtil)) {
            const childIds = this.getSortedChildIds(id);
            for (const childId of childIds) {
              addShapeById(childId);
            }
          } else {
            shapesToUpdate.push(shape);
          }
        };
        if (selectedIds.length > 0) {
          for (const id of selectedIds) {
            addShapeById(id);
          }
          this.updateShapes(
            shapesToUpdate.map((shape) => {
              return {
                id: shape.id,
                type: shape.type,
                opacity
              };
            }),
            ephemeral
          );
        }
      }
      this.updateInstanceState({ opacityForNextShape: opacity }, ephemeral, squashing);
    });
    return this;
  }
  /**
   * Set the current styles
   *
   * @example
   * ```ts
   * editor.setProp(DefaultColorStyle, 'red')
   * editor.setProp(DefaultColorStyle, 'red', true)
   * ```
   *
   * @param style - The style to set.
   * @param value - The value to set.
   * @param ephemeral - Whether the style change is ephemeral. Ephemeral changes don't get added to the undo/redo stack. Defaults to false.
   * @param squashing - Whether the style change will be squashed into the existing history entry rather than creating a new one. Defaults to false.
   *
   * @public
   */
  setStyle(style, value, ephemeral = false, squashing = false) {
    this.history.batch(() => {
      if (this.isIn("select")) {
        const {
          pageState: { selectedIds }
        } = this;
        if (selectedIds.length > 0) {
          const updates = [];
          const addShapeById = (id) => {
            const shape = this.getShapeById(id);
            if (!shape)
              return;
            if (this.isShapeOfType(shape, import_GroupShapeUtil.GroupShapeUtil)) {
              const childIds = this.getSortedChildIds(id);
              for (const childId of childIds) {
                addShapeById(childId);
              }
            } else {
              const util = this.getShapeUtil(shape);
              if (util.hasStyle(style)) {
                const shapePartial = {
                  id: shape.id,
                  type: shape.type,
                  props: {}
                };
                updates.push({
                  originalShape: shape,
                  updatePartial: util.setStyleInPartial(style, shapePartial, value)
                });
              }
            }
          };
          for (const id of selectedIds) {
            addShapeById(id);
          }
          this.updateShapes(
            updates.map(({ updatePartial }) => updatePartial),
            ephemeral
          );
          const changes = [];
          for (const { originalShape } of updates) {
            const currentShape = this.getShapeById(originalShape.id);
            if (!currentShape)
              continue;
            const util = this.getShapeUtil(currentShape);
            const boundsA = util.bounds(originalShape);
            const boundsB = util.bounds(currentShape);
            const change = { id: originalShape.id, type: originalShape.type };
            let didChange = false;
            if (boundsA.width !== boundsB.width) {
              didChange = true;
              if (this.isShapeOfType(originalShape, import_TextShapeUtil.TextShapeUtil)) {
                switch (originalShape.props.align) {
                  case "middle": {
                    change.x = currentShape.x + (boundsA.width - boundsB.width) / 2;
                    break;
                  }
                  case "end": {
                    change.x = currentShape.x + boundsA.width - boundsB.width;
                    break;
                  }
                }
              } else {
                change.x = currentShape.x + (boundsA.width - boundsB.width) / 2;
              }
            }
            if (boundsA.height !== boundsB.height) {
              didChange = true;
              change.y = currentShape.y + (boundsA.height - boundsB.height) / 2;
            }
            if (didChange) {
              changes.push(change);
            }
          }
          if (changes.length) {
            this.updateShapes(changes, ephemeral);
          }
        }
      }
      this.updateInstanceState(
        {
          stylesForNextShape: { ...this._stylesForNextShape, [style.id]: value }
        },
        ephemeral,
        squashing
      );
    });
    return this;
  }
  /** @internal */
  _willSetInitialBounds = true;
  /** @internal */
  _setCamera(x, y, z = this.camera.z) {
    const currentCamera = this.camera;
    if (currentCamera.x === x && currentCamera.y === y && currentCamera.z === z)
      return this;
    const nextCamera = { ...currentCamera, x, y, z };
    this.batch(() => {
      this.store.put([nextCamera]);
      const { currentScreenPoint } = this.inputs;
      this.dispatch({
        type: "pointer",
        target: "canvas",
        name: "pointer_move",
        point: currentScreenPoint,
        pointerId: import_constants.INTERNAL_POINTER_IDS.CAMERA_MOVE,
        ctrlKey: this.inputs.ctrlKey,
        altKey: this.inputs.altKey,
        shiftKey: this.inputs.shiftKey,
        button: 0,
        isPen: this.isPenMode ?? false
      });
      this._tickCameraState();
    });
    return this;
  }
  /**
   * Set the current camera.
   *
   * @example
   * ```ts
   * editor.setCamera(0, 0)
   * editor.setCamera(0, 0, 1)
   * ```
   *
   * @param x - The camera's x position.
   * @param y - The camera's y position.
   * @param z - The camera's z position. Defaults to the current zoom.
   * @param options - Options for the camera change.
   *
   * @public
   */
  setCamera(x, y, z = this.camera.z, { stopFollowing = true } = {}) {
    this.stopCameraAnimation();
    if (stopFollowing && this.instanceState.followingUserId) {
      this.stopFollowingUser();
    }
    x = Number.isNaN(x) ? 0 : x;
    y = Number.isNaN(y) ? 0 : y;
    z = Number.isNaN(z) ? 1 : z;
    this._setCamera(x, y, z);
    return this;
  }
  /**
   * Animate the camera.
   *
   * @example
   * ```ts
   * editor.animateCamera(0, 0)
   * editor.animateCamera(0, 0, 1)
   * editor.animateCamera(0, 0, 1, { duration: 1000, easing: (t) => t * t })
   * ```
   *
   * @param x - The camera's x position.
   * @param y - The camera's y position.
   * @param z - The camera's z position. Defaults to the current zoom.
   * @param opts - Options for the animation.
   *
   * @public
   */
  animateCamera(x, y, z = this.camera.z, opts = import_constants.DEFAULT_ANIMATION_OPTIONS) {
    x = Number.isNaN(x) ? 0 : x;
    y = Number.isNaN(y) ? 0 : y;
    z = Number.isNaN(z) ? 1 : z;
    const { width, height } = this.viewportScreenBounds;
    const w = width / z;
    const h = height / z;
    const targetViewport = new import_primitives.Box2d(-x, -y, w, h);
    return this._animateToViewport(targetViewport, opts);
  }
  /**
   * Center the camera on a point (in page space).
   *
   * @example
   * ```ts
   * editor.centerOnPoint(100, 100)
   * ```
   *
   * @param x - The x position of the point.
   * @param y - The y position of the point.
   * @param opts - The options for an animation.
   *
   * @public
   */
  centerOnPoint(x, y, opts) {
    if (!this.canMoveCamera)
      return this;
    const {
      viewportPageBounds: { width: pw, height: ph },
      camera
    } = this;
    if (opts?.duration) {
      this.animateCamera(-(x - pw / 2), -(y - ph / 2), camera.z, opts);
    } else {
      this.setCamera(-(x - pw / 2), -(y - ph / 2), camera.z);
    }
    return this;
  }
  /**
   * Move the camera to the nearest content.
   *
   * @public
   */
  zoomToContent() {
    const bounds = this.selectedPageBounds ?? this.allShapesCommonBounds;
    if (bounds) {
      this.zoomToBounds(
        bounds.minX,
        bounds.minY,
        bounds.width,
        bounds.height,
        Math.min(1, this.zoomLevel),
        { duration: 220 }
      );
    }
    return this;
  }
  /**
   * Zoom the camera to fit the current page's content in the viewport.
   *
   * @example
   * ```ts
   * editor.zoomToFit()
   * ```
   *
   * @public
   */
  zoomToFit(opts) {
    if (!this.canMoveCamera)
      return this;
    const ids = [...this.currentPageShapeIds];
    if (ids.length <= 0)
      return this;
    const pageBounds = import_primitives.Box2d.Common((0, import_utils.compact)(ids.map((id) => this.getPageBoundsById(id))));
    this.zoomToBounds(
      pageBounds.minX,
      pageBounds.minY,
      pageBounds.width,
      pageBounds.height,
      void 0,
      opts
    );
    return this;
  }
  /**
   * Set the zoom back to 100%.
   *
   * @example
   * ```ts
   * editor.resetZoom()
   * ```
   *
   * @param opts - The options for an animation.
   *
   * @public
   */
  resetZoom(point = this.viewportScreenCenter, opts) {
    if (!this.canMoveCamera)
      return this;
    const { x: cx, y: cy, z: cz } = this.camera;
    const { x, y } = point;
    if (opts?.duration) {
      this.animateCamera(cx + (x / 1 - x) - (x / cz - x), cy + (y / 1 - y) - (y / cz - y), 1, opts);
    } else {
      this.setCamera(cx + (x / 1 - x) - (x / cz - x), cy + (y / 1 - y) - (y / cz - y), 1);
    }
    return this;
  }
  /**
   * Zoom the camera in.
   *
   * @example
   * ```ts
   * editor.zoomIn()
   * editor.zoomIn(editor.viewportScreenCenter, { duration: 120 })
   * editor.zoomIn(editor.inputs.currentScreenPoint, { duration: 120 })
   * ```
   *
   * @param opts - The options for an animation.
   *
   * @public
   */
  zoomIn(point = this.viewportScreenCenter, opts) {
    if (!this.canMoveCamera)
      return this;
    const { x: cx, y: cy, z: cz } = this.camera;
    let zoom = import_constants.MAX_ZOOM;
    for (let i = 1; i < import_constants.ZOOMS.length; i++) {
      const z1 = import_constants.ZOOMS[i - 1];
      const z2 = import_constants.ZOOMS[i];
      if (z2 - cz <= (z2 - z1) / 2)
        continue;
      zoom = z2;
      break;
    }
    const { x, y } = point;
    if (opts?.duration) {
      this.animateCamera(
        cx + (x / zoom - x) - (x / cz - x),
        cy + (y / zoom - y) - (y / cz - y),
        zoom,
        opts
      );
    } else {
      this.setCamera(cx + (x / zoom - x) - (x / cz - x), cy + (y / zoom - y) - (y / cz - y), zoom);
    }
    return this;
  }
  /**
   * Zoom the camera out.
   *
   * @example
   * ```ts
   * editor.zoomOut()
   * editor.zoomOut(editor.viewportScreenCenter, { duration: 120 })
   * editor.zoomOut(editor.inputs.currentScreenPoint, { duration: 120 })
   * ```
   *
   * @param opts - The options for an animation.
   *
   * @public
   */
  zoomOut(point = this.viewportScreenCenter, opts) {
    if (!this.canMoveCamera)
      return this;
    const { x: cx, y: cy, z: cz } = this.camera;
    let zoom = import_constants.MIN_ZOOM;
    for (let i = import_constants.ZOOMS.length - 1; i > 0; i--) {
      const z1 = import_constants.ZOOMS[i - 1];
      const z2 = import_constants.ZOOMS[i];
      if (z2 - cz >= (z2 - z1) / 2)
        continue;
      zoom = z1;
      break;
    }
    const { x, y } = point;
    if (opts?.duration) {
      this.animateCamera(
        cx + (x / zoom - x) - (x / cz - x),
        cy + (y / zoom - y) - (y / cz - y),
        zoom,
        opts
      );
    } else {
      this.setCamera(cx + (x / zoom - x) - (x / cz - x), cy + (y / zoom - y) - (y / cz - y), zoom);
    }
    return this;
  }
  /**
   * Zoom the camera to fit the current selection in the viewport.
   *
   * @example
   * ```ts
   * editor.zoomToSelection()
   * ```
   *
   * @param opts - The options for an animation.
   *
   * @public
   */
  zoomToSelection(opts) {
    if (!this.canMoveCamera)
      return this;
    const ids = this.selectedIds;
    if (ids.length <= 0)
      return this;
    const selectedBounds = import_primitives.Box2d.Common((0, import_utils.compact)(ids.map((id) => this.getPageBoundsById(id))));
    this.zoomToBounds(
      selectedBounds.minX,
      selectedBounds.minY,
      selectedBounds.width,
      selectedBounds.height,
      Math.max(1, this.camera.z),
      opts
    );
    return this;
  }
  /**
   * Pan or pan/zoom the selected ids into view. This method tries to not change the zoom if possible.
   *
   * @param ids - The ids of the shapes to pan and zoom into view.
   * @param opts - The options for an animation.
   *
   * @public
   */
  panZoomIntoView(ids, opts) {
    if (!this.canMoveCamera)
      return this;
    if (ids.length <= 0)
      return this;
    const selectedBounds = import_primitives.Box2d.Common((0, import_utils.compact)(ids.map((id) => this.getPageBoundsById(id))));
    const { viewportPageBounds } = this;
    if (viewportPageBounds.h < selectedBounds.h || viewportPageBounds.w < selectedBounds.w) {
      this.zoomToBounds(
        selectedBounds.minX,
        selectedBounds.minY,
        selectedBounds.width,
        selectedBounds.height,
        this.camera.z,
        opts
      );
      return this;
    } else {
      const bufferOffsets = this._activeAreaManager.offsets.value;
      const pageTop = viewportPageBounds.y + bufferOffsets.top;
      const pageRight = viewportPageBounds.maxY - bufferOffsets.right;
      const pageBottom = viewportPageBounds.maxY - bufferOffsets.bottom;
      const pageLeft = viewportPageBounds.x + bufferOffsets.left;
      const selectedTop = selectedBounds.y;
      const selectedRight = selectedBounds.maxX;
      const selectedBottom = selectedBounds.maxY;
      const selectedLeft = selectedBounds.x;
      let offsetX = 0;
      let offsetY = 0;
      if (pageBottom < selectedBottom) {
        offsetY = pageBottom - selectedBottom;
      } else if (pageTop > selectedTop) {
        offsetY = pageTop - selectedTop;
      } else {
      }
      if (pageRight < selectedRight) {
        offsetX = pageRight - selectedRight;
      } else if (pageLeft > selectedLeft) {
        offsetX = pageLeft - selectedLeft;
      } else {
      }
      const { camera } = this;
      if (opts?.duration) {
        this.animateCamera(camera.x + offsetX, camera.y + offsetY, camera.z, opts);
      } else {
        this.setCamera(camera.x + offsetX, camera.y + offsetY, camera.z);
      }
    }
    return this;
  }
  /**
   * Zoom the camera to fit a bounding box (in page space).
   *
   * @example
   * ```ts
   * editor.zoomToBounds(0, 0, 100, 100)
   * ```
   *
   * @param x - The bounding box's x position.
   * @param y - The bounding box's y position.
   * @param width - The bounding box's width.
   * @param height - The bounding box's height.
   * @param targetZoom - The desired zoom level. Defaults to 0.1.
   *
   * @public
   */
  zoomToBounds(x, y, width, height, targetZoom, opts) {
    if (!this.canMoveCamera)
      return this;
    const { viewportScreenBounds } = this;
    const inset = Math.min(256, viewportScreenBounds.width * 0.28);
    let zoom = (0, import_primitives.clamp)(
      Math.min(
        (viewportScreenBounds.width - inset) / width,
        (viewportScreenBounds.height - inset) / height
      ),
      import_constants.MIN_ZOOM,
      import_constants.MAX_ZOOM
    );
    if (targetZoom !== void 0) {
      zoom = Math.min(targetZoom, zoom);
    }
    if (opts?.duration) {
      this.animateCamera(
        -x + (viewportScreenBounds.width - width * zoom) / 2 / zoom,
        -y + (viewportScreenBounds.height - height * zoom) / 2 / zoom,
        zoom,
        opts
      );
    } else {
      this.setCamera(
        -x + (viewportScreenBounds.width - width * zoom) / 2 / zoom,
        -y + (viewportScreenBounds.height - height * zoom) / 2 / zoom,
        zoom
      );
    }
    return this;
  }
  /**
   * Pan the camera.
   *
   * @example
   * ```ts
   * editor.pan(100, 100)
   * editor.pan(100, 100, { duration: 1000 })
   * ```
   *
   * @param dx - The amount to pan on the x axis.
   * @param dy - The amount to pan on the y axis.
   * @param opts - The animation options
   */
  pan(dx, dy, opts) {
    if (!this.canMoveCamera)
      return this;
    const { camera } = this;
    const { x: cx, y: cy, z: cz } = camera;
    const d = new import_primitives.Vec2d(dx, dy).div(cz);
    if (opts?.duration ?? 0 > 0) {
      return this.animateCamera(cx + d.x, cy + d.y, cz, opts);
    } else {
      this.setCamera(cx + d.x, cy + d.y, cz);
    }
    return this;
  }
  /**
   * Stop the current camera animation, if any.
   *
   * @public
   */
  stopCameraAnimation() {
    this.emit("stop-camera-animation");
    return this;
  }
  /** @internal */
  _viewportAnimation = null;
  /** @internal */
  _animateViewport(ms) {
    if (!this._viewportAnimation)
      return;
    const cancel = () => {
      this.removeListener("tick", this._animateViewport);
      this.removeListener("stop-camera-animation", cancel);
      this._viewportAnimation = null;
    };
    this.once("stop-camera-animation", cancel);
    this._viewportAnimation.elapsed += ms;
    const { elapsed, easing, duration, start, end } = this._viewportAnimation;
    if (elapsed > duration) {
      const z2 = this.viewportScreenBounds.width / end.width;
      const x2 = -end.x;
      const y2 = -end.y;
      this._setCamera(x2, y2, z2);
      cancel();
      return;
    }
    const remaining = duration - elapsed;
    const t = easing(1 - remaining / duration);
    const left = start.minX + (end.minX - start.minX) * t;
    const top = start.minY + (end.minY - start.minY) * t;
    const right = start.maxX + (end.maxX - start.maxX) * t;
    const bottom = start.maxY + (end.maxY - start.maxY) * t;
    const easedViewport = new import_primitives.Box2d(left, top, right - left, bottom - top);
    const z = this.viewportScreenBounds.width / easedViewport.width;
    const x = -easedViewport.x;
    const y = -easedViewport.y;
    this._setCamera(x, y, z);
  }
  /** @internal */
  _animateToViewport(targetViewportPage, opts = {}) {
    const { duration = 0, easing = import_primitives.EASINGS.easeInOutCubic } = opts;
    const { animationSpeed, viewportPageBounds } = this;
    this.stopCameraAnimation();
    if (this.instanceState.followingUserId) {
      this.stopFollowingUser();
    }
    if (duration === 0 || animationSpeed === 0) {
      return this._setCamera(
        -targetViewportPage.x,
        -targetViewportPage.y,
        this.viewportScreenBounds.width / targetViewportPage.width
      );
    }
    this._viewportAnimation = {
      elapsed: 0,
      duration: duration / animationSpeed,
      easing,
      start: viewportPageBounds.clone(),
      end: targetViewportPage
    };
    this.addListener("tick", this._animateViewport);
    return this;
  }
  /**
   * Slide the camera in a certain direction.
   *
   * @param opts - Options for the slide
   * @public
   */
  slideCamera(opts = {}) {
    if (!this.canMoveCamera)
      return this;
    this.stopCameraAnimation();
    const { animationSpeed } = this;
    if (animationSpeed === 0)
      return;
    const { speed, friction, direction, speedThreshold = 0.01 } = opts;
    let currentSpeed = Math.min(speed, 1);
    const cancel = () => {
      this.removeListener("tick", moveCamera);
      this.removeListener("stop-camera-animation", cancel);
    };
    this.once("stop-camera-animation", cancel);
    const moveCamera = (elapsed) => {
      const { x: cx, y: cy, z: cz } = this.camera;
      const movementVec = direction.clone().mul(currentSpeed * elapsed / cz);
      currentSpeed *= 1 - friction;
      if (currentSpeed < speedThreshold) {
        cancel();
      } else {
        this._setCamera(cx + movementVec.x, cy + movementVec.y, cz);
      }
    };
    this.addListener("tick", moveCamera);
    return this;
  }
  /**
   * Animate the camera to a user's cursor position.
   * This also briefly show the user's cursor if it's not currently visible.
   *
   * @param userId - The id of the user to aniamte to.
   * @public
   */
  animateToUser(userId) {
    const presences = this.store.query.records("instance_presence", () => ({
      userId: { eq: userId }
    }));
    const presence = [...presences.value].sort((a, b) => {
      return a.lastActivityTimestamp - b.lastActivityTimestamp;
    }).pop();
    if (!presence)
      return;
    this.batch(() => {
      if (this.instanceState.followingUserId !== null) {
        this.stopFollowingUser();
      }
      const isOnSamePage = presence.currentPageId === this.currentPageId;
      if (!isOnSamePage) {
        this.setCurrentPageId(presence.currentPageId);
      }
      const options = isOnSamePage ? { duration: 500 } : void 0;
      const position = presence.cursor;
      this.centerOnPoint(position.x, position.y, options);
      const { highlightedUserIds } = this.instanceState;
      this.updateInstanceState({ highlightedUserIds: [...highlightedUserIds, userId] });
      setTimeout(() => {
        const highlightedUserIds2 = [...this.instanceState.highlightedUserIds];
        const index = highlightedUserIds2.indexOf(userId);
        if (index < 0)
          return;
        highlightedUserIds2.splice(index, 1);
        this.updateInstanceState({ highlightedUserIds: highlightedUserIds2 });
      }, import_constants.COLLABORATOR_TIMEOUT);
    });
  }
  /**
   * Start viewport-following a user.
   *
   * @param userId - The id of the user to follow.
   *
   * @public
   */
  startFollowingUser(userId) {
    const leaderPresences = this.store.query.records("instance_presence", () => ({
      userId: { eq: userId }
    }));
    const thisUserId = this.user.id;
    if (!thisUserId) {
      console.warn("You should set the userId for the current instance before following a user");
    }
    if (leaderPresences.value.some((p) => p.followingUserId === thisUserId)) {
      return;
    }
    (0, import_signia.transact)(() => {
      this.stopFollowingUser();
      this.updateInstanceState({ followingUserId: userId }, true);
    });
    const cancel = () => {
      this.removeListener("frame", moveTowardsUser);
      this.removeListener("stop-following", cancel);
    };
    let isCaughtUp = false;
    const moveTowardsUser = () => {
      const leaderPresence = [...leaderPresences.value].sort((a, b) => {
        return a.lastActivityTimestamp - b.lastActivityTimestamp;
      }).pop();
      if (!leaderPresence) {
        this.stopFollowingUser();
        return;
      }
      const isOnSamePage = leaderPresence.currentPageId === this.currentPageId;
      const chaseProportion = isOnSamePage ? import_constants.FOLLOW_CHASE_PROPORTION : 1;
      if (!isOnSamePage) {
        this.setCurrentPageId(leaderPresence.currentPageId, { stopFollowing: false });
      }
      const { center, width, height } = this.viewportPageBounds;
      const leaderScreen = import_primitives.Box2d.From(leaderPresence.screenBounds);
      const leaderWidth = leaderScreen.width / leaderPresence.camera.z;
      const leaderHeight = leaderScreen.height / leaderPresence.camera.z;
      const leaderCenter = new import_primitives.Vec2d(
        leaderWidth / 2 - leaderPresence.camera.x,
        leaderHeight / 2 - leaderPresence.camera.y
      );
      const isFollowingFollower = leaderPresence.followingUserId === thisUserId;
      const desiredWidth = width + (leaderWidth - width) * chaseProportion;
      const desiredHeight = height + (leaderHeight - height) * chaseProportion;
      const ratio = !isFollowingFollower ? Math.min(width / desiredWidth, height / desiredHeight) : height / desiredHeight;
      const targetZoom = (0, import_primitives.clamp)(this.camera.z * ratio, import_constants.MIN_ZOOM, import_constants.MAX_ZOOM);
      const targetWidth = this.viewportScreenBounds.w / targetZoom;
      const targetHeight = this.viewportScreenBounds.h / targetZoom;
      const displacement = leaderCenter.sub(center);
      const targetCenter = import_primitives.Vec2d.Add(center, import_primitives.Vec2d.Mul(displacement, chaseProportion));
      const distance = import_primitives.Vec2d.Sub(targetCenter, center).len();
      const zoomChange = Math.abs(targetZoom - this.camera.z);
      if (distance < import_constants.FOLLOW_CHASE_PAN_SNAP && zoomChange < import_constants.FOLLOW_CHASE_ZOOM_SNAP) {
        isCaughtUp = true;
        return;
      }
      if (isCaughtUp && distance < import_constants.FOLLOW_CHASE_PAN_UNSNAP && zoomChange < import_constants.FOLLOW_CHASE_ZOOM_UNSNAP) {
        return;
      }
      isCaughtUp = false;
      this.stopCameraAnimation();
      this.setCamera(
        -(targetCenter.x - targetWidth / 2),
        -(targetCenter.y - targetHeight / 2),
        targetZoom,
        { stopFollowing: false }
      );
    };
    this.once("stop-following", cancel);
    this.addListener("frame", moveTowardsUser);
    return this;
  }
  /**
   * Stop viewport-following a user.
   *
   * @public
   */
  stopFollowingUser() {
    this.updateInstanceState({ followingUserId: null }, true);
    this.emit("stop-following");
    return this;
  }
  /**
   * Animate the camera to a shape.
   *
   * @public
   */
  animateToShape(shapeId, opts = import_constants.DEFAULT_ANIMATION_OPTIONS) {
    if (!this.canMoveCamera)
      return this;
    const activeArea = (0, import_ActiveAreaManager.getActiveAreaScreenSpace)(this);
    const viewportAspectRatio = activeArea.width / activeArea.height;
    const shapePageBounds = this.getPageBoundsById(shapeId);
    if (!shapePageBounds)
      return this;
    const shapeAspectRatio = shapePageBounds.width / shapePageBounds.height;
    const targetViewportPage = shapePageBounds.clone();
    const z = shapePageBounds.width / activeArea.width;
    targetViewportPage.width += (activeArea.left + activeArea.right) * z;
    targetViewportPage.height += (activeArea.top + activeArea.bottom) * z;
    targetViewportPage.x -= activeArea.left * z;
    targetViewportPage.y -= activeArea.top * z;
    if (shapeAspectRatio > viewportAspectRatio) {
      targetViewportPage.height = shapePageBounds.width / viewportAspectRatio;
      targetViewportPage.y -= (targetViewportPage.height - shapePageBounds.height) / 2;
    } else {
      targetViewportPage.width = shapePageBounds.height * viewportAspectRatio;
      targetViewportPage.x -= (targetViewportPage.width - shapePageBounds.width) / 2;
    }
    return this._animateToViewport(targetViewportPage, opts);
  }
  /**
   * Blur the app, cancelling any interaction state.
   *
   * @example
   * ```ts
   * editor.blur()
   * ```
   *
   * @public
   */
  blur() {
    this.complete();
    this.getContainer().blur();
    this._isFocused.set(false);
    return this;
  }
  /**
   * Focus the editor.
   *
   * @example
   * ```ts
   * editor.focus()
   * ```
   *
   * @public
   */
  focus() {
    this.getContainer().focus();
    this._isFocused.set(true);
    return this;
  }
  /**
   * Dispatch a cancel event.
   *
   * @example
   * ```ts
   * editor.cancel()
   * ```
   *
   * @public
   */
  cancel() {
    this.dispatch({ type: "misc", name: "cancel" });
    return this;
  }
  /**
   * Dispatch an interrupt event.
   *
   * @example
   * ```ts
   * editor.interrupt()
   * ```
   *
   * @public
   */
  interrupt() {
    this.dispatch({ type: "misc", name: "interrupt" });
    return this;
  }
  /**
   * Dispatch a complete event.
   *
   * @example
   * ```ts
   * editor.complete()
   * ```
   *
   * @public
   */
  complete() {
    this.dispatch({ type: "misc", name: "complete" });
    return this;
  }
  /* -------------------- Callbacks ------------------- */
  /**
   * Handle external content, such as files, urls, embeds, or plain text which has been put into the app, for example by pasting external text or dropping external images onto canvas.
   *
   * @param info - Info about the external content.
   */
  async putExternalContent(info) {
    this.externalContentManager.handleContent(info);
  }
  /* ---------------- Text Measurement ---------------- */
  /**
   * A helper for measuring text.
   *
   * @public
   */
  textMeasure;
  /* --------------------- Groups --------------------- */
  /**
   * Group some shapes together.
   *
   * @param ids - Ids of the shapes to group. Defaults to the selected shapes.
   * @param groupId - Id of the group to create. Defaults to a new shape id.
   *
   * @public
   */
  groupShapes(ids = this.selectedIds, groupId = (0, import_tlschema.createShapeId)()) {
    if (this.isReadOnly)
      return this;
    if (ids.length <= 1)
      return this;
    const shapes = (0, import_utils.compact)(this._getUnlockedShapeIds(ids).map((id) => this.getShapeById(id)));
    const sortedShapeIds = shapes.sort(import_indices.sortByIndex).map((s) => s.id);
    const pageBounds = import_primitives.Box2d.Common((0, import_utils.compact)(shapes.map((id) => this.getPageBounds(id))));
    const { x, y } = pageBounds.point;
    const parentId = this.findCommonAncestor(shapes) ?? this.currentPageId;
    if (this.currentToolId !== "select")
      return this;
    if (!this.isIn("select.idle")) {
      this.cancel();
    }
    const shapesWithRootParent = shapes.filter((shape) => shape.parentId === parentId).sort(import_indices.sortByIndex);
    const highestIndex = shapesWithRootParent[shapesWithRootParent.length - 1]?.index;
    this.batch(() => {
      this.createShapes([
        {
          id: groupId,
          type: "group",
          parentId,
          index: highestIndex,
          x,
          y,
          opacity: 1,
          props: {}
        }
      ]);
      this.reparentShapesById(sortedShapeIds, groupId);
      this.select(groupId);
    });
    return this;
  }
  /**
   * Ungroup some shapes.
   *
   * @param ids - Ids of the shapes to ungroup. Defaults to the selected shapes.
   *
   * @public
   */
  ungroupShapes(ids = this.selectedIds) {
    if (this.isReadOnly)
      return this;
    if (ids.length === 0)
      return this;
    if (this.currentToolId !== "select")
      return this;
    if (!this.isIn("select.idle")) {
      this.cancel();
    }
    const idsToSelect = /* @__PURE__ */ new Set();
    const shapes = (0, import_utils.compact)(ids.map((id) => this.getShapeById(id)));
    const groups = [];
    shapes.forEach((shape) => {
      if (this.isShapeOfType(shape, import_GroupShapeUtil.GroupShapeUtil)) {
        groups.push(shape);
      } else {
        idsToSelect.add(shape.id);
      }
    });
    if (groups.length === 0)
      return this;
    this.batch(() => {
      let group;
      for (let i = 0, n = groups.length; i < n; i++) {
        group = groups[i];
        const childIds = this.getSortedChildIds(group.id);
        for (let j = 0, n2 = childIds.length; j < n2; j++) {
          idsToSelect.add(childIds[j]);
        }
        this.reparentShapesById(childIds, group.parentId, group.index);
      }
      this.deleteShapes(groups.map((group2) => group2.id));
      this.select(...idsToSelect);
    });
    return this;
  }
  /**
   * Get an exported SVG of the given shapes.
   *
   * @param ids - The ids of the shapes to export. Defaults to selected shapes.
   * @param opts - Options for the export.
   *
   * @returns The SVG element.
   *
   * @public
   */
  async getSvg(ids = this.selectedIds.length ? this.selectedIds : Object.keys(this.currentPageShapeIds), opts = {}) {
    if (ids.length === 0)
      return;
    if (!window.document)
      throw Error("No document");
    const {
      scale = 1,
      background = false,
      padding = import_constants.SVG_PADDING,
      darkMode = this.isDarkMode,
      preserveAspectRatio = false
    } = opts;
    const realContainerEl = this.getContainer();
    const realContainerStyle = getComputedStyle(realContainerEl);
    const fakeContainerEl = document.createElement("div");
    fakeContainerEl.className = `tl-container tl-theme__${darkMode ? "dark" : "light"} tl-theme__force-sRGB`;
    document.body.appendChild(fakeContainerEl);
    const containerStyle = getComputedStyle(fakeContainerEl);
    const fontsUsedInExport = /* @__PURE__ */ new Map();
    const colors = {
      fill: (0, import_utils.objectMapFromEntries)(
        import_tlschema.DefaultColorStyle.values.map((color) => [
          color,
          containerStyle.getPropertyValue(`--palette-${color}`)
        ])
      ),
      pattern: (0, import_utils.objectMapFromEntries)(
        import_tlschema.DefaultColorStyle.values.map((color) => [
          color,
          containerStyle.getPropertyValue(`--palette-${color}-pattern`)
        ])
      ),
      semi: (0, import_utils.objectMapFromEntries)(
        import_tlschema.DefaultColorStyle.values.map((color) => [
          color,
          containerStyle.getPropertyValue(`--palette-${color}-semi`)
        ])
      ),
      highlight: (0, import_utils.objectMapFromEntries)(
        import_tlschema.DefaultColorStyle.values.map((color) => [
          color,
          containerStyle.getPropertyValue(`--palette-${color}-highlight`)
        ])
      ),
      text: containerStyle.getPropertyValue(`--color-text`),
      background: containerStyle.getPropertyValue(`--color-background`),
      solid: containerStyle.getPropertyValue(`--palette-solid`)
    };
    document.body.removeChild(fakeContainerEl);
    const shapeIdsToInclude = this.getShapeAndDescendantIds(ids);
    const renderingShapes = this.computeUnorderedRenderingShapes([this.currentPageId]).filter(
      ({ id }) => shapeIdsToInclude.has(id)
    );
    let bbox = null;
    for (const { maskedPageBounds } of renderingShapes) {
      if (!maskedPageBounds)
        continue;
      if (bbox) {
        bbox.union(maskedPageBounds);
      } else {
        bbox = maskedPageBounds.clone();
      }
    }
    if (!bbox)
      return;
    const singleFrameShapeId = ids.length === 1 && this.isShapeOfType(this.getShapeById(ids[0]), import_FrameShapeUtil.FrameShapeUtil) ? ids[0] : null;
    if (!singleFrameShapeId) {
      bbox.expandBy(padding);
    }
    const w = bbox.width * scale;
    const h = bbox.height * scale;
    const svg = window.document.createElementNS("http://www.w3.org/2000/svg", "svg");
    if (preserveAspectRatio) {
      svg.setAttribute("preserveAspectRatio", preserveAspectRatio);
    }
    svg.setAttribute("direction", "ltr");
    svg.setAttribute("width", w + "");
    svg.setAttribute("height", h + "");
    svg.setAttribute("viewBox", `${bbox.minX} ${bbox.minY} ${bbox.width} ${bbox.height}`);
    svg.setAttribute("stroke-linecap", "round");
    svg.setAttribute("stroke-linejoin", "round");
    if (background) {
      if (singleFrameShapeId) {
        svg.style.setProperty("background", colors.solid);
      } else {
        svg.style.setProperty("background-color", colors.background);
      }
    } else {
      svg.style.setProperty("background-color", "transparent");
    }
    const defs = window.document.createElementNS("http://www.w3.org/2000/svg", "defs");
    for (const element of Array.from((0, import_usePattern.exportPatternSvgDefs)(colors.solid))) {
      defs.appendChild(element);
    }
    try {
      document.body.focus?.();
    } catch (e) {
    }
    svg.append(defs);
    const unorderedShapeElements = (await Promise.all(
      renderingShapes.map(async ({ id, opacity, index, backgroundIndex }) => {
        if (id === singleFrameShapeId)
          return [];
        const shape = this.getShapeById(id);
        if (this.isShapeOfType(shape, import_GroupShapeUtil.GroupShapeUtil))
          return [];
        const util = this.getShapeUtil(shape);
        let font;
        const fontFromShape = util.getStyleIfExists(import_tlschema.DefaultFontStyle, shape);
        if (fontFromShape) {
          if (fontsUsedInExport.has(fontFromShape)) {
            font = fontsUsedInExport.get(fontFromShape);
          } else {
            font = realContainerStyle.getPropertyValue(`--tl-font-${fontFromShape}`);
            fontsUsedInExport.set(fontFromShape, font);
          }
        }
        let shapeSvgElement = await util.toSvg?.(shape, font, colors);
        let backgroundSvgElement = await util.toBackgroundSvg?.(shape, font, colors);
        if (shapeSvgElement) {
          const outerElement = document.createElementNS("http://www.w3.org/2000/svg", "g");
          outerElement.appendChild(shapeSvgElement);
          shapeSvgElement = outerElement;
        }
        if (backgroundSvgElement) {
          const outerElement = document.createElementNS("http://www.w3.org/2000/svg", "g");
          outerElement.appendChild(backgroundSvgElement);
          backgroundSvgElement = outerElement;
        }
        if (!shapeSvgElement && !backgroundSvgElement) {
          const bounds = this.getPageBounds(shape);
          const elm = window.document.createElementNS("http://www.w3.org/2000/svg", "rect");
          elm.setAttribute("width", bounds.width + "");
          elm.setAttribute("height", bounds.height + "");
          elm.setAttribute("fill", colors.solid);
          elm.setAttribute("stroke", colors.pattern.grey);
          elm.setAttribute("stroke-width", "1");
          shapeSvgElement = elm;
        }
        let pageTransform = this.getPageTransform(shape).toCssString();
        if ("scale" in shape.props) {
          if (shape.props.scale !== 1) {
            pageTransform = `${pageTransform} scale(${shape.props.scale}, ${shape.props.scale})`;
          }
        }
        shapeSvgElement?.setAttribute("transform", pageTransform);
        backgroundSvgElement?.setAttribute("transform", pageTransform);
        shapeSvgElement?.setAttribute("opacity", opacity + "");
        backgroundSvgElement?.setAttribute("opacity", opacity + "");
        const pageMask = this.getPageMaskById(shape.id);
        if (pageMask) {
          const clipPathEl = document.createElementNS("http://www.w3.org/2000/svg", "clipPath");
          defs.appendChild(clipPathEl);
          const id2 = (0, import_nanoid.nanoid)();
          clipPathEl.id = id2;
          const mask = document.createElementNS("http://www.w3.org/2000/svg", "path");
          mask.setAttribute("d", `M${pageMask.map(({ x, y }) => `${x},${y}`).join("L")}Z`);
          clipPathEl.appendChild(mask);
          if (shapeSvgElement) {
            const outerElement = document.createElementNS("http://www.w3.org/2000/svg", "g");
            outerElement.setAttribute("clip-path", `url(#${id2})`);
            outerElement.appendChild(shapeSvgElement);
            shapeSvgElement = outerElement;
          }
          if (backgroundSvgElement) {
            const outerElement = document.createElementNS("http://www.w3.org/2000/svg", "g");
            outerElement.setAttribute("clip-path", `url(#${id2})`);
            outerElement.appendChild(backgroundSvgElement);
            backgroundSvgElement = outerElement;
          }
        }
        const elements = [];
        if (shapeSvgElement) {
          elements.push({ zIndex: index, element: shapeSvgElement });
        }
        if (backgroundSvgElement) {
          elements.push({ zIndex: backgroundIndex, element: backgroundSvgElement });
        }
        return elements;
      })
    )).flat();
    for (const { element } of unorderedShapeElements.sort((a, b) => a.zIndex - b.zIndex)) {
      svg.appendChild(element);
    }
    let styles = ``;
    const style = window.document.createElementNS("http://www.w3.org/2000/svg", "style");
    const fontInstances = [];
    if ("fonts" in document) {
      document.fonts.forEach((font) => fontInstances.push(font));
    }
    await Promise.all(
      fontInstances.map(async (font) => {
        const fileReader = new FileReader();
        let isUsed = false;
        fontsUsedInExport.forEach((fontName) => {
          if (fontName.includes(font.family)) {
            isUsed = true;
          }
        });
        if (!isUsed)
          return;
        const url = font.$$_url;
        const fontFaceRule = font.$$_fontface;
        if (url) {
          const fontFile = await (await fetch(url)).blob();
          const base64Font = await new Promise((resolve, reject) => {
            fileReader.onload = () => resolve(fileReader.result);
            fileReader.onerror = () => reject(fileReader.error);
            fileReader.readAsDataURL(fontFile);
          });
          const newFontFaceRule = "\n" + fontFaceRule.replaceAll(url, base64Font);
          styles += newFontFaceRule;
        }
      })
    );
    style.textContent = styles;
    defs.append(style);
    return svg;
  }
}
__decorateClass([
  import_signia.computed
], Editor.prototype, "_pageTransformCache", 1);
__decorateClass([
  import_signia.computed
], Editor.prototype, "_pageBoundsCache", 1);
__decorateClass([
  import_signia.computed
], Editor.prototype, "canUndo", 1);
__decorateClass([
  import_signia.computed
], Editor.prototype, "canRedo", 1);
__decorateClass([
  import_signia.computed
], Editor.prototype, "_stylesForNextShape", 1);
__decorateClass([
  (0, import_signia.computed)({ isEqual: (a, b) => a.equals(b) })
], Editor.prototype, "sharedStyles", 1);
__decorateClass([
  import_signia.computed
], Editor.prototype, "sharedOpacity", 1);
__decorateClass([
  import_signia.computed
], Editor.prototype, "_arrowBindingsIndex", 1);
__decorateClass([
  import_signia.computed
], Editor.prototype, "_allPageStates", 1);
__decorateClass([
  import_signia.computed
], Editor.prototype, "openMenus", 1);
__decorateClass([
  import_signia.computed
], Editor.prototype, "isMenuOpen", 1);
__decorateClass([
  import_signia.computed
], Editor.prototype, "documentSettings", 1);
__decorateClass([
  import_signia.computed
], Editor.prototype, "_pages", 1);
__decorateClass([
  import_signia.computed
], Editor.prototype, "pages", 1);
__decorateClass([
  import_signia.computed
], Editor.prototype, "_pageStates", 1);
__decorateClass([
  import_signia.computed
], Editor.prototype, "pageStateId", 1);
__decorateClass([
  import_signia.computed
], Editor.prototype, "pageState", 1);
__decorateClass([
  import_signia.computed
], Editor.prototype, "selectedIds", 1);
__decorateClass([
  import_signia.computed
], Editor.prototype, "selectedIdsSet", 1);
__decorateClass([
  import_signia.computed
], Editor.prototype, "editingShape", 1);
__decorateClass([
  import_signia.computed
], Editor.prototype, "hoveredId", 1);
__decorateClass([
  import_signia.computed
], Editor.prototype, "hoveredShape", 1);
__decorateClass([
  import_signia.computed
], Editor.prototype, "hintingIds", 1);
__decorateClass([
  import_signia.computed
], Editor.prototype, "erasingIds", 1);
__decorateClass([
  import_signia.computed
], Editor.prototype, "erasingIdsSet", 1);
__decorateClass([
  import_signia.computed
], Editor.prototype, "cameraId", 1);
__decorateClass([
  import_signia.computed
], Editor.prototype, "camera", 1);
__decorateClass([
  import_signia.computed
], Editor.prototype, "zoomLevel", 1);
__decorateClass([
  import_signia.computed
], Editor.prototype, "viewportScreenBounds", 1);
__decorateClass([
  import_signia.computed
], Editor.prototype, "viewportScreenCenter", 1);
__decorateClass([
  import_signia.computed
], Editor.prototype, "viewportPageBounds", 1);
__decorateClass([
  import_signia.computed
], Editor.prototype, "viewportPageCenter", 1);
__decorateClass([
  import_signia.computed
], Editor.prototype, "cameraState", 1);
__decorateClass([
  import_signia.computed
], Editor.prototype, "renderingShapes", 1);
__decorateClass([
  import_signia.computed
], Editor.prototype, "renderingBounds", 1);
__decorateClass([
  import_signia.computed
], Editor.prototype, "renderingBoundsExpanded", 1);
__decorateClass([
  import_signia.computed
], Editor.prototype, "_clipPathCache", 1);
__decorateClass([
  import_signia.computed
], Editor.prototype, "_pageMaskCache", 1);
__decorateClass([
  import_signia.computed
], Editor.prototype, "allShapesCommonBounds", 1);
__decorateClass([
  import_signia.computed
], Editor.prototype, "selectedPageBounds", 1);
__decorateClass([
  import_signia.computed
], Editor.prototype, "selectionRotation", 1);
__decorateClass([
  import_signia.computed
], Editor.prototype, "selectionBounds", 1);
__decorateClass([
  import_signia.computed
], Editor.prototype, "selectionPageCenter", 1);
__decorateClass([
  import_signia.computed
], Editor.prototype, "_assets", 1);
__decorateClass([
  import_signia.computed
], Editor.prototype, "shapesArray", 1);
__decorateClass([
  import_signia.computed
], Editor.prototype, "sortedShapesArray", 1);
__decorateClass([
  import_signia.computed
], Editor.prototype, "selectedShapes", 1);
__decorateClass([
  import_signia.computed
], Editor.prototype, "onlySelectedShape", 1);
function alertMaxShapes(editor, pageId = editor.currentPageId) {
  const name = editor.getPageById(pageId).name;
  editor.emit("max-shapes", { name, pageId, count: import_constants.MAX_SHAPES_PER_PAGE });
}
//# sourceMappingURL=Editor.js.map
