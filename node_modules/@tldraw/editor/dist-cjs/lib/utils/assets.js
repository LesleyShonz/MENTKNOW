"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var assets_exports = {};
__export(assets_exports, {
  ACCEPTED_ASSET_TYPE: () => ACCEPTED_ASSET_TYPE,
  ACCEPTED_IMG_TYPE: () => ACCEPTED_IMG_TYPE,
  ACCEPTED_VID_TYPE: () => ACCEPTED_VID_TYPE,
  base64ToFile: () => base64ToFile,
  containBoxSize: () => containBoxSize,
  dataUrlToFile: () => dataUrlToFile,
  getFileMetaData: () => getFileMetaData,
  getImageSizeFromSrc: () => getImageSizeFromSrc,
  getMediaAssetFromFile: () => getMediaAssetFromFile,
  getResizedImageDataUrl: () => getResizedImageDataUrl,
  getValidHttpURLList: () => getValidHttpURLList,
  getVideoSizeFromSrc: () => getVideoSizeFromSrc,
  isImage: () => isImage,
  isSvgText: () => isSvgText,
  isValidHttpURL: () => isValidHttpURL
});
module.exports = __toCommonJS(assets_exports);
var import_tlschema = require("@tldraw/tlschema");
var import_utils = require("@tldraw/utils");
var import_lodash = __toESM(require("lodash.uniq"));
var import_constants = require("../constants");
var import_is_gif_animated = require("./is-gif-animated");
var import_png = require("./png");
const ACCEPTED_IMG_TYPE = ["image/jpeg", "image/png", "image/gif", "image/svg+xml"];
const ACCEPTED_VID_TYPE = ["video/mp4", "video/quicktime"];
const ACCEPTED_ASSET_TYPE = ACCEPTED_IMG_TYPE.concat(ACCEPTED_VID_TYPE).join(", ");
const isImage = (ext) => ACCEPTED_IMG_TYPE.includes(ext);
async function getVideoSizeFromSrc(src) {
  return await new Promise((resolve, reject) => {
    const video = document.createElement("video");
    video.onloadeddata = () => resolve({ w: video.videoWidth, h: video.videoHeight });
    video.onerror = (e) => {
      console.error(e);
      reject(new Error("Could not get video size"));
    };
    video.crossOrigin = "anonymous";
    video.src = src;
  });
}
async function base64ToFile(dataURL) {
  return fetch(dataURL).then(function(result) {
    return result.arrayBuffer();
  });
}
async function getImageSizeFromSrc(dataURL) {
  return await new Promise((resolve, reject) => {
    const img = new Image();
    img.onload = async () => {
      try {
        const blob = await base64ToFile(dataURL);
        const view = new DataView(blob);
        if ((0, import_png.isPng)(view, 0)) {
          const physChunk = (0, import_png.findChunk)(view, "pHYs");
          if (physChunk) {
            const physData = (0, import_png.parsePhys)(view, physChunk.dataOffset);
            if (physData.unit === 0 && physData.ppux === physData.ppuy) {
              const pixelRatio = Math.round(physData.ppux / 2834.5);
              resolve({ w: img.width / pixelRatio, h: img.height / pixelRatio });
              return;
            }
          }
        }
        resolve({ w: img.width, h: img.height });
      } catch (err) {
        console.error(err);
        resolve({ w: img.width, h: img.height });
      }
    };
    img.onerror = (err) => {
      console.error(err);
      reject(new Error("Could not get image size"));
    };
    img.crossOrigin = "anonymous";
    img.src = dataURL;
  });
}
async function getResizedImageDataUrl(dataURLForImage, width, height) {
  return await new Promise((resolve) => {
    const img = new Image();
    img.onload = () => {
      const canvas = document.createElement("canvas");
      const ctx = canvas.getContext("2d");
      if (!ctx)
        return;
      canvas.width = width * 2;
      canvas.height = height * 2;
      ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
      const newDataURL = canvas.toDataURL();
      resolve(newDataURL);
    };
    img.crossOrigin = "anonymous";
    img.src = dataURLForImage;
  });
}
async function getMediaAssetFromFile(file) {
  return await new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onerror = () => reject(reader.error);
    reader.onload = async () => {
      let dataUrl = reader.result;
      const isImageType = isImage(file.type);
      const sizeFn = isImageType ? getImageSizeFromSrc : getVideoSizeFromSrc;
      if (file.type === "video/quicktime" && dataUrl.includes("video/quicktime")) {
        dataUrl = dataUrl.replace("video/quicktime", "video/mp4");
      }
      const originalSize = await sizeFn(dataUrl);
      const size = containBoxSize(originalSize, { w: import_constants.MAX_ASSET_WIDTH, h: import_constants.MAX_ASSET_HEIGHT });
      if (size !== originalSize && (file.type === "image/jpeg" || file.type === "image/png")) {
        dataUrl = await getResizedImageDataUrl(dataUrl, size.w, size.h);
      }
      const assetId = import_tlschema.AssetRecordType.createId((0, import_utils.getHashForString)(dataUrl));
      const metadata = await getFileMetaData(file);
      const asset = {
        id: assetId,
        type: isImageType ? "image" : "video",
        typeName: "asset",
        props: {
          name: file.name,
          src: dataUrl,
          w: size.w,
          h: size.h,
          mimeType: file.type,
          isAnimated: metadata.isAnimated
        }
      };
      resolve(asset);
    };
    reader.readAsDataURL(file);
  });
}
async function getFileMetaData(file) {
  if (file.type === "image/gif") {
    return await new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onerror = () => reject(reader.error);
      reader.onload = () => {
        resolve({
          isAnimated: reader.result ? (0, import_is_gif_animated.isAnimated)(reader.result) : false
        });
      };
      reader.readAsArrayBuffer(file);
    });
  }
  return {
    isAnimated: isImage(file.type) ? false : true
  };
}
function containBoxSize(originalSize, containBoxSize2) {
  const overByXScale = originalSize.w / containBoxSize2.w;
  const overByYScale = originalSize.h / containBoxSize2.h;
  if (overByXScale <= 1 && overByYScale <= 1) {
    return originalSize;
  } else if (overByXScale > overByYScale) {
    return {
      w: originalSize.w / overByXScale,
      h: originalSize.h / overByXScale
    };
  } else {
    return {
      w: originalSize.w / overByYScale,
      h: originalSize.h / overByYScale
    };
  }
}
const isValidHttpURL = (url) => {
  try {
    const u = new URL(url);
    return u.protocol === "http:" || u.protocol === "https:";
  } catch (e) {
    return false;
  }
};
const getValidHttpURLList = (url) => {
  const urls = url.split(/[\n\s]/);
  for (const url2 of urls) {
    try {
      const u = new URL(url2);
      if (!(u.protocol === "http:" || u.protocol === "https:")) {
        return;
      }
    } catch (e) {
      return;
    }
  }
  return (0, import_lodash.default)(urls);
};
const isSvgText = (text) => {
  return /^<svg/.test(text);
};
function dataUrlToFile(url, filename, mimeType) {
  return fetch(url).then(function(res) {
    return res.arrayBuffer();
  }).then(function(buf) {
    return new File([buf], filename, { type: mimeType });
  });
}
//# sourceMappingURL=assets.js.map
