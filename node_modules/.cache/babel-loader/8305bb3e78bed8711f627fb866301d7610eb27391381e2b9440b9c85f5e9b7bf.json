{"ast":null,"code":"import { Vec2d } from \"../Vec2d.mjs\";\nvar PI = Math.PI;\nvar FIXED_PI = PI + 1e-4;\nfunction getStrokeOutlinePoints(strokePoints) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var _options$size = options.size,\n    size = _options$size === void 0 ? 16 : _options$size,\n    _options$smoothing = options.smoothing,\n    smoothing = _options$smoothing === void 0 ? 0.5 : _options$smoothing,\n    _options$start = options.start,\n    start = _options$start === void 0 ? {} : _options$start,\n    _options$end = options.end,\n    end = _options$end === void 0 ? {} : _options$end,\n    _options$last = options.last,\n    isComplete = _options$last === void 0 ? false : _options$last;\n  var _start$cap = start.cap,\n    capStart = _start$cap === void 0 ? true : _start$cap;\n  var _end$cap = end.cap,\n    capEnd = _end$cap === void 0 ? true : _end$cap;\n  if (strokePoints.length === 0 || size <= 0) {\n    return [];\n  }\n  var firstStrokePoint = strokePoints[0];\n  var lastStrokePoint = strokePoints[strokePoints.length - 1];\n  var totalLength = lastStrokePoint.runningLength;\n  var taperStart = start.taper === false ? 0 : start.taper === true ? Math.max(size, totalLength) : start.taper;\n  var taperEnd = end.taper === false ? 0 : end.taper === true ? Math.max(size, totalLength) : end.taper;\n  var minDistance = Math.pow(size * smoothing, 2);\n  var leftPts = [];\n  var rightPts = [];\n  var prevVector = strokePoints[0].vector;\n  var pl = strokePoints[0].point;\n  var pr = pl;\n  var tl = pl;\n  var tr = pr;\n  var isPrevPointSharpCorner = false;\n  var strokePoint;\n  for (var i = 0; i < strokePoints.length; i++) {\n    strokePoint = strokePoints[i];\n    var _strokePoints$i = strokePoints[i],\n      point = _strokePoints$i.point,\n      vector = _strokePoints$i.vector;\n    var prevDpr = strokePoint.vector.dpr(prevVector);\n    var nextVector = (i < strokePoints.length - 1 ? strokePoints[i + 1] : strokePoints[i]).vector;\n    var nextDpr = i < strokePoints.length - 1 ? nextVector.dpr(strokePoint.vector) : 1;\n    var isPointSharpCorner = prevDpr < 0 && !isPrevPointSharpCorner;\n    var isNextPointSharpCorner = nextDpr !== null && nextDpr < 0.2;\n    if (isPointSharpCorner || isNextPointSharpCorner) {\n      if (nextDpr > -0.62 && totalLength - strokePoint.runningLength > strokePoint.radius) {\n        var offset2 = prevVector.clone().mul(strokePoint.radius);\n        var cpr = prevVector.clone().cpr(nextVector);\n        if (cpr < 0) {\n          tl = Vec2d.Add(point, offset2);\n          tr = Vec2d.Sub(point, offset2);\n        } else {\n          tl = Vec2d.Sub(point, offset2);\n          tr = Vec2d.Add(point, offset2);\n        }\n        leftPts.push(tl);\n        rightPts.push(tr);\n      } else {\n        var _offset = prevVector.clone().mul(strokePoint.radius).per();\n        var start2 = Vec2d.Sub(strokePoint.input, _offset);\n        for (var step = 1 / 13, t = 0; t < 1; t += step) {\n          tl = Vec2d.RotWith(start2, strokePoint.input, FIXED_PI * t);\n          leftPts.push(tl);\n          tr = Vec2d.RotWith(start2, strokePoint.input, FIXED_PI + FIXED_PI * -t);\n          rightPts.push(tr);\n        }\n      }\n      pl = tl;\n      pr = tr;\n      if (isNextPointSharpCorner) {\n        isPrevPointSharpCorner = true;\n      }\n      continue;\n    }\n    isPrevPointSharpCorner = false;\n    if (strokePoint === firstStrokePoint || strokePoint === lastStrokePoint) {\n      var _offset2 = Vec2d.Per(vector).mul(strokePoint.radius);\n      leftPts.push(Vec2d.Sub(point, _offset2));\n      rightPts.push(Vec2d.Add(point, _offset2));\n      continue;\n    }\n    var offset = Vec2d.Lrp(nextVector, vector, nextDpr).per().mul(strokePoint.radius);\n    tl = Vec2d.Sub(point, offset);\n    if (i <= 1 || Vec2d.Dist2(pl, tl) > minDistance) {\n      leftPts.push(tl);\n      pl = tl;\n    }\n    tr = Vec2d.Add(point, offset);\n    if (i <= 1 || Vec2d.Dist2(pr, tr) > minDistance) {\n      rightPts.push(tr);\n      pr = tr;\n    }\n    prevVector = vector;\n    continue;\n  }\n  var firstPoint = firstStrokePoint.point;\n  var lastPoint = strokePoints.length > 1 ? strokePoints[strokePoints.length - 1].point : Vec2d.AddXY(firstStrokePoint.point, 1, 1);\n  if (strokePoints.length === 1) {\n    if (!(taperStart || taperEnd) || isComplete) {\n      var _start = Vec2d.Add(firstPoint, Vec2d.Sub(firstPoint, lastPoint).uni().per().mul(-firstStrokePoint.radius));\n      var dotPts = [];\n      for (var _step = 1 / 13, _t = _step; _t <= 1; _t += _step) {\n        dotPts.push(Vec2d.RotWith(_start, firstPoint, FIXED_PI * 2 * _t));\n      }\n      return dotPts;\n    }\n  }\n  var startCap = [];\n  if (taperStart || taperEnd && strokePoints.length === 1) {} else if (capStart) {\n    for (var _step2 = 1 / 8, _t2 = _step2; _t2 <= 1; _t2 += _step2) {\n      var pt = Vec2d.RotWith(rightPts[0], firstPoint, FIXED_PI * _t2);\n      startCap.push(pt);\n    }\n  } else {\n    var cornersVector = Vec2d.Sub(leftPts[0], rightPts[0]);\n    var offsetA = Vec2d.Mul(cornersVector, 0.5);\n    var offsetB = Vec2d.Mul(cornersVector, 0.51);\n    startCap.push(Vec2d.Sub(firstPoint, offsetA), Vec2d.Sub(firstPoint, offsetB), Vec2d.Add(firstPoint, offsetB), Vec2d.Add(firstPoint, offsetA));\n  }\n  var endCap = [];\n  var direction = lastStrokePoint.vector.clone().per().neg();\n  if (taperEnd || taperStart && strokePoints.length === 1) {\n    endCap.push(lastPoint);\n  } else if (capEnd) {\n    var _start2 = Vec2d.Add(lastPoint, Vec2d.Mul(direction, lastStrokePoint.radius));\n    for (var _step3 = 1 / 29, _t3 = _step3; _t3 < 1; _t3 += _step3) {\n      endCap.push(Vec2d.RotWith(_start2, lastPoint, FIXED_PI * 3 * _t3));\n    }\n  } else {\n    endCap.push(Vec2d.Add(lastPoint, Vec2d.Mul(direction, lastStrokePoint.radius)), Vec2d.Add(lastPoint, Vec2d.Mul(direction, lastStrokePoint.radius * 0.99)), Vec2d.Sub(lastPoint, Vec2d.Mul(direction, lastStrokePoint.radius * 0.99)), Vec2d.Sub(lastPoint, Vec2d.Mul(direction, lastStrokePoint.radius)));\n  }\n  return leftPts.concat(endCap, rightPts.reverse(), startCap);\n}\nexport { getStrokeOutlinePoints };","map":{"version":3,"names":["Vec2d","PI","Math","FIXED_PI","getStrokeOutlinePoints","strokePoints","options","arguments","length","undefined","_options$size","size","_options$smoothing","smoothing","_options$start","start","_options$end","end","_options$last","last","isComplete","_start$cap","cap","capStart","_end$cap","capEnd","firstStrokePoint","lastStrokePoint","totalLength","runningLength","taperStart","taper","max","taperEnd","minDistance","pow","leftPts","rightPts","prevVector","vector","pl","point","pr","tl","tr","isPrevPointSharpCorner","strokePoint","i","_strokePoints$i","prevDpr","dpr","nextVector","nextDpr","isPointSharpCorner","isNextPointSharpCorner","radius","offset2","clone","mul","cpr","Add","Sub","push","per","start2","input","step","t","RotWith","Per","offset","Lrp","Dist2","firstPoint","lastPoint","AddXY","uni","dotPts","startCap","pt","cornersVector","offsetA","Mul","offsetB","endCap","direction","neg","concat","reverse"],"sources":["/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@tldraw/primitives/src/lib/freehand/getStrokeOutlinePoints.ts"],"sourcesContent":["import { Vec2d } from '../Vec2d'\nimport type { StrokeOptions, StrokePoint } from './types'\n\nconst { PI } = Math\n\n// Browser strokes seem to be off if PI is regular, a tiny offset seems to fix it\nconst FIXED_PI = PI + 0.0001\n\n/**\n * ## getStrokeOutlinePoints\n *\n * Get an array of points (as `[x, y]`) representing the outline of a stroke.\n *\n * @param points - An array of StrokePoints as returned from `getStrokePoints`.\n * @param options - An object with options.\n * @public\n */\nexport function getStrokeOutlinePoints(\n\tstrokePoints: StrokePoint[],\n\toptions: StrokeOptions = {}\n): Vec2d[] {\n\tconst { size = 16, smoothing = 0.5, start = {}, end = {}, last: isComplete = false } = options\n\n\tconst { cap: capStart = true } = start\n\tconst { cap: capEnd = true } = end\n\n\t// We can't do anything with an empty array or a stroke with negative size.\n\tif (strokePoints.length === 0 || size <= 0) {\n\t\treturn []\n\t}\n\n\tconst firstStrokePoint = strokePoints[0]\n\tconst lastStrokePoint = strokePoints[strokePoints.length - 1]\n\n\t// The total length of the line\n\tconst totalLength = lastStrokePoint.runningLength\n\n\tconst taperStart =\n\t\tstart.taper === false\n\t\t\t? 0\n\t\t\t: start.taper === true\n\t\t\t? Math.max(size, totalLength)\n\t\t\t: (start.taper as number)\n\n\tconst taperEnd =\n\t\tend.taper === false\n\t\t\t? 0\n\t\t\t: end.taper === true\n\t\t\t? Math.max(size, totalLength)\n\t\t\t: (end.taper as number)\n\n\t// The minimum allowed distance between points (squared)\n\tconst minDistance = Math.pow(size * smoothing, 2)\n\n\t// Our collected left and right points\n\tconst leftPts: Vec2d[] = []\n\tconst rightPts: Vec2d[] = []\n\n\t// Previous vector\n\tlet prevVector = strokePoints[0].vector\n\n\t// Previous left and right points\n\tlet pl = strokePoints[0].point\n\tlet pr = pl\n\n\t// Temporary left and right points\n\tlet tl = pl\n\tlet tr = pr\n\n\t// Keep track of whether the previous point is a sharp corner\n\t// ... so that we don't detect the same corner twice\n\tlet isPrevPointSharpCorner = false\n\n\t/*\n    Find the outline's left and right points\n\n    Iterating through the points and populate the rightPts and leftPts arrays,\n    skipping the first and last pointsm, which will get caps later on.\n  */\n\n\tlet strokePoint: StrokePoint\n\n\tfor (let i = 0; i < strokePoints.length; i++) {\n\t\tstrokePoint = strokePoints[i]\n\t\tconst { point, vector } = strokePoints[i]\n\n\t\t/*\n      Handle sharp corners\n\n      Find the difference (dot product) between the current and next vector.\n      If the next vector is at more than a right angle to the current vector,\n      draw a cap at the current point.\n    */\n\n\t\tconst prevDpr = strokePoint.vector.dpr(prevVector)\n\t\tconst nextVector = (i < strokePoints.length - 1 ? strokePoints[i + 1] : strokePoints[i]).vector\n\t\tconst nextDpr = i < strokePoints.length - 1 ? nextVector.dpr(strokePoint.vector) : 1\n\n\t\tconst isPointSharpCorner = prevDpr < 0 && !isPrevPointSharpCorner\n\t\tconst isNextPointSharpCorner = nextDpr !== null && nextDpr < 0.2\n\n\t\tif (isPointSharpCorner || isNextPointSharpCorner) {\n\t\t\t// It's a sharp corner. Draw a rounded cap and move on to the next point\n\t\t\t// Considering saving these and drawing them later? So that we can avoid\n\t\t\t// crossing future points.\n\n\t\t\tif (nextDpr > -0.62 && totalLength - strokePoint.runningLength > strokePoint.radius) {\n\t\t\t\t// Draw a \"soft\" corner\n\t\t\t\tconst offset = prevVector.clone().mul(strokePoint.radius)\n\t\t\t\tconst cpr = prevVector.clone().cpr(nextVector)\n\n\t\t\t\tif (cpr < 0) {\n\t\t\t\t\ttl = Vec2d.Add(point, offset)\n\t\t\t\t\ttr = Vec2d.Sub(point, offset)\n\t\t\t\t} else {\n\t\t\t\t\ttl = Vec2d.Sub(point, offset)\n\t\t\t\t\ttr = Vec2d.Add(point, offset)\n\t\t\t\t}\n\n\t\t\t\tleftPts.push(tl)\n\t\t\t\trightPts.push(tr)\n\t\t\t} else {\n\t\t\t\t// Draw a \"sharp\" corner\n\t\t\t\tconst offset = prevVector.clone().mul(strokePoint.radius).per()\n\t\t\t\tconst start = Vec2d.Sub(strokePoint.input, offset)\n\n\t\t\t\tfor (let step = 1 / 13, t = 0; t < 1; t += step) {\n\t\t\t\t\ttl = Vec2d.RotWith(start, strokePoint.input, FIXED_PI * t)\n\t\t\t\t\tleftPts.push(tl)\n\n\t\t\t\t\ttr = Vec2d.RotWith(start, strokePoint.input, FIXED_PI + FIXED_PI * -t)\n\t\t\t\t\trightPts.push(tr)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpl = tl\n\t\t\tpr = tr\n\n\t\t\tif (isNextPointSharpCorner) {\n\t\t\t\tisPrevPointSharpCorner = true\n\t\t\t}\n\n\t\t\tcontinue\n\t\t}\n\n\t\tisPrevPointSharpCorner = false\n\n\t\tif (strokePoint === firstStrokePoint || strokePoint === lastStrokePoint) {\n\t\t\tconst offset = Vec2d.Per(vector).mul(strokePoint.radius)\n\t\t\tleftPts.push(Vec2d.Sub(point, offset))\n\t\t\trightPts.push(Vec2d.Add(point, offset))\n\n\t\t\tcontinue\n\t\t}\n\n\t\t/* \n      Add regular points\n\n      Project points to either side of the current point, using the\n      calculated size as a distance. If a point's distance to the \n      previous point on that side greater than the minimum distance\n      (or if the corner is kinda sharp), add the points to the side's\n      points array.\n    */\n\n\t\tconst offset = Vec2d.Lrp(nextVector, vector, nextDpr).per().mul(strokePoint.radius)\n\n\t\ttl = Vec2d.Sub(point, offset)\n\n\t\tif (i <= 1 || Vec2d.Dist2(pl, tl) > minDistance) {\n\t\t\tleftPts.push(tl)\n\t\t\tpl = tl\n\t\t}\n\n\t\ttr = Vec2d.Add(point, offset)\n\n\t\tif (i <= 1 || Vec2d.Dist2(pr, tr) > minDistance) {\n\t\t\trightPts.push(tr)\n\t\t\tpr = tr\n\t\t}\n\n\t\t// Set variables for next iteration\n\t\tprevVector = vector\n\n\t\tcontinue\n\t}\n\n\t/*\n    Drawing caps\n    \n    Now that we have our points on either side of the line, we need to\n    draw caps at the start and end. Tapered lines don't have caps, but\n    may have dots for very short lines.\n  */\n\n\tconst firstPoint = firstStrokePoint.point\n\n\tconst lastPoint =\n\t\tstrokePoints.length > 1\n\t\t\t? strokePoints[strokePoints.length - 1].point\n\t\t\t: Vec2d.AddXY(firstStrokePoint.point, 1, 1)\n\n\t/* \n    Draw a dot for very short or completed strokes\n    \n    If the line is too short to gather left or right points and if the line is\n    not tapered on either side, draw a dot. If the line is tapered, then only\n    draw a dot if the line is both very short and complete. If we draw a dot,\n    we can just return those points.\n  */\n\n\tif (strokePoints.length === 1) {\n\t\tif (!(taperStart || taperEnd) || isComplete) {\n\t\t\tconst start = Vec2d.Add(\n\t\t\t\tfirstPoint,\n\t\t\t\tVec2d.Sub(firstPoint, lastPoint).uni().per().mul(-firstStrokePoint.radius)\n\t\t\t)\n\t\t\tconst dotPts: Vec2d[] = []\n\t\t\tfor (let step = 1 / 13, t = step; t <= 1; t += step) {\n\t\t\t\tdotPts.push(Vec2d.RotWith(start, firstPoint, FIXED_PI * 2 * t))\n\t\t\t}\n\t\t\treturn dotPts\n\t\t}\n\t}\n\n\t/*\n    Draw a start cap\n\n    Unless the line has a tapered start, or unless the line has a tapered end\n    and the line is very short, draw a start cap around the first point. Use\n    the distance between the second left and right point for the cap's radius.\n    Finally remove the first left and right points. :psyduck:\n  */\n\n\tconst startCap: Vec2d[] = []\n\tif (taperStart || (taperEnd && strokePoints.length === 1)) {\n\t\t// The start point is tapered, noop\n\t} else if (capStart) {\n\t\t// Draw the round cap - add thirteen points rotating the right point around the start point to the left point\n\t\tfor (let step = 1 / 8, t = step; t <= 1; t += step) {\n\t\t\tconst pt = Vec2d.RotWith(rightPts[0], firstPoint, FIXED_PI * t)\n\t\t\tstartCap.push(pt)\n\t\t}\n\t} else {\n\t\t// Draw the flat cap - add a point to the left and right of the start point\n\t\tconst cornersVector = Vec2d.Sub(leftPts[0], rightPts[0])\n\t\tconst offsetA = Vec2d.Mul(cornersVector, 0.5)\n\t\tconst offsetB = Vec2d.Mul(cornersVector, 0.51)\n\n\t\tstartCap.push(\n\t\t\tVec2d.Sub(firstPoint, offsetA),\n\t\t\tVec2d.Sub(firstPoint, offsetB),\n\t\t\tVec2d.Add(firstPoint, offsetB),\n\t\t\tVec2d.Add(firstPoint, offsetA)\n\t\t)\n\t}\n\n\t/*\n    Draw an end cap\n\n    If the line does not have a tapered end, and unless the line has a tapered\n    start and the line is very short, draw a cap around the last point. Finally,\n    remove the last left and right points. Otherwise, add the last point. Note\n    that This cap is a full-turn-and-a-half: this prevents incorrect caps on\n    sharp end turns.\n  */\n\n\tconst endCap: Vec2d[] = []\n\tconst direction = lastStrokePoint.vector.clone().per().neg()\n\n\tif (taperEnd || (taperStart && strokePoints.length === 1)) {\n\t\t// Tapered end - push the last point to the line\n\t\tendCap.push(lastPoint)\n\t} else if (capEnd) {\n\t\t// Draw the round end cap\n\t\tconst start = Vec2d.Add(lastPoint, Vec2d.Mul(direction, lastStrokePoint.radius))\n\t\tfor (let step = 1 / 29, t = step; t < 1; t += step) {\n\t\t\tendCap.push(Vec2d.RotWith(start, lastPoint, FIXED_PI * 3 * t))\n\t\t}\n\t} else {\n\t\t// Draw the flat end cap\n\t\tendCap.push(\n\t\t\tVec2d.Add(lastPoint, Vec2d.Mul(direction, lastStrokePoint.radius)),\n\t\t\tVec2d.Add(lastPoint, Vec2d.Mul(direction, lastStrokePoint.radius * 0.99)),\n\t\t\tVec2d.Sub(lastPoint, Vec2d.Mul(direction, lastStrokePoint.radius * 0.99)),\n\t\t\tVec2d.Sub(lastPoint, Vec2d.Mul(direction, lastStrokePoint.radius))\n\t\t)\n\t}\n\n\t/*\n    Return the points in the correct winding order: begin on the left side, then \n    continue around the end cap, then come back along the right side, and finally \n    complete the start cap.\n  */\n\n\treturn leftPts.concat(endCap, rightPts.reverse(), startCap)\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}