import { jsx, jsxs } from "react/jsx-runtime";
import { getIndexBetween, sortByIndex } from "@tldraw/indices";
import {
  CubicSpline2d,
  Polyline2d,
  Vec2d,
  getDrawLinePathData,
  intersectLineSegmentPolyline,
  pointNearToPolyline
} from "@tldraw/primitives";
import { deepCopy } from "@tldraw/utils";
import { SVGContainer } from "../../../components/SVGContainer.mjs";
import { WeakMapCache } from "../../../utils/WeakMapCache.mjs";
import { ShapeUtil } from "../ShapeUtil.mjs";
import { ShapeFill } from "../shared/ShapeFill.mjs";
import { STROKE_SIZES } from "../shared/default-shape-constants.mjs";
import { getPerfectDashProps } from "../shared/getPerfectDashProps.mjs";
import { useForceSolid } from "../shared/useForceSolid.mjs";
import { getLineDrawPath, getLineIndicatorPath, getLinePoints } from "./components/getLinePath.mjs";
import { getLineSvg } from "./components/getLineSvg.mjs";
const splinesCache = new WeakMapCache();
const handlesCache = new WeakMapCache();
class LineShapeUtil extends ShapeUtil {
  static type = "line";
  hideResizeHandles = () => true;
  hideRotateHandle = () => true;
  hideSelectionBoundsBg = () => true;
  hideSelectionBoundsFg = () => true;
  isClosed = () => false;
  defaultProps() {
    return {
      dash: "draw",
      size: "m",
      color: "black",
      spline: "line",
      handles: {
        start: {
          id: "start",
          type: "vertex",
          canBind: false,
          index: "a1",
          x: 0,
          y: 0
        },
        end: {
          id: "end",
          type: "vertex",
          canBind: false,
          index: "a2",
          x: 0,
          y: 0
        }
      }
    };
  }
  getBounds(shape) {
    const spline = getSplineForLineShape(shape);
    return spline.bounds;
  }
  getCenter(shape) {
    return this.bounds(shape).center;
  }
  getHandles(shape) {
    return handlesCache.get(shape.props, () => {
      const handles = shape.props.handles;
      const spline = getSplineForLineShape(shape);
      const sortedHandles = Object.values(handles).sort(sortByIndex);
      const results = sortedHandles.slice();
      for (let i = 0; i < spline.segments.length; i++) {
        const segment = spline.segments[i];
        const point = segment.midPoint;
        const index = getIndexBetween(sortedHandles[i].index, sortedHandles[i + 1].index);
        results.push({
          id: `mid-${i}`,
          type: "create",
          index,
          x: point.x,
          y: point.y
        });
      }
      return results.sort(sortByIndex);
    });
  }
  getOutline(shape) {
    return getLinePoints(getSplineForLineShape(shape));
  }
  getOutlineSegments(shape) {
    const spline = getSplineForLineShape(shape);
    return shape.props.spline === "cubic" ? spline.segments.map((s) => s.lut) : spline.segments.map((s) => [s.getPoint(0), s.getPoint(1)]);
  }
  //   Events
  onResize = (shape, info) => {
    const { scaleX, scaleY } = info;
    const handles = deepCopy(shape.props.handles);
    Object.values(shape.props.handles).forEach(({ id, x, y }) => {
      handles[id].x = x * scaleX;
      handles[id].y = y * scaleY;
    });
    return {
      props: {
        handles
      }
    };
  };
  onHandleChange = (shape, { handle }) => {
    const next = deepCopy(shape);
    switch (handle.id) {
      case "start":
      case "end": {
        next.props.handles[handle.id] = {
          ...next.props.handles[handle.id],
          x: handle.x,
          y: handle.y
        };
        break;
      }
      default: {
        const id = "handle:" + handle.index;
        const existing = shape.props.handles[id];
        if (existing) {
          next.props.handles[id] = {
            ...existing,
            x: handle.x,
            y: handle.y
          };
        } else {
          next.props.handles[id] = {
            id,
            type: "vertex",
            canBind: false,
            index: handle.index,
            x: handle.x,
            y: handle.y
          };
        }
        break;
      }
    }
    return next;
  };
  hitTestPoint(shape, point) {
    const zoomLevel = this.editor.zoomLevel;
    const offsetDist = STROKE_SIZES[shape.props.size] / zoomLevel;
    return pointNearToPolyline(point, this.outline(shape), offsetDist);
  }
  hitTestLineSegment(shape, A, B) {
    return intersectLineSegmentPolyline(A, B, this.outline(shape)) !== null;
  }
  component(shape) {
    const forceSolid = useForceSolid();
    const spline = getSplineForLineShape(shape);
    const strokeWidth = STROKE_SIZES[shape.props.size];
    const { dash, color } = shape.props;
    if (shape.props.spline === "line") {
      if (dash === "solid") {
        const outline = spline.points;
        const pathData = "M" + outline[0] + "L" + outline.slice(1);
        return /* @__PURE__ */ jsxs(SVGContainer, { id: shape.id, children: [
          /* @__PURE__ */ jsx(ShapeFill, { d: pathData, fill: "none", color }),
          /* @__PURE__ */ jsx(
            "path",
            {
              d: pathData,
              stroke: `var(--palette-${color})`,
              strokeWidth,
              fill: "none"
            }
          )
        ] });
      }
      if (dash === "dashed" || dash === "dotted") {
        const outline = spline.points;
        const pathData = "M" + outline[0] + "L" + outline.slice(1);
        return /* @__PURE__ */ jsxs(SVGContainer, { id: shape.id, children: [
          /* @__PURE__ */ jsx(ShapeFill, { d: pathData, fill: "none", color }),
          /* @__PURE__ */ jsx("g", { stroke: `var(--palette-${color})`, strokeWidth, children: spline.segments.map((segment, i) => {
            const { strokeDasharray, strokeDashoffset } = getPerfectDashProps(
              segment.length,
              strokeWidth,
              {
                style: dash,
                start: i > 0 ? "outset" : "none",
                end: i < spline.segments.length - 1 ? "outset" : "none"
              }
            );
            return /* @__PURE__ */ jsx(
              "path",
              {
                strokeDasharray,
                strokeDashoffset,
                d: segment.path,
                fill: "none"
              },
              i
            );
          }) })
        ] });
      }
      if (dash === "draw") {
        const outline = spline.points;
        const [innerPathData, outerPathData] = getDrawLinePathData(shape.id, outline, strokeWidth);
        return /* @__PURE__ */ jsxs(SVGContainer, { id: shape.id, children: [
          /* @__PURE__ */ jsx(ShapeFill, { d: innerPathData, fill: "none", color }),
          /* @__PURE__ */ jsx(
            "path",
            {
              d: outerPathData,
              stroke: `var(--palette-${color})`,
              strokeWidth,
              fill: "none"
            }
          )
        ] });
      }
    }
    if (shape.props.spline === "cubic") {
      const splinePath = spline.path;
      if (dash === "solid" || dash === "draw" && forceSolid) {
        return /* @__PURE__ */ jsxs(SVGContainer, { id: shape.id, children: [
          /* @__PURE__ */ jsx(ShapeFill, { d: splinePath, fill: "none", color }),
          /* @__PURE__ */ jsx(
            "path",
            {
              strokeWidth,
              stroke: `var(--palette-${color})`,
              fill: "none",
              d: splinePath
            }
          )
        ] });
      }
      if (dash === "dashed" || dash === "dotted") {
        return /* @__PURE__ */ jsxs(SVGContainer, { id: shape.id, children: [
          /* @__PURE__ */ jsx(ShapeFill, { d: splinePath, fill: "none", color }),
          /* @__PURE__ */ jsx("g", { stroke: `var(--palette-${color})`, strokeWidth, children: spline.segments.map((segment, i) => {
            const { strokeDasharray, strokeDashoffset } = getPerfectDashProps(
              segment.length,
              strokeWidth,
              {
                style: dash,
                start: i > 0 ? "outset" : "none",
                end: i < spline.segments.length - 1 ? "outset" : "none"
              }
            );
            return /* @__PURE__ */ jsx(
              "path",
              {
                strokeDasharray,
                strokeDashoffset,
                d: segment.path,
                fill: "none"
              },
              i
            );
          }) })
        ] });
      }
      if (dash === "draw") {
        return /* @__PURE__ */ jsxs(SVGContainer, { id: shape.id, children: [
          /* @__PURE__ */ jsx(ShapeFill, { d: splinePath, fill: "none", color }),
          /* @__PURE__ */ jsx(
            "path",
            {
              d: getLineDrawPath(shape, spline, strokeWidth),
              strokeWidth: 1,
              stroke: `var(--palette-${color})`,
              fill: `var(--palette-${color})`
            }
          )
        ] });
      }
    }
  }
  indicator(shape) {
    const strokeWidth = STROKE_SIZES[shape.props.size];
    const spline = getSplineForLineShape(shape);
    const { dash } = shape.props;
    let path;
    if (shape.props.spline === "line") {
      const outline = spline.points;
      if (dash === "solid" || dash === "dotted" || dash === "dashed") {
        path = "M" + outline[0] + "L" + outline.slice(1);
      } else {
        const [innerPathData] = getDrawLinePathData(shape.id, outline, strokeWidth);
        path = innerPathData;
      }
    } else {
      path = getLineIndicatorPath(shape, spline, strokeWidth);
    }
    return /* @__PURE__ */ jsx("path", { d: path });
  }
  toSvg(shape, _font, colors) {
    const { color: _color, size } = shape.props;
    const color = colors.fill[_color];
    const spline = getSplineForLineShape(shape);
    return getLineSvg(shape, spline, color, STROKE_SIZES[size]);
  }
}
function getSplineForLineShape(shape) {
  return splinesCache.get(shape.props, () => {
    const { spline, handles } = shape.props;
    const handlePoints = Object.values(handles).sort(sortByIndex).map(Vec2d.From);
    switch (spline) {
      case "cubic": {
        return new CubicSpline2d(handlePoints, handlePoints.length === 2 ? 2 : 1.2, 20);
      }
      case "line": {
        return new Polyline2d(handlePoints);
      }
    }
  });
}
export {
  LineShapeUtil,
  getSplineForLineShape
};
//# sourceMappingURL=LineShapeUtil.mjs.map
