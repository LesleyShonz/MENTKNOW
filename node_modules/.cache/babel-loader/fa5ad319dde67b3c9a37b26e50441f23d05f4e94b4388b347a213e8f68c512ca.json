{"ast":null,"code":"import _objectSpread from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _classCallCheck from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _inherits from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _defineProperty from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __decorateClass = function __decorateClass(decorators, target, key, kind) {\n  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;\n  for (var i = decorators.length - 1, decorator; i >= 0; i--) if (decorator = decorators[i]) result = (kind ? decorator(target, key, result) : decorator(result)) || result;\n  if (kind && result) __defProp(target, key, result);\n  return result;\n};\nimport { Fragment, jsx, jsxs } from \"react/jsx-runtime\";\nimport { Box2d, getPointOnCircle, linesIntersect, longAngleDist, Matrix2d, pointInPolygon, shortAngleDist, toDomPrecision, Vec2d } from \"@tldraw/primitives\";\nimport { deepCopy, last, minBy } from \"@tldraw/utils\";\nimport * as React from \"react\";\nimport { computed, EMPTY_ARRAY } from \"signia\";\nimport { SVGContainer } from \"../../../components/SVGContainer.mjs\";\nimport { ShapeUtil } from \"../ShapeUtil.mjs\";\nimport { createTextSvgElementFromSpans } from \"../shared/createTextSvgElementFromSpans.mjs\";\nimport { ARROW_LABEL_FONT_SIZES, FONT_FAMILIES, STROKE_SIZES, TEXT_PROPS } from \"../shared/default-shape-constants.mjs\";\nimport { getPerfectDashProps } from \"../shared/getPerfectDashProps.mjs\";\nimport { getShapeFillSvg, ShapeFill } from \"../shared/ShapeFill.mjs\";\nimport { getArrowheadPathForType } from \"./arrow/arrowheads.mjs\";\nimport { getCurvedArrowHandlePath, getCurvedArrowInfo, getSolidCurvedArrowPath } from \"./arrow/curved-arrow.mjs\";\nimport { getArrowTerminalsInArrowSpace, getIsArrowStraight } from \"./arrow/shared.mjs\";\nimport { getSolidStraightArrowPath, getStraightArrowHandlePath, getStraightArrowInfo } from \"./arrow/straight-arrow.mjs\";\nimport { ArrowTextLabel } from \"./components/ArrowTextLabel.mjs\";\nvar globalRenderIndex = 0;\nvar ArrowShapeUtil = /*#__PURE__*/function (_ShapeUtil) {\n  _inherits(ArrowShapeUtil, _ShapeUtil);\n  var _super = _createSuper(ArrowShapeUtil);\n  function ArrowShapeUtil() {\n    var _this;\n    _classCallCheck(this, ArrowShapeUtil);\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    _this = _super.call.apply(_super, [this].concat(args));\n    _defineProperty(_assertThisInitialized(_this), \"canEdit\", function () {\n      return true;\n    });\n    _defineProperty(_assertThisInitialized(_this), \"canBind\", function () {\n      return false;\n    });\n    _defineProperty(_assertThisInitialized(_this), \"isClosed\", function () {\n      return false;\n    });\n    _defineProperty(_assertThisInitialized(_this), \"canSnap\", function () {\n      return true;\n    });\n    _defineProperty(_assertThisInitialized(_this), \"hideResizeHandles\", function () {\n      return true;\n    });\n    _defineProperty(_assertThisInitialized(_this), \"hideRotateHandle\", function () {\n      return true;\n    });\n    _defineProperty(_assertThisInitialized(_this), \"hideSelectionBoundsFg\", function () {\n      return true;\n    });\n    _defineProperty(_assertThisInitialized(_this), \"hideSelectionBoundsBg\", function () {\n      return true;\n    });\n    _defineProperty(_assertThisInitialized(_this), \"onHandleChange\", function (shape, _ref) {\n      var handle = _ref.handle,\n        isPrecise2 = _ref.isPrecise;\n      var next = deepCopy(shape);\n      switch (handle.id) {\n        case \"start\":\n        case \"end\":\n          {\n            var pageTransform = _this.editor.getPageTransformById(next.id);\n            var pointInPageSpace = Matrix2d.applyToPoint(pageTransform, handle);\n            if (_this.editor.inputs.ctrlKey) {\n              next.props[handle.id] = {\n                type: \"point\",\n                x: handle.x,\n                y: handle.y\n              };\n            } else {\n              var target = last(_this.editor.sortedShapesArray.filter(function (hitShape) {\n                if (hitShape.id === shape.id) {\n                  return;\n                }\n                var util = _this.editor.getShapeUtil(hitShape);\n                if (!util.canBind(hitShape)) {\n                  return;\n                }\n                var pageMask = _this.editor.getPageMaskById(hitShape.id);\n                if (pageMask) {\n                  if (!pointInPolygon(pointInPageSpace, pageMask)) return;\n                }\n                var pointInTargetSpace = _this.editor.getPointInShapeSpace(hitShape, pointInPageSpace);\n                if (util.isClosed(hitShape)) {\n                  return pointInPolygon(pointInTargetSpace, util.outline(hitShape));\n                }\n                return util.hitTestPoint(hitShape, pointInTargetSpace);\n              }));\n              if (target) {\n                var targetBounds = _this.editor.getBounds(target);\n                var pointInTargetSpace = _this.editor.getPointInShapeSpace(target, pointInPageSpace);\n                var prevHandle = next.props[handle.id];\n                var startBindingId = shape.props.start.type === \"binding\" && shape.props.start.boundShapeId;\n                var endBindingId = shape.props.end.type === \"binding\" && shape.props.end.boundShapeId;\n                var precise =\n                // If externally precise, then always precise\n                // If the other shape is not closed, then precise\n                isPrecise2 ||\n                // If the other handle is bound to the same shape, then precise\n                (startBindingId || endBindingId) && startBindingId === endBindingId || !_this.editor.getShapeUtil(target).isClosed(next);\n                if (\n                // If we're switching to a new bound shape, then precise only if moving slowly\n                prevHandle.type === \"point\" || prevHandle.type === \"binding\" && target.id !== prevHandle.boundShapeId) {\n                  precise = _this.editor.inputs.pointerVelocity.len() < 0.5;\n                }\n                if (precise) {\n                  precise = Vec2d.Dist(pointInTargetSpace, targetBounds.center) > Math.max(4, Math.min(Math.min(targetBounds.width, targetBounds.height) * 0.15, 16)) / _this.editor.zoomLevel;\n                }\n                next.props[handle.id] = {\n                  type: \"binding\",\n                  boundShapeId: target.id,\n                  normalizedAnchor: precise ? {\n                    x: (pointInTargetSpace.x - targetBounds.minX) / targetBounds.width,\n                    y: (pointInTargetSpace.y - targetBounds.minY) / targetBounds.height\n                  } : {\n                    x: 0.5,\n                    y: 0.5\n                  },\n                  isExact: _this.editor.inputs.altKey\n                };\n              } else {\n                next.props[handle.id] = {\n                  type: \"point\",\n                  x: handle.x,\n                  y: handle.y\n                };\n              }\n            }\n            break;\n          }\n        case \"middle\":\n          {\n            var _getArrowTerminalsInA = getArrowTerminalsInArrowSpace(_this.editor, next),\n              start = _getArrowTerminalsInA.start,\n              end = _getArrowTerminalsInA.end;\n            var delta = Vec2d.Sub(end, start);\n            var v = Vec2d.Per(delta);\n            var med = Vec2d.Med(end, start);\n            var A = Vec2d.Sub(med, v);\n            var B = Vec2d.Add(med, v);\n            var point = Vec2d.NearestPointOnLineSegment(A, B, handle, false);\n            var bend = Vec2d.Dist(point, med);\n            if (Vec2d.Clockwise(point, end, med)) bend *= -1;\n            next.props.bend = bend;\n            break;\n          }\n      }\n      return next;\n    });\n    _defineProperty(_assertThisInitialized(_this), \"onTranslateStart\", function (shape) {\n      var startBinding = shape.props.start.type === \"binding\" ? shape.props.start.boundShapeId : null;\n      var endBinding = shape.props.end.type === \"binding\" ? shape.props.end.boundShapeId : null;\n      if (startBinding && _this.editor.isWithinSelection(startBinding) || endBinding && _this.editor.isWithinSelection(endBinding)) {\n        return;\n      }\n      startBinding = null;\n      endBinding = null;\n      var _getArrowTerminalsInA2 = getArrowTerminalsInArrowSpace(_this.editor, shape),\n        start = _getArrowTerminalsInA2.start,\n        end = _getArrowTerminalsInA2.end;\n      return {\n        id: shape.id,\n        type: shape.type,\n        props: _objectSpread(_objectSpread({}, shape.props), {}, {\n          start: {\n            type: \"point\",\n            x: start.x,\n            y: start.y\n          },\n          end: {\n            type: \"point\",\n            x: end.x,\n            y: end.y\n          }\n        })\n      };\n    });\n    _defineProperty(_assertThisInitialized(_this), \"onResize\", function (shape, info) {\n      var scaleX = info.scaleX,\n        scaleY = info.scaleY;\n      var terminals = getArrowTerminalsInArrowSpace(_this.editor, shape);\n      var _deepCopy = deepCopy(shape.props),\n        start = _deepCopy.start,\n        end = _deepCopy.end;\n      var bend = shape.props.bend;\n      if (start.type === \"point\") {\n        start.x = terminals.start.x * scaleX;\n        start.y = terminals.start.y * scaleY;\n      }\n      if (end.type === \"point\") {\n        end.x = terminals.end.x * scaleX;\n        end.y = terminals.end.y * scaleY;\n      }\n      var mx = Math.abs(scaleX);\n      var my = Math.abs(scaleY);\n      if (scaleX < 0 && scaleY >= 0) {\n        if (bend !== 0) {\n          bend *= -1;\n          bend *= Math.max(mx, my);\n        }\n        if (start.type === \"binding\") {\n          start.normalizedAnchor.x = 1 - start.normalizedAnchor.x;\n        }\n        if (end.type === \"binding\") {\n          end.normalizedAnchor.x = 1 - end.normalizedAnchor.x;\n        }\n      } else if (scaleX >= 0 && scaleY < 0) {\n        if (bend !== 0) {\n          bend *= -1;\n          bend *= Math.max(mx, my);\n        }\n        if (start.type === \"binding\") {\n          start.normalizedAnchor.y = 1 - start.normalizedAnchor.y;\n        }\n        if (end.type === \"binding\") {\n          end.normalizedAnchor.y = 1 - end.normalizedAnchor.y;\n        }\n      } else if (scaleX >= 0 && scaleY >= 0) {\n        if (bend !== 0) {\n          bend *= Math.max(mx, my);\n        }\n      } else if (scaleX < 0 && scaleY < 0) {\n        if (bend !== 0) {\n          bend *= Math.max(mx, my);\n        }\n        if (start.type === \"binding\") {\n          start.normalizedAnchor.x = 1 - start.normalizedAnchor.x;\n          start.normalizedAnchor.y = 1 - start.normalizedAnchor.y;\n        }\n        if (end.type === \"binding\") {\n          end.normalizedAnchor.x = 1 - end.normalizedAnchor.x;\n          end.normalizedAnchor.y = 1 - end.normalizedAnchor.y;\n        }\n      }\n      var next = {\n        props: {\n          start: start,\n          end: end,\n          bend: bend\n        }\n      };\n      return next;\n    });\n    _defineProperty(_assertThisInitialized(_this), \"onDoubleClickHandle\", function (shape, handle) {\n      switch (handle.id) {\n        case \"start\":\n          {\n            return {\n              id: shape.id,\n              type: shape.type,\n              props: _objectSpread(_objectSpread({}, shape.props), {}, {\n                arrowheadStart: shape.props.arrowheadStart === \"none\" ? \"arrow\" : \"none\"\n              })\n            };\n          }\n        case \"end\":\n          {\n            return {\n              id: shape.id,\n              type: shape.type,\n              props: _objectSpread(_objectSpread({}, shape.props), {}, {\n                arrowheadEnd: shape.props.arrowheadEnd === \"none\" ? \"arrow\" : \"none\"\n              })\n            };\n          }\n      }\n    });\n    _defineProperty(_assertThisInitialized(_this), \"getEditingBounds\", function (shape) {\n      var _this$getLabelBounds;\n      return (_this$getLabelBounds = _this.getLabelBounds(shape)) !== null && _this$getLabelBounds !== void 0 ? _this$getLabelBounds : new Box2d();\n    });\n    _defineProperty(_assertThisInitialized(_this), \"onEditEnd\", function (shape) {\n      var id = shape.id,\n        type = shape.type,\n        text = shape.props.text;\n      if (text.trimEnd() !== shape.props.text) {\n        _this.editor.updateShapes([{\n          id: id,\n          type: type,\n          props: {\n            text: text.trimEnd()\n          }\n        }]);\n      }\n    });\n    return _this;\n  }\n  _createClass(ArrowShapeUtil, [{\n    key: \"defaultProps\",\n    value: function defaultProps() {\n      return {\n        dash: \"draw\",\n        size: \"m\",\n        fill: \"none\",\n        color: \"black\",\n        labelColor: \"black\",\n        bend: 0,\n        start: {\n          type: \"point\",\n          x: 0,\n          y: 0\n        },\n        end: {\n          type: \"point\",\n          x: 0,\n          y: 0\n        },\n        arrowheadStart: \"none\",\n        arrowheadEnd: \"arrow\",\n        text: \"\",\n        font: \"draw\"\n      };\n    }\n  }, {\n    key: \"getCenter\",\n    value: function getCenter(shape) {\n      return this.bounds(shape).center;\n    }\n  }, {\n    key: \"getBounds\",\n    value: function getBounds(shape) {\n      return Box2d.FromPoints(this.getOutlineWithoutLabel(shape));\n    }\n  }, {\n    key: \"getOutlineWithoutLabel\",\n    value: function getOutlineWithoutLabel(shape) {\n      var info = this.getArrowInfo(shape);\n      if (!info) {\n        return [];\n      }\n      if (info.isStraight) {\n        if (info.isValid) {\n          return [Vec2d.From(info.start.point), Vec2d.From(info.end.point)];\n        } else {\n          return [new Vec2d(0, 0), new Vec2d(1, 1)];\n        }\n      }\n      if (!info.isValid) {\n        return [new Vec2d(0, 0), new Vec2d(1, 1)];\n      }\n      var pointsToPush = Math.max(5, Math.ceil(Math.abs(info.bodyArc.length) / 16));\n      if (pointsToPush <= 0 && !isFinite(pointsToPush)) {\n        return [new Vec2d(0, 0), new Vec2d(1, 1)];\n      }\n      var results = Array(pointsToPush);\n      var startAngle = Vec2d.Angle(info.bodyArc.center, info.start.point);\n      var endAngle = Vec2d.Angle(info.bodyArc.center, info.end.point);\n      var a = info.bodyArc.sweepFlag ? endAngle : startAngle;\n      var b = info.bodyArc.sweepFlag ? startAngle : endAngle;\n      var l = info.bodyArc.largeArcFlag ? -longAngleDist(a, b) : shortAngleDist(a, b);\n      var r = Math.max(1, info.bodyArc.radius);\n      for (var i = 0; i < pointsToPush; i++) {\n        var t = i / (pointsToPush - 1);\n        var angle = a + l * t;\n        var point = getPointOnCircle(info.bodyArc.center.x, info.bodyArc.center.y, r, angle);\n        results[i] = point;\n      }\n      return results;\n    }\n  }, {\n    key: \"getOutline\",\n    value: function getOutline(shape) {\n      var outlineWithoutLabel = this.getOutlineWithoutLabel(shape);\n      var labelBounds = this.getLabelBounds(shape);\n      if (!labelBounds) {\n        return outlineWithoutLabel;\n      }\n      var sides = labelBounds.sides;\n      var sideIndexes = [0, 1, 2, 3];\n      var prevPoint = outlineWithoutLabel[0];\n      var didAddLabel = false;\n      var result = [prevPoint];\n      var _loop = function _loop() {\n        var nextPoint = outlineWithoutLabel[i];\n        if (!didAddLabel) {\n          var nearestIntersectingSideIndex = minBy(sideIndexes.filter(function (sideIndex) {\n            return linesIntersect(sides[sideIndex][0], sides[sideIndex][1], prevPoint, nextPoint);\n          }), function (sideIndex) {\n            return Vec2d.DistanceToLineSegment(sides[sideIndex][0], sides[sideIndex][1], prevPoint);\n          });\n          if (nearestIntersectingSideIndex !== void 0) {\n            var intersectingPoint = Vec2d.NearestPointOnLineSegment(sides[nearestIntersectingSideIndex][0], sides[nearestIntersectingSideIndex][1], prevPoint);\n            result.push(intersectingPoint);\n            for (var j = 0; j < 4; j++) {\n              var sideIndex = (nearestIntersectingSideIndex + j) % 4;\n              result.push(sides[sideIndex][1]);\n            }\n            result.push(intersectingPoint);\n            didAddLabel = true;\n          }\n        }\n        result.push(nextPoint);\n        prevPoint = nextPoint;\n      };\n      for (var i = 1; i < outlineWithoutLabel.length; i++) {\n        _loop();\n      }\n      return result;\n    }\n  }, {\n    key: \"snapPoints\",\n    value: function snapPoints(_shape) {\n      return EMPTY_ARRAY;\n    }\n  }, {\n    key: \"infoCache\",\n    get: function get() {\n      var _this2 = this;\n      return this.editor.store.createComputedCache(\"arrow infoCache\", function (shape) {\n        return getIsArrowStraight(shape) ? getStraightArrowInfo(_this2.editor, shape) : getCurvedArrowInfo(_this2.editor, shape);\n      });\n    }\n  }, {\n    key: \"getArrowInfo\",\n    value: function getArrowInfo(shape) {\n      return this.infoCache.get(shape.id);\n    }\n  }, {\n    key: \"getHandles\",\n    value: function getHandles(shape) {\n      var info = this.infoCache.get(shape.id);\n      return [{\n        id: \"start\",\n        type: \"vertex\",\n        index: \"a0\",\n        x: info.start.handle.x,\n        y: info.start.handle.y,\n        canBind: true\n      }, {\n        id: \"middle\",\n        type: \"vertex\",\n        index: \"a2\",\n        x: info.middle.x,\n        y: info.middle.y,\n        canBind: false\n      }, {\n        id: \"end\",\n        type: \"vertex\",\n        index: \"a3\",\n        x: info.end.handle.x,\n        y: info.end.handle.y,\n        canBind: true\n      }];\n    }\n  }, {\n    key: \"hitTestPoint\",\n    value: function hitTestPoint(shape, point) {\n      var outline = this.outline(shape);\n      var zoomLevel = this.editor.zoomLevel;\n      var offsetDist = STROKE_SIZES[shape.props.size] / zoomLevel;\n      for (var i = 0; i < outline.length - 1; i++) {\n        var C = outline[i];\n        var D = outline[i + 1];\n        if (Vec2d.DistanceToLineSegment(C, D, point) < offsetDist) return true;\n      }\n      return false;\n    }\n  }, {\n    key: \"hitTestLineSegment\",\n    value: function hitTestLineSegment(shape, A, B) {\n      var outline = this.outline(shape);\n      for (var i = 0; i < outline.length - 1; i++) {\n        var C = outline[i];\n        var D = outline[i + 1];\n        if (linesIntersect(A, B, C, D)) return true;\n      }\n      return false;\n    }\n  }, {\n    key: \"component\",\n    value: function component(shape) {\n      var _this3 = this,\n        _labelSize$w;\n      var onlySelectedShape = this.editor.onlySelectedShape;\n      var shouldDisplayHandles = this.editor.isInAny(\"select.idle\", \"select.pointing_handle\", \"select.dragging_handle\", \"arrow.dragging\") && !this.editor.isReadOnly;\n      var info = this.getArrowInfo(shape);\n      var bounds = this.bounds(shape);\n      var labelSize = this.getLabelBounds(shape);\n      var changeIndex = React.useMemo(function () {\n        return _this3.editor.isSafari ? globalRenderIndex += 1 : 0;\n      }, [shape]);\n      if (!(info !== null && info !== void 0 && info.isValid)) return null;\n      var strokeWidth = STROKE_SIZES[shape.props.size];\n      var as = info.start.arrowhead && getArrowheadPathForType(info, \"start\", strokeWidth);\n      var ae = info.end.arrowhead && getArrowheadPathForType(info, \"end\", strokeWidth);\n      var path = info.isStraight ? getSolidStraightArrowPath(info) : getSolidCurvedArrowPath(info);\n      var handlePath = null;\n      if (onlySelectedShape === shape && shouldDisplayHandles) {\n        var sw = 2;\n        var _getPerfectDashProps = getPerfectDashProps(info.isStraight ? Vec2d.Dist(info.start.handle, info.end.handle) : Math.abs(info.handleArc.length), sw, {\n            end: \"skip\",\n            start: \"skip\",\n            lengthRatio: 2.5\n          }),\n          strokeDasharray2 = _getPerfectDashProps.strokeDasharray,\n          strokeDashoffset2 = _getPerfectDashProps.strokeDashoffset;\n        handlePath = shape.props.start.type === \"binding\" || shape.props.end.type === \"binding\" ? /* @__PURE__ */jsx(\"path\", {\n          className: \"tl-arrow-hint\",\n          d: info.isStraight ? getStraightArrowHandlePath(info) : getCurvedArrowHandlePath(info),\n          strokeDasharray: strokeDasharray2,\n          strokeDashoffset: strokeDashoffset2,\n          strokeWidth: sw,\n          markerStart: shape.props.start.type === \"binding\" ? shape.props.start.isExact ? \"\" : isPrecise(shape.props.start.normalizedAnchor) ? \"url(#arrowhead-cross)\" : \"url(#arrowhead-dot)\" : \"\",\n          markerEnd: shape.props.end.type === \"binding\" ? shape.props.end.isExact ? \"\" : isPrecise(shape.props.end.normalizedAnchor) ? \"url(#arrowhead-cross)\" : \"url(#arrowhead-dot)\" : \"\",\n          opacity: 0.16\n        }) : null;\n      }\n      var _getPerfectDashProps2 = getPerfectDashProps(info.isStraight ? info.length : Math.abs(info.bodyArc.length), strokeWidth, {\n          style: shape.props.dash\n        }),\n        strokeDasharray = _getPerfectDashProps2.strokeDasharray,\n        strokeDashoffset = _getPerfectDashProps2.strokeDashoffset;\n      var maskStartArrowhead = !(info.start.arrowhead === \"none\" || info.start.arrowhead === \"arrow\");\n      var maskEndArrowhead = !(info.end.arrowhead === \"none\" || info.end.arrowhead === \"arrow\");\n      var includeMask = maskStartArrowhead || maskEndArrowhead || labelSize;\n      var maskId = (shape.id + \"_clip_\" + changeIndex).replace(\":\", \"_\");\n      return /* @__PURE__ */jsxs(Fragment, {\n        children: [/* @__PURE__ */jsxs(SVGContainer, {\n          id: shape.id,\n          style: {\n            minWidth: 50,\n            minHeight: 50\n          },\n          children: [includeMask && /* @__PURE__ */jsx(\"defs\", {\n            children: /* @__PURE__ */jsxs(\"mask\", {\n              id: maskId,\n              children: [/* @__PURE__ */jsx(\"rect\", {\n                x: toDomPrecision(-100 + bounds.minX),\n                y: toDomPrecision(-100 + bounds.minY),\n                width: toDomPrecision(bounds.width + 200),\n                height: toDomPrecision(bounds.height + 200),\n                fill: \"white\"\n              }), labelSize && /* @__PURE__ */jsx(\"rect\", {\n                x: toDomPrecision(labelSize.x),\n                y: toDomPrecision(labelSize.y),\n                width: toDomPrecision(labelSize.w),\n                height: toDomPrecision(labelSize.h),\n                fill: \"black\",\n                rx: 4,\n                ry: 4\n              }), as && maskStartArrowhead && /* @__PURE__ */jsx(\"path\", {\n                d: as,\n                fill: info.start.arrowhead === \"arrow\" ? \"none\" : \"black\",\n                stroke: \"none\"\n              }), ae && maskEndArrowhead && /* @__PURE__ */jsx(\"path\", {\n                d: ae,\n                fill: info.end.arrowhead === \"arrow\" ? \"none\" : \"black\",\n                stroke: \"none\"\n              })]\n            })\n          }), /* @__PURE__ */jsxs(\"g\", {\n            fill: \"none\",\n            stroke: \"var(--palette-\".concat(shape.props.color, \")\"),\n            strokeWidth: strokeWidth,\n            strokeLinejoin: \"round\",\n            strokeLinecap: \"round\",\n            pointerEvents: \"none\",\n            children: [handlePath, /* @__PURE__ */jsxs(\"g\", _objectSpread(_objectSpread({}, includeMask ? {\n              mask: \"url(#\".concat(maskId, \")\")\n            } : void 0), {}, {\n              children: [includeMask && /* @__PURE__ */jsx(\"rect\", {\n                x: toDomPrecision(bounds.minX - 100),\n                y: toDomPrecision(bounds.minY - 100),\n                width: toDomPrecision(bounds.width + 200),\n                height: toDomPrecision(bounds.height + 200),\n                opacity: 0\n              }), /* @__PURE__ */jsx(\"path\", {\n                d: path,\n                strokeDasharray: strokeDasharray,\n                strokeDashoffset: strokeDashoffset\n              })]\n            })), as && maskStartArrowhead && shape.props.fill !== \"none\" && /* @__PURE__ */jsx(ShapeFill, {\n              d: as,\n              color: shape.props.color,\n              fill: shape.props.fill\n            }), ae && maskEndArrowhead && shape.props.fill !== \"none\" && /* @__PURE__ */jsx(ShapeFill, {\n              d: ae,\n              color: shape.props.color,\n              fill: shape.props.fill\n            }), as && /* @__PURE__ */jsx(\"path\", {\n              d: as\n            }), ae && /* @__PURE__ */jsx(\"path\", {\n              d: ae\n            })]\n          }), /* @__PURE__ */jsx(\"path\", {\n            d: path,\n            className: \"tl-hitarea-stroke\"\n          })]\n        }), /* @__PURE__ */jsx(ArrowTextLabel, {\n          id: shape.id,\n          text: shape.props.text,\n          font: shape.props.font,\n          size: shape.props.size,\n          position: info.middle,\n          width: (_labelSize$w = labelSize === null || labelSize === void 0 ? void 0 : labelSize.w) !== null && _labelSize$w !== void 0 ? _labelSize$w : 0,\n          labelColor: shape.props.labelColor\n        })]\n      });\n    }\n  }, {\n    key: \"indicator\",\n    value: function indicator(shape) {\n      var _getArrowTerminalsInA3 = getArrowTerminalsInArrowSpace(this.editor, shape),\n        start = _getArrowTerminalsInA3.start,\n        end = _getArrowTerminalsInA3.end;\n      var info = this.getArrowInfo(shape);\n      var bounds = this.bounds(shape);\n      var labelSize = this.getLabelBounds(shape);\n      if (!info) return null;\n      if (Vec2d.Equals(start, end)) return null;\n      var strokeWidth = STROKE_SIZES[shape.props.size];\n      var as = info.start.arrowhead && getArrowheadPathForType(info, \"start\", strokeWidth);\n      var ae = info.end.arrowhead && getArrowheadPathForType(info, \"end\", strokeWidth);\n      var path = info.isStraight ? getSolidStraightArrowPath(info) : getSolidCurvedArrowPath(info);\n      var includeMask = as && info.start.arrowhead !== \"arrow\" || ae && info.end.arrowhead !== \"arrow\" || labelSize !== null;\n      var maskId = (shape.id + \"_clip\").replace(\":\", \"_\");\n      return /* @__PURE__ */jsxs(\"g\", {\n        children: [includeMask && /* @__PURE__ */jsx(\"defs\", {\n          children: /* @__PURE__ */jsxs(\"mask\", {\n            id: maskId,\n            children: [/* @__PURE__ */jsx(\"rect\", {\n              x: bounds.minX - 100,\n              y: bounds.minY - 100,\n              width: bounds.w + 200,\n              height: bounds.h + 200,\n              fill: \"white\"\n            }), labelSize && /* @__PURE__ */jsx(\"rect\", {\n              x: labelSize.x,\n              y: labelSize.y,\n              width: labelSize.w,\n              height: labelSize.h,\n              fill: \"black\",\n              rx: 4,\n              ry: 4\n            }), as && /* @__PURE__ */jsx(\"path\", {\n              d: as,\n              fill: info.start.arrowhead === \"arrow\" ? \"none\" : \"black\",\n              stroke: \"none\"\n            }), ae && /* @__PURE__ */jsx(\"path\", {\n              d: ae,\n              fill: info.end.arrowhead === \"arrow\" ? \"none\" : \"black\",\n              stroke: \"none\"\n            })]\n          })\n        }), /* @__PURE__ */jsxs(\"g\", _objectSpread(_objectSpread({}, includeMask ? {\n          mask: \"url(#\".concat(maskId, \")\")\n        } : void 0), {}, {\n          children: [includeMask && /* @__PURE__ */jsx(\"rect\", {\n            x: bounds.minX - 100,\n            y: bounds.minY - 100,\n            width: bounds.width + 200,\n            height: bounds.height + 200,\n            opacity: 0\n          }), /* @__PURE__ */jsx(\"path\", {\n            d: path\n          })]\n        })), as && /* @__PURE__ */jsx(\"path\", {\n          d: as\n        }), ae && /* @__PURE__ */jsx(\"path\", {\n          d: ae\n        }), labelSize && /* @__PURE__ */jsx(\"rect\", {\n          x: labelSize.x,\n          y: labelSize.y,\n          width: labelSize.w,\n          height: labelSize.h,\n          rx: 4,\n          ry: 4\n        })]\n      });\n    }\n  }, {\n    key: \"labelBoundsCache\",\n    get: function get() {\n      var _this4 = this;\n      return this.editor.store.createComputedCache(\"labelBoundsCache\", function (shape) {\n        var info = _this4.getArrowInfo(shape);\n        var bounds = _this4.bounds(shape);\n        var _shape$props = shape.props,\n          text = _shape$props.text,\n          font = _shape$props.font,\n          size = _shape$props.size;\n        if (!info) return null;\n        if (!text.trim()) return null;\n        var _this4$editor$textMea = _this4.editor.textMeasure.measureText(text, _objectSpread(_objectSpread({}, TEXT_PROPS), {}, {\n            fontFamily: FONT_FAMILIES[font],\n            fontSize: ARROW_LABEL_FONT_SIZES[size],\n            width: \"fit-content\"\n          })),\n          w = _this4$editor$textMea.w,\n          h = _this4$editor$textMea.h;\n        var width = w;\n        var height = h;\n        if (bounds.width > bounds.height) {\n          width = Math.max(Math.min(w, 64), Math.min(bounds.width - 64, w));\n          var _this4$editor$textMea2 = _this4.editor.textMeasure.measureText(text, _objectSpread(_objectSpread({}, TEXT_PROPS), {}, {\n              fontFamily: FONT_FAMILIES[font],\n              fontSize: ARROW_LABEL_FONT_SIZES[size],\n              width: width + \"px\"\n            })),\n            squishedWidth = _this4$editor$textMea2.w,\n            squishedHeight = _this4$editor$textMea2.h;\n          width = squishedWidth;\n          height = squishedHeight;\n        }\n        if (width > 16 * ARROW_LABEL_FONT_SIZES[size]) {\n          width = 16 * ARROW_LABEL_FONT_SIZES[size];\n          var _this4$editor$textMea3 = _this4.editor.textMeasure.measureText(text, _objectSpread(_objectSpread({}, TEXT_PROPS), {}, {\n              fontFamily: FONT_FAMILIES[font],\n              fontSize: ARROW_LABEL_FONT_SIZES[size],\n              width: width + \"px\"\n            })),\n            _squishedWidth = _this4$editor$textMea3.w,\n            _squishedHeight = _this4$editor$textMea3.h;\n          width = _squishedWidth;\n          height = _squishedHeight;\n        }\n        return new Box2d(info.middle.x - (width + 8) / 2, info.middle.y - (height + 8) / 2, width + 8, height + 8);\n      });\n    }\n  }, {\n    key: \"getLabelBounds\",\n    value: function getLabelBounds(shape) {\n      return this.labelBoundsCache.get(shape.id) || null;\n    }\n  }, {\n    key: \"toSvg\",\n    value: function toSvg(shape, font, colors) {\n      var color = colors.fill[shape.props.color];\n      var info = this.getArrowInfo(shape);\n      var strokeWidth = STROKE_SIZES[shape.props.size];\n      var g = document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\");\n      if (!info) return g;\n      var as = info.start.arrowhead && getArrowheadPathForType(info, \"start\", strokeWidth);\n      var ae = info.end.arrowhead && getArrowheadPathForType(info, \"end\", strokeWidth);\n      var bounds = this.bounds(shape);\n      var labelSize = this.getLabelBounds(shape);\n      var maskId = (shape.id + \"_clip\").replace(\":\", \"_\");\n      if (as || ae || labelSize) {\n        var defs = document.createElementNS(\"http://www.w3.org/2000/svg\", \"defs\");\n        var mask = document.createElementNS(\"http://www.w3.org/2000/svg\", \"mask\");\n        mask.id = maskId;\n        var rect = document.createElementNS(\"http://www.w3.org/2000/svg\", \"rect\");\n        rect.setAttribute(\"x\", bounds.minX - 100 + \"\");\n        rect.setAttribute(\"y\", bounds.minY - 100 + \"\");\n        rect.setAttribute(\"width\", bounds.width + 200 + \"\");\n        rect.setAttribute(\"height\", bounds.height + 200 + \"\");\n        rect.setAttribute(\"fill\", \"white\");\n        mask.appendChild(rect);\n        if (as) mask.appendChild(getArrowheadSvgMask(as, info.start.arrowhead));\n        if (ae) mask.appendChild(getArrowheadSvgMask(ae, info.end.arrowhead));\n        if (labelSize) {\n          var labelMask = document.createElementNS(\"http://www.w3.org/2000/svg\", \"rect\");\n          labelMask.setAttribute(\"x\", labelSize.x + \"\");\n          labelMask.setAttribute(\"y\", labelSize.y + \"\");\n          labelMask.setAttribute(\"width\", labelSize.w + \"\");\n          labelMask.setAttribute(\"height\", labelSize.h + \"\");\n          labelMask.setAttribute(\"fill\", \"black\");\n          mask.appendChild(labelMask);\n        }\n        defs.appendChild(mask);\n        g.appendChild(defs);\n      }\n      var g2 = document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\");\n      g2.setAttribute(\"mask\", \"url(#\".concat(maskId, \")\"));\n      g.appendChild(g2);\n      var rect2 = document.createElementNS(\"http://www.w3.org/2000/svg\", \"rect\");\n      rect2.setAttribute(\"x\", \"-100\");\n      rect2.setAttribute(\"y\", \"-100\");\n      rect2.setAttribute(\"width\", bounds.width + 200 + \"\");\n      rect2.setAttribute(\"height\", bounds.height + 200 + \"\");\n      rect2.setAttribute(\"fill\", \"transparent\");\n      rect2.setAttribute(\"stroke\", \"none\");\n      g2.appendChild(rect2);\n      var path = getArrowSvgPath(info.isStraight ? getSolidStraightArrowPath(info) : getSolidCurvedArrowPath(info), color, strokeWidth);\n      var _getPerfectDashProps3 = getPerfectDashProps(info.isStraight ? info.length : Math.abs(info.bodyArc.length), strokeWidth, {\n          style: shape.props.dash\n        }),\n        strokeDasharray = _getPerfectDashProps3.strokeDasharray,\n        strokeDashoffset = _getPerfectDashProps3.strokeDashoffset;\n      path.setAttribute(\"stroke-dasharray\", strokeDasharray);\n      path.setAttribute(\"stroke-dashoffset\", strokeDashoffset);\n      g2.appendChild(path);\n      if (as) {\n        g.appendChild(getArrowheadSvgPath(as, shape.props.color, strokeWidth, shape.props.arrowheadStart === \"arrow\" ? \"none\" : shape.props.fill, colors));\n      }\n      if (ae) {\n        g.appendChild(getArrowheadSvgPath(ae, shape.props.color, strokeWidth, shape.props.arrowheadEnd === \"arrow\" ? \"none\" : shape.props.fill, colors));\n      }\n      if (labelSize) {\n        var opts = {\n          fontSize: ARROW_LABEL_FONT_SIZES[shape.props.size],\n          lineHeight: TEXT_PROPS.lineHeight,\n          fontFamily: font,\n          padding: 0,\n          textAlign: \"middle\",\n          width: labelSize.w - 8,\n          verticalTextAlign: \"middle\",\n          height: labelSize.h,\n          fontStyle: \"normal\",\n          fontWeight: \"normal\",\n          overflow: \"wrap\"\n        };\n        var textElm = createTextSvgElementFromSpans(this.editor, this.editor.textMeasure.measureTextSpans(shape.props.text, opts), opts);\n        textElm.setAttribute(\"fill\", colors.fill[shape.props.labelColor]);\n        var children = Array.from(textElm.children);\n        children.forEach(function (child) {\n          var x = parseFloat(child.getAttribute(\"x\") || \"0\");\n          var y = parseFloat(child.getAttribute(\"y\") || \"0\");\n          child.setAttribute(\"x\", x + 4 + labelSize.x + \"px\");\n          child.setAttribute(\"y\", y + labelSize.y + \"px\");\n        });\n        var textBgEl = textElm.cloneNode(true);\n        textBgEl.setAttribute(\"stroke-width\", \"2\");\n        textBgEl.setAttribute(\"fill\", colors.background);\n        textBgEl.setAttribute(\"stroke\", colors.background);\n        g.appendChild(textBgEl);\n        g.appendChild(textElm);\n      }\n      return g;\n    }\n  }]);\n  return ArrowShapeUtil;\n}(ShapeUtil);\n_defineProperty(ArrowShapeUtil, \"type\", \"arrow\");\n__decorateClass([computed], ArrowShapeUtil.prototype, \"infoCache\", 1);\n__decorateClass([computed], ArrowShapeUtil.prototype, \"labelBoundsCache\", 1);\nfunction getArrowheadSvgMask(d, arrowhead) {\n  var path = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n  path.setAttribute(\"d\", d);\n  path.setAttribute(\"fill\", arrowhead === \"arrow\" ? \"none\" : \"black\");\n  path.setAttribute(\"stroke\", \"none\");\n  return path;\n}\nfunction getArrowSvgPath(d, color, strokeWidth) {\n  var path = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n  path.setAttribute(\"d\", d);\n  path.setAttribute(\"fill\", \"none\");\n  path.setAttribute(\"stroke\", color);\n  path.setAttribute(\"stroke-width\", strokeWidth + \"\");\n  return path;\n}\nfunction getArrowheadSvgPath(d, color, strokeWidth, fill, colors) {\n  var path = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n  path.setAttribute(\"d\", d);\n  path.setAttribute(\"fill\", \"none\");\n  path.setAttribute(\"stroke\", colors.fill[color]);\n  path.setAttribute(\"stroke-width\", strokeWidth + \"\");\n  var shapeFill = getShapeFillSvg({\n    d: d,\n    fill: fill,\n    color: color,\n    colors: colors\n  });\n  if (shapeFill) {\n    var g = document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\");\n    g.appendChild(shapeFill);\n    g.appendChild(path);\n    return g;\n  } else {\n    return path;\n  }\n}\nfunction isPrecise(normalizedAnchor) {\n  return normalizedAnchor.x !== 0.5 || normalizedAnchor.y !== 0.5;\n}\nexport { ArrowShapeUtil };","map":{"version":3,"names":["Fragment","jsx","jsxs","Box2d","getPointOnCircle","linesIntersect","longAngleDist","Matrix2d","pointInPolygon","shortAngleDist","toDomPrecision","Vec2d","deepCopy","last","minBy","React","computed","EMPTY_ARRAY","SVGContainer","ShapeUtil","createTextSvgElementFromSpans","ARROW_LABEL_FONT_SIZES","FONT_FAMILIES","STROKE_SIZES","TEXT_PROPS","getPerfectDashProps","getShapeFillSvg","ShapeFill","getArrowheadPathForType","getCurvedArrowHandlePath","getCurvedArrowInfo","getSolidCurvedArrowPath","getArrowTerminalsInArrowSpace","getIsArrowStraight","getSolidStraightArrowPath","getStraightArrowHandlePath","getStraightArrowInfo","ArrowTextLabel","globalRenderIndex","ArrowShapeUtil","_ShapeUtil","_inherits","_super","_createSuper","_this","_classCallCheck","_len","arguments","length","args","Array","_key","call","apply","concat","_defineProperty","_assertThisInitialized","shape","_ref","handle","isPrecise2","isPrecise","next","id","pageTransform","editor","getPageTransformById","pointInPageSpace","applyToPoint","inputs","ctrlKey","props","type","x","y","target","sortedShapesArray","filter","hitShape","util","getShapeUtil","canBind","pageMask","getPageMaskById","pointInTargetSpace","getPointInShapeSpace","isClosed","outline","hitTestPoint","targetBounds","getBounds","prevHandle","startBindingId","start","boundShapeId","endBindingId","end","precise","pointerVelocity","len","Dist","center","Math","max","min","width","height","zoomLevel","normalizedAnchor","minX","minY","isExact","altKey","_getArrowTerminalsInA","delta","Sub","v","Per","med","Med","A","B","Add","point","NearestPointOnLineSegment","bend","Clockwise","startBinding","endBinding","isWithinSelection","_getArrowTerminalsInA2","_objectSpread","info","scaleX","scaleY","terminals","_deepCopy","mx","abs","my","arrowheadStart","arrowheadEnd","_this$getLabelBounds","getLabelBounds","text","trimEnd","updateShapes","_createClass","key","value","defaultProps","dash","size","fill","color","labelColor","font","getCenter","bounds","FromPoints","getOutlineWithoutLabel","getArrowInfo","isStraight","isValid","From","pointsToPush","ceil","bodyArc","isFinite","results","startAngle","Angle","endAngle","a","sweepFlag","b","l","largeArcFlag","r","radius","i","t","angle","getOutline","outlineWithoutLabel","labelBounds","sides","sideIndexes","prevPoint","didAddLabel","result","_loop","nextPoint","nearestIntersectingSideIndex","sideIndex","DistanceToLineSegment","intersectingPoint","push","j","snapPoints","_shape","get","_this2","store","createComputedCache","infoCache","getHandles","index","middle","offsetDist","C","D","hitTestLineSegment","component","_this3","_labelSize$w","onlySelectedShape","shouldDisplayHandles","isInAny","isReadOnly","labelSize","changeIndex","useMemo","isSafari","strokeWidth","as","arrowhead","ae","path","handlePath","sw","_getPerfectDashProps","handleArc","lengthRatio","strokeDasharray2","strokeDasharray","strokeDashoffset2","strokeDashoffset","className","d","markerStart","markerEnd","opacity","_getPerfectDashProps2","style","maskStartArrowhead","maskEndArrowhead","includeMask","maskId","replace","children","minWidth","minHeight","w","h","rx","ry","stroke","strokeLinejoin","strokeLinecap","pointerEvents","mask","position","indicator","_getArrowTerminalsInA3","Equals","_this4","_shape$props","trim","_this4$editor$textMea","textMeasure","measureText","fontFamily","fontSize","_this4$editor$textMea2","squishedWidth","squishedHeight","_this4$editor$textMea3","labelBoundsCache","toSvg","colors","g","document","createElementNS","defs","rect","setAttribute","appendChild","getArrowheadSvgMask","labelMask","g2","rect2","getArrowSvgPath","_getPerfectDashProps3","getArrowheadSvgPath","opts","lineHeight","padding","textAlign","verticalTextAlign","fontStyle","fontWeight","overflow","textElm","measureTextSpans","from","forEach","child","parseFloat","getAttribute","textBgEl","cloneNode","background","__decorateClass","prototype","shapeFill"],"sources":["/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@tldraw/editor/src/lib/editor/shapes/arrow/ArrowShapeUtil.tsx"],"sourcesContent":["import {\n\tBox2d,\n\tgetPointOnCircle,\n\tlinesIntersect,\n\tlongAngleDist,\n\tMatrix2d,\n\tpointInPolygon,\n\tshortAngleDist,\n\ttoDomPrecision,\n\tVec2d,\n\tVecLike,\n} from '@tldraw/primitives'\nimport { ComputedCache } from '@tldraw/store'\nimport {\n\tTLArrowShape,\n\tTLArrowShapeArrowheadStyle,\n\tTLDefaultColorStyle,\n\tTLDefaultFillStyle,\n\tTLHandle,\n\tTLShapeId,\n\tTLShapePartial,\n\tVec2dModel,\n} from '@tldraw/tlschema'\nimport { deepCopy, last, minBy } from '@tldraw/utils'\nimport * as React from 'react'\nimport { computed, EMPTY_ARRAY } from 'signia'\nimport { SVGContainer } from '../../../components/SVGContainer'\nimport {\n\tShapeUtil,\n\tTLOnEditEndHandler,\n\tTLOnHandleChangeHandler,\n\tTLOnResizeHandler,\n\tTLOnTranslateStartHandler,\n\tTLShapeUtilFlag,\n} from '../ShapeUtil'\nimport { createTextSvgElementFromSpans } from '../shared/createTextSvgElementFromSpans'\nimport {\n\tARROW_LABEL_FONT_SIZES,\n\tFONT_FAMILIES,\n\tSTROKE_SIZES,\n\tTEXT_PROPS,\n} from '../shared/default-shape-constants'\nimport { getPerfectDashProps } from '../shared/getPerfectDashProps'\nimport { getShapeFillSvg, ShapeFill } from '../shared/ShapeFill'\nimport { TLExportColors } from '../shared/TLExportColors'\nimport { ArrowInfo } from './arrow/arrow-types'\nimport { getArrowheadPathForType } from './arrow/arrowheads'\nimport {\n\tgetCurvedArrowHandlePath,\n\tgetCurvedArrowInfo,\n\tgetSolidCurvedArrowPath,\n} from './arrow/curved-arrow'\nimport { getArrowTerminalsInArrowSpace, getIsArrowStraight } from './arrow/shared'\nimport {\n\tgetSolidStraightArrowPath,\n\tgetStraightArrowHandlePath,\n\tgetStraightArrowInfo,\n} from './arrow/straight-arrow'\nimport { ArrowTextLabel } from './components/ArrowTextLabel'\n\nlet globalRenderIndex = 0\n\n/** @public */\nexport class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {\n\tstatic override type = 'arrow' as const\n\n\toverride canEdit = () => true\n\toverride canBind = () => false\n\toverride isClosed = () => false\n\toverride canSnap = () => true\n\toverride hideResizeHandles: TLShapeUtilFlag<TLArrowShape> = () => true\n\toverride hideRotateHandle: TLShapeUtilFlag<TLArrowShape> = () => true\n\toverride hideSelectionBoundsFg: TLShapeUtilFlag<TLArrowShape> = () => true\n\toverride hideSelectionBoundsBg: TLShapeUtilFlag<TLArrowShape> = () => true\n\n\toverride defaultProps(): TLArrowShape['props'] {\n\t\treturn {\n\t\t\tdash: 'draw',\n\t\t\tsize: 'm',\n\t\t\tfill: 'none',\n\t\t\tcolor: 'black',\n\t\t\tlabelColor: 'black',\n\t\t\tbend: 0,\n\t\t\tstart: { type: 'point', x: 0, y: 0 },\n\t\t\tend: { type: 'point', x: 0, y: 0 },\n\t\t\tarrowheadStart: 'none',\n\t\t\tarrowheadEnd: 'arrow',\n\t\t\ttext: '',\n\t\t\tfont: 'draw',\n\t\t}\n\t}\n\n\tgetCenter(shape: TLArrowShape): Vec2d {\n\t\treturn this.bounds(shape).center\n\t}\n\n\tgetBounds(shape: TLArrowShape) {\n\t\treturn Box2d.FromPoints(this.getOutlineWithoutLabel(shape))\n\t}\n\n\tgetOutlineWithoutLabel(shape: TLArrowShape): Vec2d[] {\n\t\tconst info = this.getArrowInfo(shape)\n\n\t\tif (!info) {\n\t\t\treturn []\n\t\t}\n\n\t\tif (info.isStraight) {\n\t\t\tif (info.isValid) {\n\t\t\t\treturn [Vec2d.From(info.start.point), Vec2d.From(info.end.point)]\n\t\t\t} else {\n\t\t\t\treturn [new Vec2d(0, 0), new Vec2d(1, 1)]\n\t\t\t}\n\t\t}\n\n\t\tif (!info.isValid) {\n\t\t\treturn [new Vec2d(0, 0), new Vec2d(1, 1)]\n\t\t}\n\n\t\tconst pointsToPush = Math.max(5, Math.ceil(Math.abs(info.bodyArc.length) / 16))\n\n\t\tif (pointsToPush <= 0 && !isFinite(pointsToPush)) {\n\t\t\treturn [new Vec2d(0, 0), new Vec2d(1, 1)]\n\t\t}\n\n\t\tconst results: Vec2d[] = Array(pointsToPush)\n\n\t\tconst startAngle = Vec2d.Angle(info.bodyArc.center, info.start.point)\n\t\tconst endAngle = Vec2d.Angle(info.bodyArc.center, info.end.point)\n\n\t\tconst a = info.bodyArc.sweepFlag ? endAngle : startAngle\n\t\tconst b = info.bodyArc.sweepFlag ? startAngle : endAngle\n\t\tconst l = info.bodyArc.largeArcFlag ? -longAngleDist(a, b) : shortAngleDist(a, b)\n\n\t\tconst r = Math.max(1, info.bodyArc.radius)\n\n\t\tfor (let i = 0; i < pointsToPush; i++) {\n\t\t\tconst t = i / (pointsToPush - 1)\n\t\t\tconst angle = a + l * t\n\t\t\tconst point = getPointOnCircle(info.bodyArc.center.x, info.bodyArc.center.y, r, angle)\n\t\t\tresults[i] = point\n\t\t}\n\n\t\treturn results\n\t}\n\n\tgetOutline(shape: TLArrowShape): Vec2d[] {\n\t\tconst outlineWithoutLabel = this.getOutlineWithoutLabel(shape)\n\n\t\tconst labelBounds = this.getLabelBounds(shape)\n\t\tif (!labelBounds) {\n\t\t\treturn outlineWithoutLabel\n\t\t}\n\n\t\tconst sides = labelBounds.sides\n\t\tconst sideIndexes = [0, 1, 2, 3]\n\n\t\t// start with the first point...\n\t\tlet prevPoint = outlineWithoutLabel[0]\n\t\tlet didAddLabel = false\n\t\tconst result = [prevPoint]\n\t\tfor (let i = 1; i < outlineWithoutLabel.length; i++) {\n\t\t\t// ...and use the next point to form a line segment for the outline.\n\t\t\tconst nextPoint = outlineWithoutLabel[i]\n\n\t\t\tif (!didAddLabel) {\n\t\t\t\t// find the index of the side of the label bounds that intersects the line segment\n\t\t\t\tconst nearestIntersectingSideIndex = minBy(\n\t\t\t\t\tsideIndexes.filter((sideIndex) =>\n\t\t\t\t\t\tlinesIntersect(sides[sideIndex][0], sides[sideIndex][1], prevPoint, nextPoint)\n\t\t\t\t\t),\n\t\t\t\t\t(sideIndex) =>\n\t\t\t\t\t\tVec2d.DistanceToLineSegment(sides[sideIndex][0], sides[sideIndex][1], prevPoint)\n\t\t\t\t)\n\n\t\t\t\t// if we've found one, start at that index and trace around all four corners of the label bounds\n\t\t\t\tif (nearestIntersectingSideIndex !== undefined) {\n\t\t\t\t\tconst intersectingPoint = Vec2d.NearestPointOnLineSegment(\n\t\t\t\t\t\tsides[nearestIntersectingSideIndex][0],\n\t\t\t\t\t\tsides[nearestIntersectingSideIndex][1],\n\t\t\t\t\t\tprevPoint\n\t\t\t\t\t)\n\n\t\t\t\t\tresult.push(intersectingPoint)\n\t\t\t\t\tfor (let j = 0; j < 4; j++) {\n\t\t\t\t\t\tconst sideIndex = (nearestIntersectingSideIndex + j) % 4\n\t\t\t\t\t\tresult.push(sides[sideIndex][1])\n\t\t\t\t\t}\n\t\t\t\t\tresult.push(intersectingPoint)\n\n\t\t\t\t\t// we've added the label, so we can just continue with the rest of the outline as normal\n\t\t\t\t\tdidAddLabel = true\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tresult.push(nextPoint)\n\t\t\tprevPoint = nextPoint\n\t\t}\n\n\t\treturn result\n\t}\n\n\tsnapPoints(_shape: TLArrowShape): Vec2d[] {\n\t\treturn EMPTY_ARRAY\n\t}\n\n\t@computed\n\tprivate get infoCache() {\n\t\treturn this.editor.store.createComputedCache<ArrowInfo, TLArrowShape>(\n\t\t\t'arrow infoCache',\n\t\t\t(shape) => {\n\t\t\t\treturn getIsArrowStraight(shape)\n\t\t\t\t\t? getStraightArrowInfo(this.editor, shape)\n\t\t\t\t\t: getCurvedArrowInfo(this.editor, shape)\n\t\t\t}\n\t\t)\n\t}\n\n\tgetArrowInfo(shape: TLArrowShape) {\n\t\treturn this.infoCache.get(shape.id)\n\t}\n\n\tgetHandles(shape: TLArrowShape): TLHandle[] {\n\t\tconst info = this.infoCache.get(shape.id)!\n\t\treturn [\n\t\t\t{\n\t\t\t\tid: 'start',\n\t\t\t\ttype: 'vertex',\n\t\t\t\tindex: 'a0',\n\t\t\t\tx: info.start.handle.x,\n\t\t\t\ty: info.start.handle.y,\n\t\t\t\tcanBind: true,\n\t\t\t},\n\t\t\t{\n\t\t\t\tid: 'middle',\n\t\t\t\ttype: 'vertex',\n\t\t\t\tindex: 'a2',\n\t\t\t\tx: info.middle.x,\n\t\t\t\ty: info.middle.y,\n\t\t\t\tcanBind: false,\n\t\t\t},\n\t\t\t{\n\t\t\t\tid: 'end',\n\t\t\t\ttype: 'vertex',\n\t\t\t\tindex: 'a3',\n\t\t\t\tx: info.end.handle.x,\n\t\t\t\ty: info.end.handle.y,\n\t\t\t\tcanBind: true,\n\t\t\t},\n\t\t]\n\t}\n\n\tonHandleChange: TLOnHandleChangeHandler<TLArrowShape> = (shape, { handle, isPrecise }) => {\n\t\tconst next = deepCopy(shape)\n\n\t\tswitch (handle.id) {\n\t\t\tcase 'start':\n\t\t\tcase 'end': {\n\t\t\t\tconst pageTransform = this.editor.getPageTransformById(next.id)!\n\t\t\t\tconst pointInPageSpace = Matrix2d.applyToPoint(pageTransform, handle)\n\n\t\t\t\tif (this.editor.inputs.ctrlKey) {\n\t\t\t\t\tnext.props[handle.id] = {\n\t\t\t\t\t\ttype: 'point',\n\t\t\t\t\t\tx: handle.x,\n\t\t\t\t\t\ty: handle.y,\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tconst target = last(\n\t\t\t\t\t\tthis.editor.sortedShapesArray.filter((hitShape) => {\n\t\t\t\t\t\t\tif (hitShape.id === shape.id) {\n\t\t\t\t\t\t\t\t// We're testing against the arrow\n\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tconst util = this.editor.getShapeUtil(hitShape)\n\t\t\t\t\t\t\tif (!util.canBind(hitShape)) {\n\t\t\t\t\t\t\t\t// The shape can't be bound to\n\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Check the page mask\n\t\t\t\t\t\t\tconst pageMask = this.editor.getPageMaskById(hitShape.id)\n\t\t\t\t\t\t\tif (pageMask) {\n\t\t\t\t\t\t\t\tif (!pointInPolygon(pointInPageSpace, pageMask)) return\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tconst pointInTargetSpace = this.editor.getPointInShapeSpace(\n\t\t\t\t\t\t\t\thitShape,\n\t\t\t\t\t\t\t\tpointInPageSpace\n\t\t\t\t\t\t\t)\n\n\t\t\t\t\t\t\tif (util.isClosed(hitShape)) {\n\t\t\t\t\t\t\t\t// Test the polygon\n\t\t\t\t\t\t\t\treturn pointInPolygon(pointInTargetSpace, util.outline(hitShape))\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Test the point using the shape's idea of what a hit is\n\t\t\t\t\t\t\treturn util.hitTestPoint(hitShape, pointInTargetSpace)\n\t\t\t\t\t\t})\n\t\t\t\t\t)\n\n\t\t\t\t\tif (target) {\n\t\t\t\t\t\tconst targetBounds = this.editor.getBounds(target)\n\t\t\t\t\t\tconst pointInTargetSpace = this.editor.getPointInShapeSpace(target, pointInPageSpace)\n\n\t\t\t\t\t\tconst prevHandle = next.props[handle.id]\n\n\t\t\t\t\t\tconst startBindingId =\n\t\t\t\t\t\t\tshape.props.start.type === 'binding' && shape.props.start.boundShapeId\n\t\t\t\t\t\tconst endBindingId = shape.props.end.type === 'binding' && shape.props.end.boundShapeId\n\n\t\t\t\t\t\tlet precise =\n\t\t\t\t\t\t\t// If externally precise, then always precise\n\t\t\t\t\t\t\tisPrecise ||\n\t\t\t\t\t\t\t// If the other handle is bound to the same shape, then precise\n\t\t\t\t\t\t\t((startBindingId || endBindingId) && startBindingId === endBindingId) ||\n\t\t\t\t\t\t\t// If the other shape is not closed, then precise\n\t\t\t\t\t\t\t!this.editor.getShapeUtil(target).isClosed(next)\n\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t// If we're switching to a new bound shape, then precise only if moving slowly\n\t\t\t\t\t\t\tprevHandle.type === 'point' ||\n\t\t\t\t\t\t\t(prevHandle.type === 'binding' && target.id !== prevHandle.boundShapeId)\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tprecise = this.editor.inputs.pointerVelocity.len() < 0.5\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (precise) {\n\t\t\t\t\t\t\t// Funky math but we want the snap distance to be 4 at the minimum and either\n\t\t\t\t\t\t\t// 16 or 15% of the smaller dimension of the target shape, whichever is smaller\n\t\t\t\t\t\t\tprecise =\n\t\t\t\t\t\t\t\tVec2d.Dist(pointInTargetSpace, targetBounds.center) >\n\t\t\t\t\t\t\t\tMath.max(\n\t\t\t\t\t\t\t\t\t4,\n\t\t\t\t\t\t\t\t\tMath.min(Math.min(targetBounds.width, targetBounds.height) * 0.15, 16)\n\t\t\t\t\t\t\t\t) /\n\t\t\t\t\t\t\t\t\tthis.editor.zoomLevel\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tnext.props[handle.id] = {\n\t\t\t\t\t\t\ttype: 'binding',\n\t\t\t\t\t\t\tboundShapeId: target.id,\n\t\t\t\t\t\t\tnormalizedAnchor: precise\n\t\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t\tx: (pointInTargetSpace.x - targetBounds.minX) / targetBounds.width,\n\t\t\t\t\t\t\t\t\t\ty: (pointInTargetSpace.y - targetBounds.minY) / targetBounds.height,\n\t\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t\t: { x: 0.5, y: 0.5 },\n\t\t\t\t\t\t\tisExact: this.editor.inputs.altKey,\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnext.props[handle.id] = {\n\t\t\t\t\t\t\ttype: 'point',\n\t\t\t\t\t\t\tx: handle.x,\n\t\t\t\t\t\t\ty: handle.y,\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tcase 'middle': {\n\t\t\t\tconst { start, end } = getArrowTerminalsInArrowSpace(this.editor, next)\n\n\t\t\t\tconst delta = Vec2d.Sub(end, start)\n\t\t\t\tconst v = Vec2d.Per(delta)\n\n\t\t\t\tconst med = Vec2d.Med(end, start)\n\t\t\t\tconst A = Vec2d.Sub(med, v)\n\t\t\t\tconst B = Vec2d.Add(med, v)\n\n\t\t\t\tconst point = Vec2d.NearestPointOnLineSegment(A, B, handle, false)\n\t\t\t\tlet bend = Vec2d.Dist(point, med)\n\t\t\t\tif (Vec2d.Clockwise(point, end, med)) bend *= -1\n\t\t\t\tnext.props.bend = bend\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\treturn next\n\t}\n\n\tonTranslateStart: TLOnTranslateStartHandler<TLArrowShape> = (shape) => {\n\t\tlet startBinding: TLShapeId | null =\n\t\t\tshape.props.start.type === 'binding' ? shape.props.start.boundShapeId : null\n\t\tlet endBinding: TLShapeId | null =\n\t\t\tshape.props.end.type === 'binding' ? shape.props.end.boundShapeId : null\n\n\t\t// If at least one bound shape is in the selection, do nothing;\n\t\t// If no bound shapes are in the selection, unbind any bound shapes\n\n\t\tif (\n\t\t\t(startBinding && this.editor.isWithinSelection(startBinding)) ||\n\t\t\t(endBinding && this.editor.isWithinSelection(endBinding))\n\t\t) {\n\t\t\treturn\n\t\t}\n\n\t\tstartBinding = null\n\t\tendBinding = null\n\n\t\tconst { start, end } = getArrowTerminalsInArrowSpace(this.editor, shape)\n\n\t\treturn {\n\t\t\tid: shape.id,\n\t\t\ttype: shape.type,\n\t\t\tprops: {\n\t\t\t\t...shape.props,\n\t\t\t\tstart: {\n\t\t\t\t\ttype: 'point',\n\t\t\t\t\tx: start.x,\n\t\t\t\t\ty: start.y,\n\t\t\t\t},\n\t\t\t\tend: {\n\t\t\t\t\ttype: 'point',\n\t\t\t\t\tx: end.x,\n\t\t\t\t\ty: end.y,\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\t}\n\n\tonResize: TLOnResizeHandler<TLArrowShape> = (shape, info) => {\n\t\tconst { scaleX, scaleY } = info\n\n\t\tconst terminals = getArrowTerminalsInArrowSpace(this.editor, shape)\n\n\t\tconst { start, end } = deepCopy<TLArrowShape['props']>(shape.props)\n\t\tlet { bend } = shape.props\n\n\t\t// Rescale start handle if it's not bound to a shape\n\t\tif (start.type === 'point') {\n\t\t\tstart.x = terminals.start.x * scaleX\n\t\t\tstart.y = terminals.start.y * scaleY\n\t\t}\n\n\t\t// Rescale end handle if it's not bound to a shape\n\t\tif (end.type === 'point') {\n\t\t\tend.x = terminals.end.x * scaleX\n\t\t\tend.y = terminals.end.y * scaleY\n\t\t}\n\n\t\t// todo: we should only change the normalized anchor positions\n\t\t// of the shape's handles if the bound shape is also being resized\n\n\t\tconst mx = Math.abs(scaleX)\n\t\tconst my = Math.abs(scaleY)\n\n\t\tif (scaleX < 0 && scaleY >= 0) {\n\t\t\tif (bend !== 0) {\n\t\t\t\tbend *= -1\n\t\t\t\tbend *= Math.max(mx, my)\n\t\t\t}\n\n\t\t\tif (start.type === 'binding') {\n\t\t\t\tstart.normalizedAnchor.x = 1 - start.normalizedAnchor.x\n\t\t\t}\n\n\t\t\tif (end.type === 'binding') {\n\t\t\t\tend.normalizedAnchor.x = 1 - end.normalizedAnchor.x\n\t\t\t}\n\t\t} else if (scaleX >= 0 && scaleY < 0) {\n\t\t\tif (bend !== 0) {\n\t\t\t\tbend *= -1\n\t\t\t\tbend *= Math.max(mx, my)\n\t\t\t}\n\n\t\t\tif (start.type === 'binding') {\n\t\t\t\tstart.normalizedAnchor.y = 1 - start.normalizedAnchor.y\n\t\t\t}\n\n\t\t\tif (end.type === 'binding') {\n\t\t\t\tend.normalizedAnchor.y = 1 - end.normalizedAnchor.y\n\t\t\t}\n\t\t} else if (scaleX >= 0 && scaleY >= 0) {\n\t\t\tif (bend !== 0) {\n\t\t\t\tbend *= Math.max(mx, my)\n\t\t\t}\n\t\t} else if (scaleX < 0 && scaleY < 0) {\n\t\t\tif (bend !== 0) {\n\t\t\t\tbend *= Math.max(mx, my)\n\t\t\t}\n\n\t\t\tif (start.type === 'binding') {\n\t\t\t\tstart.normalizedAnchor.x = 1 - start.normalizedAnchor.x\n\t\t\t\tstart.normalizedAnchor.y = 1 - start.normalizedAnchor.y\n\t\t\t}\n\n\t\t\tif (end.type === 'binding') {\n\t\t\t\tend.normalizedAnchor.x = 1 - end.normalizedAnchor.x\n\t\t\t\tend.normalizedAnchor.y = 1 - end.normalizedAnchor.y\n\t\t\t}\n\t\t}\n\n\t\tconst next = {\n\t\t\tprops: {\n\t\t\t\tstart,\n\t\t\t\tend,\n\t\t\t\tbend,\n\t\t\t},\n\t\t}\n\n\t\treturn next\n\t}\n\n\tonDoubleClickHandle = (\n\t\tshape: TLArrowShape,\n\t\thandle: TLHandle\n\t): TLShapePartial<TLArrowShape> | void => {\n\t\tswitch (handle.id) {\n\t\t\tcase 'start': {\n\t\t\t\treturn {\n\t\t\t\t\tid: shape.id,\n\t\t\t\t\ttype: shape.type,\n\t\t\t\t\tprops: {\n\t\t\t\t\t\t...shape.props,\n\t\t\t\t\t\tarrowheadStart: shape.props.arrowheadStart === 'none' ? 'arrow' : 'none',\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t}\n\t\t\tcase 'end': {\n\t\t\t\treturn {\n\t\t\t\t\tid: shape.id,\n\t\t\t\t\ttype: shape.type,\n\t\t\t\t\tprops: {\n\t\t\t\t\t\t...shape.props,\n\t\t\t\t\t\tarrowheadEnd: shape.props.arrowheadEnd === 'none' ? 'arrow' : 'none',\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\thitTestPoint(shape: TLArrowShape, point: VecLike): boolean {\n\t\tconst outline = this.outline(shape)\n\t\tconst zoomLevel = this.editor.zoomLevel\n\t\tconst offsetDist = STROKE_SIZES[shape.props.size] / zoomLevel\n\n\t\tfor (let i = 0; i < outline.length - 1; i++) {\n\t\t\tconst C = outline[i]\n\t\t\tconst D = outline[i + 1]\n\n\t\t\tif (Vec2d.DistanceToLineSegment(C, D, point) < offsetDist) return true\n\t\t}\n\n\t\treturn false\n\t}\n\n\thitTestLineSegment(shape: TLArrowShape, A: VecLike, B: VecLike): boolean {\n\t\tconst outline = this.outline(shape)\n\n\t\tfor (let i = 0; i < outline.length - 1; i++) {\n\t\t\tconst C = outline[i]\n\t\t\tconst D = outline[i + 1]\n\t\t\tif (linesIntersect(A, B, C, D)) return true\n\t\t}\n\n\t\treturn false\n\t}\n\n\tcomponent(shape: TLArrowShape) {\n\t\t// Not a class component, but eslint can't tell that :(\n\t\tconst onlySelectedShape = this.editor.onlySelectedShape\n\t\tconst shouldDisplayHandles =\n\t\t\tthis.editor.isInAny(\n\t\t\t\t'select.idle',\n\t\t\t\t'select.pointing_handle',\n\t\t\t\t'select.dragging_handle',\n\t\t\t\t'arrow.dragging'\n\t\t\t) && !this.editor.isReadOnly\n\n\t\tconst info = this.getArrowInfo(shape)\n\t\tconst bounds = this.bounds(shape)\n\t\tconst labelSize = this.getLabelBounds(shape)\n\n\t\t// eslint-disable-next-line react-hooks/rules-of-hooks\n\t\tconst changeIndex = React.useMemo<number>(() => {\n\t\t\treturn this.editor.isSafari ? (globalRenderIndex += 1) : 0\n\t\t\t// eslint-disable-next-line react-hooks/exhaustive-deps\n\t\t}, [shape])\n\n\t\tif (!info?.isValid) return null\n\n\t\tconst strokeWidth = STROKE_SIZES[shape.props.size]\n\n\t\tconst as = info.start.arrowhead && getArrowheadPathForType(info, 'start', strokeWidth)\n\t\tconst ae = info.end.arrowhead && getArrowheadPathForType(info, 'end', strokeWidth)\n\n\t\tconst path = info.isStraight ? getSolidStraightArrowPath(info) : getSolidCurvedArrowPath(info)\n\n\t\tlet handlePath: null | JSX.Element = null\n\n\t\tif (onlySelectedShape === shape && shouldDisplayHandles) {\n\t\t\tconst sw = 2\n\t\t\tconst { strokeDasharray, strokeDashoffset } = getPerfectDashProps(\n\t\t\t\tinfo.isStraight\n\t\t\t\t\t? Vec2d.Dist(info.start.handle, info.end.handle)\n\t\t\t\t\t: Math.abs(info.handleArc.length),\n\t\t\t\tsw,\n\t\t\t\t{\n\t\t\t\t\tend: 'skip',\n\t\t\t\t\tstart: 'skip',\n\t\t\t\t\tlengthRatio: 2.5,\n\t\t\t\t}\n\t\t\t)\n\n\t\t\thandlePath =\n\t\t\t\tshape.props.start.type === 'binding' || shape.props.end.type === 'binding' ? (\n\t\t\t\t\t<path\n\t\t\t\t\t\tclassName=\"tl-arrow-hint\"\n\t\t\t\t\t\td={info.isStraight ? getStraightArrowHandlePath(info) : getCurvedArrowHandlePath(info)}\n\t\t\t\t\t\tstrokeDasharray={strokeDasharray}\n\t\t\t\t\t\tstrokeDashoffset={strokeDashoffset}\n\t\t\t\t\t\tstrokeWidth={sw}\n\t\t\t\t\t\tmarkerStart={\n\t\t\t\t\t\t\tshape.props.start.type === 'binding'\n\t\t\t\t\t\t\t\t? shape.props.start.isExact\n\t\t\t\t\t\t\t\t\t? ''\n\t\t\t\t\t\t\t\t\t: isPrecise(shape.props.start.normalizedAnchor)\n\t\t\t\t\t\t\t\t\t? 'url(#arrowhead-cross)'\n\t\t\t\t\t\t\t\t\t: 'url(#arrowhead-dot)'\n\t\t\t\t\t\t\t\t: ''\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmarkerEnd={\n\t\t\t\t\t\t\tshape.props.end.type === 'binding'\n\t\t\t\t\t\t\t\t? shape.props.end.isExact\n\t\t\t\t\t\t\t\t\t? ''\n\t\t\t\t\t\t\t\t\t: isPrecise(shape.props.end.normalizedAnchor)\n\t\t\t\t\t\t\t\t\t? 'url(#arrowhead-cross)'\n\t\t\t\t\t\t\t\t\t: 'url(#arrowhead-dot)'\n\t\t\t\t\t\t\t\t: ''\n\t\t\t\t\t\t}\n\t\t\t\t\t\topacity={0.16}\n\t\t\t\t\t/>\n\t\t\t\t) : null\n\t\t}\n\n\t\tconst { strokeDasharray, strokeDashoffset } = getPerfectDashProps(\n\t\t\tinfo.isStraight ? info.length : Math.abs(info.bodyArc.length),\n\t\t\tstrokeWidth,\n\t\t\t{\n\t\t\t\tstyle: shape.props.dash,\n\t\t\t}\n\t\t)\n\n\t\tconst maskStartArrowhead = !(\n\t\t\tinfo.start.arrowhead === 'none' || info.start.arrowhead === 'arrow'\n\t\t)\n\t\tconst maskEndArrowhead = !(info.end.arrowhead === 'none' || info.end.arrowhead === 'arrow')\n\t\tconst includeMask = maskStartArrowhead || maskEndArrowhead || labelSize\n\n\t\t// NOTE: I know right setting `changeIndex` hacky-as right! But we need this because otherwise safari loses\n\t\t// the mask, see <https://linear.app/tldraw/issue/TLD-1500/changing-arrow-color-makes-line-pass-through-text>\n\t\tconst maskId = (shape.id + '_clip_' + changeIndex).replace(':', '_')\n\n\t\treturn (\n\t\t\t<>\n\t\t\t\t<SVGContainer id={shape.id} style={{ minWidth: 50, minHeight: 50 }}>\n\t\t\t\t\t{includeMask && (\n\t\t\t\t\t\t<defs>\n\t\t\t\t\t\t\t<mask id={maskId}>\n\t\t\t\t\t\t\t\t<rect\n\t\t\t\t\t\t\t\t\tx={toDomPrecision(-100 + bounds.minX)}\n\t\t\t\t\t\t\t\t\ty={toDomPrecision(-100 + bounds.minY)}\n\t\t\t\t\t\t\t\t\twidth={toDomPrecision(bounds.width + 200)}\n\t\t\t\t\t\t\t\t\theight={toDomPrecision(bounds.height + 200)}\n\t\t\t\t\t\t\t\t\tfill=\"white\"\n\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t\t{labelSize && (\n\t\t\t\t\t\t\t\t\t<rect\n\t\t\t\t\t\t\t\t\t\tx={toDomPrecision(labelSize.x)}\n\t\t\t\t\t\t\t\t\t\ty={toDomPrecision(labelSize.y)}\n\t\t\t\t\t\t\t\t\t\twidth={toDomPrecision(labelSize.w)}\n\t\t\t\t\t\t\t\t\t\theight={toDomPrecision(labelSize.h)}\n\t\t\t\t\t\t\t\t\t\tfill=\"black\"\n\t\t\t\t\t\t\t\t\t\trx={4}\n\t\t\t\t\t\t\t\t\t\try={4}\n\t\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t\t{as && maskStartArrowhead && (\n\t\t\t\t\t\t\t\t\t<path\n\t\t\t\t\t\t\t\t\t\td={as}\n\t\t\t\t\t\t\t\t\t\tfill={info.start.arrowhead === 'arrow' ? 'none' : 'black'}\n\t\t\t\t\t\t\t\t\t\tstroke=\"none\"\n\t\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t\t{ae && maskEndArrowhead && (\n\t\t\t\t\t\t\t\t\t<path\n\t\t\t\t\t\t\t\t\t\td={ae}\n\t\t\t\t\t\t\t\t\t\tfill={info.end.arrowhead === 'arrow' ? 'none' : 'black'}\n\t\t\t\t\t\t\t\t\t\tstroke=\"none\"\n\t\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t</mask>\n\t\t\t\t\t\t</defs>\n\t\t\t\t\t)}\n\t\t\t\t\t<g\n\t\t\t\t\t\tfill=\"none\"\n\t\t\t\t\t\tstroke={`var(--palette-${shape.props.color})`}\n\t\t\t\t\t\tstrokeWidth={strokeWidth}\n\t\t\t\t\t\tstrokeLinejoin=\"round\"\n\t\t\t\t\t\tstrokeLinecap=\"round\"\n\t\t\t\t\t\tpointerEvents=\"none\"\n\t\t\t\t\t>\n\t\t\t\t\t\t{handlePath}\n\t\t\t\t\t\t{/* firefox will clip if you provide a maskURL even if there is no mask matching that URL in the DOM */}\n\t\t\t\t\t\t<g {...(includeMask ? { mask: `url(#${maskId})` } : undefined)}>\n\t\t\t\t\t\t\t{/* This rect needs to be here if we're creating a mask due to an svg quirk on Chrome */}\n\t\t\t\t\t\t\t{includeMask && (\n\t\t\t\t\t\t\t\t<rect\n\t\t\t\t\t\t\t\t\tx={toDomPrecision(bounds.minX - 100)}\n\t\t\t\t\t\t\t\t\ty={toDomPrecision(bounds.minY - 100)}\n\t\t\t\t\t\t\t\t\twidth={toDomPrecision(bounds.width + 200)}\n\t\t\t\t\t\t\t\t\theight={toDomPrecision(bounds.height + 200)}\n\t\t\t\t\t\t\t\t\topacity={0}\n\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t<path\n\t\t\t\t\t\t\t\td={path}\n\t\t\t\t\t\t\t\tstrokeDasharray={strokeDasharray}\n\t\t\t\t\t\t\t\tstrokeDashoffset={strokeDashoffset}\n\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t</g>\n\t\t\t\t\t\t{as && maskStartArrowhead && shape.props.fill !== 'none' && (\n\t\t\t\t\t\t\t<ShapeFill d={as} color={shape.props.color} fill={shape.props.fill} />\n\t\t\t\t\t\t)}\n\t\t\t\t\t\t{ae && maskEndArrowhead && shape.props.fill !== 'none' && (\n\t\t\t\t\t\t\t<ShapeFill d={ae} color={shape.props.color} fill={shape.props.fill} />\n\t\t\t\t\t\t)}\n\t\t\t\t\t\t{as && <path d={as} />}\n\t\t\t\t\t\t{ae && <path d={ae} />}\n\t\t\t\t\t</g>\n\t\t\t\t\t<path d={path} className=\"tl-hitarea-stroke\" />\n\t\t\t\t</SVGContainer>\n\t\t\t\t<ArrowTextLabel\n\t\t\t\t\tid={shape.id}\n\t\t\t\t\ttext={shape.props.text}\n\t\t\t\t\tfont={shape.props.font}\n\t\t\t\t\tsize={shape.props.size}\n\t\t\t\t\tposition={info.middle}\n\t\t\t\t\twidth={labelSize?.w ?? 0}\n\t\t\t\t\tlabelColor={shape.props.labelColor}\n\t\t\t\t/>\n\t\t\t</>\n\t\t)\n\t}\n\n\tindicator(shape: TLArrowShape) {\n\t\tconst { start, end } = getArrowTerminalsInArrowSpace(this.editor, shape)\n\n\t\tconst info = this.getArrowInfo(shape)\n\t\tconst bounds = this.bounds(shape)\n\t\tconst labelSize = this.getLabelBounds(shape)\n\n\t\tif (!info) return null\n\t\tif (Vec2d.Equals(start, end)) return null\n\n\t\tconst strokeWidth = STROKE_SIZES[shape.props.size]\n\n\t\tconst as = info.start.arrowhead && getArrowheadPathForType(info, 'start', strokeWidth)\n\t\tconst ae = info.end.arrowhead && getArrowheadPathForType(info, 'end', strokeWidth)\n\n\t\tconst path = info.isStraight ? getSolidStraightArrowPath(info) : getSolidCurvedArrowPath(info)\n\n\t\tconst includeMask =\n\t\t\t(as && info.start.arrowhead !== 'arrow') ||\n\t\t\t(ae && info.end.arrowhead !== 'arrow') ||\n\t\t\tlabelSize !== null\n\n\t\tconst maskId = (shape.id + '_clip').replace(':', '_')\n\n\t\treturn (\n\t\t\t<g>\n\t\t\t\t{includeMask && (\n\t\t\t\t\t<defs>\n\t\t\t\t\t\t<mask id={maskId}>\n\t\t\t\t\t\t\t<rect\n\t\t\t\t\t\t\t\tx={bounds.minX - 100}\n\t\t\t\t\t\t\t\ty={bounds.minY - 100}\n\t\t\t\t\t\t\t\twidth={bounds.w + 200}\n\t\t\t\t\t\t\t\theight={bounds.h + 200}\n\t\t\t\t\t\t\t\tfill=\"white\"\n\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t{labelSize && (\n\t\t\t\t\t\t\t\t<rect\n\t\t\t\t\t\t\t\t\tx={labelSize.x}\n\t\t\t\t\t\t\t\t\ty={labelSize.y}\n\t\t\t\t\t\t\t\t\twidth={labelSize.w}\n\t\t\t\t\t\t\t\t\theight={labelSize.h}\n\t\t\t\t\t\t\t\t\tfill=\"black\"\n\t\t\t\t\t\t\t\t\trx={4}\n\t\t\t\t\t\t\t\t\try={4}\n\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t{as && (\n\t\t\t\t\t\t\t\t<path\n\t\t\t\t\t\t\t\t\td={as}\n\t\t\t\t\t\t\t\t\tfill={info.start.arrowhead === 'arrow' ? 'none' : 'black'}\n\t\t\t\t\t\t\t\t\tstroke=\"none\"\n\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t{ae && (\n\t\t\t\t\t\t\t\t<path\n\t\t\t\t\t\t\t\t\td={ae}\n\t\t\t\t\t\t\t\t\tfill={info.end.arrowhead === 'arrow' ? 'none' : 'black'}\n\t\t\t\t\t\t\t\t\tstroke=\"none\"\n\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t</mask>\n\t\t\t\t\t</defs>\n\t\t\t\t)}\n\t\t\t\t{/* firefox will clip if you provide a maskURL even if there is no mask matching that URL in the DOM */}\n\t\t\t\t<g {...(includeMask ? { mask: `url(#${maskId})` } : undefined)}>\n\t\t\t\t\t{/* This rect needs to be here if we're creating a mask due to an svg quirk on Chrome */}\n\t\t\t\t\t{includeMask && (\n\t\t\t\t\t\t<rect\n\t\t\t\t\t\t\tx={bounds.minX - 100}\n\t\t\t\t\t\t\ty={bounds.minY - 100}\n\t\t\t\t\t\t\twidth={bounds.width + 200}\n\t\t\t\t\t\t\theight={bounds.height + 200}\n\t\t\t\t\t\t\topacity={0}\n\t\t\t\t\t\t/>\n\t\t\t\t\t)}\n\n\t\t\t\t\t<path d={path} />\n\t\t\t\t</g>\n\t\t\t\t{as && <path d={as} />}\n\t\t\t\t{ae && <path d={ae} />}\n\t\t\t\t{labelSize && (\n\t\t\t\t\t<rect\n\t\t\t\t\t\tx={labelSize.x}\n\t\t\t\t\t\ty={labelSize.y}\n\t\t\t\t\t\twidth={labelSize.w}\n\t\t\t\t\t\theight={labelSize.h}\n\t\t\t\t\t\trx={4}\n\t\t\t\t\t\try={4}\n\t\t\t\t\t/>\n\t\t\t\t)}\n\t\t\t</g>\n\t\t)\n\t}\n\n\t@computed get labelBoundsCache(): ComputedCache<Box2d | null, TLArrowShape> {\n\t\treturn this.editor.store.createComputedCache('labelBoundsCache', (shape) => {\n\t\t\tconst info = this.getArrowInfo(shape)\n\t\t\tconst bounds = this.bounds(shape)\n\t\t\tconst { text, font, size } = shape.props\n\n\t\t\tif (!info) return null\n\t\t\tif (!text.trim()) return null\n\n\t\t\tconst { w, h } = this.editor.textMeasure.measureText(text, {\n\t\t\t\t...TEXT_PROPS,\n\t\t\t\tfontFamily: FONT_FAMILIES[font],\n\t\t\t\tfontSize: ARROW_LABEL_FONT_SIZES[size],\n\t\t\t\twidth: 'fit-content',\n\t\t\t})\n\n\t\t\tlet width = w\n\t\t\tlet height = h\n\n\t\t\tif (bounds.width > bounds.height) {\n\t\t\t\twidth = Math.max(Math.min(w, 64), Math.min(bounds.width - 64, w))\n\n\t\t\t\tconst { w: squishedWidth, h: squishedHeight } = this.editor.textMeasure.measureText(text, {\n\t\t\t\t\t...TEXT_PROPS,\n\t\t\t\t\tfontFamily: FONT_FAMILIES[font],\n\t\t\t\t\tfontSize: ARROW_LABEL_FONT_SIZES[size],\n\t\t\t\t\twidth: width + 'px',\n\t\t\t\t})\n\n\t\t\t\twidth = squishedWidth\n\t\t\t\theight = squishedHeight\n\t\t\t}\n\n\t\t\tif (width > 16 * ARROW_LABEL_FONT_SIZES[size]) {\n\t\t\t\twidth = 16 * ARROW_LABEL_FONT_SIZES[size]\n\n\t\t\t\tconst { w: squishedWidth, h: squishedHeight } = this.editor.textMeasure.measureText(text, {\n\t\t\t\t\t...TEXT_PROPS,\n\t\t\t\t\tfontFamily: FONT_FAMILIES[font],\n\t\t\t\t\tfontSize: ARROW_LABEL_FONT_SIZES[size],\n\t\t\t\t\twidth: width + 'px',\n\t\t\t\t})\n\n\t\t\t\twidth = squishedWidth\n\t\t\t\theight = squishedHeight\n\t\t\t}\n\n\t\t\treturn new Box2d(\n\t\t\t\tinfo.middle.x - (width + 8) / 2,\n\t\t\t\tinfo.middle.y - (height + 8) / 2,\n\t\t\t\twidth + 8,\n\t\t\t\theight + 8\n\t\t\t)\n\t\t})\n\t}\n\n\tgetLabelBounds(shape: TLArrowShape): Box2d | null {\n\t\treturn this.labelBoundsCache.get(shape.id) || null\n\t}\n\n\tgetEditingBounds = (shape: TLArrowShape): Box2d => {\n\t\treturn this.getLabelBounds(shape) ?? new Box2d()\n\t}\n\n\tonEditEnd: TLOnEditEndHandler<TLArrowShape> = (shape) => {\n\t\tconst {\n\t\t\tid,\n\t\t\ttype,\n\t\t\tprops: { text },\n\t\t} = shape\n\n\t\tif (text.trimEnd() !== shape.props.text) {\n\t\t\tthis.editor.updateShapes<TLArrowShape>([\n\t\t\t\t{\n\t\t\t\t\tid,\n\t\t\t\t\ttype,\n\t\t\t\t\tprops: {\n\t\t\t\t\t\ttext: text.trimEnd(),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t])\n\t\t}\n\t}\n\n\ttoSvg(shape: TLArrowShape, font: string, colors: TLExportColors) {\n\t\tconst color = colors.fill[shape.props.color]\n\n\t\tconst info = this.getArrowInfo(shape)\n\n\t\tconst strokeWidth = STROKE_SIZES[shape.props.size]\n\n\t\t// Group for arrow\n\t\tconst g = document.createElementNS('http://www.w3.org/2000/svg', 'g')\n\t\tif (!info) return g\n\n\t\t// Arrowhead start path\n\t\tconst as = info.start.arrowhead && getArrowheadPathForType(info, 'start', strokeWidth)\n\t\t// Arrowhead end path\n\t\tconst ae = info.end.arrowhead && getArrowheadPathForType(info, 'end', strokeWidth)\n\n\t\tconst bounds = this.bounds(shape)\n\t\tconst labelSize = this.getLabelBounds(shape)\n\n\t\tconst maskId = (shape.id + '_clip').replace(':', '_')\n\n\t\t// If we have any arrowheads, then mask the arrowheads\n\t\tif (as || ae || labelSize) {\n\t\t\t// Create mask for arrowheads\n\n\t\t\t// Create defs\n\t\t\tconst defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs')\n\n\t\t\t// Create mask\n\t\t\tconst mask = document.createElementNS('http://www.w3.org/2000/svg', 'mask')\n\t\t\tmask.id = maskId\n\n\t\t\t// Create large white shape for mask\n\t\t\tconst rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect')\n\t\t\trect.setAttribute('x', bounds.minX - 100 + '')\n\t\t\trect.setAttribute('y', bounds.minY - 100 + '')\n\t\t\trect.setAttribute('width', bounds.width + 200 + '')\n\t\t\trect.setAttribute('height', bounds.height + 200 + '')\n\t\t\trect.setAttribute('fill', 'white')\n\t\t\tmask.appendChild(rect)\n\n\t\t\t// add arrowhead start mask\n\t\t\tif (as) mask.appendChild(getArrowheadSvgMask(as, info.start.arrowhead))\n\n\t\t\t// add arrowhead end mask\n\t\t\tif (ae) mask.appendChild(getArrowheadSvgMask(ae, info.end.arrowhead))\n\n\t\t\t// Mask out text label if text is present\n\t\t\tif (labelSize) {\n\t\t\t\tconst labelMask = document.createElementNS('http://www.w3.org/2000/svg', 'rect')\n\t\t\t\tlabelMask.setAttribute('x', labelSize.x + '')\n\t\t\t\tlabelMask.setAttribute('y', labelSize.y + '')\n\t\t\t\tlabelMask.setAttribute('width', labelSize.w + '')\n\t\t\t\tlabelMask.setAttribute('height', labelSize.h + '')\n\t\t\t\tlabelMask.setAttribute('fill', 'black')\n\n\t\t\t\tmask.appendChild(labelMask)\n\t\t\t}\n\n\t\t\tdefs.appendChild(mask)\n\t\t\tg.appendChild(defs)\n\t\t}\n\n\t\tconst g2 = document.createElementNS('http://www.w3.org/2000/svg', 'g')\n\t\tg2.setAttribute('mask', `url(#${maskId})`)\n\t\tg.appendChild(g2)\n\n\t\t// Dumb mask fix thing\n\t\tconst rect2 = document.createElementNS('http://www.w3.org/2000/svg', 'rect')\n\t\trect2.setAttribute('x', '-100')\n\t\trect2.setAttribute('y', '-100')\n\t\trect2.setAttribute('width', bounds.width + 200 + '')\n\t\trect2.setAttribute('height', bounds.height + 200 + '')\n\t\trect2.setAttribute('fill', 'transparent')\n\t\trect2.setAttribute('stroke', 'none')\n\t\tg2.appendChild(rect2)\n\n\t\t// Arrowhead body path\n\t\tconst path = getArrowSvgPath(\n\t\t\tinfo.isStraight ? getSolidStraightArrowPath(info) : getSolidCurvedArrowPath(info),\n\t\t\tcolor,\n\t\t\tstrokeWidth\n\t\t)\n\n\t\tconst { strokeDasharray, strokeDashoffset } = getPerfectDashProps(\n\t\t\tinfo.isStraight ? info.length : Math.abs(info.bodyArc.length),\n\t\t\tstrokeWidth,\n\t\t\t{\n\t\t\t\tstyle: shape.props.dash,\n\t\t\t}\n\t\t)\n\n\t\tpath.setAttribute('stroke-dasharray', strokeDasharray)\n\t\tpath.setAttribute('stroke-dashoffset', strokeDashoffset)\n\n\t\tg2.appendChild(path)\n\n\t\t// Arrowhead start path\n\t\tif (as) {\n\t\t\tg.appendChild(\n\t\t\t\tgetArrowheadSvgPath(\n\t\t\t\t\tas,\n\t\t\t\t\tshape.props.color,\n\t\t\t\t\tstrokeWidth,\n\t\t\t\t\tshape.props.arrowheadStart === 'arrow' ? 'none' : shape.props.fill,\n\t\t\t\t\tcolors\n\t\t\t\t)\n\t\t\t)\n\t\t}\n\t\t// Arrowhead end path\n\t\tif (ae) {\n\t\t\tg.appendChild(\n\t\t\t\tgetArrowheadSvgPath(\n\t\t\t\t\tae,\n\t\t\t\t\tshape.props.color,\n\t\t\t\t\tstrokeWidth,\n\t\t\t\t\tshape.props.arrowheadEnd === 'arrow' ? 'none' : shape.props.fill,\n\t\t\t\t\tcolors\n\t\t\t\t)\n\t\t\t)\n\t\t}\n\n\t\t// Text Label\n\t\tif (labelSize) {\n\t\t\tconst opts = {\n\t\t\t\tfontSize: ARROW_LABEL_FONT_SIZES[shape.props.size],\n\t\t\t\tlineHeight: TEXT_PROPS.lineHeight,\n\t\t\t\tfontFamily: font,\n\t\t\t\tpadding: 0,\n\t\t\t\ttextAlign: 'middle' as const,\n\t\t\t\twidth: labelSize.w - 8,\n\t\t\t\tverticalTextAlign: 'middle' as const,\n\t\t\t\theight: labelSize.h,\n\t\t\t\tfontStyle: 'normal',\n\t\t\t\tfontWeight: 'normal',\n\t\t\t\toverflow: 'wrap' as const,\n\t\t\t}\n\n\t\t\tconst textElm = createTextSvgElementFromSpans(\n\t\t\t\tthis.editor,\n\t\t\t\tthis.editor.textMeasure.measureTextSpans(shape.props.text, opts),\n\t\t\t\topts\n\t\t\t)\n\t\t\ttextElm.setAttribute('fill', colors.fill[shape.props.labelColor])\n\n\t\t\tconst children = Array.from(textElm.children) as unknown as SVGTSpanElement[]\n\n\t\t\tchildren.forEach((child) => {\n\t\t\t\tconst x = parseFloat(child.getAttribute('x') || '0')\n\t\t\t\tconst y = parseFloat(child.getAttribute('y') || '0')\n\n\t\t\t\tchild.setAttribute('x', x + 4 + labelSize!.x + 'px')\n\t\t\t\tchild.setAttribute('y', y + labelSize!.y + 'px')\n\t\t\t})\n\n\t\t\tconst textBgEl = textElm.cloneNode(true) as SVGTextElement\n\t\t\ttextBgEl.setAttribute('stroke-width', '2')\n\t\t\ttextBgEl.setAttribute('fill', colors.background)\n\t\t\ttextBgEl.setAttribute('stroke', colors.background)\n\n\t\t\tg.appendChild(textBgEl)\n\t\t\tg.appendChild(textElm)\n\t\t}\n\n\t\treturn g\n\t}\n}\n\nfunction getArrowheadSvgMask(d: string, arrowhead: TLArrowShapeArrowheadStyle) {\n\tconst path = document.createElementNS('http://www.w3.org/2000/svg', 'path')\n\tpath.setAttribute('d', d)\n\tpath.setAttribute('fill', arrowhead === 'arrow' ? 'none' : 'black')\n\tpath.setAttribute('stroke', 'none')\n\treturn path\n}\n\nfunction getArrowSvgPath(d: string, color: string, strokeWidth: number) {\n\tconst path = document.createElementNS('http://www.w3.org/2000/svg', 'path')\n\tpath.setAttribute('d', d)\n\tpath.setAttribute('fill', 'none')\n\tpath.setAttribute('stroke', color)\n\tpath.setAttribute('stroke-width', strokeWidth + '')\n\treturn path\n}\n\nfunction getArrowheadSvgPath(\n\td: string,\n\tcolor: TLDefaultColorStyle,\n\tstrokeWidth: number,\n\tfill: TLDefaultFillStyle,\n\tcolors: TLExportColors\n) {\n\tconst path = document.createElementNS('http://www.w3.org/2000/svg', 'path')\n\tpath.setAttribute('d', d)\n\tpath.setAttribute('fill', 'none')\n\tpath.setAttribute('stroke', colors.fill[color])\n\tpath.setAttribute('stroke-width', strokeWidth + '')\n\n\t// Get the fill element, if any\n\tconst shapeFill = getShapeFillSvg({\n\t\td,\n\t\tfill,\n\t\tcolor,\n\t\tcolors,\n\t})\n\n\tif (shapeFill) {\n\t\t// If there is a fill element, return a group containing the fill and the path\n\t\tconst g = document.createElementNS('http://www.w3.org/2000/svg', 'g')\n\t\tg.appendChild(shapeFill)\n\t\tg.appendChild(path)\n\t\treturn g\n\t} else {\n\t\t// Otherwise, just return the path\n\t\treturn path\n\t}\n}\n\nfunction isPrecise(normalizedAnchor: Vec2dModel) {\n\treturn normalizedAnchor.x !== 0.5 || normalizedAnchor.y !== 0.5\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}