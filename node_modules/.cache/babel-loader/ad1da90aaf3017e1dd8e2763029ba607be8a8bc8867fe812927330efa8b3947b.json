{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _defineProperty from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport { Box2d } from \"./Box2d.mjs\";\nimport { Vec2d } from \"./Vec2d.mjs\";\nvar BaseSpline2d = /*#__PURE__*/function () {\n  function BaseSpline2d(points) {\n    var p = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 50;\n    var k = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n    _classCallCheck(this, BaseSpline2d);\n    _defineProperty(this, \"computed\", {});\n    this.points = points;\n    this.p = p;\n    this.k = k;\n  }\n  _createClass(BaseSpline2d, [{\n    key: \"length\",\n    get: function get() {\n      if (this.computed.length !== void 0) {\n        return this.computed.length;\n      }\n      var segments = this.segments;\n      var result = segments.reduce(function (acc, curr) {\n        return acc + curr.length;\n      }, 0);\n      this.computed.length = result;\n      return result;\n    }\n  }, {\n    key: \"bounds\",\n    get: function get() {\n      if (this.computed.bounds !== void 0) {\n        return this.computed.bounds;\n      }\n      var segments = this.segments;\n      var result = Box2d.Common(segments.map(function (segment) {\n        return segment.bounds;\n      }));\n      this.computed.bounds = result;\n      return result;\n    }\n  }, {\n    key: \"head\",\n    get: function get() {\n      var points = this.points;\n      return points[0];\n    }\n  }, {\n    key: \"tail\",\n    get: function get() {\n      var points = this.points;\n      return points[points.length - 1];\n    }\n  }, {\n    key: \"path\",\n    get: function get() {\n      if (this.computed.path !== void 0) {\n        return this.computed.path;\n      }\n      var result = this.segments.map(function (segment) {\n        return segment.path;\n      }).filter(function (i) {\n        return i !== void 0 && i !== null && i !== \"\";\n      }).join(\" \");\n      this.computed.path = result;\n      return result;\n    }\n  }, {\n    key: \"addPoint\",\n    value: function addPoint(point) {\n      var points = this.points,\n        k = this.k,\n        p = this.p;\n      points.push(point);\n      this.computed = {};\n      this.getSegmentsFromPoints(this.points, p, k);\n      return this;\n    }\n  }, {\n    key: \"removePoint\",\n    value: function removePoint(point) {\n      var points = this.points,\n        k = this.k,\n        p = this.p;\n      var index = typeof point === \"number\" ? Math.floor(point) : points.indexOf(point);\n      if (index === -1) return this;\n      points.splice(index, 1);\n      this.computed = {};\n      this.getSegmentsFromPoints(this.points, p, k);\n      return this;\n    }\n  }, {\n    key: \"getPointAtLength\",\n    value: function getPointAtLength(length) {\n      var segments = this.segments;\n      var remaining = length;\n      if (length <= 0) return segments[0].getPoint(0);\n      if (length >= this.length) return segments[segments.length - 1].getPoint(1);\n      for (var i = 0; i < segments.length; i++) {\n        var segment = segments[i];\n        var segmentLength = segment.length;\n        if (remaining < segmentLength) {\n          return segment.getPoint(remaining / segmentLength);\n        }\n        remaining -= segment.length;\n      }\n      return segments[segments.length - 1].getPoint(1);\n    }\n  }, {\n    key: \"getPoint\",\n    value: function getPoint(t) {\n      if (t <= 0) return this.segments[0].getPoint(0);\n      if (t >= 1) return this.segments[this.segments.length - 1].getPoint(1);\n      return this.getPointAtLength(t * this.length);\n    }\n  }, {\n    key: \"getNormal\",\n    value: function getNormal(t) {\n      var length = this.length;\n      return this.getNormalAtLength(t * length);\n    }\n  }, {\n    key: \"getNormalAtLength\",\n    value: function getNormalAtLength(t) {\n      var segments = this.segments;\n      if (t < 0) return new Vec2d(0, 0);\n      var remaining = t;\n      var _iterator = _createForOfIteratorHelper(segments),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var segment = _step.value;\n          var segmentLength = segment.length;\n          if (remaining <= segmentLength) {\n            return segment.getNormal(remaining / segmentLength);\n          }\n          remaining -= segmentLength;\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return new Vec2d(0, 0);\n    }\n  }, {\n    key: \"getClosestPointTo\",\n    value: function getClosestPointTo(point) {\n      var head = this.head,\n        segments = this.segments;\n      var closestPoint = head;\n      var closestDistance = Vec2d.Dist(point, head);\n      var _iterator2 = _createForOfIteratorHelper(segments),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var segment = _step2.value;\n          var p = segment.getClosestPointTo(point);\n          if (p.distance < closestDistance) {\n            closestDistance = p.distance;\n            closestPoint = p.point;\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      return {\n        point: closestPoint,\n        distance: closestDistance\n      };\n    }\n  }]);\n  return BaseSpline2d;\n}();\nexport { BaseSpline2d };","map":{"version":3,"names":["Box2d","Vec2d","BaseSpline2d","points","p","arguments","length","undefined","k","_classCallCheck","_defineProperty","_createClass","key","get","computed","segments","result","reduce","acc","curr","bounds","Common","map","segment","path","filter","i","join","value","addPoint","point","push","getSegmentsFromPoints","removePoint","index","Math","floor","indexOf","splice","getPointAtLength","remaining","getPoint","segmentLength","t","getNormal","getNormalAtLength","_iterator","_createForOfIteratorHelper","_step","s","n","done","err","e","f","getClosestPointTo","head","closestPoint","closestDistance","Dist","_iterator2","_step2","distance"],"sources":["/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@tldraw/primitives/src/lib/BaseSpline2d.ts"],"sourcesContent":["import { BaseSegment2d } from './BaseSegment2d'\nimport { Box2d } from './Box2d'\nimport { Vec2d, VecLike } from './Vec2d'\n\nexport abstract class BaseSpline2d<T extends { p: number }> {\n\tconstructor(public points: VecLike[], public p = 50, public k = 1) {}\n\n\tabstract segments: BaseSegment2d<T>[]\n\n\tabstract getSegmentsFromPoints(points: VecLike[], p: number, k: number): BaseSegment2d<T>[]\n\n\tprotected computed: {\n\t\tlength?: number\n\t\tbounds?: Box2d\n\t\tpath?: string\n\t\tlut?: Vec2d[]\n\t} = {}\n\n\tget length() {\n\t\tif (this.computed.length !== undefined) {\n\t\t\treturn this.computed.length\n\t\t}\n\n\t\tconst { segments } = this\n\n\t\tconst result = segments.reduce((acc, curr) => acc + curr.length, 0)\n\n\t\tthis.computed.length = result\n\n\t\treturn result\n\t}\n\n\tget bounds() {\n\t\tif (this.computed.bounds !== undefined) {\n\t\t\treturn this.computed.bounds\n\t\t}\n\n\t\tconst { segments } = this\n\n\t\tconst result = Box2d.Common(segments.map((segment) => segment.bounds))\n\n\t\tthis.computed.bounds = result\n\n\t\treturn result\n\t}\n\n\tget head() {\n\t\tconst { points } = this\n\t\treturn points[0]\n\t}\n\n\tget tail() {\n\t\tconst { points } = this\n\t\treturn points[points.length - 1]\n\t}\n\n\tget path() {\n\t\tif (this.computed.path !== undefined) {\n\t\t\treturn this.computed.path\n\t\t}\n\n\t\tconst result = this.segments\n\t\t\t.map((segment) => segment.path)\n\t\t\t.filter((i) => i !== undefined && i !== null && i !== '')\n\t\t\t.join(' ')\n\n\t\tthis.computed.path = result\n\n\t\treturn result\n\t}\n\n\taddPoint(point: Vec2d) {\n\t\tconst { points, k, p } = this\n\t\tpoints.push(point)\n\t\tthis.computed = {}\n\t\tthis.getSegmentsFromPoints(this.points, p, k)\n\t\treturn this\n\t}\n\n\tremovePoint(point: Vec2d | number) {\n\t\tconst { points, k, p } = this\n\t\tconst index = typeof point === 'number' ? Math.floor(point) : points.indexOf(point)\n\t\tif (index === -1) return this\n\t\tpoints.splice(index, 1)\n\t\tthis.computed = {}\n\t\tthis.getSegmentsFromPoints(this.points, p, k)\n\t\treturn this\n\t}\n\n\tgetPointAtLength(length: number) {\n\t\tconst { segments } = this\n\n\t\tlet remaining = length\n\n\t\tif (length <= 0) return segments[0].getPoint(0)\n\t\tif (length >= this.length) return segments[segments.length - 1].getPoint(1)\n\n\t\tfor (let i = 0; i < segments.length; i++) {\n\t\t\tconst segment = segments[i]\n\t\t\tconst { length: segmentLength } = segment\n\n\t\t\tif (remaining < segmentLength) {\n\t\t\t\treturn segment.getPoint(remaining / segmentLength)\n\t\t\t}\n\n\t\t\tremaining -= segment.length\n\t\t}\n\n\t\treturn segments[segments.length - 1].getPoint(1)\n\t}\n\n\tgetPoint(t: number) {\n\t\tif (t <= 0) return this.segments[0].getPoint(0)\n\t\tif (t >= 1) return this.segments[this.segments.length - 1].getPoint(1)\n\t\treturn this.getPointAtLength(t * this.length)\n\t}\n\n\tgetNormal(t: number): Vec2d {\n\t\tconst { length } = this\n\t\treturn this.getNormalAtLength(t * length)\n\t}\n\n\tgetNormalAtLength(t: number): Vec2d {\n\t\tconst { segments } = this\n\n\t\tif (t < 0) return new Vec2d(0, 0)\n\n\t\tlet remaining = t\n\n\t\tfor (const segment of segments) {\n\t\t\tconst segmentLength = segment.length\n\t\t\tif (remaining <= segmentLength) {\n\t\t\t\treturn segment.getNormal(remaining / segmentLength)\n\t\t\t}\n\t\t\tremaining -= segmentLength\n\t\t}\n\n\t\treturn new Vec2d(0, 0)\n\t}\n\n\tgetClosestPointTo(point: Vec2d) {\n\t\tconst { head, segments } = this\n\t\tlet closestPoint = head\n\t\tlet closestDistance = Vec2d.Dist(point, head)\n\n\t\tfor (const segment of segments) {\n\t\t\tconst p = segment.getClosestPointTo(point)\n\t\t\tif (p.distance < closestDistance) {\n\t\t\t\tclosestDistance = p.distance\n\t\t\t\tclosestPoint = p.point\n\t\t\t}\n\t\t}\n\n\t\treturn { point: closestPoint, distance: closestDistance }\n\t}\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}