{"ast":null,"code":"import _objectSpread from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _classCallCheck from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _defineProperty from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport { devFreeze } from \"@tldraw/store\";\nimport { atom, transact } from \"signia\";\nimport { uniqueId } from \"../../utils/data.mjs\";\nimport { stack } from \"./Stack.mjs\";\nvar HistoryManager = /*#__PURE__*/function () {\n  // A flag for whether the user is in a batch operation\n  function HistoryManager(ctx, onBatchComplete, annotateError) {\n    var _this = this;\n    _classCallCheck(this, HistoryManager);\n    _defineProperty(this, \"_undos\", atom(\"HistoryManager.undos\", stack()));\n    // Updated by each action that includes and undo\n    _defineProperty(this, \"_redos\", atom(\"HistoryManager.redos\", stack()));\n    // Updated when a user undoes\n    _defineProperty(this, \"_batchDepth\", 0);\n    _defineProperty(this, \"_commands\", {});\n    _defineProperty(this, \"createCommand\", function (name, constructor, handle) {\n      if (_this._commands[name]) {\n        throw new Error(\"Duplicate command: \".concat(name));\n      }\n      _this._commands[name] = handle;\n      var exec = function exec() {\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n        if (!_this._batchDepth) {\n          _this.batch(function () {\n            return exec.apply(void 0, args);\n          });\n          return _this.ctx;\n        }\n        var result = constructor.apply(void 0, args);\n        if (!result) {\n          return _this.ctx;\n        }\n        var data = result.data,\n          ephemeral = result.ephemeral,\n          squashing = result.squashing,\n          preservesRedoStack = result.preservesRedoStack;\n        _this.ignoringUpdates(function (undos, redos) {\n          handle.do(data);\n          return {\n            undos: undos,\n            redos: redos\n          };\n        });\n        if (!ephemeral) {\n          var prev = _this._undos.value.head;\n          if (squashing && prev && prev.type === \"command\" && prev.name === name && prev.preservesRedoStack === preservesRedoStack) {\n            _this._undos.update(function (undos) {\n              return undos.tail.push(_objectSpread(_objectSpread({}, prev), {}, {\n                id: uniqueId(),\n                data: devFreeze(handle.squash(prev.data, data))\n              }));\n            });\n          } else {\n            _this._undos.update(function (undos) {\n              return undos.push({\n                type: \"command\",\n                name: name,\n                data: devFreeze(data),\n                id: uniqueId(),\n                preservesRedoStack: preservesRedoStack\n              });\n            });\n          }\n          if (!result.preservesRedoStack) {\n            _this._redos.set(stack());\n          }\n          _this.ctx.emit(\"change-history\", {\n            reason: \"push\"\n          });\n        }\n        return _this.ctx;\n      };\n      return exec;\n    });\n    _defineProperty(this, \"batch\", function (fn) {\n      try {\n        _this._batchDepth++;\n        if (_this._batchDepth === 1) {\n          transact(function () {\n            var _this$_undos$value$he, _this$_undos$value$he2;\n            var mostRecentActionId = (_this$_undos$value$he = _this._undos.value.head) === null || _this$_undos$value$he === void 0 ? void 0 : _this$_undos$value$he.id;\n            fn();\n            if (mostRecentActionId !== ((_this$_undos$value$he2 = _this._undos.value.head) === null || _this$_undos$value$he2 === void 0 ? void 0 : _this$_undos$value$he2.id)) {\n              _this.onBatchComplete();\n            }\n          });\n        } else {\n          fn();\n        }\n      } catch (error) {\n        _this.annotateError(error);\n        throw error;\n      } finally {\n        _this._batchDepth--;\n      }\n      return _this;\n    });\n    _defineProperty(this, \"ignoringUpdates\", function (fn) {\n      var undos = _this._undos.value;\n      var redos = _this._redos.value;\n      _this._undos.set(stack());\n      _this._redos.set(stack());\n      try {\n        ;\n        var _transact = transact(function () {\n          return fn(undos, redos);\n        });\n        undos = _transact.undos;\n        redos = _transact.redos;\n      } finally {\n        _this._undos.set(undos);\n        _this._redos.set(redos);\n      }\n    });\n    // History\n    _defineProperty(this, \"_undo\", function (_ref) {\n      var pushToRedoStack = _ref.pushToRedoStack,\n        _ref$toMark = _ref.toMark,\n        toMark = _ref$toMark === void 0 ? void 0 : _ref$toMark;\n      _this.ignoringUpdates(function (undos, redos) {\n        if (undos.length === 0) {\n          return {\n            undos: undos,\n            redos: redos\n          };\n        }\n        while (((_undos$head = undos.head) === null || _undos$head === void 0 ? void 0 : _undos$head.type) === \"STOP\") {\n          var _undos$head;\n          var mark = undos.head;\n          undos = undos.tail;\n          if (pushToRedoStack) {\n            redos = redos.push(mark);\n          }\n          if (mark.id === toMark) {\n            _this.ctx.emit(\"change-history\", pushToRedoStack ? {\n              reason: \"undo\"\n            } : {\n              reason: \"bail\",\n              markId: toMark\n            });\n            return {\n              undos: undos,\n              redos: redos\n            };\n          }\n        }\n        if (undos.length === 0) {\n          _this.ctx.emit(\"change-history\", pushToRedoStack ? {\n            reason: \"undo\"\n          } : {\n            reason: \"bail\",\n            markId: toMark\n          });\n          return {\n            undos: undos,\n            redos: redos\n          };\n        }\n        while (undos.head) {\n          var command = undos.head;\n          undos = undos.tail;\n          if (pushToRedoStack) {\n            redos = redos.push(command);\n          }\n          if (command.type === \"STOP\") {\n            if (command.onUndo && (!toMark || command.id === toMark)) {\n              _this.ctx.emit(\"change-history\", pushToRedoStack ? {\n                reason: \"undo\"\n              } : {\n                reason: \"bail\",\n                markId: toMark\n              });\n              return {\n                undos: undos,\n                redos: redos\n              };\n            }\n          } else {\n            var handler = _this._commands[command.name];\n            handler.undo(command.data);\n          }\n        }\n        _this.ctx.emit(\"change-history\", pushToRedoStack ? {\n          reason: \"undo\"\n        } : {\n          reason: \"bail\",\n          markId: toMark\n        });\n        return {\n          undos: undos,\n          redos: redos\n        };\n      });\n      return _this;\n    });\n    _defineProperty(this, \"undo\", function () {\n      _this._undo({\n        pushToRedoStack: true\n      });\n      return _this;\n    });\n    _defineProperty(this, \"redo\", function () {\n      _this.ignoringUpdates(function (undos, redos) {\n        if (redos.length === 0) {\n          return {\n            undos: undos,\n            redos: redos\n          };\n        }\n        while (((_redos$head = redos.head) === null || _redos$head === void 0 ? void 0 : _redos$head.type) === \"STOP\") {\n          var _redos$head;\n          undos = undos.push(redos.head);\n          redos = redos.tail;\n        }\n        if (redos.length === 0) {\n          _this.ctx.emit(\"change-history\", {\n            reason: \"redo\"\n          });\n          return {\n            undos: undos,\n            redos: redos\n          };\n        }\n        while (redos.head) {\n          var command = redos.head;\n          undos = undos.push(redos.head);\n          redos = redos.tail;\n          if (command.type === \"STOP\") {\n            if (command.onRedo) {\n              break;\n            }\n          } else {\n            var handler = _this._commands[command.name];\n            if (handler.redo) {\n              handler.redo(command.data);\n            } else {\n              handler.do(command.data);\n            }\n          }\n        }\n        _this.ctx.emit(\"change-history\", {\n          reason: \"redo\"\n        });\n        return {\n          undos: undos,\n          redos: redos\n        };\n      });\n      return _this;\n    });\n    _defineProperty(this, \"bail\", function () {\n      _this._undo({\n        pushToRedoStack: false\n      });\n      return _this;\n    });\n    _defineProperty(this, \"bailToMark\", function (id) {\n      _this._undo({\n        pushToRedoStack: false,\n        toMark: id\n      });\n      return _this;\n    });\n    _defineProperty(this, \"mark\", function () {\n      var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : uniqueId();\n      var onUndo = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var onRedo = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      var mostRecent = _this._undos.value.head;\n      if (mostRecent && mostRecent.type === \"STOP\") {\n        if (mostRecent.id === id && mostRecent.onUndo === onUndo && mostRecent.onRedo === onRedo) {\n          return mostRecent.id;\n        }\n      }\n      _this._undos.update(function (undos) {\n        return undos.push({\n          type: \"STOP\",\n          id: id,\n          onUndo: onUndo,\n          onRedo: onRedo\n        });\n      });\n      _this.ctx.emit(\"mark-history\", {\n        id: id\n      });\n      return id;\n    });\n    this.ctx = ctx;\n    this.onBatchComplete = onBatchComplete;\n    this.annotateError = annotateError;\n  }\n  _createClass(HistoryManager, [{\n    key: \"numUndos\",\n    get: function get() {\n      return this._undos.value.length;\n    }\n  }, {\n    key: \"numRedos\",\n    get: function get() {\n      return this._redos.value.length;\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this._undos.set(stack());\n      this._redos.set(stack());\n    }\n  }]);\n  return HistoryManager;\n}();\nexport { HistoryManager };","map":{"version":3,"names":["devFreeze","atom","transact","uniqueId","stack","HistoryManager","ctx","onBatchComplete","annotateError","_this","_classCallCheck","_defineProperty","name","constructor","handle","_commands","Error","concat","exec","_len","arguments","length","args","Array","_key","_batchDepth","batch","apply","result","data","ephemeral","squashing","preservesRedoStack","ignoringUpdates","undos","redos","do","prev","_undos","value","head","type","update","tail","push","_objectSpread","id","squash","_redos","set","emit","reason","fn","_this$_undos$value$he","_this$_undos$value$he2","mostRecentActionId","error","_transact","_ref","pushToRedoStack","_ref$toMark","toMark","_undos$head","mark","markId","command","onUndo","handler","undo","_undo","_redos$head","onRedo","redo","undefined","mostRecent","_createClass","key","get","clear"],"sources":["/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@tldraw/editor/src/lib/editor/managers/HistoryManager.ts"],"sourcesContent":["import { devFreeze } from '@tldraw/store'\nimport { atom, transact } from 'signia'\nimport { uniqueId } from '../../utils/data'\nimport { TLCommandHandler, TLHistoryEntry } from '../types/history-types'\nimport { Stack, stack } from './Stack'\n\ntype CommandFn<Data> = (...args: any[]) =>\n\t| {\n\t\t\tdata: Data\n\t\t\tsquashing?: boolean\n\t\t\tephemeral?: boolean\n\t\t\tpreservesRedoStack?: boolean\n\t  }\n\t| null\n\t| undefined\n\t| void\n\ntype ExtractData<Fn> = Fn extends CommandFn<infer Data> ? Data : never\ntype ExtractArgs<Fn> = Parameters<Extract<Fn, (...args: any[]) => any>>\n\nexport class HistoryManager<\n\tCTX extends {\n\t\temit: (name: 'change-history' | 'mark-history', ...args: any) => void\n\t}\n> {\n\t_undos = atom<Stack<TLHistoryEntry>>('HistoryManager.undos', stack()) // Updated by each action that includes and undo\n\t_redos = atom<Stack<TLHistoryEntry>>('HistoryManager.redos', stack()) // Updated when a user undoes\n\t_batchDepth = 0 // A flag for whether the user is in a batch operation\n\n\tconstructor(\n\t\tprivate readonly ctx: CTX,\n\t\tprivate readonly onBatchComplete: () => void,\n\t\tprivate readonly annotateError: (error: unknown) => void\n\t) {}\n\n\tprivate _commands: Record<string, TLCommandHandler<any>> = {}\n\n\tget numUndos() {\n\t\treturn this._undos.value.length\n\t}\n\n\tget numRedos() {\n\t\treturn this._redos.value.length\n\t}\n\n\tcreateCommand = <Name extends string, Constructor extends CommandFn<any>>(\n\t\tname: Name,\n\t\tconstructor: Constructor,\n\t\thandle: TLCommandHandler<ExtractData<Constructor>>\n\t) => {\n\t\tif (this._commands[name]) {\n\t\t\tthrow new Error(`Duplicate command: ${name}`)\n\t\t}\n\t\tthis._commands[name] = handle\n\n\t\tconst exec = (...args: ExtractArgs<Constructor>) => {\n\t\t\tif (!this._batchDepth) {\n\t\t\t\t// If we're not batching, run again in a batch\n\t\t\t\tthis.batch(() => exec(...args))\n\t\t\t\treturn this.ctx\n\t\t\t}\n\n\t\t\tconst result = constructor(...args)\n\n\t\t\tif (!result) {\n\t\t\t\treturn this.ctx\n\t\t\t}\n\n\t\t\tconst { data, ephemeral, squashing, preservesRedoStack } = result\n\n\t\t\tthis.ignoringUpdates((undos, redos) => {\n\t\t\t\thandle.do(data)\n\t\t\t\treturn { undos, redos }\n\t\t\t})\n\n\t\t\tif (!ephemeral) {\n\t\t\t\tconst prev = this._undos.value.head\n\t\t\t\tif (\n\t\t\t\t\tsquashing &&\n\t\t\t\t\tprev &&\n\t\t\t\t\tprev.type === 'command' &&\n\t\t\t\t\tprev.name === name &&\n\t\t\t\t\tprev.preservesRedoStack === preservesRedoStack\n\t\t\t\t) {\n\t\t\t\t\t// replace the last command with a squashed version\n\t\t\t\t\tthis._undos.update((undos) =>\n\t\t\t\t\t\tundos.tail.push({\n\t\t\t\t\t\t\t...prev,\n\t\t\t\t\t\t\tid: uniqueId(),\n\t\t\t\t\t\t\tdata: devFreeze(handle.squash!(prev.data, data)),\n\t\t\t\t\t\t})\n\t\t\t\t\t)\n\t\t\t\t} else {\n\t\t\t\t\t// add to the undo stack\n\t\t\t\t\tthis._undos.update((undos) =>\n\t\t\t\t\t\tundos.push({\n\t\t\t\t\t\t\ttype: 'command',\n\t\t\t\t\t\t\tname,\n\t\t\t\t\t\t\tdata: devFreeze(data),\n\t\t\t\t\t\t\tid: uniqueId(),\n\t\t\t\t\t\t\tpreservesRedoStack: preservesRedoStack,\n\t\t\t\t\t\t})\n\t\t\t\t\t)\n\t\t\t\t}\n\n\t\t\t\tif (!result.preservesRedoStack) {\n\t\t\t\t\tthis._redos.set(stack())\n\t\t\t\t}\n\n\t\t\t\tthis.ctx.emit('change-history', { reason: 'push' })\n\t\t\t}\n\n\t\t\treturn this.ctx\n\t\t}\n\n\t\treturn exec\n\t}\n\n\tbatch = (fn: () => void) => {\n\t\ttry {\n\t\t\tthis._batchDepth++\n\t\t\tif (this._batchDepth === 1) {\n\t\t\t\ttransact(() => {\n\t\t\t\t\tconst mostRecentActionId = this._undos.value.head?.id\n\t\t\t\t\tfn()\n\t\t\t\t\tif (mostRecentActionId !== this._undos.value.head?.id) {\n\t\t\t\t\t\tthis.onBatchComplete()\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t} else {\n\t\t\t\tfn()\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tthis.annotateError(error)\n\t\t\tthrow error\n\t\t} finally {\n\t\t\tthis._batchDepth--\n\t\t}\n\n\t\treturn this\n\t}\n\n\tprivate ignoringUpdates = (\n\t\tfn: (\n\t\t\tundos: Stack<TLHistoryEntry>,\n\t\t\tredos: Stack<TLHistoryEntry>\n\t\t) => { undos: Stack<TLHistoryEntry>; redos: Stack<TLHistoryEntry> }\n\t) => {\n\t\tlet undos = this._undos.value\n\t\tlet redos = this._redos.value\n\n\t\tthis._undos.set(stack())\n\t\tthis._redos.set(stack())\n\t\ttry {\n\t\t\t;({ undos, redos } = transact(() => fn(undos, redos)))\n\t\t} finally {\n\t\t\tthis._undos.set(undos)\n\t\t\tthis._redos.set(redos)\n\t\t}\n\t}\n\n\t// History\n\tprivate _undo = ({\n\t\tpushToRedoStack,\n\t\ttoMark = undefined,\n\t}: {\n\t\tpushToRedoStack: boolean\n\t\ttoMark?: string\n\t}) => {\n\t\tthis.ignoringUpdates((undos, redos) => {\n\t\t\tif (undos.length === 0) {\n\t\t\t\treturn { undos, redos }\n\t\t\t}\n\n\t\t\twhile (undos.head?.type === 'STOP') {\n\t\t\t\tconst mark = undos.head\n\t\t\t\tundos = undos.tail\n\t\t\t\tif (pushToRedoStack) {\n\t\t\t\t\tredos = redos.push(mark)\n\t\t\t\t}\n\t\t\t\tif (mark.id === toMark) {\n\t\t\t\t\tthis.ctx.emit(\n\t\t\t\t\t\t'change-history',\n\t\t\t\t\t\tpushToRedoStack ? { reason: 'undo' } : { reason: 'bail', markId: toMark }\n\t\t\t\t\t)\n\t\t\t\t\treturn { undos, redos }\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (undos.length === 0) {\n\t\t\t\tthis.ctx.emit(\n\t\t\t\t\t'change-history',\n\t\t\t\t\tpushToRedoStack ? { reason: 'undo' } : { reason: 'bail', markId: toMark }\n\t\t\t\t)\n\t\t\t\treturn { undos, redos }\n\t\t\t}\n\n\t\t\twhile (undos.head) {\n\t\t\t\tconst command = undos.head\n\t\t\t\tundos = undos.tail\n\n\t\t\t\tif (pushToRedoStack) {\n\t\t\t\t\tredos = redos.push(command)\n\t\t\t\t}\n\n\t\t\t\tif (command.type === 'STOP') {\n\t\t\t\t\tif (command.onUndo && (!toMark || command.id === toMark)) {\n\t\t\t\t\t\tthis.ctx.emit(\n\t\t\t\t\t\t\t'change-history',\n\t\t\t\t\t\t\tpushToRedoStack ? { reason: 'undo' } : { reason: 'bail', markId: toMark }\n\t\t\t\t\t\t)\n\t\t\t\t\t\treturn { undos, redos }\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tconst handler = this._commands[command.name]\n\t\t\t\t\thandler.undo(command.data)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.ctx.emit(\n\t\t\t\t'change-history',\n\t\t\t\tpushToRedoStack ? { reason: 'undo' } : { reason: 'bail', markId: toMark }\n\t\t\t)\n\t\t\treturn { undos, redos }\n\t\t})\n\n\t\treturn this\n\t}\n\n\tundo = () => {\n\t\tthis._undo({ pushToRedoStack: true })\n\n\t\treturn this\n\t}\n\n\tredo = () => {\n\t\tthis.ignoringUpdates((undos, redos) => {\n\t\t\tif (redos.length === 0) {\n\t\t\t\treturn { undos, redos }\n\t\t\t}\n\n\t\t\twhile (redos.head?.type === 'STOP') {\n\t\t\t\tundos = undos.push(redos.head)\n\t\t\t\tredos = redos.tail\n\t\t\t}\n\n\t\t\tif (redos.length === 0) {\n\t\t\t\tthis.ctx.emit('change-history', { reason: 'redo' })\n\t\t\t\treturn { undos, redos }\n\t\t\t}\n\n\t\t\twhile (redos.head) {\n\t\t\t\tconst command = redos.head\n\t\t\t\tundos = undos.push(redos.head)\n\t\t\t\tredos = redos.tail\n\n\t\t\t\tif (command.type === 'STOP') {\n\t\t\t\t\tif (command.onRedo) {\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tconst handler = this._commands[command.name]\n\t\t\t\t\tif (handler.redo) {\n\t\t\t\t\t\thandler.redo(command.data)\n\t\t\t\t\t} else {\n\t\t\t\t\t\thandler.do(command.data)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.ctx.emit('change-history', { reason: 'redo' })\n\t\t\treturn { undos, redos }\n\t\t})\n\n\t\treturn this\n\t}\n\n\tbail = () => {\n\t\tthis._undo({ pushToRedoStack: false })\n\n\t\treturn this\n\t}\n\n\tbailToMark = (id: string) => {\n\t\tthis._undo({ pushToRedoStack: false, toMark: id })\n\n\t\treturn this\n\t}\n\n\tmark = (id = uniqueId(), onUndo = true, onRedo = true) => {\n\t\tconst mostRecent = this._undos.value.head\n\t\t// dedupe marks, why not\n\t\tif (mostRecent && mostRecent.type === 'STOP') {\n\t\t\tif (mostRecent.id === id && mostRecent.onUndo === onUndo && mostRecent.onRedo === onRedo) {\n\t\t\t\treturn mostRecent.id\n\t\t\t}\n\t\t}\n\n\t\tthis._undos.update((undos) => undos.push({ type: 'STOP', id, onUndo, onRedo }))\n\n\t\tthis.ctx.emit('mark-history', { id })\n\n\t\treturn id\n\t}\n\n\tclear() {\n\t\tthis._undos.set(stack())\n\t\tthis._redos.set(stack())\n\t}\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}