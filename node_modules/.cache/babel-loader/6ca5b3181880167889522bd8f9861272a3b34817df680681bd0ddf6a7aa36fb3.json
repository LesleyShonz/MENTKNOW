{"ast":null,"code":"import _toConsumableArray from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport { Vec2d } from \"../Vec2d.mjs\";\nvar MIN_START_PRESSURE = 0.025;\nvar MIN_END_PRESSURE = 0.01;\nfunction getStrokePoints(rawInputPoints) {\n  var _strokePoints$;\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var _options$streamline = options.streamline,\n    streamline = _options$streamline === void 0 ? 0.5 : _options$streamline,\n    _options$size = options.size,\n    size = _options$size === void 0 ? 16 : _options$size,\n    _options$simulatePres = options.simulatePressure,\n    simulatePressure = _options$simulatePres === void 0 ? false : _options$simulatePres;\n  if (rawInputPoints.length === 0) return [];\n  var t = 0.15 + (1 - streamline) * 0.85;\n  var pts = rawInputPoints.map(Vec2d.From);\n  var pointsRemovedFromNearEnd = 0;\n  if (!simulatePressure) {\n    var pt2 = pts[0];\n    while (pt2) {\n      if (pt2.z >= MIN_START_PRESSURE) break;\n      pts.shift();\n      pt2 = pts[0];\n    }\n  }\n  if (!simulatePressure) {\n    var _pt = pts[pts.length - 1];\n    while (_pt) {\n      if (_pt.z >= MIN_END_PRESSURE) break;\n      pts.pop();\n      _pt = pts[pts.length - 1];\n    }\n  }\n  if (pts.length === 0) return [{\n    point: Vec2d.From(rawInputPoints[0]),\n    input: Vec2d.From(rawInputPoints[0]),\n    pressure: simulatePressure ? 0.5 : 0.15,\n    vector: new Vec2d(1, 1),\n    distance: 0,\n    runningLength: 0,\n    radius: 1\n  }];\n  var pt = pts[1];\n  while (pt) {\n    if (Vec2d.Dist(pt, pts[0]) > size / 3) break;\n    pts[0].z = Math.max(pts[0].z, pt.z);\n    pts.splice(1, 1);\n    pt = pts[1];\n  }\n  var last = pts.pop();\n  pt = pts[pts.length - 1];\n  while (pt) {\n    if (Vec2d.Dist(pt, last) > size / 3) break;\n    pts.pop();\n    pt = pts[pts.length - 1];\n    pointsRemovedFromNearEnd++;\n  }\n  pts.push(last);\n  var isComplete = options.last || !options.simulatePressure || pts.length > 1 && Vec2d.Dist(pts[pts.length - 1], pts[pts.length - 2]) < size || pointsRemovedFromNearEnd > 0;\n  if (pts.length === 2 && options.simulatePressure) {\n    var last2 = pts[1];\n    pts = pts.slice(0, -1);\n    for (var i = 1; i < 5; i++) {\n      var next = Vec2d.Lrp(pts[0], last2, i / 4);\n      next.z = (pts[0].z + (last2.z - pts[0].z)) * i / 4;\n      pts.push(next);\n    }\n  }\n  var strokePoints = [{\n    point: pts[0],\n    input: pts[0],\n    pressure: simulatePressure ? 0.5 : pts[0].z,\n    vector: new Vec2d(1, 1),\n    distance: 0,\n    runningLength: 0,\n    radius: 1\n  }];\n  var totalLength = 0;\n  var prev = strokePoints[0];\n  var point, distance;\n  if (isComplete && streamline > 0) {\n    pts.push(pts[pts.length - 1].clone());\n  }\n  for (var _i = 1, n = pts.length; _i < n; _i++) {\n    point = !t || options.last && _i === n - 1 ? pts[_i].clone() : pts[_i].clone().lrp(prev.point, 1 - t);\n    if (prev.point.equals(point)) continue;\n    distance = Vec2d.Dist(point, prev.point);\n    totalLength += distance;\n    if (_i < 4 && totalLength < size) {\n      continue;\n    }\n    prev = {\n      input: pts[_i],\n      // The adjusted point\n      point: point,\n      // The input pressure (or .5 if not specified)\n      pressure: simulatePressure ? 0.5 : pts[_i].z,\n      // The vector from the current point to the previous point\n      vector: Vec2d.Sub(prev.point, point).uni(),\n      // The distance between the current point and the previous point\n      distance: distance,\n      // The total distance so far\n      runningLength: totalLength,\n      // The stroke point's radius\n      radius: 1\n    };\n    strokePoints.push(prev);\n  }\n  if ((_strokePoints$ = strokePoints[1]) !== null && _strokePoints$ !== void 0 && _strokePoints$.vector) {\n    strokePoints[0].vector = strokePoints[1].vector.clone();\n  }\n  if (totalLength < 1) {\n    var maxPressureAmongPoints = Math.max.apply(Math, [0.5].concat(_toConsumableArray(strokePoints.map(function (s) {\n      return s.pressure;\n    }))));\n    strokePoints.forEach(function (s) {\n      return s.pressure = maxPressureAmongPoints;\n    });\n  }\n  return strokePoints;\n}\nexport { getStrokePoints };","map":{"version":3,"names":["Vec2d","MIN_START_PRESSURE","MIN_END_PRESSURE","getStrokePoints","rawInputPoints","_strokePoints$","options","arguments","length","undefined","_options$streamline","streamline","_options$size","size","_options$simulatePres","simulatePressure","t","pts","map","From","pointsRemovedFromNearEnd","pt2","z","shift","pop","point","input","pressure","vector","distance","runningLength","radius","pt","Dist","Math","max","splice","last","push","isComplete","last2","slice","i","next","Lrp","strokePoints","totalLength","prev","clone","n","lrp","equals","Sub","uni","maxPressureAmongPoints","apply","concat","_toConsumableArray","s","forEach"],"sources":["/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@tldraw/primitives/src/lib/freehand/getStrokePoints.ts"],"sourcesContent":["import { Vec2d, VecLike } from '../Vec2d'\nimport type { StrokeOptions, StrokePoint } from './types'\n\nconst MIN_START_PRESSURE = 0.025\nconst MIN_END_PRESSURE = 0.01\n\n/**\n * ## getStrokePoints\n *\n * Get an array of points as objects with an adjusted point, pressure, vector, distance, and\n * runningLength.\n *\n * @param points - An array of points (as `[x, y, pressure]` or `{x, y, pressure}`). Pressure is\n *   optional in both cases.\n * @param options - An object with options.\n * @public\n */\nexport function getStrokePoints(\n\trawInputPoints: VecLike[],\n\toptions: StrokeOptions = {}\n): StrokePoint[] {\n\tconst { streamline = 0.5, size = 16, simulatePressure = false } = options\n\n\t// If we don't have any points, return an empty array.\n\tif (rawInputPoints.length === 0) return []\n\n\t// Find the interpolation level between points.\n\tconst t = 0.15 + (1 - streamline) * 0.85\n\n\t// Whatever the input is, make sure that the points are in number[][].\n\tlet pts = rawInputPoints.map(Vec2d.From)\n\n\tlet pointsRemovedFromNearEnd = 0\n\n\tif (!simulatePressure) {\n\t\t// Strip low pressure points from the start of the array.\n\t\tlet pt = pts[0]\n\t\twhile (pt) {\n\t\t\tif (pt.z >= MIN_START_PRESSURE) break\n\t\t\tpts.shift()\n\t\t\tpt = pts[0]\n\t\t}\n\t}\n\n\tif (!simulatePressure) {\n\t\t// Strip low pressure points from the end of the array.\n\t\tlet pt = pts[pts.length - 1]\n\t\twhile (pt) {\n\t\t\tif (pt.z >= MIN_END_PRESSURE) break\n\t\t\tpts.pop()\n\t\t\tpt = pts[pts.length - 1]\n\t\t}\n\t}\n\n\tif (pts.length === 0)\n\t\treturn [\n\t\t\t{\n\t\t\t\tpoint: Vec2d.From(rawInputPoints[0]),\n\t\t\t\tinput: Vec2d.From(rawInputPoints[0]),\n\t\t\t\tpressure: simulatePressure ? 0.5 : 0.15,\n\t\t\t\tvector: new Vec2d(1, 1),\n\t\t\t\tdistance: 0,\n\t\t\t\trunningLength: 0,\n\t\t\t\tradius: 1,\n\t\t\t},\n\t\t]\n\n\t// Strip points that are too close to the first point.\n\tlet pt = pts[1]\n\twhile (pt) {\n\t\tif (Vec2d.Dist(pt, pts[0]) > size / 3) break\n\t\tpts[0].z = Math.max(pts[0].z, pt.z) // Use maximum pressure\n\t\tpts.splice(1, 1)\n\t\tpt = pts[1]\n\t}\n\n\t// Strip points that are too close to the last point.\n\tconst last = pts.pop()!\n\tpt = pts[pts.length - 1]\n\twhile (pt) {\n\t\tif (Vec2d.Dist(pt, last) > size / 3) break\n\t\tpts.pop()\n\t\tpt = pts[pts.length - 1]\n\t\tpointsRemovedFromNearEnd++\n\t}\n\tpts.push(last)\n\n\tconst isComplete =\n\t\toptions.last ||\n\t\t!options.simulatePressure ||\n\t\t(pts.length > 1 && Vec2d.Dist(pts[pts.length - 1], pts[pts.length - 2]) < size) ||\n\t\tpointsRemovedFromNearEnd > 0\n\n\t// Add extra points between the two, to help avoid \"dash\" lines\n\t// for strokes with tapered start and ends. Don't mutate the\n\t// input array!\n\tif (pts.length === 2 && options.simulatePressure) {\n\t\tconst last = pts[1]\n\t\tpts = pts.slice(0, -1)\n\t\tfor (let i = 1; i < 5; i++) {\n\t\t\tconst next = Vec2d.Lrp(pts[0], last, i / 4)\n\t\t\tnext.z = ((pts[0].z + (last.z - pts[0].z)) * i) / 4\n\t\t\tpts.push(next)\n\t\t}\n\t}\n\n\t// The strokePoints array will hold the points for the stroke.\n\t// Start it out with the first point, which needs no adjustment.\n\tconst strokePoints: StrokePoint[] = [\n\t\t{\n\t\t\tpoint: pts[0],\n\t\t\tinput: pts[0],\n\t\t\tpressure: simulatePressure ? 0.5 : pts[0].z,\n\t\t\tvector: new Vec2d(1, 1),\n\t\t\tdistance: 0,\n\t\t\trunningLength: 0,\n\t\t\tradius: 1,\n\t\t},\n\t]\n\n\t// We use the totalLength to keep track of the total distance\n\tlet totalLength = 0\n\n\t// We're set this to the latest point, so we can use it to calculate\n\t// the distance and vector of the next point.\n\tlet prev = strokePoints[0]\n\n\t// Iterate through all of the points, creating StrokePoints.\n\tlet point: Vec2d, distance: number\n\n\tif (isComplete && streamline > 0) {\n\t\tpts.push(pts[pts.length - 1].clone())\n\t}\n\n\tfor (let i = 1, n = pts.length; i < n; i++) {\n\t\tpoint =\n\t\t\t!t || (options.last && i === n - 1) ? pts[i].clone() : pts[i].clone().lrp(prev.point, 1 - t)\n\n\t\t// If the new point is the same as the previous point, skip ahead.\n\t\tif (prev.point.equals(point)) continue\n\n\t\t// How far is the new point from the previous point?\n\t\tdistance = Vec2d.Dist(point, prev.point)\n\n\t\t// Add this distance to the total \"running length\" of the line.\n\t\ttotalLength += distance\n\n\t\t// At the start of the line, we wait until the new point is a\n\t\t// certain distance away from the original point, to avoid noise\n\n\t\tif (i < 4 && totalLength < size) {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Create a new strokepoint (it will be the new \"previous\" one).\n\t\tprev = {\n\t\t\tinput: pts[i],\n\t\t\t// The adjusted point\n\t\t\tpoint,\n\t\t\t// The input pressure (or .5 if not specified)\n\t\t\tpressure: simulatePressure ? 0.5 : pts[i].z,\n\t\t\t// The vector from the current point to the previous point\n\t\t\tvector: Vec2d.Sub(prev.point, point).uni(),\n\t\t\t// The distance between the current point and the previous point\n\t\t\tdistance,\n\t\t\t// The total distance so far\n\t\t\trunningLength: totalLength,\n\t\t\t// The stroke point's radius\n\t\t\tradius: 1,\n\t\t}\n\n\t\t// Push it to the strokePoints array.\n\t\tstrokePoints.push(prev)\n\t}\n\n\t// Set the vector of the first point to be the same as the second point.\n\tif (strokePoints[1]?.vector) {\n\t\tstrokePoints[0].vector = strokePoints[1].vector.clone()\n\t}\n\n\tif (totalLength < 1) {\n\t\tconst maxPressureAmongPoints = Math.max(0.5, ...strokePoints.map((s) => s.pressure))\n\t\tstrokePoints.forEach((s) => (s.pressure = maxPressureAmongPoints))\n\t}\n\n\treturn strokePoints\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}