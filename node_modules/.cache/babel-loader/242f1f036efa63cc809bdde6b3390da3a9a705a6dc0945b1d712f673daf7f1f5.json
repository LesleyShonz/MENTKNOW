{"ast":null,"code":"import { toDomPrecision } from \"@tldraw/primitives\";\nfunction getPointerInfo(e, container) {\n  ;\n  e.isKilled = true;\n  var _container$getBoundin = container.getBoundingClientRect(),\n    top = _container$getBoundin.top,\n    left = _container$getBoundin.left;\n  return {\n    point: {\n      x: e.clientX - left,\n      y: e.clientY - top,\n      z: e.pressure\n    },\n    shiftKey: e.shiftKey,\n    altKey: e.altKey,\n    ctrlKey: e.metaKey || e.ctrlKey,\n    pointerId: e.pointerId,\n    button: e.button,\n    isPen: e.pointerType === \"pen\"\n  };\n}\nfunction precise(A) {\n  return \"\".concat(toDomPrecision(A.x), \",\").concat(toDomPrecision(A.y), \" \");\n}\nfunction average(A, B) {\n  return \"\".concat(toDomPrecision((A.x + B.x) / 2), \",\").concat(toDomPrecision((A.y + B.y) / 2), \" \");\n}\nfunction getSvgPathFromStroke(points) {\n  var closed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  var len = points.length;\n  if (len < 2) {\n    return \"\";\n  }\n  var a = points[0];\n  var b = points[1];\n  if (len === 2) {\n    return \"M\".concat(precise(a), \"L\").concat(precise(b));\n  }\n  var result = \"\";\n  for (var i = 2, max = len - 1; i < max; i++) {\n    a = points[i];\n    b = points[i + 1];\n    result += average(a, b);\n  }\n  if (closed) {\n    return \"M\".concat(average(points[0], points[1]), \"Q\").concat(precise(points[1])).concat(average(points[1], points[2]), \"T\").concat(result).concat(average(points[len - 1], points[0])).concat(average(points[0], points[1]), \"Z\");\n  } else {\n    return \"M\".concat(precise(points[0]), \"Q\").concat(precise(points[1])).concat(average(points[1], points[2])).concat(points.length > 3 ? \"T\" : \"\").concat(result, \"L\").concat(precise(points[len - 1]));\n  }\n}\nfunction getSvgPathFromStrokePoints(points) {\n  var closed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var len = points.length;\n  if (len < 2) {\n    return \"\";\n  }\n  var a = points[0].point;\n  var b = points[1].point;\n  if (len === 2) {\n    return \"M\".concat(precise(a), \"L\").concat(precise(b));\n  }\n  var result = \"\";\n  for (var i = 2, max = len - 1; i < max; i++) {\n    a = points[i].point;\n    b = points[i + 1].point;\n    result += average(a, b);\n  }\n  if (closed) {\n    return \"M\".concat(average(points[0].point, points[1].point), \"Q\").concat(precise(points[1].point)).concat(average(points[1].point, points[2].point), \"T\").concat(result).concat(average(points[len - 1].point, points[0].point)).concat(average(points[0].point, points[1].point), \"Z\");\n  } else {\n    return \"M\".concat(precise(points[0].point), \"Q\").concat(precise(points[1].point)).concat(average(points[1].point, points[2].point)).concat(points.length > 3 ? \"T\" : \"\").concat(result, \"L\").concat(precise(points[len - 1].point));\n  }\n}\nexport { getPointerInfo, getSvgPathFromStroke, getSvgPathFromStrokePoints };","map":{"version":3,"names":["toDomPrecision","getPointerInfo","e","container","isKilled","_container$getBoundin","getBoundingClientRect","top","left","point","x","clientX","y","clientY","z","pressure","shiftKey","altKey","ctrlKey","metaKey","pointerId","button","isPen","pointerType","precise","A","concat","average","B","getSvgPathFromStroke","points","closed","arguments","length","undefined","len","a","b","result","i","max","getSvgPathFromStrokePoints"],"sources":["/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@tldraw/editor/src/lib/utils/svg.ts"],"sourcesContent":["import { StrokePoint, toDomPrecision, Vec2d, VecLike } from '@tldraw/primitives'\n\n/** @internal */\nexport function getPointerInfo(e: React.PointerEvent | PointerEvent, container: HTMLElement) {\n\t;(e as any).isKilled = true\n\n\tconst { top, left } = container.getBoundingClientRect()\n\n\treturn {\n\t\tpoint: {\n\t\t\tx: e.clientX - left,\n\t\t\ty: e.clientY - top,\n\t\t\tz: e.pressure,\n\t\t},\n\t\tshiftKey: e.shiftKey,\n\t\taltKey: e.altKey,\n\t\tctrlKey: e.metaKey || e.ctrlKey,\n\t\tpointerId: e.pointerId,\n\t\tbutton: e.button,\n\t\tisPen: e.pointerType === 'pen',\n\t}\n}\n\nfunction precise(A: VecLike) {\n\treturn `${toDomPrecision(A.x)},${toDomPrecision(A.y)} `\n}\n\nfunction average(A: VecLike, B: VecLike) {\n\treturn `${toDomPrecision((A.x + B.x) / 2)},${toDomPrecision((A.y + B.y) / 2)} `\n}\n\n/**\n * Turn an array of points into a path of quadradic curves.\n *\n * @param points - The points returned from perfect-freehand\n * @param closed - Whether the stroke is closed\n * @public\n */\nexport function getSvgPathFromStroke(points: Vec2d[], closed = true): string {\n\tconst len = points.length\n\n\tif (len < 2) {\n\t\treturn ''\n\t}\n\n\tlet a = points[0]\n\tlet b = points[1]\n\n\tif (len === 2) {\n\t\t// If only two points, just draw a line\n\t\treturn `M${precise(a)}L${precise(b)}`\n\t}\n\n\tlet result = ''\n\n\tfor (let i = 2, max = len - 1; i < max; i++) {\n\t\ta = points[i]\n\t\tb = points[i + 1]\n\t\tresult += average(a, b)\n\t}\n\n\tif (closed) {\n\t\t// If closed, draw a curve from the last point to the first\n\t\treturn `M${average(points[0], points[1])}Q${precise(points[1])}${average(\n\t\t\tpoints[1],\n\t\t\tpoints[2]\n\t\t)}T${result}${average(points[len - 1], points[0])}${average(points[0], points[1])}Z`\n\t} else {\n\t\t// If not closed, draw a curve starting at the first point and\n\t\t// ending at the midpoint of the last and second-last point, then\n\t\t// complete the curve with a line segment to the last point.\n\t\treturn `M${precise(points[0])}Q${precise(points[1])}${average(points[1], points[2])}${\n\t\t\tpoints.length > 3 ? 'T' : ''\n\t\t}${result}L${precise(points[len - 1])}`\n\t}\n}\n\n/**\n * Turn an array of stroke points into a path of quadradic curves.\n *\n * @param points - The stroke points returned from perfect-freehand\n * @param closed - Whether the shape is closed\n * @public\n */\nexport function getSvgPathFromStrokePoints(points: StrokePoint[], closed = false): string {\n\tconst len = points.length\n\n\tif (len < 2) {\n\t\treturn ''\n\t}\n\n\tlet a = points[0].point\n\tlet b = points[1].point\n\n\tif (len === 2) {\n\t\treturn `M${precise(a)}L${precise(b)}`\n\t}\n\n\tlet result = ''\n\n\tfor (let i = 2, max = len - 1; i < max; i++) {\n\t\ta = points[i].point\n\t\tb = points[i + 1].point\n\t\tresult += average(a, b)\n\t}\n\n\tif (closed) {\n\t\t// If closed, draw a curve from the last point to the first\n\t\treturn `M${average(points[0].point, points[1].point)}Q${precise(points[1].point)}${average(\n\t\t\tpoints[1].point,\n\t\t\tpoints[2].point\n\t\t)}T${result}${average(points[len - 1].point, points[0].point)}${average(\n\t\t\tpoints[0].point,\n\t\t\tpoints[1].point\n\t\t)}Z`\n\t} else {\n\t\t// If not closed, draw a curve starting at the first point and\n\t\t// ending at the midpoint of the last and second-last point, then\n\t\t// complete the curve with a line segment to the last point.\n\t\treturn `M${precise(points[0].point)}Q${precise(points[1].point)}${average(\n\t\t\tpoints[1].point,\n\t\t\tpoints[2].point\n\t\t)}${points.length > 3 ? 'T' : ''}${result}L${precise(points[len - 1].point)}`\n\t}\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}