{"ast":null,"code":"import _inherits from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _createClass from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\n/**\n * Efficient schema-less binary encoding with support for variable length encoding.\n *\n * Use [lib0/encoding] with [lib0/decoding]. Every encoding function has a corresponding decoding function.\n *\n * Encodes numbers in little-endian order (least to most significant byte order)\n * and is compatible with Golang's binary encoding (https://golang.org/pkg/encoding/binary/)\n * which is also used in Protocol Buffers.\n *\n * ```js\n * // encoding step\n * const encoder = encoding.createEncoder()\n * encoding.writeVarUint(encoder, 256)\n * encoding.writeVarString(encoder, 'Hello world!')\n * const buf = encoding.toUint8Array(encoder)\n * ```\n *\n * ```js\n * // decoding step\n * const decoder = decoding.createDecoder(buf)\n * decoding.readVarUint(decoder) // => 256\n * decoding.readVarString(decoder) // => 'Hello world!'\n * decoding.hasContent(decoder) // => false - all data is read\n * ```\n *\n * @module encoding\n */\n\nimport * as buffer from './buffer.js';\nimport * as math from './math.js';\nimport * as number from './number.js';\nimport * as binary from './binary.js';\nimport * as string from './string.js';\nimport * as array from './array.js';\n\n/**\n * A BinaryEncoder handles the encoding to an Uint8Array.\n */\nexport var Encoder = /*#__PURE__*/_createClass(function Encoder() {\n  _classCallCheck(this, Encoder);\n  this.cpos = 0;\n  this.cbuf = new Uint8Array(100);\n  /**\n   * @type {Array<Uint8Array>}\n   */\n  this.bufs = [];\n});\n\n/**\n * @function\n * @return {Encoder}\n */\nexport var createEncoder = function createEncoder() {\n  return new Encoder();\n};\n\n/**\n * @param {function(Encoder):void} f\n */\nexport var encode = function encode(f) {\n  var encoder = createEncoder();\n  f(encoder);\n  return _toUint8Array(encoder);\n};\n\n/**\n * The current length of the encoded data.\n *\n * @function\n * @param {Encoder} encoder\n * @return {number}\n */\nexport var length = function length(encoder) {\n  var len = encoder.cpos;\n  for (var i = 0; i < encoder.bufs.length; i++) {\n    len += encoder.bufs[i].length;\n  }\n  return len;\n};\n\n/**\n * Check whether encoder is empty.\n *\n * @function\n * @param {Encoder} encoder\n * @return {boolean}\n */\nexport var hasContent = function hasContent(encoder) {\n  return encoder.cpos > 0 || encoder.bufs.length > 0;\n};\n\n/**\n * Transform to Uint8Array.\n *\n * @function\n * @param {Encoder} encoder\n * @return {Uint8Array} The created ArrayBuffer.\n */\nvar _toUint8Array = function toUint8Array(encoder) {\n  var uint8arr = new Uint8Array(length(encoder));\n  var curPos = 0;\n  for (var i = 0; i < encoder.bufs.length; i++) {\n    var d = encoder.bufs[i];\n    uint8arr.set(d, curPos);\n    curPos += d.length;\n  }\n  uint8arr.set(buffer.createUint8ArrayViewFromArrayBuffer(encoder.cbuf.buffer, 0, encoder.cpos), curPos);\n  return uint8arr;\n};\n\n/**\n * Verify that it is possible to write `len` bytes wtihout checking. If\n * necessary, a new Buffer with the required length is attached.\n *\n * @param {Encoder} encoder\n * @param {number} len\n */\nexport { _toUint8Array as toUint8Array };\nexport var verifyLen = function verifyLen(encoder, len) {\n  var bufferLen = encoder.cbuf.length;\n  if (bufferLen - encoder.cpos < len) {\n    encoder.bufs.push(buffer.createUint8ArrayViewFromArrayBuffer(encoder.cbuf.buffer, 0, encoder.cpos));\n    encoder.cbuf = new Uint8Array(math.max(bufferLen, len) * 2);\n    encoder.cpos = 0;\n  }\n};\n\n/**\n * Write one byte to the encoder.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The byte that is to be encoded.\n */\nexport var write = function write(encoder, num) {\n  var bufferLen = encoder.cbuf.length;\n  if (encoder.cpos === bufferLen) {\n    encoder.bufs.push(encoder.cbuf);\n    encoder.cbuf = new Uint8Array(bufferLen * 2);\n    encoder.cpos = 0;\n  }\n  encoder.cbuf[encoder.cpos++] = num;\n};\n\n/**\n * Write one byte at a specific position.\n * Position must already be written (i.e. encoder.length > pos)\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} pos Position to which to write data\n * @param {number} num Unsigned 8-bit integer\n */\nexport var set = function set(encoder, pos, num) {\n  var buffer = null;\n  // iterate all buffers and adjust position\n  for (var i = 0; i < encoder.bufs.length && buffer === null; i++) {\n    var b = encoder.bufs[i];\n    if (pos < b.length) {\n      buffer = b; // found buffer\n    } else {\n      pos -= b.length;\n    }\n  }\n  if (buffer === null) {\n    // use current buffer\n    buffer = encoder.cbuf;\n  }\n  buffer[pos] = num;\n};\n\n/**\n * Write one byte as an unsigned integer.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nexport var writeUint8 = write;\n\n/**\n * Write one byte as an unsigned Integer at a specific location.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} pos The location where the data will be written.\n * @param {number} num The number that is to be encoded.\n */\nexport var setUint8 = set;\n\n/**\n * Write two bytes as an unsigned integer.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nexport var writeUint16 = function writeUint16(encoder, num) {\n  write(encoder, num & binary.BITS8);\n  write(encoder, num >>> 8 & binary.BITS8);\n};\n/**\n * Write two bytes as an unsigned integer at a specific location.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} pos The location where the data will be written.\n * @param {number} num The number that is to be encoded.\n */\nexport var setUint16 = function setUint16(encoder, pos, num) {\n  set(encoder, pos, num & binary.BITS8);\n  set(encoder, pos + 1, num >>> 8 & binary.BITS8);\n};\n\n/**\n * Write two bytes as an unsigned integer\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nexport var writeUint32 = function writeUint32(encoder, num) {\n  for (var i = 0; i < 4; i++) {\n    write(encoder, num & binary.BITS8);\n    num >>>= 8;\n  }\n};\n\n/**\n * Write two bytes as an unsigned integer in big endian order.\n * (most significant byte first)\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nexport var writeUint32BigEndian = function writeUint32BigEndian(encoder, num) {\n  for (var i = 3; i >= 0; i--) {\n    write(encoder, num >>> 8 * i & binary.BITS8);\n  }\n};\n\n/**\n * Write two bytes as an unsigned integer at a specific location.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} pos The location where the data will be written.\n * @param {number} num The number that is to be encoded.\n */\nexport var setUint32 = function setUint32(encoder, pos, num) {\n  for (var i = 0; i < 4; i++) {\n    set(encoder, pos + i, num & binary.BITS8);\n    num >>>= 8;\n  }\n};\n\n/**\n * Write a variable length unsigned integer. Max encodable integer is 2^53.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nexport var writeVarUint = function writeVarUint(encoder, num) {\n  while (num > binary.BITS7) {\n    write(encoder, binary.BIT8 | binary.BITS7 & num);\n    num = math.floor(num / 128); // shift >>> 7\n  }\n\n  write(encoder, binary.BITS7 & num);\n};\n\n/**\n * Write a variable length integer.\n *\n * We use the 7th bit instead for signaling that this is a negative number.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nexport var writeVarInt = function writeVarInt(encoder, num) {\n  var isNegative = math.isNegativeZero(num);\n  if (isNegative) {\n    num = -num;\n  }\n  //             |- whether to continue reading         |- whether is negative     |- number\n  write(encoder, (num > binary.BITS6 ? binary.BIT8 : 0) | (isNegative ? binary.BIT7 : 0) | binary.BITS6 & num);\n  num = math.floor(num / 64); // shift >>> 6\n  // We don't need to consider the case of num === 0 so we can use a different\n  // pattern here than above.\n  while (num > 0) {\n    write(encoder, (num > binary.BITS7 ? binary.BIT8 : 0) | binary.BITS7 & num);\n    num = math.floor(num / 128); // shift >>> 7\n  }\n};\n\n/**\n * A cache to store strings temporarily\n */\nvar _strBuffer = new Uint8Array(30000);\nvar _maxStrBSize = _strBuffer.length / 3;\n\n/**\n * Write a variable length string.\n *\n * @function\n * @param {Encoder} encoder\n * @param {String} str The string that is to be encoded.\n */\nexport var _writeVarStringNative = function _writeVarStringNative(encoder, str) {\n  if (str.length < _maxStrBSize) {\n    // We can encode the string into the existing buffer\n    /* c8 ignore next */\n    var written = string.utf8TextEncoder.encodeInto(str, _strBuffer).written || 0;\n    writeVarUint(encoder, written);\n    for (var i = 0; i < written; i++) {\n      write(encoder, _strBuffer[i]);\n    }\n  } else {\n    writeVarUint8Array(encoder, string.encodeUtf8(str));\n  }\n};\n\n/**\n * Write a variable length string.\n *\n * @function\n * @param {Encoder} encoder\n * @param {String} str The string that is to be encoded.\n */\nexport var _writeVarStringPolyfill = function _writeVarStringPolyfill(encoder, str) {\n  var encodedString = unescape(encodeURIComponent(str));\n  var len = encodedString.length;\n  writeVarUint(encoder, len);\n  for (var i = 0; i < len; i++) {\n    write(encoder, /** @type {number} */encodedString.codePointAt(i));\n  }\n};\n\n/**\n * Write a variable length string.\n *\n * @function\n * @param {Encoder} encoder\n * @param {String} str The string that is to be encoded.\n */\n/* c8 ignore next */\nexport var writeVarString = string.utf8TextEncoder && /** @type {any} */string.utf8TextEncoder.encodeInto ? _writeVarStringNative : _writeVarStringPolyfill;\n\n/**\n * Write a string terminated by a special byte sequence. This is not very performant and is\n * generally discouraged. However, the resulting byte arrays are lexiographically ordered which\n * makes this a nice feature for databases.\n *\n * The string will be encoded using utf8 and then terminated and escaped using writeTerminatingUint8Array.\n *\n * @function\n * @param {Encoder} encoder\n * @param {String} str The string that is to be encoded.\n */\nexport var writeTerminatedString = function writeTerminatedString(encoder, str) {\n  return writeTerminatedUint8Array(encoder, string.encodeUtf8(str));\n};\n\n/**\n * Write a terminating Uint8Array. Note that this is not performant and is generally\n * discouraged. There are few situations when this is needed.\n *\n * We use 0x0 as a terminating character. 0x1 serves as an escape character for 0x0 and 0x1.\n *\n * Example: [0,1,2] is encoded to [1,0,1,1,2,0]. 0x0, and 0x1 needed to be escaped using 0x1. Then\n * the result is terminated using the 0x0 character.\n *\n * This is basically how many systems implement null terminated strings. However, we use an escape\n * character 0x1 to avoid issues and potenial attacks on our database (if this is used as a key\n * encoder for NoSql databases).\n *\n * @function\n * @param {Encoder} encoder\n * @param {Uint8Array} buf The string that is to be encoded.\n */\nexport var writeTerminatedUint8Array = function writeTerminatedUint8Array(encoder, buf) {\n  for (var i = 0; i < buf.length; i++) {\n    var b = buf[i];\n    if (b === 0 || b === 1) {\n      write(encoder, 1);\n    }\n    write(encoder, buf[i]);\n  }\n  write(encoder, 0);\n};\n\n/**\n * Write the content of another Encoder.\n *\n * @TODO: can be improved!\n *        - Note: Should consider that when appending a lot of small Encoders, we should rather clone than referencing the old structure.\n *                Encoders start with a rather big initial buffer.\n *\n * @function\n * @param {Encoder} encoder The enUint8Arr\n * @param {Encoder} append The BinaryEncoder to be written.\n */\nexport var writeBinaryEncoder = function writeBinaryEncoder(encoder, append) {\n  return writeUint8Array(encoder, _toUint8Array(append));\n};\n\n/**\n * Append fixed-length Uint8Array to the encoder.\n *\n * @function\n * @param {Encoder} encoder\n * @param {Uint8Array} uint8Array\n */\nexport var writeUint8Array = function writeUint8Array(encoder, uint8Array) {\n  var bufferLen = encoder.cbuf.length;\n  var cpos = encoder.cpos;\n  var leftCopyLen = math.min(bufferLen - cpos, uint8Array.length);\n  var rightCopyLen = uint8Array.length - leftCopyLen;\n  encoder.cbuf.set(uint8Array.subarray(0, leftCopyLen), cpos);\n  encoder.cpos += leftCopyLen;\n  if (rightCopyLen > 0) {\n    // Still something to write, write right half..\n    // Append new buffer\n    encoder.bufs.push(encoder.cbuf);\n    // must have at least size of remaining buffer\n    encoder.cbuf = new Uint8Array(math.max(bufferLen * 2, rightCopyLen));\n    // copy array\n    encoder.cbuf.set(uint8Array.subarray(leftCopyLen));\n    encoder.cpos = rightCopyLen;\n  }\n};\n\n/**\n * Append an Uint8Array to Encoder.\n *\n * @function\n * @param {Encoder} encoder\n * @param {Uint8Array} uint8Array\n */\nexport var writeVarUint8Array = function writeVarUint8Array(encoder, uint8Array) {\n  writeVarUint(encoder, uint8Array.byteLength);\n  writeUint8Array(encoder, uint8Array);\n};\n\n/**\n * Create an DataView of the next `len` bytes. Use it to write data after\n * calling this function.\n *\n * ```js\n * // write float32 using DataView\n * const dv = writeOnDataView(encoder, 4)\n * dv.setFloat32(0, 1.1)\n * // read float32 using DataView\n * const dv = readFromDataView(encoder, 4)\n * dv.getFloat32(0) // => 1.100000023841858 (leaving it to the reader to find out why this is the correct result)\n * ```\n *\n * @param {Encoder} encoder\n * @param {number} len\n * @return {DataView}\n */\nexport var writeOnDataView = function writeOnDataView(encoder, len) {\n  verifyLen(encoder, len);\n  var dview = new DataView(encoder.cbuf.buffer, encoder.cpos, len);\n  encoder.cpos += len;\n  return dview;\n};\n\n/**\n * @param {Encoder} encoder\n * @param {number} num\n */\nexport var writeFloat32 = function writeFloat32(encoder, num) {\n  return writeOnDataView(encoder, 4).setFloat32(0, num, false);\n};\n\n/**\n * @param {Encoder} encoder\n * @param {number} num\n */\nexport var writeFloat64 = function writeFloat64(encoder, num) {\n  return writeOnDataView(encoder, 8).setFloat64(0, num, false);\n};\n\n/**\n * @param {Encoder} encoder\n * @param {bigint} num\n */\nexport var writeBigInt64 = function writeBigInt64(encoder, num) {\n  return (/** @type {any} */writeOnDataView(encoder, 8).setBigInt64(0, num, false)\n  );\n};\n\n/**\n * @param {Encoder} encoder\n * @param {bigint} num\n */\nexport var writeBigUint64 = function writeBigUint64(encoder, num) {\n  return (/** @type {any} */writeOnDataView(encoder, 8).setBigUint64(0, num, false)\n  );\n};\nvar floatTestBed = new DataView(new ArrayBuffer(4));\n/**\n * Check if a number can be encoded as a 32 bit float.\n *\n * @param {number} num\n * @return {boolean}\n */\nvar isFloat32 = function isFloat32(num) {\n  floatTestBed.setFloat32(0, num);\n  return floatTestBed.getFloat32(0) === num;\n};\n\n/**\n * Encode data with efficient binary format.\n *\n * Differences to JSON:\n * • Transforms data to a binary format (not to a string)\n * • Encodes undefined, NaN, and ArrayBuffer (these can't be represented in JSON)\n * • Numbers are efficiently encoded either as a variable length integer, as a\n *   32 bit float, as a 64 bit float, or as a 64 bit bigint.\n *\n * Encoding table:\n *\n * | Data Type           | Prefix   | Encoding Method    | Comment |\n * | ------------------- | -------- | ------------------ | ------- |\n * | undefined           | 127      |                    | Functions, symbol, and everything that cannot be identified is encoded as undefined |\n * | null                | 126      |                    | |\n * | integer             | 125      | writeVarInt        | Only encodes 32 bit signed integers |\n * | float32             | 124      | writeFloat32       | |\n * | float64             | 123      | writeFloat64       | |\n * | bigint              | 122      | writeBigInt64      | |\n * | boolean (false)     | 121      |                    | True and false are different data types so we save the following byte |\n * | boolean (true)      | 120      |                    | - 0b01111000 so the last bit determines whether true or false |\n * | string              | 119      | writeVarString     | |\n * | object<string,any>  | 118      | custom             | Writes {length} then {length} key-value pairs |\n * | array<any>          | 117      | custom             | Writes {length} then {length} json values |\n * | Uint8Array          | 116      | writeVarUint8Array | We use Uint8Array for any kind of binary data |\n *\n * Reasons for the decreasing prefix:\n * We need the first bit for extendability (later we may want to encode the\n * prefix with writeVarUint). The remaining 7 bits are divided as follows:\n * [0-30]   the beginning of the data range is used for custom purposes\n *          (defined by the function that uses this library)\n * [31-127] the end of the data range is used for data encoding by\n *          lib0/encoding.js\n *\n * @param {Encoder} encoder\n * @param {undefined|null|number|bigint|boolean|string|Object<string,any>|Array<any>|Uint8Array} data\n */\nexport var writeAny = function writeAny(encoder, data) {\n  switch (typeof data) {\n    case 'string':\n      // TYPE 119: STRING\n      write(encoder, 119);\n      writeVarString(encoder, data);\n      break;\n    case 'number':\n      if (number.isInteger(data) && math.abs(data) <= binary.BITS31) {\n        // TYPE 125: INTEGER\n        write(encoder, 125);\n        writeVarInt(encoder, data);\n      } else if (isFloat32(data)) {\n        // TYPE 124: FLOAT32\n        write(encoder, 124);\n        writeFloat32(encoder, data);\n      } else {\n        // TYPE 123: FLOAT64\n        write(encoder, 123);\n        writeFloat64(encoder, data);\n      }\n      break;\n    case 'bigint':\n      // TYPE 122: BigInt\n      write(encoder, 122);\n      writeBigInt64(encoder, data);\n      break;\n    case 'object':\n      if (data === null) {\n        // TYPE 126: null\n        write(encoder, 126);\n      } else if (array.isArray(data)) {\n        // TYPE 117: Array\n        write(encoder, 117);\n        writeVarUint(encoder, data.length);\n        for (var i = 0; i < data.length; i++) {\n          writeAny(encoder, data[i]);\n        }\n      } else if (data instanceof Uint8Array) {\n        // TYPE 116: ArrayBuffer\n        write(encoder, 116);\n        writeVarUint8Array(encoder, data);\n      } else {\n        // TYPE 118: Object\n        write(encoder, 118);\n        var keys = Object.keys(data);\n        writeVarUint(encoder, keys.length);\n        for (var _i = 0; _i < keys.length; _i++) {\n          var key = keys[_i];\n          writeVarString(encoder, key);\n          writeAny(encoder, data[key]);\n        }\n      }\n      break;\n    case 'boolean':\n      // TYPE 120/121: boolean (true/false)\n      write(encoder, data ? 120 : 121);\n      break;\n    default:\n      // TYPE 127: undefined\n      write(encoder, 127);\n  }\n};\n\n/**\n * Now come a few stateful encoder that have their own classes.\n */\n\n/**\n * Basic Run Length Encoder - a basic compression implementation.\n *\n * Encodes [1,1,1,7] to [1,3,7,1] (3 times 1, 1 time 7). This encoder might do more harm than good if there are a lot of values that are not repeated.\n *\n * It was originally used for image compression. Cool .. article http://csbruce.com/cbm/transactor/pdfs/trans_v7_i06.pdf\n *\n * @note T must not be null!\n *\n * @template T\n */\nexport var RleEncoder = /*#__PURE__*/function (_Encoder) {\n  _inherits(RleEncoder, _Encoder);\n  var _super = _createSuper(RleEncoder);\n  /**\n   * @param {function(Encoder, T):void} writer\n   */\n  function RleEncoder(writer) {\n    var _this;\n    _classCallCheck(this, RleEncoder);\n    _this = _super.call(this);\n    /**\n     * The writer\n     */\n    _this.w = writer;\n    /**\n     * Current state\n     * @type {T|null}\n     */\n    _this.s = null;\n    _this.count = 0;\n    return _this;\n  }\n\n  /**\n   * @param {T} v\n   */\n  _createClass(RleEncoder, [{\n    key: \"write\",\n    value: function write(v) {\n      if (this.s === v) {\n        this.count++;\n      } else {\n        if (this.count > 0) {\n          // flush counter, unless this is the first value (count = 0)\n          writeVarUint(this, this.count - 1); // since count is always > 0, we can decrement by one. non-standard encoding ftw\n        }\n\n        this.count = 1;\n        // write first value\n        this.w(this, v);\n        this.s = v;\n      }\n    }\n  }]);\n  return RleEncoder;\n}(Encoder);\n\n/**\n * Basic diff decoder using variable length encoding.\n *\n * Encodes the values [3, 1100, 1101, 1050, 0] to [3, 1097, 1, -51, -1050] using writeVarInt.\n */\nexport var IntDiffEncoder = /*#__PURE__*/function (_Encoder2) {\n  _inherits(IntDiffEncoder, _Encoder2);\n  var _super2 = _createSuper(IntDiffEncoder);\n  /**\n   * @param {number} start\n   */\n  function IntDiffEncoder(start) {\n    var _this2;\n    _classCallCheck(this, IntDiffEncoder);\n    _this2 = _super2.call(this);\n    /**\n     * Current state\n     * @type {number}\n     */\n    _this2.s = start;\n    return _this2;\n  }\n\n  /**\n   * @param {number} v\n   */\n  _createClass(IntDiffEncoder, [{\n    key: \"write\",\n    value: function write(v) {\n      writeVarInt(this, v - this.s);\n      this.s = v;\n    }\n  }]);\n  return IntDiffEncoder;\n}(Encoder);\n\n/**\n * A combination of IntDiffEncoder and RleEncoder.\n *\n * Basically first writes the IntDiffEncoder and then counts duplicate diffs using RleEncoding.\n *\n * Encodes the values [1,1,1,2,3,4,5,6] as [1,1,0,2,1,5] (RLE([1,0,0,1,1,1,1,1]) ⇒ RleIntDiff[1,1,0,2,1,5])\n */\nexport var RleIntDiffEncoder = /*#__PURE__*/function (_Encoder3) {\n  _inherits(RleIntDiffEncoder, _Encoder3);\n  var _super3 = _createSuper(RleIntDiffEncoder);\n  /**\n   * @param {number} start\n   */\n  function RleIntDiffEncoder(start) {\n    var _this3;\n    _classCallCheck(this, RleIntDiffEncoder);\n    _this3 = _super3.call(this);\n    /**\n     * Current state\n     * @type {number}\n     */\n    _this3.s = start;\n    _this3.count = 0;\n    return _this3;\n  }\n\n  /**\n   * @param {number} v\n   */\n  _createClass(RleIntDiffEncoder, [{\n    key: \"write\",\n    value: function write(v) {\n      if (this.s === v && this.count > 0) {\n        this.count++;\n      } else {\n        if (this.count > 0) {\n          // flush counter, unless this is the first value (count = 0)\n          writeVarUint(this, this.count - 1); // since count is always > 0, we can decrement by one. non-standard encoding ftw\n        }\n\n        this.count = 1;\n        // write first value\n        writeVarInt(this, v - this.s);\n        this.s = v;\n      }\n    }\n  }]);\n  return RleIntDiffEncoder;\n}(Encoder);\n\n/**\n * @param {UintOptRleEncoder} encoder\n */\nvar flushUintOptRleEncoder = function flushUintOptRleEncoder(encoder) {\n  if (encoder.count > 0) {\n    // flush counter, unless this is the first value (count = 0)\n    // case 1: just a single value. set sign to positive\n    // case 2: write several values. set sign to negative to indicate that there is a length coming\n    writeVarInt(encoder.encoder, encoder.count === 1 ? encoder.s : -encoder.s);\n    if (encoder.count > 1) {\n      writeVarUint(encoder.encoder, encoder.count - 2); // since count is always > 1, we can decrement by one. non-standard encoding ftw\n    }\n  }\n};\n\n/**\n * Optimized Rle encoder that does not suffer from the mentioned problem of the basic Rle encoder.\n *\n * Internally uses VarInt encoder to write unsigned integers. If the input occurs multiple times, we write\n * write it as a negative number. The UintOptRleDecoder then understands that it needs to read a count.\n *\n * Encodes [1,2,3,3,3] as [1,2,-3,3] (once 1, once 2, three times 3)\n */\nexport var UintOptRleEncoder = /*#__PURE__*/function () {\n  function UintOptRleEncoder() {\n    _classCallCheck(this, UintOptRleEncoder);\n    this.encoder = new Encoder();\n    /**\n     * @type {number}\n     */\n    this.s = 0;\n    this.count = 0;\n  }\n\n  /**\n   * @param {number} v\n   */\n  _createClass(UintOptRleEncoder, [{\n    key: \"write\",\n    value: function write(v) {\n      if (this.s === v) {\n        this.count++;\n      } else {\n        flushUintOptRleEncoder(this);\n        this.count = 1;\n        this.s = v;\n      }\n    }\n  }, {\n    key: \"toUint8Array\",\n    value: function toUint8Array() {\n      flushUintOptRleEncoder(this);\n      return _toUint8Array(this.encoder);\n    }\n  }]);\n  return UintOptRleEncoder;\n}();\n\n/**\n * Increasing Uint Optimized RLE Encoder\n *\n * The RLE encoder counts the number of same occurences of the same value.\n * The IncUintOptRle encoder counts if the value increases.\n * I.e. 7, 8, 9, 10 will be encoded as [-7, 4]. 1, 3, 5 will be encoded\n * as [1, 3, 5].\n */\nexport var IncUintOptRleEncoder = /*#__PURE__*/function () {\n  function IncUintOptRleEncoder() {\n    _classCallCheck(this, IncUintOptRleEncoder);\n    this.encoder = new Encoder();\n    /**\n     * @type {number}\n     */\n    this.s = 0;\n    this.count = 0;\n  }\n\n  /**\n   * @param {number} v\n   */\n  _createClass(IncUintOptRleEncoder, [{\n    key: \"write\",\n    value: function write(v) {\n      if (this.s + this.count === v) {\n        this.count++;\n      } else {\n        flushUintOptRleEncoder(this);\n        this.count = 1;\n        this.s = v;\n      }\n    }\n  }, {\n    key: \"toUint8Array\",\n    value: function toUint8Array() {\n      flushUintOptRleEncoder(this);\n      return _toUint8Array(this.encoder);\n    }\n  }]);\n  return IncUintOptRleEncoder;\n}();\n\n/**\n * @param {IntDiffOptRleEncoder} encoder\n */\nvar flushIntDiffOptRleEncoder = function flushIntDiffOptRleEncoder(encoder) {\n  if (encoder.count > 0) {\n    //          31 bit making up the diff | wether to write the counter\n    // const encodedDiff = encoder.diff << 1 | (encoder.count === 1 ? 0 : 1)\n    var encodedDiff = encoder.diff * 2 + (encoder.count === 1 ? 0 : 1);\n    // flush counter, unless this is the first value (count = 0)\n    // case 1: just a single value. set first bit to positive\n    // case 2: write several values. set first bit to negative to indicate that there is a length coming\n    writeVarInt(encoder.encoder, encodedDiff);\n    if (encoder.count > 1) {\n      writeVarUint(encoder.encoder, encoder.count - 2); // since count is always > 1, we can decrement by one. non-standard encoding ftw\n    }\n  }\n};\n\n/**\n * A combination of the IntDiffEncoder and the UintOptRleEncoder.\n *\n * The count approach is similar to the UintDiffOptRleEncoder, but instead of using the negative bitflag, it encodes\n * in the LSB whether a count is to be read. Therefore this Encoder only supports 31 bit integers!\n *\n * Encodes [1, 2, 3, 2] as [3, 1, 6, -1] (more specifically [(1 << 1) | 1, (3 << 0) | 0, -1])\n *\n * Internally uses variable length encoding. Contrary to normal UintVar encoding, the first byte contains:\n * * 1 bit that denotes whether the next value is a count (LSB)\n * * 1 bit that denotes whether this value is negative (MSB - 1)\n * * 1 bit that denotes whether to continue reading the variable length integer (MSB)\n *\n * Therefore, only five bits remain to encode diff ranges.\n *\n * Use this Encoder only when appropriate. In most cases, this is probably a bad idea.\n */\nexport var IntDiffOptRleEncoder = /*#__PURE__*/function () {\n  function IntDiffOptRleEncoder() {\n    _classCallCheck(this, IntDiffOptRleEncoder);\n    this.encoder = new Encoder();\n    /**\n     * @type {number}\n     */\n    this.s = 0;\n    this.count = 0;\n    this.diff = 0;\n  }\n\n  /**\n   * @param {number} v\n   */\n  _createClass(IntDiffOptRleEncoder, [{\n    key: \"write\",\n    value: function write(v) {\n      if (this.diff === v - this.s) {\n        this.s = v;\n        this.count++;\n      } else {\n        flushIntDiffOptRleEncoder(this);\n        this.count = 1;\n        this.diff = v - this.s;\n        this.s = v;\n      }\n    }\n  }, {\n    key: \"toUint8Array\",\n    value: function toUint8Array() {\n      flushIntDiffOptRleEncoder(this);\n      return _toUint8Array(this.encoder);\n    }\n  }]);\n  return IntDiffOptRleEncoder;\n}();\n\n/**\n * Optimized String Encoder.\n *\n * Encoding many small strings in a simple Encoder is not very efficient. The function call to decode a string takes some time and creates references that must be eventually deleted.\n * In practice, when decoding several million small strings, the GC will kick in more and more often to collect orphaned string objects (or maybe there is another reason?).\n *\n * This string encoder solves the above problem. All strings are concatenated and written as a single string using a single encoding call.\n *\n * The lengths are encoded using a UintOptRleEncoder.\n */\nexport var StringEncoder = /*#__PURE__*/function () {\n  function StringEncoder() {\n    _classCallCheck(this, StringEncoder);\n    /**\n     * @type {Array<string>}\n     */\n    this.sarr = [];\n    this.s = '';\n    this.lensE = new UintOptRleEncoder();\n  }\n\n  /**\n   * @param {string} string\n   */\n  _createClass(StringEncoder, [{\n    key: \"write\",\n    value: function write(string) {\n      this.s += string;\n      if (this.s.length > 19) {\n        this.sarr.push(this.s);\n        this.s = '';\n      }\n      this.lensE.write(string.length);\n    }\n  }, {\n    key: \"toUint8Array\",\n    value: function toUint8Array() {\n      var encoder = new Encoder();\n      this.sarr.push(this.s);\n      this.s = '';\n      writeVarString(encoder, this.sarr.join(''));\n      writeUint8Array(encoder, this.lensE.toUint8Array());\n      return _toUint8Array(encoder);\n    }\n  }]);\n  return StringEncoder;\n}();","map":{"version":3,"names":["buffer","math","number","binary","string","array","Encoder","_createClass","_classCallCheck","cpos","cbuf","Uint8Array","bufs","createEncoder","encode","f","encoder","toUint8Array","length","len","i","hasContent","uint8arr","curPos","d","set","createUint8ArrayViewFromArrayBuffer","_toUint8Array","verifyLen","bufferLen","push","max","write","num","pos","b","writeUint8","setUint8","writeUint16","BITS8","setUint16","writeUint32","writeUint32BigEndian","setUint32","writeVarUint","BITS7","BIT8","floor","writeVarInt","isNegative","isNegativeZero","BITS6","BIT7","_strBuffer","_maxStrBSize","_writeVarStringNative","str","written","utf8TextEncoder","encodeInto","writeVarUint8Array","encodeUtf8","_writeVarStringPolyfill","encodedString","unescape","encodeURIComponent","codePointAt","writeVarString","writeTerminatedString","writeTerminatedUint8Array","buf","writeBinaryEncoder","append","writeUint8Array","uint8Array","leftCopyLen","min","rightCopyLen","subarray","byteLength","writeOnDataView","dview","DataView","writeFloat32","setFloat32","writeFloat64","setFloat64","writeBigInt64","setBigInt64","writeBigUint64","setBigUint64","floatTestBed","ArrayBuffer","isFloat32","getFloat32","writeAny","data","isInteger","abs","BITS31","isArray","keys","Object","key","RleEncoder","_Encoder","_inherits","_super","_createSuper","writer","_this","call","w","s","count","value","v","IntDiffEncoder","_Encoder2","_super2","start","_this2","RleIntDiffEncoder","_Encoder3","_super3","_this3","flushUintOptRleEncoder","UintOptRleEncoder","IncUintOptRleEncoder","flushIntDiffOptRleEncoder","encodedDiff","diff","IntDiffOptRleEncoder","StringEncoder","sarr","lensE","join"],"sources":["/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/lib0/encoding.js"],"sourcesContent":["/**\n * Efficient schema-less binary encoding with support for variable length encoding.\n *\n * Use [lib0/encoding] with [lib0/decoding]. Every encoding function has a corresponding decoding function.\n *\n * Encodes numbers in little-endian order (least to most significant byte order)\n * and is compatible with Golang's binary encoding (https://golang.org/pkg/encoding/binary/)\n * which is also used in Protocol Buffers.\n *\n * ```js\n * // encoding step\n * const encoder = encoding.createEncoder()\n * encoding.writeVarUint(encoder, 256)\n * encoding.writeVarString(encoder, 'Hello world!')\n * const buf = encoding.toUint8Array(encoder)\n * ```\n *\n * ```js\n * // decoding step\n * const decoder = decoding.createDecoder(buf)\n * decoding.readVarUint(decoder) // => 256\n * decoding.readVarString(decoder) // => 'Hello world!'\n * decoding.hasContent(decoder) // => false - all data is read\n * ```\n *\n * @module encoding\n */\n\nimport * as buffer from './buffer.js'\nimport * as math from './math.js'\nimport * as number from './number.js'\nimport * as binary from './binary.js'\nimport * as string from './string.js'\nimport * as array from './array.js'\n\n/**\n * A BinaryEncoder handles the encoding to an Uint8Array.\n */\nexport class Encoder {\n  constructor () {\n    this.cpos = 0\n    this.cbuf = new Uint8Array(100)\n    /**\n     * @type {Array<Uint8Array>}\n     */\n    this.bufs = []\n  }\n}\n\n/**\n * @function\n * @return {Encoder}\n */\nexport const createEncoder = () => new Encoder()\n\n/**\n * @param {function(Encoder):void} f\n */\nexport const encode = (f) => {\n  const encoder = createEncoder()\n  f(encoder)\n  return toUint8Array(encoder)\n}\n\n/**\n * The current length of the encoded data.\n *\n * @function\n * @param {Encoder} encoder\n * @return {number}\n */\nexport const length = encoder => {\n  let len = encoder.cpos\n  for (let i = 0; i < encoder.bufs.length; i++) {\n    len += encoder.bufs[i].length\n  }\n  return len\n}\n\n/**\n * Check whether encoder is empty.\n *\n * @function\n * @param {Encoder} encoder\n * @return {boolean}\n */\nexport const hasContent = encoder => encoder.cpos > 0 || encoder.bufs.length > 0\n\n/**\n * Transform to Uint8Array.\n *\n * @function\n * @param {Encoder} encoder\n * @return {Uint8Array} The created ArrayBuffer.\n */\nexport const toUint8Array = encoder => {\n  const uint8arr = new Uint8Array(length(encoder))\n  let curPos = 0\n  for (let i = 0; i < encoder.bufs.length; i++) {\n    const d = encoder.bufs[i]\n    uint8arr.set(d, curPos)\n    curPos += d.length\n  }\n  uint8arr.set(buffer.createUint8ArrayViewFromArrayBuffer(encoder.cbuf.buffer, 0, encoder.cpos), curPos)\n  return uint8arr\n}\n\n/**\n * Verify that it is possible to write `len` bytes wtihout checking. If\n * necessary, a new Buffer with the required length is attached.\n *\n * @param {Encoder} encoder\n * @param {number} len\n */\nexport const verifyLen = (encoder, len) => {\n  const bufferLen = encoder.cbuf.length\n  if (bufferLen - encoder.cpos < len) {\n    encoder.bufs.push(buffer.createUint8ArrayViewFromArrayBuffer(encoder.cbuf.buffer, 0, encoder.cpos))\n    encoder.cbuf = new Uint8Array(math.max(bufferLen, len) * 2)\n    encoder.cpos = 0\n  }\n}\n\n/**\n * Write one byte to the encoder.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The byte that is to be encoded.\n */\nexport const write = (encoder, num) => {\n  const bufferLen = encoder.cbuf.length\n  if (encoder.cpos === bufferLen) {\n    encoder.bufs.push(encoder.cbuf)\n    encoder.cbuf = new Uint8Array(bufferLen * 2)\n    encoder.cpos = 0\n  }\n  encoder.cbuf[encoder.cpos++] = num\n}\n\n/**\n * Write one byte at a specific position.\n * Position must already be written (i.e. encoder.length > pos)\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} pos Position to which to write data\n * @param {number} num Unsigned 8-bit integer\n */\nexport const set = (encoder, pos, num) => {\n  let buffer = null\n  // iterate all buffers and adjust position\n  for (let i = 0; i < encoder.bufs.length && buffer === null; i++) {\n    const b = encoder.bufs[i]\n    if (pos < b.length) {\n      buffer = b // found buffer\n    } else {\n      pos -= b.length\n    }\n  }\n  if (buffer === null) {\n    // use current buffer\n    buffer = encoder.cbuf\n  }\n  buffer[pos] = num\n}\n\n/**\n * Write one byte as an unsigned integer.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nexport const writeUint8 = write\n\n/**\n * Write one byte as an unsigned Integer at a specific location.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} pos The location where the data will be written.\n * @param {number} num The number that is to be encoded.\n */\nexport const setUint8 = set\n\n/**\n * Write two bytes as an unsigned integer.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nexport const writeUint16 = (encoder, num) => {\n  write(encoder, num & binary.BITS8)\n  write(encoder, (num >>> 8) & binary.BITS8)\n}\n/**\n * Write two bytes as an unsigned integer at a specific location.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} pos The location where the data will be written.\n * @param {number} num The number that is to be encoded.\n */\nexport const setUint16 = (encoder, pos, num) => {\n  set(encoder, pos, num & binary.BITS8)\n  set(encoder, pos + 1, (num >>> 8) & binary.BITS8)\n}\n\n/**\n * Write two bytes as an unsigned integer\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nexport const writeUint32 = (encoder, num) => {\n  for (let i = 0; i < 4; i++) {\n    write(encoder, num & binary.BITS8)\n    num >>>= 8\n  }\n}\n\n/**\n * Write two bytes as an unsigned integer in big endian order.\n * (most significant byte first)\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nexport const writeUint32BigEndian = (encoder, num) => {\n  for (let i = 3; i >= 0; i--) {\n    write(encoder, (num >>> (8 * i)) & binary.BITS8)\n  }\n}\n\n/**\n * Write two bytes as an unsigned integer at a specific location.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} pos The location where the data will be written.\n * @param {number} num The number that is to be encoded.\n */\nexport const setUint32 = (encoder, pos, num) => {\n  for (let i = 0; i < 4; i++) {\n    set(encoder, pos + i, num & binary.BITS8)\n    num >>>= 8\n  }\n}\n\n/**\n * Write a variable length unsigned integer. Max encodable integer is 2^53.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nexport const writeVarUint = (encoder, num) => {\n  while (num > binary.BITS7) {\n    write(encoder, binary.BIT8 | (binary.BITS7 & num))\n    num = math.floor(num / 128) // shift >>> 7\n  }\n  write(encoder, binary.BITS7 & num)\n}\n\n/**\n * Write a variable length integer.\n *\n * We use the 7th bit instead for signaling that this is a negative number.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nexport const writeVarInt = (encoder, num) => {\n  const isNegative = math.isNegativeZero(num)\n  if (isNegative) {\n    num = -num\n  }\n  //             |- whether to continue reading         |- whether is negative     |- number\n  write(encoder, (num > binary.BITS6 ? binary.BIT8 : 0) | (isNegative ? binary.BIT7 : 0) | (binary.BITS6 & num))\n  num = math.floor(num / 64) // shift >>> 6\n  // We don't need to consider the case of num === 0 so we can use a different\n  // pattern here than above.\n  while (num > 0) {\n    write(encoder, (num > binary.BITS7 ? binary.BIT8 : 0) | (binary.BITS7 & num))\n    num = math.floor(num / 128) // shift >>> 7\n  }\n}\n\n/**\n * A cache to store strings temporarily\n */\nconst _strBuffer = new Uint8Array(30000)\nconst _maxStrBSize = _strBuffer.length / 3\n\n/**\n * Write a variable length string.\n *\n * @function\n * @param {Encoder} encoder\n * @param {String} str The string that is to be encoded.\n */\nexport const _writeVarStringNative = (encoder, str) => {\n  if (str.length < _maxStrBSize) {\n    // We can encode the string into the existing buffer\n    /* c8 ignore next */\n    const written = string.utf8TextEncoder.encodeInto(str, _strBuffer).written || 0\n    writeVarUint(encoder, written)\n    for (let i = 0; i < written; i++) {\n      write(encoder, _strBuffer[i])\n    }\n  } else {\n    writeVarUint8Array(encoder, string.encodeUtf8(str))\n  }\n}\n\n/**\n * Write a variable length string.\n *\n * @function\n * @param {Encoder} encoder\n * @param {String} str The string that is to be encoded.\n */\nexport const _writeVarStringPolyfill = (encoder, str) => {\n  const encodedString = unescape(encodeURIComponent(str))\n  const len = encodedString.length\n  writeVarUint(encoder, len)\n  for (let i = 0; i < len; i++) {\n    write(encoder, /** @type {number} */ (encodedString.codePointAt(i)))\n  }\n}\n\n/**\n * Write a variable length string.\n *\n * @function\n * @param {Encoder} encoder\n * @param {String} str The string that is to be encoded.\n */\n/* c8 ignore next */\nexport const writeVarString = (string.utf8TextEncoder && /** @type {any} */ (string.utf8TextEncoder).encodeInto) ? _writeVarStringNative : _writeVarStringPolyfill\n\n/**\n * Write a string terminated by a special byte sequence. This is not very performant and is\n * generally discouraged. However, the resulting byte arrays are lexiographically ordered which\n * makes this a nice feature for databases.\n *\n * The string will be encoded using utf8 and then terminated and escaped using writeTerminatingUint8Array.\n *\n * @function\n * @param {Encoder} encoder\n * @param {String} str The string that is to be encoded.\n */\nexport const writeTerminatedString = (encoder, str) =>\n  writeTerminatedUint8Array(encoder, string.encodeUtf8(str))\n\n/**\n * Write a terminating Uint8Array. Note that this is not performant and is generally\n * discouraged. There are few situations when this is needed.\n *\n * We use 0x0 as a terminating character. 0x1 serves as an escape character for 0x0 and 0x1.\n *\n * Example: [0,1,2] is encoded to [1,0,1,1,2,0]. 0x0, and 0x1 needed to be escaped using 0x1. Then\n * the result is terminated using the 0x0 character.\n *\n * This is basically how many systems implement null terminated strings. However, we use an escape\n * character 0x1 to avoid issues and potenial attacks on our database (if this is used as a key\n * encoder for NoSql databases).\n *\n * @function\n * @param {Encoder} encoder\n * @param {Uint8Array} buf The string that is to be encoded.\n */\nexport const writeTerminatedUint8Array = (encoder, buf) => {\n  for (let i = 0; i < buf.length; i++) {\n    const b = buf[i]\n    if (b === 0 || b === 1) {\n      write(encoder, 1)\n    }\n    write(encoder, buf[i])\n  }\n  write(encoder, 0)\n}\n\n/**\n * Write the content of another Encoder.\n *\n * @TODO: can be improved!\n *        - Note: Should consider that when appending a lot of small Encoders, we should rather clone than referencing the old structure.\n *                Encoders start with a rather big initial buffer.\n *\n * @function\n * @param {Encoder} encoder The enUint8Arr\n * @param {Encoder} append The BinaryEncoder to be written.\n */\nexport const writeBinaryEncoder = (encoder, append) => writeUint8Array(encoder, toUint8Array(append))\n\n/**\n * Append fixed-length Uint8Array to the encoder.\n *\n * @function\n * @param {Encoder} encoder\n * @param {Uint8Array} uint8Array\n */\nexport const writeUint8Array = (encoder, uint8Array) => {\n  const bufferLen = encoder.cbuf.length\n  const cpos = encoder.cpos\n  const leftCopyLen = math.min(bufferLen - cpos, uint8Array.length)\n  const rightCopyLen = uint8Array.length - leftCopyLen\n  encoder.cbuf.set(uint8Array.subarray(0, leftCopyLen), cpos)\n  encoder.cpos += leftCopyLen\n  if (rightCopyLen > 0) {\n    // Still something to write, write right half..\n    // Append new buffer\n    encoder.bufs.push(encoder.cbuf)\n    // must have at least size of remaining buffer\n    encoder.cbuf = new Uint8Array(math.max(bufferLen * 2, rightCopyLen))\n    // copy array\n    encoder.cbuf.set(uint8Array.subarray(leftCopyLen))\n    encoder.cpos = rightCopyLen\n  }\n}\n\n/**\n * Append an Uint8Array to Encoder.\n *\n * @function\n * @param {Encoder} encoder\n * @param {Uint8Array} uint8Array\n */\nexport const writeVarUint8Array = (encoder, uint8Array) => {\n  writeVarUint(encoder, uint8Array.byteLength)\n  writeUint8Array(encoder, uint8Array)\n}\n\n/**\n * Create an DataView of the next `len` bytes. Use it to write data after\n * calling this function.\n *\n * ```js\n * // write float32 using DataView\n * const dv = writeOnDataView(encoder, 4)\n * dv.setFloat32(0, 1.1)\n * // read float32 using DataView\n * const dv = readFromDataView(encoder, 4)\n * dv.getFloat32(0) // => 1.100000023841858 (leaving it to the reader to find out why this is the correct result)\n * ```\n *\n * @param {Encoder} encoder\n * @param {number} len\n * @return {DataView}\n */\nexport const writeOnDataView = (encoder, len) => {\n  verifyLen(encoder, len)\n  const dview = new DataView(encoder.cbuf.buffer, encoder.cpos, len)\n  encoder.cpos += len\n  return dview\n}\n\n/**\n * @param {Encoder} encoder\n * @param {number} num\n */\nexport const writeFloat32 = (encoder, num) => writeOnDataView(encoder, 4).setFloat32(0, num, false)\n\n/**\n * @param {Encoder} encoder\n * @param {number} num\n */\nexport const writeFloat64 = (encoder, num) => writeOnDataView(encoder, 8).setFloat64(0, num, false)\n\n/**\n * @param {Encoder} encoder\n * @param {bigint} num\n */\nexport const writeBigInt64 = (encoder, num) => /** @type {any} */ (writeOnDataView(encoder, 8)).setBigInt64(0, num, false)\n\n/**\n * @param {Encoder} encoder\n * @param {bigint} num\n */\nexport const writeBigUint64 = (encoder, num) => /** @type {any} */ (writeOnDataView(encoder, 8)).setBigUint64(0, num, false)\n\nconst floatTestBed = new DataView(new ArrayBuffer(4))\n/**\n * Check if a number can be encoded as a 32 bit float.\n *\n * @param {number} num\n * @return {boolean}\n */\nconst isFloat32 = num => {\n  floatTestBed.setFloat32(0, num)\n  return floatTestBed.getFloat32(0) === num\n}\n\n/**\n * Encode data with efficient binary format.\n *\n * Differences to JSON:\n * • Transforms data to a binary format (not to a string)\n * • Encodes undefined, NaN, and ArrayBuffer (these can't be represented in JSON)\n * • Numbers are efficiently encoded either as a variable length integer, as a\n *   32 bit float, as a 64 bit float, or as a 64 bit bigint.\n *\n * Encoding table:\n *\n * | Data Type           | Prefix   | Encoding Method    | Comment |\n * | ------------------- | -------- | ------------------ | ------- |\n * | undefined           | 127      |                    | Functions, symbol, and everything that cannot be identified is encoded as undefined |\n * | null                | 126      |                    | |\n * | integer             | 125      | writeVarInt        | Only encodes 32 bit signed integers |\n * | float32             | 124      | writeFloat32       | |\n * | float64             | 123      | writeFloat64       | |\n * | bigint              | 122      | writeBigInt64      | |\n * | boolean (false)     | 121      |                    | True and false are different data types so we save the following byte |\n * | boolean (true)      | 120      |                    | - 0b01111000 so the last bit determines whether true or false |\n * | string              | 119      | writeVarString     | |\n * | object<string,any>  | 118      | custom             | Writes {length} then {length} key-value pairs |\n * | array<any>          | 117      | custom             | Writes {length} then {length} json values |\n * | Uint8Array          | 116      | writeVarUint8Array | We use Uint8Array for any kind of binary data |\n *\n * Reasons for the decreasing prefix:\n * We need the first bit for extendability (later we may want to encode the\n * prefix with writeVarUint). The remaining 7 bits are divided as follows:\n * [0-30]   the beginning of the data range is used for custom purposes\n *          (defined by the function that uses this library)\n * [31-127] the end of the data range is used for data encoding by\n *          lib0/encoding.js\n *\n * @param {Encoder} encoder\n * @param {undefined|null|number|bigint|boolean|string|Object<string,any>|Array<any>|Uint8Array} data\n */\nexport const writeAny = (encoder, data) => {\n  switch (typeof data) {\n    case 'string':\n      // TYPE 119: STRING\n      write(encoder, 119)\n      writeVarString(encoder, data)\n      break\n    case 'number':\n      if (number.isInteger(data) && math.abs(data) <= binary.BITS31) {\n        // TYPE 125: INTEGER\n        write(encoder, 125)\n        writeVarInt(encoder, data)\n      } else if (isFloat32(data)) {\n        // TYPE 124: FLOAT32\n        write(encoder, 124)\n        writeFloat32(encoder, data)\n      } else {\n        // TYPE 123: FLOAT64\n        write(encoder, 123)\n        writeFloat64(encoder, data)\n      }\n      break\n    case 'bigint':\n      // TYPE 122: BigInt\n      write(encoder, 122)\n      writeBigInt64(encoder, data)\n      break\n    case 'object':\n      if (data === null) {\n        // TYPE 126: null\n        write(encoder, 126)\n      } else if (array.isArray(data)) {\n        // TYPE 117: Array\n        write(encoder, 117)\n        writeVarUint(encoder, data.length)\n        for (let i = 0; i < data.length; i++) {\n          writeAny(encoder, data[i])\n        }\n      } else if (data instanceof Uint8Array) {\n        // TYPE 116: ArrayBuffer\n        write(encoder, 116)\n        writeVarUint8Array(encoder, data)\n      } else {\n        // TYPE 118: Object\n        write(encoder, 118)\n        const keys = Object.keys(data)\n        writeVarUint(encoder, keys.length)\n        for (let i = 0; i < keys.length; i++) {\n          const key = keys[i]\n          writeVarString(encoder, key)\n          writeAny(encoder, data[key])\n        }\n      }\n      break\n    case 'boolean':\n      // TYPE 120/121: boolean (true/false)\n      write(encoder, data ? 120 : 121)\n      break\n    default:\n      // TYPE 127: undefined\n      write(encoder, 127)\n  }\n}\n\n/**\n * Now come a few stateful encoder that have their own classes.\n */\n\n/**\n * Basic Run Length Encoder - a basic compression implementation.\n *\n * Encodes [1,1,1,7] to [1,3,7,1] (3 times 1, 1 time 7). This encoder might do more harm than good if there are a lot of values that are not repeated.\n *\n * It was originally used for image compression. Cool .. article http://csbruce.com/cbm/transactor/pdfs/trans_v7_i06.pdf\n *\n * @note T must not be null!\n *\n * @template T\n */\nexport class RleEncoder extends Encoder {\n  /**\n   * @param {function(Encoder, T):void} writer\n   */\n  constructor (writer) {\n    super()\n    /**\n     * The writer\n     */\n    this.w = writer\n    /**\n     * Current state\n     * @type {T|null}\n     */\n    this.s = null\n    this.count = 0\n  }\n\n  /**\n   * @param {T} v\n   */\n  write (v) {\n    if (this.s === v) {\n      this.count++\n    } else {\n      if (this.count > 0) {\n        // flush counter, unless this is the first value (count = 0)\n        writeVarUint(this, this.count - 1) // since count is always > 0, we can decrement by one. non-standard encoding ftw\n      }\n      this.count = 1\n      // write first value\n      this.w(this, v)\n      this.s = v\n    }\n  }\n}\n\n/**\n * Basic diff decoder using variable length encoding.\n *\n * Encodes the values [3, 1100, 1101, 1050, 0] to [3, 1097, 1, -51, -1050] using writeVarInt.\n */\nexport class IntDiffEncoder extends Encoder {\n  /**\n   * @param {number} start\n   */\n  constructor (start) {\n    super()\n    /**\n     * Current state\n     * @type {number}\n     */\n    this.s = start\n  }\n\n  /**\n   * @param {number} v\n   */\n  write (v) {\n    writeVarInt(this, v - this.s)\n    this.s = v\n  }\n}\n\n/**\n * A combination of IntDiffEncoder and RleEncoder.\n *\n * Basically first writes the IntDiffEncoder and then counts duplicate diffs using RleEncoding.\n *\n * Encodes the values [1,1,1,2,3,4,5,6] as [1,1,0,2,1,5] (RLE([1,0,0,1,1,1,1,1]) ⇒ RleIntDiff[1,1,0,2,1,5])\n */\nexport class RleIntDiffEncoder extends Encoder {\n  /**\n   * @param {number} start\n   */\n  constructor (start) {\n    super()\n    /**\n     * Current state\n     * @type {number}\n     */\n    this.s = start\n    this.count = 0\n  }\n\n  /**\n   * @param {number} v\n   */\n  write (v) {\n    if (this.s === v && this.count > 0) {\n      this.count++\n    } else {\n      if (this.count > 0) {\n        // flush counter, unless this is the first value (count = 0)\n        writeVarUint(this, this.count - 1) // since count is always > 0, we can decrement by one. non-standard encoding ftw\n      }\n      this.count = 1\n      // write first value\n      writeVarInt(this, v - this.s)\n      this.s = v\n    }\n  }\n}\n\n/**\n * @param {UintOptRleEncoder} encoder\n */\nconst flushUintOptRleEncoder = encoder => {\n  if (encoder.count > 0) {\n    // flush counter, unless this is the first value (count = 0)\n    // case 1: just a single value. set sign to positive\n    // case 2: write several values. set sign to negative to indicate that there is a length coming\n    writeVarInt(encoder.encoder, encoder.count === 1 ? encoder.s : -encoder.s)\n    if (encoder.count > 1) {\n      writeVarUint(encoder.encoder, encoder.count - 2) // since count is always > 1, we can decrement by one. non-standard encoding ftw\n    }\n  }\n}\n\n/**\n * Optimized Rle encoder that does not suffer from the mentioned problem of the basic Rle encoder.\n *\n * Internally uses VarInt encoder to write unsigned integers. If the input occurs multiple times, we write\n * write it as a negative number. The UintOptRleDecoder then understands that it needs to read a count.\n *\n * Encodes [1,2,3,3,3] as [1,2,-3,3] (once 1, once 2, three times 3)\n */\nexport class UintOptRleEncoder {\n  constructor () {\n    this.encoder = new Encoder()\n    /**\n     * @type {number}\n     */\n    this.s = 0\n    this.count = 0\n  }\n\n  /**\n   * @param {number} v\n   */\n  write (v) {\n    if (this.s === v) {\n      this.count++\n    } else {\n      flushUintOptRleEncoder(this)\n      this.count = 1\n      this.s = v\n    }\n  }\n\n  toUint8Array () {\n    flushUintOptRleEncoder(this)\n    return toUint8Array(this.encoder)\n  }\n}\n\n/**\n * Increasing Uint Optimized RLE Encoder\n *\n * The RLE encoder counts the number of same occurences of the same value.\n * The IncUintOptRle encoder counts if the value increases.\n * I.e. 7, 8, 9, 10 will be encoded as [-7, 4]. 1, 3, 5 will be encoded\n * as [1, 3, 5].\n */\nexport class IncUintOptRleEncoder {\n  constructor () {\n    this.encoder = new Encoder()\n    /**\n     * @type {number}\n     */\n    this.s = 0\n    this.count = 0\n  }\n\n  /**\n   * @param {number} v\n   */\n  write (v) {\n    if (this.s + this.count === v) {\n      this.count++\n    } else {\n      flushUintOptRleEncoder(this)\n      this.count = 1\n      this.s = v\n    }\n  }\n\n  toUint8Array () {\n    flushUintOptRleEncoder(this)\n    return toUint8Array(this.encoder)\n  }\n}\n\n/**\n * @param {IntDiffOptRleEncoder} encoder\n */\nconst flushIntDiffOptRleEncoder = encoder => {\n  if (encoder.count > 0) {\n    //          31 bit making up the diff | wether to write the counter\n    // const encodedDiff = encoder.diff << 1 | (encoder.count === 1 ? 0 : 1)\n    const encodedDiff = encoder.diff * 2 + (encoder.count === 1 ? 0 : 1)\n    // flush counter, unless this is the first value (count = 0)\n    // case 1: just a single value. set first bit to positive\n    // case 2: write several values. set first bit to negative to indicate that there is a length coming\n    writeVarInt(encoder.encoder, encodedDiff)\n    if (encoder.count > 1) {\n      writeVarUint(encoder.encoder, encoder.count - 2) // since count is always > 1, we can decrement by one. non-standard encoding ftw\n    }\n  }\n}\n\n/**\n * A combination of the IntDiffEncoder and the UintOptRleEncoder.\n *\n * The count approach is similar to the UintDiffOptRleEncoder, but instead of using the negative bitflag, it encodes\n * in the LSB whether a count is to be read. Therefore this Encoder only supports 31 bit integers!\n *\n * Encodes [1, 2, 3, 2] as [3, 1, 6, -1] (more specifically [(1 << 1) | 1, (3 << 0) | 0, -1])\n *\n * Internally uses variable length encoding. Contrary to normal UintVar encoding, the first byte contains:\n * * 1 bit that denotes whether the next value is a count (LSB)\n * * 1 bit that denotes whether this value is negative (MSB - 1)\n * * 1 bit that denotes whether to continue reading the variable length integer (MSB)\n *\n * Therefore, only five bits remain to encode diff ranges.\n *\n * Use this Encoder only when appropriate. In most cases, this is probably a bad idea.\n */\nexport class IntDiffOptRleEncoder {\n  constructor () {\n    this.encoder = new Encoder()\n    /**\n     * @type {number}\n     */\n    this.s = 0\n    this.count = 0\n    this.diff = 0\n  }\n\n  /**\n   * @param {number} v\n   */\n  write (v) {\n    if (this.diff === v - this.s) {\n      this.s = v\n      this.count++\n    } else {\n      flushIntDiffOptRleEncoder(this)\n      this.count = 1\n      this.diff = v - this.s\n      this.s = v\n    }\n  }\n\n  toUint8Array () {\n    flushIntDiffOptRleEncoder(this)\n    return toUint8Array(this.encoder)\n  }\n}\n\n/**\n * Optimized String Encoder.\n *\n * Encoding many small strings in a simple Encoder is not very efficient. The function call to decode a string takes some time and creates references that must be eventually deleted.\n * In practice, when decoding several million small strings, the GC will kick in more and more often to collect orphaned string objects (or maybe there is another reason?).\n *\n * This string encoder solves the above problem. All strings are concatenated and written as a single string using a single encoding call.\n *\n * The lengths are encoded using a UintOptRleEncoder.\n */\nexport class StringEncoder {\n  constructor () {\n    /**\n     * @type {Array<string>}\n     */\n    this.sarr = []\n    this.s = ''\n    this.lensE = new UintOptRleEncoder()\n  }\n\n  /**\n   * @param {string} string\n   */\n  write (string) {\n    this.s += string\n    if (this.s.length > 19) {\n      this.sarr.push(this.s)\n      this.s = ''\n    }\n    this.lensE.write(string.length)\n  }\n\n  toUint8Array () {\n    const encoder = new Encoder()\n    this.sarr.push(this.s)\n    this.s = ''\n    writeVarString(encoder, this.sarr.join(''))\n    writeUint8Array(encoder, this.lensE.toUint8Array())\n    return toUint8Array(encoder)\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}