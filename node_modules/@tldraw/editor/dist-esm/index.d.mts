/// <reference types="react" />

import { Atom } from 'signia';
import { Box2d } from '@tldraw/primitives';
import { Box2dModel } from '@tldraw/tlschema';
import { Computed } from 'signia';
import { ComputedCache } from '@tldraw/store';
import { CubicSpline2d } from '@tldraw/primitives';
import { EASINGS } from '@tldraw/primitives';
import { EmbedDefinition } from '@tldraw/tlschema';
import { EventEmitter } from 'eventemitter3';
import { getHashForString } from '@tldraw/utils';
import { HistoryEntry } from '@tldraw/store';
import { MatLike } from '@tldraw/primitives';
import { Matrix2d } from '@tldraw/primitives';
import { Matrix2dModel } from '@tldraw/primitives';
import { Migrations } from '@tldraw/store';
import { Polyline2d } from '@tldraw/primitives';
import { default as React_2 } from 'react';
import * as React_3 from 'react';
import { RecursivePartial } from '@tldraw/utils';
import { RotateCorner } from '@tldraw/primitives';
import { SelectionCorner } from '@tldraw/primitives';
import { SelectionEdge } from '@tldraw/primitives';
import { SelectionHandle } from '@tldraw/primitives';
import { SerializedSchema } from '@tldraw/store';
import { ShapeProps } from '@tldraw/tlschema';
import { Signal } from 'signia';
import { StoreSchema } from '@tldraw/store';
import { StoreSnapshot } from '@tldraw/store';
import { StrokePoint } from '@tldraw/primitives';
import { StyleProp } from '@tldraw/tlschema';
import { TLArrowShape } from '@tldraw/tlschema';
import { TLArrowShapeArrowheadStyle } from '@tldraw/tlschema';
import { TLAsset } from '@tldraw/tlschema';
import { TLAssetId } from '@tldraw/tlschema';
import { TLAssetPartial } from '@tldraw/tlschema';
import { TLBaseShape } from '@tldraw/tlschema';
import { TLBookmarkAsset } from '@tldraw/tlschema';
import { TLBookmarkShape } from '@tldraw/tlschema';
import { TLCamera } from '@tldraw/tlschema';
import { TLCursor } from '@tldraw/tlschema';
import { TLDefaultColorStyle } from '@tldraw/tlschema';
import { TLDefaultHorizontalAlignStyle } from '@tldraw/tlschema';
import { TLDocument } from '@tldraw/tlschema';
import { TLDrawShape } from '@tldraw/tlschema';
import { TLEmbedShape } from '@tldraw/tlschema';
import { TLFrameShape } from '@tldraw/tlschema';
import { TLGeoShape } from '@tldraw/tlschema';
import { TLGroupShape } from '@tldraw/tlschema';
import { TLHandle } from '@tldraw/tlschema';
import { TLHighlightShape } from '@tldraw/tlschema';
import { TLImageAsset } from '@tldraw/tlschema';
import { TLImageShape } from '@tldraw/tlschema';
import { TLInstance } from '@tldraw/tlschema';
import { TLInstancePageState } from '@tldraw/tlschema';
import { TLInstancePresence } from '@tldraw/tlschema';
import { TLLineShape } from '@tldraw/tlschema';
import { TLNoteShape } from '@tldraw/tlschema';
import { TLPage } from '@tldraw/tlschema';
import { TLPageId } from '@tldraw/tlschema';
import { TLParentId } from '@tldraw/tlschema';
import { TLRecord } from '@tldraw/tlschema';
import { TLScribble } from '@tldraw/tlschema';
import { TLShape } from '@tldraw/tlschema';
import { TLShapeId } from '@tldraw/tlschema';
import { TLShapePartial } from '@tldraw/tlschema';
import { TLStore } from '@tldraw/tlschema';
import { TLStoreProps } from '@tldraw/tlschema';
import { TLTextShape } from '@tldraw/tlschema';
import { TLUnknownShape } from '@tldraw/tlschema';
import { TLVideoAsset } from '@tldraw/tlschema';
import { TLVideoShape } from '@tldraw/tlschema';
import { UnknownRecord } from '@tldraw/store';
import { Vec2d } from '@tldraw/primitives';
import { Vec2dModel } from '@tldraw/tlschema';
import { VecLike } from '@tldraw/primitives';

/** @public */
export declare const ACCEPTED_ASSET_TYPE: string;

/** @public */
export declare const ACCEPTED_IMG_TYPE: string[];

/** @public */
export declare const ACCEPTED_VID_TYPE: string[];

/* Excluded from this release type: ANIMATION_MEDIUM_MS */

/* Excluded from this release type: ANIMATION_SHORT_MS */

declare type AnyTLShapeInfo = TLShapeInfo<TLBaseShape<any, any>>;

declare interface ArcInfo {
    center: VecLike;
    radius: number;
    size: number;
    length: number;
    largeArcFlag: number;
    sweepFlag: number;
}

declare type ArrowInfo = {
    isStraight: false;
    start: ArrowPoint;
    end: ArrowPoint;
    middle: VecLike;
    handleArc: ArcInfo;
    bodyArc: ArcInfo;
    isValid: boolean;
} | {
    isStraight: true;
    start: ArrowPoint;
    end: ArrowPoint;
    middle: VecLike;
    isValid: boolean;
    length: number;
};

declare type ArrowPoint = {
    handle: VecLike;
    point: VecLike;
    arrowhead: TLArrowShapeArrowheadStyle;
};

/** @public */
export declare const ArrowShape: TLShapeInfo<TLArrowShape>;

/** @public */
export declare class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
    static type: "arrow";
    canEdit: () => boolean;
    canBind: () => boolean;
    isClosed: () => boolean;
    canSnap: () => boolean;
    hideResizeHandles: TLShapeUtilFlag<TLArrowShape>;
    hideRotateHandle: TLShapeUtilFlag<TLArrowShape>;
    hideSelectionBoundsFg: TLShapeUtilFlag<TLArrowShape>;
    hideSelectionBoundsBg: TLShapeUtilFlag<TLArrowShape>;
    defaultProps(): TLArrowShape['props'];
    getCenter(shape: TLArrowShape): Vec2d;
    getBounds(shape: TLArrowShape): Box2d;
    getOutlineWithoutLabel(shape: TLArrowShape): Vec2d[];
    getOutline(shape: TLArrowShape): Vec2d[];
    snapPoints(_shape: TLArrowShape): Vec2d[];
    private get infoCache();
    getArrowInfo(shape: TLArrowShape): ArrowInfo | undefined;
    getHandles(shape: TLArrowShape): TLHandle[];
    onHandleChange: TLOnHandleChangeHandler<TLArrowShape>;
    onTranslateStart: TLOnTranslateStartHandler<TLArrowShape>;
    onResize: TLOnResizeHandler<TLArrowShape>;
    onDoubleClickHandle: (shape: TLArrowShape, handle: TLHandle) => TLShapePartial<TLArrowShape> | void;
    hitTestPoint(shape: TLArrowShape, point: VecLike): boolean;
    hitTestLineSegment(shape: TLArrowShape, A: VecLike, B: VecLike): boolean;
    component(shape: TLArrowShape): JSX.Element | null;
    indicator(shape: TLArrowShape): JSX.Element | null;
    get labelBoundsCache(): ComputedCache<Box2d | null, TLArrowShape>;
    getLabelBounds(shape: TLArrowShape): Box2d | null;
    getEditingBounds: (shape: TLArrowShape) => Box2d;
    onEditEnd: TLOnEditEndHandler<TLArrowShape>;
    toSvg(shape: TLArrowShape, font: string, colors: TLExportColors): SVGGElement;
}

/** @public */
export declare abstract class BaseBoxShapeTool extends StateNode {
    static id: string;
    static initial: string;
    static children: () => (typeof Idle_4 | typeof Pointing_2)[];
    abstract shapeType: TLShapeUtilConstructor<any>;
}

/** @public */
export declare abstract class BaseBoxShapeUtil<Shape extends TLBaseBoxShape> extends ShapeUtil<Shape> {
    getBounds(shape: Shape): Box2d;
    getCenter(shape: Shape): Vec2d;
    getOutline(shape: Shape): Vec2d[];
    hitTestPoint(shape: Shape, point: VecLike): boolean;
    hitTestLineSegment(shape: Shape, A: VecLike, B: VecLike): boolean;
    onResize: TLOnResizeHandler<any>;
}

/** @public */
export declare function blobAsString(blob: Blob): Promise<string>;

/** @public */
export declare const BookmarkShape: TLShapeInfo<TLBookmarkShape>;

/** @public */
export declare class BookmarkShapeUtil extends BaseBoxShapeUtil<TLBookmarkShape> {
    static type: "bookmark";
    canResize: () => boolean;
    hideSelectionBoundsBg: () => boolean;
    hideSelectionBoundsFg: () => boolean;
    defaultProps(): TLBookmarkShape['props'];
    component(shape: TLBookmarkShape): JSX.Element;
    indicator(shape: TLBookmarkShape): JSX.Element;
    onBeforeCreate?: TLOnBeforeCreateHandler<TLBookmarkShape>;
    onBeforeUpdate?: TLOnBeforeUpdateHandler<TLBookmarkShape>;
}

declare type BoxWidthHeight = {
    w: number;
    h: number;
};

declare class Brushing extends StateNode {
    static id: string;
    info: TLBaseEventInfo & {
        type: "pointer";
        name: TLPointerEventName;
        point: VecLike;
        pointerId: number;
        button: number;
        isPen: boolean;
    } & {
        target: "canvas";
        shape?: undefined;
    } & {
        target: 'canvas';
    };
    brush: Box2d;
    initialSelectedIds: TLShapeId[];
    excludedShapeIds: Set<TLShapeId>;
    initialStartShape: null | TLShape;
    onEnter: (info: TLPointerEventInfo & {
        target: 'canvas';
    }) => void;
    onExit: () => void;
    onPointerMove: () => void;
    onPointerUp: TLEventHandlers['onPointerUp'];
    onComplete: TLEventHandlers['onComplete'];
    onCancel?: TLCancelEvent | undefined;
    onKeyDown: TLEventHandlers['onKeyDown'];
    onKeyUp?: TLKeyboardEvent | undefined;
    private complete;
    private hitTestShapes;
    onInterrupt: TLInterruptEvent;
    private handleHit;
}

/** @public */
export declare const Canvas: React_2.MemoExoticComponent<() => JSX.Element>;

/** @public */
export declare const checkFlag: (flag: (() => boolean) | boolean | undefined) => boolean | undefined;

declare class ClickManager {
    editor: Editor;
    constructor(editor: Editor);
    private _clickId;
    private _clickTimeout?;
    private _clickScreenPoint?;
    private _previousScreenPoint?;
    private _getClickTimeout;
    /* Excluded from this release type: _clickState */
    /**
     * The current click state.
     *
     * @public
     */
    get clickState(): TLClickState | undefined;
    lastPointerInfo: TLPointerEventInfo;
    /**
     * Start the double click timeout.
     *
     * @param info - The event info.
     */
    transformPointerDownEvent: (info: TLPointerEventInfo) => TLClickEventInfo | TLPointerEventInfo;
    /**
     * Emit click_up events on pointer up.
     *
     * @param info - The event info.
     */
    transformPointerUpEvent: (info: TLPointerEventInfo) => TLClickEventInfo | TLPointerEventInfo;
    /* Excluded from this release type: cancelDoubleClickTimeout */
    /* Excluded from this release type: handleMove */
}

declare type CommandFn<Data> = (...args: any[]) => {
    data: Data;
    squashing?: boolean;
    ephemeral?: boolean;
    preservesRedoStack?: boolean;
} | null | undefined | void;

/**
 * Contains the size within the given box size
 *
 * @param originalSize - The size of the asset
 * @param containBoxSize - The container size
 * @returns Adjusted size
 * @public
 */
export declare function containBoxSize(originalSize: BoxWidthHeight, containBoxSize: BoxWidthHeight): BoxWidthHeight;

/** @public */
export declare const coreShapes: readonly [TLShapeInfo<TLGroupShape>, TLShapeInfo<TLEmbedShape>, TLShapeInfo<TLBookmarkShape>, TLShapeInfo<TLImageShape>, TLShapeInfo<TLTextShape>];

/** @public */
export declare function correctSpacesToNbsp(input: string): string;

/**
 * Creates a signal of the instance state for a given store.
 * @public
 * @param store - The store to create the instance state snapshot signal for
 * @returns
 */
export declare function createSessionStateSnapshotSignal(store: TLStore): Signal<null | TLSessionStateSnapshot>;

/**
 * A helper for creating a TLStore. Custom shapes cannot override default shapes.
 *
 * @param opts - Options for creating the store.
 *
 * @public */
export declare function createTLStore({ initialData, defaultName, ...rest }: TLStoreOptions): TLStore;

/** @public */
export declare function createTLUser(opts?: {
    /* Excluded from this release type: derivePresenceState */
    userPreferences?: Signal<TLUserPreferences, unknown> | undefined;
    setUserPreferences?: ((userPreferences: TLUserPreferences) => void) | undefined;
}): TLUser;

declare class Crop extends StateNode {
    static id: string;
    static initial: string;
    static children: () => (typeof Idle | typeof PointingCrop | typeof TranslatingCrop)[];
}

declare class Cropping extends StateNode {
    static id: string;
    info: TLBaseEventInfo & {
        type: "pointer";
        name: TLPointerEventName;
        point: VecLike;
        pointerId: number;
        button: number;
        isPen: boolean;
    } & {
        target: "selection";
        handle?: TLSelectionHandle | undefined;
        shape?: undefined;
    } & {
        target: 'selection';
        handle: SelectionHandle;
        onInteractionEnd?: string | undefined;
    };
    markId: string;
    private snapshot;
    onEnter: TLEnterEventHandler;
    onPointerMove: TLEventHandlers['onPointerMove'];
    onPointerUp: TLEventHandlers['onPointerUp'];
    onComplete: TLEventHandlers['onComplete'];
    onCancel: TLEventHandlers['onCancel'];
    private updateCursor;
    private getDefaultCrop;
    private updateShapes;
    private complete;
    private cancel;
    private createSnapshot;
}

/** @public */
export declare function dataTransferItemAsString(item: DataTransferItem): Promise<string>;

/** @public */
export declare function dataUrlToFile(url: string, filename: string, mimeType: string): Promise<File>;

/* Excluded from this release type: DebugFlag */

/* Excluded from this release type: DebugFlagDef */

/* Excluded from this release type: debugFlags */

/* Excluded from this release type: DEFAULT_ANIMATION_OPTIONS */

/** @public */
export declare let defaultEditorAssetUrls: TLEditorAssetUrls;

/** @public */
export declare function defaultEmptyAs(str: string, dflt: string): string;

/* Excluded from this release type: DefaultErrorFallback */

declare interface Defaults<T> {
    development?: T;
    staging?: T;
    production?: T;
    all: T;
}

/** @public */
export declare const defaultShapes: readonly [TLShapeInfo<TLDrawShape>, TLShapeInfo<TLGeoShape>, TLShapeInfo<TLLineShape>, TLShapeInfo<TLNoteShape>, TLShapeInfo<TLFrameShape>, TLShapeInfo<TLArrowShape>, TLShapeInfo<TLHighlightShape>, TLShapeInfo<TLVideoShape>];

/** @public */
export declare const defaultTools: TLStateNodeConstructor[];

/** @public */
export declare function defineShape<T extends TLUnknownShape>(type: T['type'], opts: Omit<TLShapeInfo<T>, 'type'>): TLShapeInfo<T>;

/* Excluded from this release type: DOUBLE_CLICK_DURATION */

/** @public */
export declare function downloadDataURLAsFile(dataUrl: string, filename: string): void;

/* Excluded from this release type: DRAG_DISTANCE */

declare class DragAndDropManager {
    editor: Editor;
    constructor(editor: Editor);
    prevDroppingShapeId: null | TLShapeId;
    currDroppingShapeId: null | TLShapeId;
    droppingNodeTimer: null | ReturnType<typeof setTimeout>;
    updateDroppingNode(movingShapes: TLShape[], cb: () => void): void;
    private setDragTimer;
    private handleDrag;
    dropShapes(shapes: TLShape[]): void;
    clear(): void;
    dispose: () => void;
}

declare class DraggingHandle extends StateNode {
    static id: string;
    shapeId: TLShapeId;
    initialHandle: TLHandle;
    initialAdjacentHandle: null | TLHandle;
    markId: string;
    initialPageTransform: any;
    initialPageRotation: any;
    info: TLBaseEventInfo & {
        type: "pointer";
        name: TLPointerEventName;
        point: VecLike;
        pointerId: number;
        button: number;
        isPen: boolean;
    } & {
        target: "handle";
        shape: TLShape;
        handle: TLHandle;
    } & {
        shape: TLArrowShape;
        target: 'handle';
        onInteractionEnd?: string | undefined;
        isCreating: boolean;
    };
    isPrecise: boolean;
    isPreciseId: null | TLShapeId;
    pointingId: null | TLShapeId;
    onEnter: TLEnterEventHandler;
    private exactTimeout;
    private resetExactTimeout;
    private clearExactTimeout;
    onPointerMove: TLEventHandlers['onPointerMove'];
    onKeyDown: TLKeyboardEvent | undefined;
    onKeyUp: TLKeyboardEvent | undefined;
    onPointerUp: TLEventHandlers['onPointerUp'];
    onComplete: TLEventHandlers['onComplete'];
    onCancel: TLCancelEvent;
    onExit: () => void;
    private complete;
    private cancel;
    private update;
}

/** @public */
export declare const DrawShape: TLShapeInfo<TLDrawShape>;

/** @public */
export declare class DrawShapeUtil extends ShapeUtil<TLDrawShape> {
    static type: "draw";
    hideResizeHandles: (shape: TLDrawShape) => boolean;
    hideRotateHandle: (shape: TLDrawShape) => boolean;
    hideSelectionBoundsBg: (shape: TLDrawShape) => boolean;
    hideSelectionBoundsFg: (shape: TLDrawShape) => boolean;
    defaultProps(): TLDrawShape['props'];
    isClosed: (shape: TLDrawShape) => boolean;
    getBounds(shape: TLDrawShape): Box2d;
    getOutline(shape: TLDrawShape): Vec2d[];
    getCenter(shape: TLDrawShape): Vec2d;
    hitTestPoint(shape: TLDrawShape, point: VecLike): boolean;
    hitTestLineSegment(shape: TLDrawShape, A: VecLike, B: VecLike): boolean;
    component(shape: TLDrawShape): JSX.Element;
    indicator(shape: TLDrawShape): JSX.Element;
    toSvg(shape: TLDrawShape, _font: string | undefined, colors: TLExportColors): SVGGElement;
    onResize: TLOnResizeHandler<TLDrawShape>;
    expandSelectionOutlinePx(shape: TLDrawShape): number;
}

declare class EditingShape extends StateNode {
    static id: string;
    onPointerEnter: TLEventHandlers['onPointerEnter'];
    onPointerLeave: TLEventHandlers['onPointerLeave'];
    onExit: () => void;
    onPointerDown: TLEventHandlers['onPointerDown'];
    onComplete: TLEventHandlers['onComplete'];
    onCancel: TLEventHandlers['onCancel'];
}

/** @public */
export declare class Editor extends EventEmitter<TLEventMap> {
    constructor({ store, user, shapes, tools, getContainer }: TLEditorOptions);
    /**
     * The editor's store
     *
     * @public
     */
    readonly store: TLStore;
    /**
     * The root state of the statechart.
     *
     * @public
     */
    readonly root: RootState;
    /**
     * A set of functions to call when the app is disposed.
     *
     * @public
     */
    readonly disposables: Set<() => void>;
    /* Excluded from this release type: _dprManager */
    /* Excluded from this release type: _activeAreaManager */
    /* Excluded from this release type: _tickManager */
    /* Excluded from this release type: _updateDepth */
    /** @public */
    externalContentManager: PlopManager;
    /**
     * A manager for the app's snapping feature.
     *
     * @public
     */
    readonly snaps: SnapManager;
    /**
     * A manager for the user and their preferences.
     *
     * @public
     */
    readonly user: UserPreferencesManager;
    /**
     * Whether the editor is running in Safari.
     *
     * @public
     */
    readonly isSafari: boolean;
    /**
     * Whether the editor is running on iOS.
     *
     * @public
     */
    readonly isIos: boolean;
    /**
     * Whether the editor is running on iOS.
     *
     * @public
     */
    readonly isChromeForIos: boolean;
    /**
     * The current HTML element containing the editor.
     *
     * @example
     * ```ts
     * const container = editor.getContainer()
     * ```
     *
     * @public
     */
    getContainer: () => HTMLElement;
    /* Excluded from this release type: _pageTransformCache */
    /* Excluded from this release type: _pageBoundsCache */
    /**
     * Dispose the editor.
     *
     * @public
     */
    dispose(): void;
    /**
     * A manager for the app's history.
     *
     * @readonly
     */
    readonly history: HistoryManager<this>;
    /**
     * Undo to the last mark.
     *
     * @example
     * ```ts
     * editor.undo()
     * ```
     *
     * @public
     */
    undo(): HistoryManager<this>;
    /**
     * Whether the app can undo.
     *
     * @public
     */
    get canUndo(): boolean;
    /**
     * Redo to the next mark.
     *
     * @example
     * ```ts
     * editor.redo()
     * ```
     *
     * @public
     */
    redo(): this;
    /**
     * Whether the app can redo.
     *
     * @public
     */
    get canRedo(): boolean;
    /**
     * Create a new "mark", or stopping point, in the undo redo history. Creating a mark will clear
     * any redos.
     *
     * @example
     * ```ts
     * editor.mark()
     * editor.mark('flip shapes')
     * ```
     *
     * @param reason - The reason for the mark.
     * @param onUndo - Whether to stop at the mark when undoing.
     * @param onRedo - Whether to stop at the mark when redoing.
     *
     * @public
     */
    mark(reason?: string, onUndo?: boolean, onRedo?: boolean): string;
    /**
     * Clear all marks in the undo stack back to the next mark.
     *
     * @example
     * ```ts
     * editor.bail()
     * ```
     *
     * @public
     */
    bail(): this;
    /**
     * Clear all marks in the undo stack back to the mark with the provided mark id.
     *
     * @example
     * ```ts
     * editor.bailToMark('creating')
     * ```
     *
     * @public
     */
    bailToMark(id: string): this;
    /**
     * Run a function in a batch, which will be undone/redone as a single action.
     *
     * @example
     * ```ts
     * editor.batch(() => {
     * 	editor.selectAll()
     * 	editor.deleteShapes()
     * 	editor.createShapes(myShapes)
     * 	editor.selectNone()
     * })
     *
     * editor.undo() // will undo all of the above
     * ```
     *
     * @public
     */
    batch(fn: () => void): this;
    /**
     * A map of shape utility classes (TLShapeUtils) by shape type.
     *
     * @public
     */
    shapeUtils: {
        readonly [K in string]?: ShapeUtil<TLUnknownShape>;
    };
    /**
     * Get a shape util by its definition.
     *
     * @example
     * ```ts
     * editor.getShapeUtil(ArrowShapeUtil)
     * ```
     *
     * @param util - The shape util.
     *
     * @public
     */
    getShapeUtil<C extends {
        new (...args: any[]): ShapeUtil<any>;
        type: string;
    }>(util: C): InstanceType<C>;
    /**
     * Get a shape util from a shape itself.
     *
     * @example
     * ```ts
     * const util = editor.getShapeUtil(myShape)
     * const util = editor.getShapeUtil<ArrowShapeUtil>(myShape)
     * const util = editor.getShapeUtil(ArrowShapeUtil)
     * ```
     *
     * @param shape - A shape or shape partial.
     *
     * @public
     */
    getShapeUtil<S extends TLUnknownShape>(shape: S | TLShapePartial<S>): ShapeUtil<S>;
    /* Excluded from this release type: _extractSharedStyles */
    /* Excluded from this release type: _selectionSharedStyles */
    private get _stylesForNextShape();
    /* Excluded from this release type: getStyleForNextShape */
    /**
     * A derived object containing either all current styles among the user's selected shapes, or
     * else the user's most recent style choices that correspond to the current active state (i.e.
     * the selected tool).
     *
     * @public
     */
    get sharedStyles(): ReadonlySharedStyleMap;
    /**
     * Get the currently selected shared opacity.
     * If any shapes are selected, this returns the shared opacity of the selected shapes.
     * Otherwise, this returns the chosen opacity for the next shape.
     *
     * @public
     */
    get sharedOpacity(): SharedStyle<number>;
    /* Excluded from this release type: _arrowBindingsIndex */
    /**
     * Get all arrows bound to a shape.
     *
     * @param shapeId - The id of the shape.
     *
     * @public
     */
    getArrowsBoundTo(shapeId: TLShapeId): {
        arrowId: TLShapeId;
        handleId: "end" | "start";
    }[];
    /* Excluded from this release type: _reparentArrow */
    /* Excluded from this release type: _unbindArrowTerminal */
    private get _allPageStates();
    /* Excluded from this release type: _shapeWillBeDeleted */
    /* Excluded from this release type: _arrowDidUpdate */
    /* Excluded from this release type: _invalidParents */
    /* Excluded from this release type: _complete */
    /* Excluded from this release type: _cleanupInstancePageState */
    /* Excluded from this release type: _shapeDidChange */
    /* Excluded from this release type: _pageStateDidChange */
    /* Excluded from this release type: _pageWillBeDeleted */
    /* Excluded from this release type: annotateError */
    /* Excluded from this release type: createErrorAnnotations */
    /* Excluded from this release type: _crashingError */
    /* Excluded from this release type: crashingError */
    /* Excluded from this release type: crash */
    private _canMoveCamera;
    /**
     * Whether the editor's camera can move.
     *
     * @example
     * ```ts
     * editor.canMoveCamera = false
     * ```
     *
     * @param canMove - Whether the camera can move.
     *
     * @public
     */
    get canMoveCamera(): boolean;
    set canMoveCamera(canMove: boolean);
    private _isFocused;
    /**
     * Whether or not the editor is focused.
     *
     * @public
     */
    get isFocused(): boolean;
    /**
     * The window's device pixel ratio.
     *
     * @public
     */
    get devicePixelRatio(): number;
    /* Excluded from this release type: _isCoarsePointer */
    /**
     * Whether the user is using a "coarse" pointer, such as on a touch screen. This is automatically set by the canvas.
     *
     * @public
     **/
    get isCoarsePointer(): boolean;
    set isCoarsePointer(v: boolean);
    private _openMenus;
    /**
     * A set of strings representing any open menus. When menus are open,
     * certain interactions will behave differently; for example, when a
     * draw tool is selected and a menu is open, a pointer-down will not
     * create a dot (because the user is probably trying to close the menu)
     * however a pointer-down event followed by a drag will begin drawing
     * a line (because the user is BOTH trying to close the menu AND start
     * drawing a line).
     *
     * @public
     */
    get openMenus(): string[];
    /**
     * Add an open menu.
     *
     * @example
     * ```ts
     * editor.addOpenMenu('menu-id')
     * ```
     *
     * @public
     */
    addOpenMenu(id: string): this;
    /**
     * Delete an open menu.
     *
     * @example
     * ```ts
     * editor.deleteOpenMenu('menu-id')
     * ```
     *
     * @public
     */
    deleteOpenMenu(id: string): this;
    /**
     * Get whether any menus are open.
     *
     * @public
     */
    get isMenuOpen(): boolean;
    /* Excluded from this release type: _isChangingStyle */
    /* Excluded from this release type: _isChangingStyleTimeout */
    /**
     * Whether the user is currently changing the style of a shape. This may cause the UI to change.
     *
     * @example
     * ```ts
     * editor.isChangingStyle = true
     * ```
     *
     * @public
     */
    get isChangingStyle(): boolean;
    set isChangingStyle(v: boolean);
    /* Excluded from this release type: _isPenMode */
    /* Excluded from this release type: _touchEventsRemainingBeforeExitingPenMode */
    /**
     * Whether the editor is in pen mode or not.
     *
     * @public
     **/
    get isPenMode(): boolean;
    /**
     * Set whether the editor is in pen mode or not.
     *
     * @public
     **/
    setPenMode(isPenMode: boolean): this;
    private _isReadOnly;
    /**
     * Set whether the editor is in read-only mode or not.
     *
     * @public
     **/
    setReadOnly(isReadOnly: boolean): this;
    /**
     * Whether the editor is in read-only mode or not.
     *
     * @public
     **/
    get isReadOnly(): boolean;
    /**
     * The global document settings that apply to all users.
     *
     * @public
     **/
    get documentSettings(): TLDocument;
    /**
     * Update the global document settings that apply to all users.
     *
     * @public
     **/
    updateDocumentSettings(settings: Partial<TLDocument>): void;
    /**
     * The document's grid size.
     *
     * @public
     **/
    get gridSize(): number;
    /* Excluded from this release type: projectName */
    /* Excluded from this release type: setProjectName */
    /**
     * Whether the user has "always snap" mode enabled.
     *
     * @public
     **/
    get isSnapMode(): boolean;
    /**
     * Set whether the user has "always snap" mode enabled.
     *
     * @public
     **/
    setSnapMode(isSnapMode: boolean): this;
    /**
     * Whether the user has dark mode enabled.
     *
     * @public
     **/
    get isDarkMode(): boolean;
    /**
     * Set whether the user has dark mode enabled.
     *
     * @public
     **/
    setDarkMode(isDarkMode: boolean): this;
    /**
     * The user's chosen animation speed.
     *
     * @public
     */
    get animationSpeed(): number;
    /**
     * Set the user's chosen animation speed.
     * Set to 0.0 to disable animations.
     * Set to 1.0 for full speed.
     *
     * @public
     */
    setAnimationSpeed(animationSpeed: number): this;
    /**
     * The current instance's state.
     *
     * @public
     */
    get instanceState(): TLInstance;
    /**
     * The instance's cursor state.
     *
     * @public
     **/
    get cursor(): TLCursor;
    /**
     * The instance's brush state.
     *
     * @public
     **/
    get brush(): Box2dModel | null;
    /**
     * The instance's zoom brush state.
     *
     * @public
     **/
    get zoomBrush(): Box2dModel | null;
    /**
     * The instance's scribble state.
     *
     * @public
     **/
    get scribble(): null | TLScribble;
    /**
     * Whether the instance is in focus mode or not.
     *
     * @public
     **/
    get isFocusMode(): boolean;
    /**
     * Set whether the instance is in focus mode or not.
     *
     * @public
     **/
    setFocusMode(isFocusMode: boolean): this;
    /**
     * Whether the instance has "tool lock" mode enabled.
     *
     * @public
     **/
    get isToolLocked(): boolean;
    /**
     * Set whether the instance has "tool lock" mode enabled.
     *
     * @public
     **/
    setToolLocked(isToolLocked: boolean): this;
    /**
     * Whether the instance's grid is enabled.
     *
     * @public
     **/
    get isGridMode(): boolean;
    /**
     * Set whether the instance's grid is enabled.
     *
     * @public
     **/
    setGridMode(isGridMode: boolean): this;
    /* Excluded from this release type: _pages */
    /**
     * Info about the project's current pages.
     *
     * @public
     */
    get pages(): TLPage[];
    /**
     * The current page.
     *
     * @public
     */
    get currentPage(): TLPage;
    /**
     * The current page id.
     *
     * @public
     */
    get currentPageId(): TLPageId;
    /**
     * Get a page by its ID.
     *
     * @example
     * ```ts
     * editor.getPageById(myPage.id)
     * ```
     *
     * @public
     */
    getPageById(id: TLPageId): TLPage | undefined;
    /**
     * Get a page by its ID.
     *
     * @example
     * ```ts
     * editor.getPageById(myPage.id)
     * ```
     *
     * @public
     */
    getPageInfoById(id: TLPage['id']): TLPage | undefined;
    /* Excluded from this release type: _currentPageShapeIds */
    /**
     * An array of all of the shapes on the current page.
     *
     * @public
     */
    get currentPageShapeIds(): Set<TLShapeId>;
    /**
     * Get the ids of shapes on a page.
     *
     * @example
     * ```ts
     * const idsOnPage1 = editor.getShapeIdsInPage('page1')
     * const idsOnPage2 = editor.getShapeIdsInPage('page2')
     * ```
     *
     * @param pageId - The id of the page.
     *
     * @public
     **/
    getShapeIdsInPage(pageId: TLPageId): Set<TLShapeId>;
    /* Excluded from this release type: _pageStates */
    /**
     * Get a page state by its id.
     *
     * @example
     * ```ts
     * editor.getPageStateByPageId('page1')
     * ```
     *
     * @public
     */
    getPageStateByPageId(id: TLPageId): TLInstancePageState | undefined;
    /* Excluded from this release type: pageStateId */
    /**
     * The current page state.
     *
     * @public
     */
    get pageState(): TLInstancePageState;
    /**
     * Update a page state.
     *
     * @example
     * ```ts
     * editor.setInstancePageState({ id: 'page1', editingId: 'shape:123' })
     * editor.setInstancePageState({ id: 'page1', editingId: 'shape:123' }, true)
     * ```
     *
     * @param partial - The partial of the page state object containing the changes.
     * @param ephemeral - Whether the command is ephemeral.
     *
     * @public
     */
    setInstancePageState(partial: Partial<TLInstancePageState>, ephemeral?: boolean): void;
    /**
     * The current selected ids.
     *
     * @public
     */
    get selectedIds(): TLShapeId[];
    /**
     * The current selected ids as a set
     *
     * @public
     */
    get selectedIdsSet(): ReadonlySet<TLShapeId>;
    /**
     * Select one or more shapes.
     *
     * @example
     * ```ts
     * editor.setSelectedIds(['id1'])
     * editor.setSelectedIds(['id1', 'id2'])
     * ```
     *
     * @param ids - The ids to select.
     * @param squashing - Whether the change should create a new history entry or combine with the
     *   previous (if the previous is the same type).
     *
     * @public
     */
    setSelectedIds(ids: TLShapeId[], squashing?: boolean): this;
    /* Excluded from this release type: _setSelectedIds */
    /**
     * Determine whether or not a shape is selected
     *
     * @example
     * ```ts
     * editor.isSelected('id1')
     * ```
     *
     * @param id - The id of the shape to check.
     *
     * @public
     */
    isSelected(id: TLShapeId): boolean;
    /**
     * Determine whether a not a shape is within the current selection. A shape is within the
     * selection if it or any of its parents is selected.
     *
     * @param id - The id of the shape to check.
     *
     * @public
     */
    isWithinSelection(id: TLShapeId): boolean;
    /**
     * Select one or more shapes.
     *
     * @example
     * ```ts
     * editor.select('id1')
     * editor.select('id1', 'id2')
     * ```
     *
     * @param ids - The ids to select.
     *
     * @public
     */
    select(...ids: TLShapeId[]): this;
    /**
     * Remove a shape from the existing set of selected shapes.
     *
     * @example
     * ```ts
     * editor.deselect(shape.id)
     * ```
     *
     * @public
     */
    deselect(...ids: TLShapeId[]): this;
    /**
     * Select all direct children of the current page.
     *
     * @example
     * ```ts
     * editor.selectAll()
     * ```
     *
     * @public
     */
    selectAll(): this;
    /**
     * Clear the selection.
     *
     * @example
     * ```ts
     * editor.selectNone()
     * ```
     *
     * @public
     */
    selectNone(): this;
    /**
     * The shape id of the current focus layer.
     *
     * @public
     */
    get focusLayerId(): TLPageId | TLShapeId;
    /**
     * The shape of the current focus layer.
     *
     * @public
     */
    get focusLayerShape(): TLShape | undefined;
    /**
     * Exit the current focus layer, moving up to the next group if there is one.
     *
     * @public
     */
    popFocusLayer(): this;
    /**
     * Set the focus layer to the given shape id.
     *
     * @param next - The next focus layer id or null to reset the focus layer to the page
     *
     * @public
     */
    setFocusLayer(next: null | TLShapeId): this;
    /* Excluded from this release type: _setFocusLayer */
    /**
     * The current editing shape's id.
     *
     * @public
     */
    get editingId(): null | TLShapeId;
    /**
     * Set the current editing id.
     *
     * @param id - The id of the shape to edit or null to clear the editing id.
     *
     * @public
     */
    setEditingId(id: null | TLShapeId): this;
    get editingShape(): null | TLUnknownShape;
    /**
     * The current hovered shape id.
     *
     * @readonly
     * @public
     */
    get hoveredId(): null | TLShapeId;
    /**
     * Set the current hovered shape.
     *
     * @example
     * ```ts
     * editor.setHoveredId('box1')
     * editor.setHoveredId() // Clears the hovered shape.
     * ```
     *
     * @param id - The id of the page to set as the current page
     *
     * @public
     */
    setHoveredId(id?: null | TLShapeId): this;
    /**
     * The current hovered shape.
     *
     * @readonly
     * @public
     */
    get hoveredShape(): null | TLUnknownShape;
    /**
     * The editor's current hinting ids.
     *
     * @public
     */
    get hintingIds(): TLShapeId[];
    /**
     * Set the hinted shape ids.
     *
     * @param ids - The ids to set as hinted.
     *
     * @public
     */
    setHintingIds(ids: TLShapeId[]): this;
    /**
     * The editor's current erasing ids.
     *
     * @public
     */
    get erasingIds(): TLShapeId[];
    /**
     * A derived set containing the current erasing ids.
     *
     * @public
     */
    get erasingIdsSet(): Set<TLShapeId>;
    /**
     * Set the current erasing shapes.
     *
     * @example
     * ```ts
     * editor.setErasingIds(['box1', 'box2'])
     * editor.setErasingIds() // Clears the erasing set
     * ```
     *
     * @param ids - The ids of shapes to set as erasing.
     *
     * @public
     */
    setErasingIds(ids?: TLShapeId[]): this;
    /**
     * The current cropping shape's id.
     *
     * @public
     */
    get croppingId(): null | TLShapeId;
    /**
     * Set the current cropping shape's id.
     *
     * @param id - The id of the shape to crop or null to clear the cropping id.
     *
     * @public
     */
    setCroppingId(id: null | TLShapeId): this;
    /* Excluded from this release type: cameraId */
    /**
     * The current camera.
     *
     * @public
     */
    get camera(): TLCamera;
    /**
     * The current camera zoom level.
     *
     * @public
     */
    get zoomLevel(): number;
    /**
     * Update the viewport. The viewport will measure the size and screen position of its container
     * element. This should be done whenever the container's position on the screen changes.
     *
     * @example
     * ```ts
     * editor.updateViewportScreenBounds()
     * editor.updateViewportScreenBounds(true)
     * ```
     *
     * @param center - (optional) Whether to preserve the viewport page center as the viewport changes.
     *
     * @public
     */
    updateViewportScreenBounds(center?: boolean): this;
    /**
     * The bounds of the editor's viewport in screen space.
     *
     * @public
     */
    get viewportScreenBounds(): Box2d;
    /**
     * The center of the editor's viewport in screen space.
     *
     * @public
     */
    get viewportScreenCenter(): Vec2d;
    /**
     * The current viewport in page space.
     *
     * @public
     */
    get viewportPageBounds(): Box2d;
    /**
     * The center of the viewport in page space.
     *
     * @public
     */
    get viewportPageCenter(): Vec2d;
    /**
     * Convert a point in screen space to a point in page space.
     *
     * @example
     * ```ts
     * editor.screenToPage(100, 100)
     * ```
     *
     * @param x - The x coordinate of the point in screen space.
     * @param y - The y coordinate of the point in screen space.
     * @param camera - The camera to use. Defaults to the current camera.
     *
     * @public
     */
    screenToPage(x: number, y: number, z?: number, camera?: Vec2dModel): {
        x: number;
        y: number;
        z: number;
    };
    /**
     * Convert a point in page space to a point in screen space.
     *
     * @example
     * ```ts
     * editor.pageToScreen(100, 100)
     * ```
     *
     * @param x - The x coordinate of the point in screen space.
     * @param y - The y coordinate of the point in screen space.
     * @param camera - The camera to use. Defaults to the current camera.
     *
     * @public
     */
    pageToScreen(x: number, y: number, z?: number, camera?: Vec2dModel): {
        x: number;
        y: number;
        z: number;
    };
    private _cameraState;
    /**
     * Whether the camera is moving or idle.
     *
     * @public
     */
    get cameraState(): "idle" | "moving";
    private _cameraStateTimeoutRemaining;
    private _lastUpdateRenderingBoundsTimestamp;
    private _decayCameraStateTimeout;
    private _tickCameraState;
    private computeUnorderedRenderingShapes;
    /**
     * Get the shapes that should be displayed in the current viewport.
     *
     * @public
     */
    get renderingShapes(): {
        id: TLShapeId;
        index: number;
        backgroundIndex: number;
        opacity: number;
        isCulled: boolean;
        isInViewport: boolean;
        maskedPageBounds: Box2d | undefined;
    }[];
    /**
     * The current rendering bounds in page space, used for checking which shapes are "on screen".
     *
     * @public
     */
    get renderingBounds(): Box2d;
    /* Excluded from this release type: _renderingBounds */
    /**
     * The current rendering bounds in page space, expanded slightly. Used for determining which shapes
     * to render and which to "cull".
     *
     * @public
     */
    get renderingBoundsExpanded(): Box2d;
    /* Excluded from this release type: _renderingBoundsExpanded */
    /* Excluded from this release type: updateRenderingBounds */
    /**
     * Get the local transform for a shape as a matrix model. This transform reflects both its
     * translation (x, y) from from either its parent's top left corner, if the shape's parent is
     * another shape, or else from the 0,0 of the page, if the shape's parent is the page; and the
     * shape's rotation.
     *
     * @example
     * ```ts
     * editor.getTransform(myShape)
     * ```
     *
     * @param shape - The shape to get the local transform for.
     *
     * @public
     */
    getTransform(shape: TLShape): Matrix2d;
    /**
     * Get the local transform of a shape's parent as a matrix model.
     *
     * @example
     * ```ts
     * editor.getParentTransform(myShape)
     * ```
     *
     * @param shape - The shape to get the parent transform for.
     *
     * @public
     */
    getParentTransform(shape: TLShape): Matrix2d;
    /**
     * Get the page transform (or absolute transform) of a shape.
     *
     * @example
     * ```ts
     * editor.getPageTransform(myShape)
     * ```
     *
     * @param shape - The shape to get the page transform for.
     *
     * @public
     */
    getPageTransform(shape: TLShape): Matrix2d | undefined;
    /**
     * Get the page transform (or absolute transform) of a shape by its id.
     *
     * @example
     * ```ts
     * editor.getPageTransformById(myShape)
     * ```
     *
     * @param id - The if of the shape to get the page transform for.
     *
     * @public
     */
    getPageTransformById(id: TLShapeId): Matrix2d | undefined;
    /**
     * Get the page point (or absolute point) of a shape.
     *
     * @example
     * ```ts
     * editor.getPagePoint(myShape)
     * ```
     *
     * @param shape - The shape to get the page point for.
     *
     * @public
     */
    getPagePointById(id: TLShapeId): undefined | Vec2d;
    /**
     * Get the page point (or absolute point) of a shape.
     *
     * @example
     * ```ts
     * editor.getPagePoint(myShape)
     * ```
     *
     * @param shape - The shape to get the page point for.
     *
     * @public
     */
    getPageCenter(shape: TLShape): null | Vec2d;
    /**
     * Get the page point (or absolute point) of a shape by its id.
     *
     * @example
     * ```ts
     * editor.getPagePoint(myShape)
     * ```
     *
     * @param id - The shape id to get the page point for.
     *
     * @public
     */
    getPageCenterById(id: TLShapeId): null | Vec2d;
    /**
     * Get the page rotation (or absolute rotation) of a shape.
     *
     * @example
     * ```ts
     * editor.getPageRotation(myShape)
     * ```
     *
     * @param shape - The shape to get the page rotation for.
     *
     * @public
     */
    getPageRotation(shape: TLShape): number;
    /**
     * Get the page rotation (or absolute rotation) of a shape by its id.
     *
     * @example
     * ```ts
     * editor.getPageRotationById(myShapeId)
     * ```
     *
     * @param id - The id of the shape to get the page rotation for.
     */
    getPageRotationById(id: TLShapeId): number;
    /**
     * Get the local bounds of a shape.
     *
     * @example
     * ```ts
     * editor.getBounds(myShape)
     * ```
     *
     * @param shape - The shape to get the bounds for.
     *
     * @public
     */
    getBounds(shape: TLShape): Box2d;
    /**
     * Get the local bounds of a shape by its id.
     *
     * @example
     * ```ts
     * editor.getBoundsById(myShape)
     * ```
     *
     * @param id - The id of the shape to get the bounds for.
     *
     * @public
     */
    getBoundsById(id: TLShapeId): Box2d | undefined;
    /**
     * Get the page (or absolute) bounds of a shape.
     *
     * @example
     * ```ts
     * editor.getPageBounds(myShape)
     * ```
     *
     * @param shape - The shape to get the bounds for.
     *
     * @public
     */
    getPageBounds(shape: TLShape): Box2d | undefined;
    /**
     * Get the page (or absolute) bounds of a shape by its id.
     *
     * @example
     * ```ts
     * editor.getPageBoundsById(myShape)
     * ```
     *
     * @param id - The id of the shape to get the page bounds for.
     *
     * @public
     */
    getPageBoundsById(id: TLShapeId): Box2d | undefined;
    /* Excluded from this release type: _clipPathCache */
    /**
     * Get the clip path for a shape.
     *
     * @example
     * ```ts
     * const clipPath = editor.getClipPathById(shape.id)
     * ```
     *
     * @param id - The shape id.
     *
     * @returns The clip path or undefined.
     *
     * @public
     */
    getClipPathById(id: TLShapeId): string | undefined;
    /* Excluded from this release type: _pageMaskCache */
    /**
     * Get the page mask for a shape.
     *
     * @example
     * ```ts
     * const pageMask = editor.getPageMaskById(shape.id)
     * ```
     *
     * @param id - The id of the shape to get the page mask for.
     *
     * @returns The page mask for the shape.
     *
     * @public
     */
    getPageMaskById(id: TLShapeId): undefined | VecLike[];
    /**
     * Get the page (or absolute) bounds of a shape, incorporating any masks. For example, if the
     * shape were the child of a frame and was half way out of the frame, the bounds would be the half
     * of the shape that was in the frame.
     *
     * @example
     * ```ts
     * editor.getMaskedPageBounds(myShape)
     * ```
     *
     * @param shape - The shape to get the masked bounds for.
     *
     * @public
     */
    getMaskedPageBounds(shape: TLShape): Box2d | undefined;
    /**
     * Get the page (or absolute) bounds of a shape by its id, incorporating any masks. For example,
     * if the shape were the child of a frame and was half way out of the frame, the bounds would be
     * the half of the shape that was in the frame.
     *
     * @example
     * ```ts
     * editor.getMaskedPageBoundsById(myShape)
     * ```
     *
     * @param id - The id of the shape to get the masked page bounds for.
     *
     * @public
     */
    getMaskedPageBoundsById(id: TLShapeId): Box2d | undefined;
    /**
     * Get the local outline of a shape.
     *
     * @example
     * ```ts
     * editor.getOutline(myShape)
     * ```
     *
     * @param shape - The shape to get the outline for.
     *
     * @public
     */
    getOutline(shape: TLShape): Vec2d[];
    /**
     * Get the local outline of a shape.
     *
     * @example
     * ```ts
     * editor.getOutlineById(myShape)
     * ```
     *
     * @param id - The shape id to get the outline for.
     *
     * @public
     */
    getOutlineById(id: TLShapeId): Vec2d[];
    /**
     * Get the ancestors of a shape.
     *
     * @example
     * ```ts
     * const ancestors = editor.getAncestors(myShape)
     * ```
     *
     * @param shape - The shape to get the ancestors for.
     *
     * @public
     */
    getAncestors(shape: TLShape, acc?: TLShape[]): TLShape[];
    /**
     * Get the ancestors of a shape by its id.
     *
     * @example
     * ```ts
     * const ancestors = editor.getAncestorsById(myShape)
     * ```
     *
     * @param id - The id of the shape to get the ancestors for.
     *
     * @public
     */
    getAncestorsById(id: TLShapeId, acc?: TLShape[]): TLShape[];
    /**
     * Find the first ancestor matching the given predicate
     *
     * @example
     * ```ts
     * const ancestor = editor.findAncestor(myShape)
     * ```
     *
     * @param shape - The shape to check the ancestors for.
     *
     * @public
     */
    findAncestor(shape: TLShape, predicate: (parent: TLShape) => boolean): TLShape | undefined;
    /**
     * Returns true if the the given shape has the given ancestor.
     *
     * @param shape - The shape.
     * @param ancestorId - The id of the ancestor.
     *
     * @public
     */
    hasAncestor(shape: TLShape | undefined, ancestorId: TLShapeId): boolean;
    /**
     * Get the common ancestor of two or more shapes that matches a predicate.
     *
     * @param shapes - The shapes to check.
     * @param predicate - The predicate to match.
     */
    findCommonAncestor(shapes: TLShape[], predicate?: (shape: TLShape) => boolean): TLShapeId | undefined;
    /**
     * Check whether a shape or its parent is locked.
     *
     * @param id - The id of the shape to check.
     *
     * @public
     */
    isShapeOrAncestorLocked(shape?: TLShape): boolean;
    /**
     * The common bounds of all of the shapes on the page.
     *
     * @public
     */
    get allShapesCommonBounds(): Box2d | null;
    /**
     * Get the corners of a shape in page space.
     *
     * @example
     * ```ts
     * const corners = editor.getPageCorners(myShape)
     * ```
     *
     * @param shape - The shape to get the corners for.
     *
     * @public
     */
    getPageCorners(shape: TLShape): Vec2d[];
    /**
     * Test whether a point (in page space) will will a shape. This method takes into account masks,
     * such as when a shape is the child of a frame and is partially clipped by the frame.
     *
     * @example
     * ```ts
     * editor.isPointInShape({ x: 100, y: 100 }, myShape)
     * ```
     *
     * @param point - The page point to test.
     * @param shape - The shape to test against.
     *
     * @public
     */
    isPointInShape(point: VecLike, shape: TLShape): boolean;
    /**
     * Get the shapes, if any, at a given page point.
     *
     * @example
     * ```ts
     * editor.getShapesAtPoint({ x: 100, y: 100 })
     * ```
     *
     * @param point - The page point to test.
     *
     * @public
     */
    getShapesAtPoint(point: VecLike): TLShape[];
    /**
     * Convert a point in page space to a point in the local space of a shape. For example, if a
     * shape's page point were `{ x: 100, y: 100 }`, a page point at `{ x: 110, y: 110 }` would be at
     * `{ x: 10, y: 10 }` in the shape's local space.
     *
     * @example
     * ```ts
     * editor.getPointInShapeSpace(myShape, { x: 100, y: 100 })
     * ```
     *
     * @param shape - The shape to get the point in the local space of.
     * @param point - The page point to get in the local space of the shape.
     *
     * @public
     */
    getPointInShapeSpace(shape: TLShape, point: VecLike): Vec2d;
    /**
     * Convert a delta in page space to a point in the local space of a shape. For example, if a
     * shape's page point were `{ x: 100, y: 100 }`, a page point at `{ x: 110, y: 110 }` would be at
     * `{ x: 10, y: 10 }` in the shape's local space.
     *
     * @example
     * ```ts
     * editor.getPointInShapeSpace(myShape.id, { x: 100, y: 100 })
     * ```
     *
     * @param shape - The shape to get the point in the local space of.
     * @param point - The page point to get in the local space of the shape.
     *
     * @public
     */
    getPointInParentSpace(shapeId: TLShapeId, point: VecLike): Vec2d;
    /**
     * Convert a delta in page space to a delta in the local space of a shape.
     *
     * @example
     * ```ts
     * editor.getDeltaInShapeSpace(myShape, { x: 100, y: 100 })
     * ```
     *
     * @param shape - The shape to get the delta in the local space of.
     * @param delta - The page delta to convert.
     *
     * @public
     */
    getDeltaInShapeSpace(shape: TLShape, delta: VecLike): Vec2d;
    /**
     * Convert a delta in page space to a delta in the parent space of a shape.
     *
     * @example
     * ```ts
     * editor.getDeltaInParentSpace(myShape, { x: 100, y: 100 })
     * ```
     *
     * @param shape - The shape to get the delta in the parent space of.
     * @param delta - The page delta to convert.
     *
     * @public
     */
    getDeltaInParentSpace(shape: TLShape, delta: VecLike): Vec2d;
    /**
     * For a given set of ids, get a map containing the ids of their parents and the children of those
     * parents.
     *
     * @example
     * ```ts
     * editor.getParentsMappedToChildren(['id1', 'id2', 'id3'])
     * ```
     *
     * @param ids - The ids to get the parents and children of.
     *
     * @public
     */
    getParentsMappedToChildren(ids: TLShapeId[]): Map<TLParentId, Set<TLShape>>;
    /**
     * The current page bounds of all the selected shapes (Not the same thing as the page bounds of
     * the selection bounding box when the selection has been rotated)
     *
     * @readonly
     *
     * @public
     */
    get selectedPageBounds(): Box2d | null;
    /**
     * The rotation of the selection bounding box.
     *
     * @readonly
     * @public
     */
    get selectionRotation(): number;
    /**
     * The bounds of the selection bounding box.
     *
     * @readonly
     * @public
     */
    get selectionBounds(): Box2d | undefined;
    /**
     * The center of the selection bounding box.
     *
     * @readonly
     * @public
     */
    get selectionPageCenter(): null | Vec2d;
    /**
     * The id of the current selected tool.
     *
     * @public
     */
    get currentToolId(): string;
    /**
     * Set the selected tool.
     *
     * @example
     * ```ts
     * editor.setSelectedTool('hand')
     * editor.setSelectedTool('hand', { date: Date.now() })
     * ```
     *
     * @param id - The id of the tool to select.
     * @param info - Arbitrary data to pass along into the transition.
     *
     * @public
     */
    setSelectedTool(id: string, info?: {}): this;
    /**
     * Get a descendant by its path.
     *
     * @example
     * ```ts
     * state.getStateDescendant('select')
     * state.getStateDescendant('select.brushing')
     * ```
     *
     * @param path - The descendant's path of state ids, separated by periods.
     *
     * @public
     */
    getStateDescendant(path: string): StateNode | undefined;
    /**
     * Get whether a certain tool (or other state node) is currently active.
     *
     * @example
     * ```ts
     * editor.isIn('select')
     * editor.isIn('select.brushing')
     * ```
     *
     * @param path - The path of active states, separated by periods.
     *
     * @public
     */
    isIn(path: string): boolean;
    /**
     * Get whether the state node is in any of the given active paths.
     *
     * @example
     * ```ts
     * state.isInAny('select', 'erase')
     * state.isInAny('select.brushing', 'erase.idle')
     * ```
     *
     * @public
     */
    isInAny(...paths: string[]): boolean;
    /**
     * The app's current input state.
     *
     * @public
     */
    inputs: {
        /** The most recent pointer down's position in page space. */
        originPagePoint: Vec2d;
        /** The most recent pointer down's position in screen space. */
        originScreenPoint: Vec2d;
        /** The previous pointer position in page space. */
        previousPagePoint: Vec2d;
        /** The previous pointer position in screen space. */
        previousScreenPoint: Vec2d;
        /** The most recent pointer position in page space. */
        currentPagePoint: Vec2d;
        /** The most recent pointer position in screen space. */
        currentScreenPoint: Vec2d;
        /** A set containing the currently pressed keys. */
        keys: Set<string>;
        /** A set containing the currently pressed buttons. */
        buttons: Set<number>;
        /** Whether the input is from a pe. */
        isPen: boolean;
        /** Whether the shift key is currently pressed. */
        shiftKey: boolean;
        /** Whether the control or command key is currently pressed. */
        ctrlKey: boolean;
        /** Whether the alt or option key is currently pressed. */
        altKey: boolean;
        /** Whether the user is dragging. */
        isDragging: boolean;
        /** Whether the user is pointing. */
        isPointing: boolean;
        /** Whether the user is pinching. */
        isPinching: boolean;
        /** Whether the user is editing. */
        isEditing: boolean;
        /** Whether the user is panning. */
        isPanning: boolean;
        /** Velocity of mouse pointer, in pixels per millisecond */
        pointerVelocity: Vec2d;
    };
    /**
     * Update the input points from a pointer or pinch event.
     *
     * @param info - The event info.
     */
    private _updateInputsFromEvent;
    /* Excluded from this release type: _clickManager */
    /**
     * Prevent a double click event from firing the next time the user clicks
     *
     * @public
     */
    cancelDoubleClick(): void;
    /* Excluded from this release type: _prevCursor */
    /* Excluded from this release type: _shiftKeyTimeout */
    /* Excluded from this release type: _setShiftKeyTimeout */
    /* Excluded from this release type: _altKeyTimeout */
    /* Excluded from this release type: _setAltKeyTimeout */
    /* Excluded from this release type: _ctrlKeyTimeout */
    /* Excluded from this release type: _setCtrlKeyTimeout */
    /* Excluded from this release type: _restoreToolId */
    /* Excluded from this release type: _pinchStart */
    /* Excluded from this release type: _didPinch */
    /* Excluded from this release type: _selectedIdsAtPointerDown */
    /* Excluded from this release type: capturedPointerId */
    /**
     * Dispatch an event to the editor.
     *
     * @example
     * ```ts
     * editor.dispatch(myPointerEvent)
     * ```
     *
     * @param info - The event info.
     *
     * @public
     */
    dispatch(info: TLEventInfo): this;
    /**
     * Replace the store's contents with the given records.
     *
     * @param records - The records to replace the store's contents with.
     */
    replaceStoreContentsWithRecordsForOtherDocument(records: TLRecord[]): void;
    /**
     * Get content that can be exported for the given shape ids.
     *
     * @param ids - The ids of the shapes to get content for. Defaults to the selected shape ids.
     *
     * @returns The exported content.
     *
     * @public
     */
    getContent(ids?: TLShapeId[]): TLContent | undefined;
    /**
     * Place content into the editor.
     *
     * @param content - The content.
     * @param options - Options for placing the content.
     *
     * @public
     */
    putContent(content: TLContent, options?: {
        point?: VecLike;
        select?: boolean;
        preservePosition?: boolean;
        preserveIds?: boolean;
    }): this;
    /**
     * Create shapes.
     *
     * @example
     * ```ts
     * editor.createShapes([{ id: 'box1', type: 'text', props: { text: "ok" } }])
     * ```
     *
     * @param partials - The shape partials to create.
     * @param select - Whether to select the created shapes. Defaults to false.
     *
     * @public
     */
    createShapes<T extends TLUnknownShape>(partials: TLShapePartial<T>[], select?: boolean): this;
    /* Excluded from this release type: _createShapes */
    private animatingShapes;
    /**
     * Animate shapes.
     *
     * @example
     * ```ts
     * editor.animateShapes([{ id: 'box1', type: 'box', x: 100, y: 100 }])
     * ```
     *
     * @param partials - The shape partials to update.
     *
     * @public
     */
    animateShapes(partials: (null | TLShapePartial | undefined)[], options?: {
        /** The animation's duration in milliseconds. */
        duration?: number;
        /** The animation's easing function. */
        ease?: (t: number) => number;
    }): this;
    /**
     * Update shapes using partials of each shape.
     *
     * @example
     * ```ts
     * editor.updateShapes([{ id: 'box1', type: 'geo', props: { w: 100, h: 100 } }])
     * ```
     *
     * @param partials - The shape partials to update.
     * @param squashing - Whether the change is ephemeral.
     *
     * @public
     */
    updateShapes<T extends TLUnknownShape>(partials: (null | TLShapePartial<T> | undefined)[], squashing?: boolean): this;
    /* Excluded from this release type: _updateShapes */
    /* Excluded from this release type: _getUnlockedShapeIds */
    /**
     * Delete shapes.
     *
     * @example
     * ```ts
     * editor.deleteShapes()
     * editor.deleteShapes(['box1', 'box2'])
     * ```
     *
     * @param ids - The ids of the shapes to delete. Defaults to the selected shapes.
     *
     * @public
     */
    deleteShapes(ids?: TLShapeId[]): this;
    /* Excluded from this release type: _deleteShapes */
    /**
     * Get the user's locale.
     *
     * @public
     */
    get locale(): string;
    /**
     * Update the user's locale. This affects which translations are used when rendering UI elements.
     *
     * @example
     * ```ts
     * editor.setLocale('fr')
     * ```
     *
     * @public
     */
    setLocale(locale: string): void;
    /**
     * Update a page.
     *
     * @example
     * ```ts
     * editor.updatePage({ id: 'page2', name: 'Page 2' })
     * ```
     *
     * @param partial - The partial of the shape to update.
     *
     * @public
     */
    updatePage(partial: RequiredKeys<TLPage, 'id'>, squashing?: boolean): this;
    /* Excluded from this release type: _updatePage */
    /**
     * Create a page.
     *
     * @example
     * ```ts
     * editor.createPage('New Page')
     * editor.createPage('New Page', 'page1')
     * ```
     *
     * @param id - The new page's id.
     * @param title - The new page's title.
     *
     * @public
     */
    createPage(title: string, id?: TLPageId, belowPageIndex?: string): this;
    /* Excluded from this release type: _createPage */
    /**
     * Duplicate a page.
     *
     * @param id - The id of the page to duplicate. Defaults to the current page.
     * @param createId - The id of the new page. Defaults to a new id.
     *
     * @public
     */
    duplicatePage(id?: TLPageId, createId?: TLPageId): this;
    /**
     * Delete a page.
     *
     * @example
     * ```ts
     * editor.deletePage('page1')
     * ```
     *
     * @param id - The id of the page to delete.
     *
     * @public
     */
    deletePage(id: TLPageId): void;
    /* Excluded from this release type: _deletePage */
    /* Excluded from this release type: _setInstancePageState */
    /* Excluded from this release type: _assets */
    /**
     * Get all assets in the editor.
     *
     * @public
     */
    get assets(): (TLBookmarkAsset | TLImageAsset | TLVideoAsset)[];
    /**
     * Create one or more assets.
     *
     * @example
     * ```ts
     * editor.createAssets([...myAssets])
     * ```
     *
     * @param assets - The assets to create.
     *
     * @public
     */
    createAssets(assets: TLAsset[]): this;
    /* Excluded from this release type: _createAssets */
    /**
     * Delete one or more assets.
     *
     * @example
     * ```ts
     * editor.deleteAssets(['asset1', 'asset2'])
     * ```
     *
     * @param ids - The assets to delete.
     *
     * @public
     */
    deleteAssets(ids: TLAssetId[]): this;
    /* Excluded from this release type: _deleteAssets */
    /**
     * Update one or more assets.
     *
     * @example
     * ```ts
     * editor.updateAssets([{ id: 'asset1', name: 'New name' }])
     * ```
     *
     * @param assets - The assets to update.
     *
     * @public
     */
    updateAssets(assets: TLAssetPartial[]): this;
    /* Excluded from this release type: _updateAssets */
    /**
     * Get an asset by its src property.
     *
     * @example
     * ```ts
     * editor.getAssetBySource('https://example.com/image.png')
     * ```
     *
     * @param src - The source value of the asset.
     *
     * @public
     */
    getAssetBySrc(src: string): TLBookmarkAsset | TLImageAsset | TLVideoAsset | undefined;
    /**
     * Get an asset by its id.
     *
     * @example
     * ```ts
     * editor.getAssetById('asset1')
     * ```
     *
     * @param id - The id of the asset.
     *
     * @public
     */
    getAssetById(id: TLAssetId): TLAsset | undefined;
    /**
     * Rename a page.
     *
     * @example
     * ```ts
     * editor.renamePage('page1', 'My Page')
     * ```
     *
     * @param id - The id of the page to rename.
     * @param name - The new name.
     *
     * @public
     */
    renamePage(id: TLPageId, name: string, squashing?: boolean): this;
    /**
     * Move shapes to page.
     *
     * @example
     * ```ts
     * editor.moveShapesToPage(['box1', 'box2'], 'page1')
     * ```
     *
     * @param ids - The ids of the shapes to move.
     * @param pageId - The id of the page where the shapes will be moved.
     *
     * @public
     */
    moveShapesToPage(ids: TLShapeId[], pageId: TLPageId): this;
    /**
     * Toggle the lock state of one or more shapes. If there is a mix of locked and unlocked shapes, all shapes will be locked.
     *
     * @param ids - The ids of the shapes to toggle. Defaults to selected shapes.
     *
     * @public
     */
    toggleLock(ids?: TLShapeId[]): this;
    /**
     * Reorder shapes.
     *
     * @param operation - The operation to perform.
     * @param ids - The ids to reorder.
     *
     * @public
     */
    reorderShapes(operation: 'backward' | 'forward' | 'toBack' | 'toFront', ids: TLShapeId[]): this;
    /**
     * Send shapes to the back of the page's object list.
     *
     * @example
     * ```ts
     * editor.sendToBack()
     * editor.sendToBack(['id1', 'id2'])
     * ```
     *
     * @param ids - The ids of the shapes to move. Defaults to the ids of the selected shapes.
     *
     * @public
     */
    sendToBack(ids?: TLShapeId[]): this;
    /**
     * Send shapes backward in the page's object list.
     *
     * @example
     * ```ts
     * editor.sendBackward()
     * editor.sendBackward(['id1', 'id2'])
     * ```
     *
     * @param ids - The ids of the shapes to move. Defaults to the ids of the selected shapes.
     *
     * @public
     */
    sendBackward(ids?: TLShapeId[]): this;
    /**
     * Bring shapes forward in the page's object list.
     *
     * @example
     * ```ts
     * editor.bringForward()
     * editor.bringForward(['id1', 'id2'])
     * ```
     *
     * @param ids - The ids of the shapes to move. Defaults to the ids of the selected shapes.
     *
     * @public
     */
    bringForward(ids?: TLShapeId[]): this;
    /**
     * Bring shapes to the front of the page's object list.
     *
     * @example
     * ```ts
     * editor.bringToFront()
     * editor.bringToFront(['id1', 'id2'])
     * ```
     *
     * @param ids - The ids of the shapes to move. Defaults to the ids of the selected shapes.
     *
     * @public
     */
    bringToFront(ids?: TLShapeId[]): this;
    /**
     * Flip shape positions.
     *
     * @example
     * ```ts
     * editor.flipShapes('horizontal')
     * editor.flipShapes('horizontal', ['box1', 'box2'])
     * ```
     *
     * @param operation - Whether to flip horizontally or vertically.
     * @param ids - The ids of the shapes to flip. Defaults to selected shapes.
     *
     * @public
     */
    flipShapes(operation: 'horizontal' | 'vertical', ids?: TLShapeId[]): this;
    /**
     * Stack shape.
     *
     * @example
     * ```ts
     * editor.stackShapes('horizontal')
     * editor.stackShapes('horizontal', ['box1', 'box2'])
     * editor.stackShapes('horizontal', ['box1', 'box2'], 20)
     * ```
     *
     * @param operation - Whether to stack horizontally or vertically.
     * @param ids - The ids of the shapes to stack. Defaults to selected shapes.
     * @param gap - A specific gap to use when stacking.
     *
     * @public
     */
    stackShapes(operation: 'horizontal' | 'vertical', ids?: TLShapeId[], gap?: number): this;
    /**
     * Pack shapes into a grid centered on their current position. Based on potpack
     * (https://github.com/mapbox/potpack)
     * @param ids - The ids of the shapes to pack. Defaults to selected shapes.
     * @param padding - The padding to apply to the packed shapes.
     */
    packShapes(ids?: TLShapeId[], padding?: number): this;
    /**
     * Align shape positions.
     *
     * @example
     * ```ts
     * editor.alignShapes('left')
     * editor.alignShapes('left', ['box1', 'box2'])
     * ```
     *
     * @param operation - The align operation to apply.
     * @param ids - The ids of the shapes to align. Defaults to selected shapes.
     *
     * @public
     */
    alignShapes(operation: 'bottom' | 'center-horizontal' | 'center-vertical' | 'left' | 'right' | 'top', ids?: TLShapeId[]): this;
    /**
     * Distribute shape positions.
     *
     * @example
     * ```ts
     * editor.distributeShapes('left')
     * editor.distributeShapes('left', ['box1', 'box2'])
     * ```
     *
     * @param operation - Whether to distribute shapes horizontally or vertically.
     * @param ids - The ids of the shapes to distribute. Defaults to selected shapes.
     *
     * @public
     */
    distributeShapes(operation: 'horizontal' | 'vertical', ids?: TLShapeId[]): this;
    /* Excluded from this release type: _resizeUnalignedShape */
    /* Excluded from this release type: _scalePagePoint */
    /**
     * Resize a shape.
     *
     * @param id - The id of the shape to resize.
     * @param scale - The scale factor to apply to the shape.
     * @param options - Additional options.
     *
     * @public
     */
    resizeShape(id: TLShapeId, scale: VecLike, options?: {
        initialBounds?: Box2d;
        scaleOrigin?: VecLike;
        scaleAxisRotation?: number;
        initialShape?: TLShape;
        initialPageTransform?: MatLike;
        dragHandle?: TLResizeHandle;
        mode?: TLResizeMode;
    }): this;
    /**
     * Stretch shape sizes and positions to fill their common bounding box.
     *
     * @example
     * ```ts
     * editor.stretchShapes('horizontal')
     * editor.stretchShapes('horizontal', ['box1', 'box2'])
     * ```
     *
     * @param operation - Whether to stretch shapes horizontally or vertically.
     * @param ids - The ids of the shapes to stretch. Defaults to selected shapes.
     *
     * @public
     */
    stretchShapes(operation: 'horizontal' | 'vertical', ids?: TLShapeId[]): this;
    /**
     * An array containing all of the shapes in the current page.
     *
     * @example
     * ```ts
     * editor.shapesArray
     * ```
     *
     * @readonly
     *
     * @public
     */
    get shapesArray(): TLShape[];
    /**
     * An array containing all of the shapes in the current page, sorted in z-index order (accounting
     * for nested shapes): e.g. A, B, BA, BB, C.
     *
     * @example
     * ```ts
     * editor.sortedShapesArray
     * ```
     *
     * @readonly
     *
     * @public
     */
    get sortedShapesArray(): TLShape[];
    /**
     * An array containing all of the currently selected shapes.
     *
     * @example
     * ```ts
     * editor.selectedShapes
     * ```
     *
     * @public
     * @readonly
     */
    get selectedShapes(): TLShape[];
    /**
     * The app's only selected shape.
     *
     * @example
     * ```ts
     * editor.onlySelectedShape
     * ```
     *
     * @returns Null if there is no shape or more than one selected shape, otherwise the selected
     *   shape.
     *
     * @public
     * @readonly
     */
    get onlySelectedShape(): null | TLShape;
    /**
     * Get whether a shape matches the type of a TLShapeUtil.
     *
     * @example
     * ```ts
     * const isArrowShape = isShapeOfType(someShape, ArrowShapeUtil)
     * ```
     *
     * @param util - the TLShapeUtil constructor to test against
     * @param shape - the shape to test
     *
     * @public
     */
    isShapeOfType<T extends TLUnknownShape>(shape: TLUnknownShape, util: {
        new (...args: any): ShapeUtil<T>;
        type: string;
    }): shape is T;
    /**
     * Get a shape by its id.
     *
     * @example
     * ```ts
     * editor.getShapeById('box1')
     * ```
     *
     * @param id - The id of the shape to get.
     *
     * @public
     */
    getShapeById<T extends TLShape = TLShape>(id: TLParentId): T | undefined;
    /**
     * Get the parent shape for a given shape. Returns undefined if the shape is the direct child of
     * the page.
     *
     * @example
     * ```ts
     * editor.getParentShape(myShape)
     * ```
     *
     * @public
     */
    getParentShape(shape?: TLShape): TLShape | undefined;
    /* Excluded from this release type: getShapeNearestSibling */
    /**
     * Get whether the given shape is the descendant of the given page.
     *
     * @example
     * ```ts
     * editor.isShapeInPage(myShape)
     * editor.isShapeInPage(myShape, 'page1')
     * ```
     *
     * @param shape - The shape to check.
     * @param pageId - The id of the page to check against. Defaults to the current page.
     *
     * @public
     */
    isShapeInPage(shape: TLShape, pageId?: TLPageId): boolean;
    /**
     * Get the id of the containing page for a given shape.
     *
     * @param shape - The shape to get the page id for.
     *
     * @returns The id of the page that contains the shape, or undefined if the shape is undefined.
     *
     * @public
     */
    getAncestorPageId(shape?: TLShape): TLPageId | undefined;
    /* Excluded from this release type: _parentIdsToChildIds */
    /**
     * Reparent shapes to a new parent. This operation preserves the shape's current page positions /
     * rotations.
     *
     * @example
     * ```ts
     * editor.reparentShapesById(['box1', 'box2'], 'frame1')
     * ```
     *
     * @param ids - The ids of the shapes to reparent.
     * @param parentId - The id of the new parent shape.
     * @param insertIndex - The index to insert the children.
     *
     * @public
     */
    reparentShapesById(ids: TLShapeId[], parentId: TLParentId, insertIndex?: string): this;
    /**
     * Get the index above the highest child of a given parent.
     *
     * @param parentId - The id of the parent.
     *
     * @returns The index.
     *
     * @public
     */
    getHighestIndexForParent(parentId: TLPageId | TLShapeId): string;
    /* Excluded from this release type: _childIdsCache */
    /**
     * Get an array of all the children of a shape.
     *
     * @example
     * ```ts
     * editor.getSortedChildIds('frame1')
     * ```
     *
     * @param parentId - The id of the parent shape.
     *
     * @public
     */
    getSortedChildIds(parentId: TLParentId): TLShapeId[];
    /**
     * Run a visitor function for all descendants of a shape.
     *
     * @example
     * ```ts
     * editor.visitDescendants('frame1', myCallback)
     * ```
     *
     * @param parentId - The id of the parent shape.
     * @param visitor - The visitor function.
     *
     * @public
     */
    visitDescendants(parentId: TLParentId, visitor: (id: TLShapeId) => false | void): void;
    /**
     * Get the shape ids of all descendants of the given shapes (including the shapes themselves).
     *
     * @param ids - The ids of the shapes to get descendants of.
     *
     * @returns The decscendant ids.
     *
     * @public
     */
    getShapeAndDescendantIds(ids: TLShapeId[]): Set<TLShapeId>;
    /**
     * Get the id of what should be the parent of a new shape at a given point. The parent can be a page or shape.
     *
     * @param point - The point to find the parent for.
     * @param shapeType - The type of shape that will be created.
     *
     * @returns The id of the parent.
     *
     * @public
     */
    getParentIdForNewShapeAtPoint(point: VecLike, shapeType: TLShape['type']): TLPageId | TLShapeId;
    /**
     * Get the shape that some shapes should be dropped on at a given point.
     *
     * @param point - The point to find the parent for.
     * @param droppingShapes - The shapes that are being dropped.
     *
     * @returns The shape to drop on.
     *
     * @public
     */
    getDroppingShape(point: VecLike, droppingShapes?: TLShape[]): TLUnknownShape | undefined;
    /**
     * Get the shape that should be selected when you click on a given shape, assuming there is
     * nothing already selected. It will not return anything higher than or including the current
     * focus layer.
     *
     * @param shape - The shape to get the outermost selectable shape for.
     * @param filter - A function to filter the selectable shapes.
     *
     * @returns The outermost selectable shape.
     *
     * @public
     */
    getOutermostSelectableShape(shape: TLShape, filter?: (shape: TLShape) => boolean): TLShape;
    /**
     * Set the current page.
     *
     * @example
     * ```ts
     * editor.setCurrentPageId('page1')
     * ```
     *
     * @param pageId - The id of the page to set as the current page.
     * @param options - Options for setting the current page.
     *
     * @public
     */
    setCurrentPageId(pageId: TLPageId, { stopFollowing }?: TLViewportOptions): this;
    /* Excluded from this release type: _setCurrentPageId */
    /**
     * Update the instance's state.
     *
     * @param partial - A partial object to update the instance state with.
     * @param ephemeral - Whether the change is ephemeral. Ephemeral changes don't get added to the undo/redo stack. Defaults to false.
     * @param squashing - Whether the change will be squashed into the existing history entry rather than creating a new one. Defaults to false.
     *
     * @public
     */
    updateInstanceState(partial: Partial<Omit<TLInstance, 'currentPageId'>>, ephemeral?: boolean, squashing?: boolean): this;
    /* Excluded from this release type: _updateInstanceState */
    /**
     * Set the current cursor.
     *
     * @example
     * ```ts
     * editor.setCursor({ type: 'default' })
     * editor.setCursor({ type: 'default', rotation: Math.PI / 2, color: 'red' })
     * ```
     *
     * @param cursor - A partial of the cursor object.
     *
     * @public
     */
    setCursor(cursor: Partial<TLCursor>): this;
    /**
     * Set the current scribble.
     *
     * @example
     * ```ts
     * editor.setScribble(nextScribble)
     * editor.setScribble() // clears the scribble
     * ```
     *
     * @param scribble - The new scribble object.
     *
     * @public
     */
    setScribble(scribble?: null | TLScribble): this;
    /**
     * Set the current brush.
     *
     * @example
     * ```ts
     * editor.setBrush({ x: 0, y: 0, w: 100, h: 100 })
     * editor.setBrush() // Clears the brush
     * ```
     *
     * @param brush - The brush box model to set, or null for no brush model.
     *
     * @public
     */
    setBrush(brush?: Box2dModel | null): this;
    /**
     * Set the current zoom brush.
     *
     * @example
     * ```ts
     * editor.setZoomBrush({ x: 0, y: 0, w: 100, h: 100 })
     * editor.setZoomBrush() // Clears the zoom
     * ```
     *
     * @param zoomBrush - The zoom box model to set, or null for no zoom model.
     *
     * @public
     */
    setZoomBrush(zoomBrush?: Box2dModel | null): this;
    /**
     * Rotate shapes by a delta in radians.
     *
     * @example
     * ```ts
     * editor.rotateShapesBy(['box1', 'box2'], Math.PI)
     * editor.rotateShapesBy(['box1', 'box2'], Math.PI / 2)
     * ```
     *
     * @param ids - The ids of the shapes to move.
     * @param delta - The delta in radians to apply to the selection rotation.
     */
    rotateShapesBy(ids: TLShapeId[], delta: number): this;
    /**
     * Move shapes by a delta.
     *
     * @example
     * ```ts
     * editor.nudgeShapes(['box1', 'box2'], { x: 0, y: 1 })
     * editor.nudgeShapes(['box1', 'box2'], { x: 0, y: 1 }, true)
     * ```
     *
     * @param ids - The ids of the shapes to move.
     * @param direction - The direction in which to move the shapes.
     * @param major - Whether this is a major nudge, e.g. a shift + arrow nudge.
     */
    nudgeShapes(ids: TLShapeId[], direction: Vec2dModel, major?: boolean, ephemeral?: boolean): this;
    /**
     * Duplicate shapes.
     *
     * @example
     * ```ts
     * editor.duplicateShapes()
     * editor.duplicateShapes(['id1', 'id2'])
     * editor.duplicateShapes(['id1', 'id2'], { x: 8, y: 8 })
     * ```
     *
     * @param ids - The ids of the shapes to duplicate. Defaults to the ids of the selected shapes.
     * @param offset - The offset (in pixels) to apply to the duplicated shapes.
     *
     * @public
     */
    duplicateShapes(ids?: TLShapeId[], offset?: VecLike): this;
    /**
     * Set the current opacity. This will effect any selected shapes, or the
     * next-created shape.
     *
     * @example
     * ```ts
     * editor.setOpacity(0.5)
     * editor.setOpacity(0.5, true)
     * ```
     *
     * @param opacity - The opacity to set. Must be a number between 0 and 1 inclusive.
     * @param ephemeral - Whether the opacity change is ephemeral. Ephemeral changes don't get added to the undo/redo stack. Defaults to false.
     * @param squashing - Whether the opacity change will be squashed into the existing history entry rather than creating a new one. Defaults to false.
     */
    setOpacity(opacity: number, ephemeral?: boolean, squashing?: boolean): this;
    /**
     * Set the current styles
     *
     * @example
     * ```ts
     * editor.setProp(DefaultColorStyle, 'red')
     * editor.setProp(DefaultColorStyle, 'red', true)
     * ```
     *
     * @param style - The style to set.
     * @param value - The value to set.
     * @param ephemeral - Whether the style change is ephemeral. Ephemeral changes don't get added to the undo/redo stack. Defaults to false.
     * @param squashing - Whether the style change will be squashed into the existing history entry rather than creating a new one. Defaults to false.
     *
     * @public
     */
    setStyle<T>(style: StyleProp<T>, value: T, ephemeral?: boolean, squashing?: boolean): this;
    /* Excluded from this release type: _willSetInitialBounds */
    /* Excluded from this release type: _setCamera */
    /**
     * Set the current camera.
     *
     * @example
     * ```ts
     * editor.setCamera(0, 0)
     * editor.setCamera(0, 0, 1)
     * ```
     *
     * @param x - The camera's x position.
     * @param y - The camera's y position.
     * @param z - The camera's z position. Defaults to the current zoom.
     * @param options - Options for the camera change.
     *
     * @public
     */
    setCamera(x: number, y: number, z?: number, { stopFollowing }?: TLViewportOptions): this;
    /**
     * Animate the camera.
     *
     * @example
     * ```ts
     * editor.animateCamera(0, 0)
     * editor.animateCamera(0, 0, 1)
     * editor.animateCamera(0, 0, 1, { duration: 1000, easing: (t) => t * t })
     * ```
     *
     * @param x - The camera's x position.
     * @param y - The camera's y position.
     * @param z - The camera's z position. Defaults to the current zoom.
     * @param opts - Options for the animation.
     *
     * @public
     */
    animateCamera(x: number, y: number, z?: number, opts?: TLAnimationOptions): this;
    /**
     * Center the camera on a point (in page space).
     *
     * @example
     * ```ts
     * editor.centerOnPoint(100, 100)
     * ```
     *
     * @param x - The x position of the point.
     * @param y - The y position of the point.
     * @param opts - The options for an animation.
     *
     * @public
     */
    centerOnPoint(x: number, y: number, opts?: TLAnimationOptions): this;
    /**
     * Move the camera to the nearest content.
     *
     * @public
     */
    zoomToContent(): this;
    /**
     * Zoom the camera to fit the current page's content in the viewport.
     *
     * @example
     * ```ts
     * editor.zoomToFit()
     * ```
     *
     * @public
     */
    zoomToFit(opts?: TLAnimationOptions): this;
    /**
     * Set the zoom back to 100%.
     *
     * @example
     * ```ts
     * editor.resetZoom()
     * ```
     *
     * @param opts - The options for an animation.
     *
     * @public
     */
    resetZoom(point?: Vec2d, opts?: TLAnimationOptions): this;
    /**
     * Zoom the camera in.
     *
     * @example
     * ```ts
     * editor.zoomIn()
     * editor.zoomIn(editor.viewportScreenCenter, { duration: 120 })
     * editor.zoomIn(editor.inputs.currentScreenPoint, { duration: 120 })
     * ```
     *
     * @param opts - The options for an animation.
     *
     * @public
     */
    zoomIn(point?: Vec2d, opts?: TLAnimationOptions): this;
    /**
     * Zoom the camera out.
     *
     * @example
     * ```ts
     * editor.zoomOut()
     * editor.zoomOut(editor.viewportScreenCenter, { duration: 120 })
     * editor.zoomOut(editor.inputs.currentScreenPoint, { duration: 120 })
     * ```
     *
     * @param opts - The options for an animation.
     *
     * @public
     */
    zoomOut(point?: Vec2d, opts?: TLAnimationOptions): this;
    /**
     * Zoom the camera to fit the current selection in the viewport.
     *
     * @example
     * ```ts
     * editor.zoomToSelection()
     * ```
     *
     * @param opts - The options for an animation.
     *
     * @public
     */
    zoomToSelection(opts?: TLAnimationOptions): this;
    /**
     * Pan or pan/zoom the selected ids into view. This method tries to not change the zoom if possible.
     *
     * @param ids - The ids of the shapes to pan and zoom into view.
     * @param opts - The options for an animation.
     *
     * @public
     */
    panZoomIntoView(ids: TLShapeId[], opts?: TLAnimationOptions): this;
    /**
     * Zoom the camera to fit a bounding box (in page space).
     *
     * @example
     * ```ts
     * editor.zoomToBounds(0, 0, 100, 100)
     * ```
     *
     * @param x - The bounding box's x position.
     * @param y - The bounding box's y position.
     * @param width - The bounding box's width.
     * @param height - The bounding box's height.
     * @param targetZoom - The desired zoom level. Defaults to 0.1.
     *
     * @public
     */
    zoomToBounds(x: number, y: number, width: number, height: number, targetZoom?: number, opts?: TLAnimationOptions): this;
    /**
     * Pan the camera.
     *
     * @example
     * ```ts
     * editor.pan(100, 100)
     * editor.pan(100, 100, { duration: 1000 })
     * ```
     *
     * @param dx - The amount to pan on the x axis.
     * @param dy - The amount to pan on the y axis.
     * @param opts - The animation options
     */
    pan(dx: number, dy: number, opts?: TLAnimationOptions): this;
    /**
     * Stop the current camera animation, if any.
     *
     * @public
     */
    stopCameraAnimation(): this;
    /* Excluded from this release type: _viewportAnimation */
    /* Excluded from this release type: _animateViewport */
    /* Excluded from this release type: _animateToViewport */
    /**
     * Slide the camera in a certain direction.
     *
     * @param opts - Options for the slide
     * @public
     */
    slideCamera(opts?: {
        speed: number;
        direction: Vec2d;
        friction: number;
        speedThreshold?: number | undefined;
    }): this | undefined;
    /**
     * Animate the camera to a user's cursor position.
     * This also briefly show the user's cursor if it's not currently visible.
     *
     * @param userId - The id of the user to aniamte to.
     * @public
     */
    animateToUser(userId: string): void;
    /**
     * Start viewport-following a user.
     *
     * @param userId - The id of the user to follow.
     *
     * @public
     */
    startFollowingUser(userId: string): this | undefined;
    /**
     * Stop viewport-following a user.
     *
     * @public
     */
    stopFollowingUser(): this;
    /**
     * Animate the camera to a shape.
     *
     * @public
     */
    animateToShape(shapeId: TLShapeId, opts?: TLAnimationOptions): this;
    /**
     * Blur the app, cancelling any interaction state.
     *
     * @example
     * ```ts
     * editor.blur()
     * ```
     *
     * @public
     */
    blur(): this;
    /**
     * Focus the editor.
     *
     * @example
     * ```ts
     * editor.focus()
     * ```
     *
     * @public
     */
    focus(): this;
    /**
     * Dispatch a cancel event.
     *
     * @example
     * ```ts
     * editor.cancel()
     * ```
     *
     * @public
     */
    cancel(): this;
    /**
     * Dispatch an interrupt event.
     *
     * @example
     * ```ts
     * editor.interrupt()
     * ```
     *
     * @public
     */
    interrupt(): this;
    /**
     * Dispatch a complete event.
     *
     * @example
     * ```ts
     * editor.complete()
     * ```
     *
     * @public
     */
    complete(): this;
    /**
     * Handle external content, such as files, urls, embeds, or plain text which has been put into the app, for example by pasting external text or dropping external images onto canvas.
     *
     * @param info - Info about the external content.
     */
    putExternalContent(info: TLExternalContent): Promise<void>;
    /**
     * A helper for measuring text.
     *
     * @public
     */
    textMeasure: TextManager;
    /**
     * Group some shapes together.
     *
     * @param ids - Ids of the shapes to group. Defaults to the selected shapes.
     * @param groupId - Id of the group to create. Defaults to a new shape id.
     *
     * @public
     */
    groupShapes(ids?: TLShapeId[], groupId?: TLShapeId): this;
    /**
     * Ungroup some shapes.
     *
     * @param ids - Ids of the shapes to ungroup. Defaults to the selected shapes.
     *
     * @public
     */
    ungroupShapes(ids?: TLShapeId[]): this;
    /**
     * Get an exported SVG of the given shapes.
     *
     * @param ids - The ids of the shapes to export. Defaults to selected shapes.
     * @param opts - Options for the export.
     *
     * @returns The SVG element.
     *
     * @public
     */
    getSvg(ids?: TLShapeId[], opts?: Partial<{
        scale: number;
        background: boolean;
        padding: number;
        darkMode?: boolean | undefined;
        preserveAspectRatio: React.SVGAttributes<SVGSVGElement>['preserveAspectRatio'];
    }>): Promise<SVGSVGElement | undefined>;
}

/** @public */
export declare const EmbedShape: TLShapeInfo<TLEmbedShape>;

/** @public */
export declare class EmbedShapeUtil extends BaseBoxShapeUtil<TLEmbedShape> {
    static type: "embed";
    hideSelectionBoundsBg: TLShapeUtilFlag<TLEmbedShape>;
    hideSelectionBoundsFg: TLShapeUtilFlag<TLEmbedShape>;
    canEdit: TLShapeUtilFlag<TLEmbedShape>;
    canUnmount: TLShapeUtilFlag<TLEmbedShape>;
    canResize: (shape: TLEmbedShape) => boolean;
    defaultProps(): TLEmbedShape['props'];
    isAspectRatioLocked: TLShapeUtilFlag<TLEmbedShape>;
    onResize: TLOnResizeHandler<TLEmbedShape>;
    component(shape: TLEmbedShape): JSX.Element;
    indicator(shape: TLEmbedShape): JSX.Element;
}

declare class EmptyStackItem<T> implements Iterable<T> {
    readonly length = 0;
    readonly head: null;
    readonly tail: Stack<T>;
    push(head: T): Stack<T>;
    toArray(): [];
    [Symbol.iterator](): {
        next(): {
            value: undefined;
            done: true;
        };
    };
}

/** @public */
export declare class ErrorBoundary extends React_3.Component<React_3.PropsWithRef<React_3.PropsWithChildren<TLErrorBoundaryProps>>, TLErrorBoundaryState> {
    static getDerivedStateFromError(error: Error): {
        error: Error;
    };
    state: TLErrorBoundaryState;
    componentDidCatch(error: unknown): void;
    render(): React_3.ReactNode;
}

/** @public */
export declare function ErrorScreen({ children }: {
    children: any;
}): JSX.Element;

/** @public */
export declare const EVENT_NAME_MAP: Record<Exclude<TLEventName, TLPinchEventName>, keyof TLEventHandlers>;

declare type ExtractData<Fn> = Fn extends CommandFn<infer Data> ? Data : never;

/* Excluded from this release type: extractSessionStateFromLegacySnapshot */

/* Excluded from this release type: featureFlags */

/**
 * Convert a file to base64.
 *
 * @example
 *
 * ```ts
 * const A = fileToBase64('./test.png')
 * ```
 *
 * @param value - The file as a blob.
 * @public
 */
export declare function fileToBase64(file: Blob): Promise<string>;

/** @public */
export declare const FrameShape: TLShapeInfo<TLFrameShape>;

/** @public */
export declare class FrameShapeUtil extends BaseBoxShapeUtil<TLFrameShape> {
    static type: "frame";
    canBind: () => boolean;
    canEdit: () => boolean;
    defaultProps(): TLFrameShape['props'];
    component(shape: TLFrameShape): JSX.Element;
    toSvg(shape: TLFrameShape, font: string, colors: TLExportColors): Promise<SVGElement> | SVGElement;
    indicator(shape: TLFrameShape): JSX.Element;
    canReceiveNewChildrenOfType: (shape: TLShape, _type: TLShape['type']) => boolean;
    providesBackgroundForChildren(): boolean;
    canDropShapes: (shape: TLFrameShape, _shapes: TLShape[]) => boolean;
    onDragShapesOver: (frame: TLFrameShape, shapes: TLShape[]) => {
        shouldHint: boolean;
    };
    onDragShapesOut: (_shape: TLFrameShape, shapes: TLShape[]) => void;
    onResizeEnd: TLOnResizeEndHandler<TLFrameShape>;
}

declare type Gap = {
    startNode: GapNode;
    endNode: GapNode;
    startEdge: [Vec2d, Vec2d];
    endEdge: [Vec2d, Vec2d];
    length: number;
    breadthIntersection: [number, number];
};

declare type GapNode = {
    id: TLShapeId;
    pageBounds: Box2d;
    isClosed: boolean;
};

declare type GapsSnapLine = {
    id: string;
    type: 'gaps';
    direction: 'horizontal' | 'vertical';
    gaps: Array<{
        startEdge: [VecLike, VecLike];
        endEdge: [VecLike, VecLike];
    }>;
};

/** @public */
export declare const GeoShape: TLShapeInfo<TLGeoShape>;

/** @public */
export declare class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {
    static type: "geo";
    canEdit: () => boolean;
    defaultProps(): TLGeoShape['props'];
    hitTestLineSegment(shape: TLGeoShape, A: VecLike, B: VecLike): boolean;
    hitTestPoint(shape: TLGeoShape, point: VecLike): boolean;
    getBounds(shape: TLGeoShape): Box2d;
    getCenter(shape: TLGeoShape): Vec2d;
    getOutline(shape: TLGeoShape): Vec2d[];
    onEditEnd: TLOnEditEndHandler<TLGeoShape>;
    component(shape: TLGeoShape): JSX.Element;
    indicator(shape: TLGeoShape): JSX.Element;
    toSvg(shape: TLGeoShape, font: string, colors: TLExportColors): SVGElement;
    onResize: TLOnResizeHandler<TLGeoShape>;
    onBeforeCreate: (shape: TLGeoShape) => {
        props: {
            growY: number;
            geo: "arrow-down" | "arrow-left" | "arrow-right" | "arrow-up" | "check-box" | "diamond" | "ellipse" | "hexagon" | "octagon" | "oval" | "pentagon" | "rectangle" | "rhombus-2" | "rhombus" | "star" | "trapezoid" | "triangle" | "x-box";
            labelColor: "black" | "blue" | "green" | "grey" | "light-blue" | "light-green" | "light-red" | "light-violet" | "orange" | "red" | "violet" | "yellow";
            color: "black" | "blue" | "green" | "grey" | "light-blue" | "light-green" | "light-red" | "light-violet" | "orange" | "red" | "violet" | "yellow";
            fill: "none" | "pattern" | "semi" | "solid";
            dash: "dashed" | "dotted" | "draw" | "solid";
            size: "l" | "m" | "s" | "xl";
            font: "draw" | "mono" | "sans" | "serif";
            align: "end-legacy" | "end" | "middle-legacy" | "middle" | "start-legacy" | "start";
            verticalAlign: "end" | "middle" | "start";
            url: string;
            w: number;
            h: number;
            text: string;
        };
        type: "geo";
        x: number;
        y: number;
        rotation: number;
        index: string;
        parentId: TLParentId;
        isLocked: boolean;
        opacity: number;
        id: TLShapeId;
        typeName: "shape";
    } | undefined;
    onBeforeUpdate: (prev: TLGeoShape, next: TLGeoShape) => {
        props: {
            growY: number;
            geo: "arrow-down" | "arrow-left" | "arrow-right" | "arrow-up" | "check-box" | "diamond" | "ellipse" | "hexagon" | "octagon" | "oval" | "pentagon" | "rectangle" | "rhombus-2" | "rhombus" | "star" | "trapezoid" | "triangle" | "x-box";
            labelColor: "black" | "blue" | "green" | "grey" | "light-blue" | "light-green" | "light-red" | "light-violet" | "orange" | "red" | "violet" | "yellow";
            color: "black" | "blue" | "green" | "grey" | "light-blue" | "light-green" | "light-red" | "light-violet" | "orange" | "red" | "violet" | "yellow";
            fill: "none" | "pattern" | "semi" | "solid";
            dash: "dashed" | "dotted" | "draw" | "solid";
            size: "l" | "m" | "s" | "xl";
            font: "draw" | "mono" | "sans" | "serif";
            align: "end-legacy" | "end" | "middle-legacy" | "middle" | "start-legacy" | "start";
            verticalAlign: "end" | "middle" | "start";
            url: string;
            w: number;
            h: number;
            text: string;
        };
        type: "geo";
        x: number;
        y: number;
        rotation: number;
        index: string;
        parentId: TLParentId;
        isLocked: boolean;
        opacity: number;
        id: TLShapeId;
        typeName: "shape";
    } | undefined;
    onDoubleClick: (shape: TLGeoShape) => {
        props: {
            geo: "check-box";
        };
        type: "geo";
        x: number;
        y: number;
        rotation: number;
        index: string;
        parentId: TLParentId;
        isLocked: boolean;
        opacity: number;
        id: TLShapeId;
        typeName: "shape";
    } | {
        props: {
            geo: "rectangle";
        };
        type: "geo";
        x: number;
        y: number;
        rotation: number;
        index: string;
        parentId: TLParentId;
        isLocked: boolean;
        opacity: number;
        id: TLShapeId;
        typeName: "shape";
    } | undefined;
}

/**
 * Tests whether an URL supports embedding and returns the result. If we encounter an error, we
 * return undefined.
 *
 * @param inputUrl - The URL to match
 * @public
 */
export declare function getEmbedInfo(inputUrl: string): TLEmbedResult;

/**
 * Tests whether an URL supports embedding and returns the result.
 *
 * @param inputUrl - The URL to match
 * @public
 */
export declare function getEmbedInfoUnsafely(inputUrl: string): TLEmbedResult;

/**
 * Get some metadata about the file
 *
 * @param file - The file.
 * @public
 */
export declare function getFileMetaData(file: File): Promise<{
    isAnimated: boolean;
}>;

/** @public */
export declare function getFreshUserPreferences(): TLUserPreferences;

export { getHashForString }

/**
 * Get the size of an image from its source.
 *
 * @param dataURL - The file as a string.
 * @public
 */
export declare function getImageSizeFromSrc(dataURL: string): Promise<{
    w: number;
    h: number;
}>;

/**
 * Get an incremented name (e.g. New page (2)) from a name (e.g. New page), based on an array of
 * existing names.
 *
 * @param name - The name to increment.
 * @param others - The array of existing names.
 * @public
 */
export declare function getIncrementedName(name: string, others: string[]): string;

/**
 * Get an asset from a file.
 *
 * @param file - The file.
 * @returns An image or video asset partial.
 * @public
 */
export declare function getMediaAssetFromFile(file: File): Promise<TLAsset>;

/* Excluded from this release type: getPointerInfo */

/**
 * Get the size of an image from its source.
 *
 * @param dataURLForImage - The image file as a string.
 * @param width - The desired width.
 * @param height - The desired height.
 * @public
 */
export declare function getResizedImageDataUrl(dataURLForImage: string, width: number, height: number): Promise<string>;

/** @public */
export declare function getRotatedBoxShadow(rotation: number): string;

/** @public */
export declare function getSplineForLineShape(shape: TLLineShape): NonNullable<CubicSpline2d | Polyline2d>;

/** @public */
export declare function getSvgAsDataUrl(svg: SVGElement): Promise<string>;

/** @public */
export declare function getSvgAsDataUrlSync(node: SVGElement): string;

/** @public */
export declare function getSvgAsImage(svg: SVGElement, options: {
    type: TLCopyType | TLExportType;
    quality: number;
    scale: number;
}): Promise<Blob | null>;

/** @public */
export declare function getSvgAsString(svg: SVGElement): string;

/**
 * Turn an array of points into a path of quadradic curves.
 *
 * @param points - The points returned from perfect-freehand
 * @param closed - Whether the stroke is closed
 * @public
 */
export declare function getSvgPathFromStroke(points: Vec2d[], closed?: boolean): string;

/**
 * Turn an array of stroke points into a path of quadradic curves.
 *
 * @param points - The stroke points returned from perfect-freehand
 * @param closed - Whether the shape is closed
 * @public
 */
export declare function getSvgPathFromStrokePoints(points: StrokePoint[], closed?: boolean): string;

/** @public */
export declare function getTextBoundingBox(text: SVGTextElement): DOMRect;

declare function getTranslatingSnapshot(editor: Editor): {
    averagePagePoint: Vec2d;
    movingShapes: TLShape[];
    shapeSnapshots: MovingShapeSnapshot[];
    initialPageBounds: Box2d;
    initialSnapPoints: {
        id: string;
        x: number;
        y: number;
    }[];
};

/** @public */
export declare function getUserPreferences(): TLUserPreferences;

/** @public */
export declare const getValidHttpURLList: (url: string) => string[] | undefined;

/**
 * Get the size of a video from its source.
 *
 * @param src - The source of the video.
 * @public
 */
export declare function getVideoSizeFromSrc(src: string): Promise<{
    w: number;
    h: number;
}>;

/* Excluded from this release type: GRID_INCREMENT */

/** @public */
export declare const GRID_STEPS: {
    min: number;
    mid: number;
    step: number;
}[];

/** @public */
export declare const GroupShape: TLShapeInfo<TLGroupShape>;

/** @public */
export declare class GroupShapeUtil extends ShapeUtil<TLGroupShape> {
    static type: "group";
    type: "group";
    hideSelectionBoundsBg: () => boolean;
    hideSelectionBoundsFg: () => boolean;
    canBind: () => boolean;
    defaultProps(): TLGroupShape['props'];
    getBounds(shape: TLGroupShape): Box2d;
    getCenter(shape: TLGroupShape): Vec2d;
    getOutline(shape: TLGroupShape): Vec2d[];
    component(shape: TLGroupShape): JSX.Element | null;
    indicator(shape: TLGroupShape): JSX.Element;
    onChildrenChange: TLOnChildrenChangeHandler<TLGroupShape>;
}

/* Excluded from this release type: HAND_TOOL_FRICTION */

/**
 * Clear the database of all data associated with tldraw.
 *
 * @public */
export declare function hardReset({ shouldReload }?: {
    shouldReload?: boolean | undefined;
}): Promise<void>;

/** @public */
export declare function hardResetEditor(): void;

/* Excluded from this release type: HASH_PATERN_ZOOM_NAMES */

/** @public */
export declare const HighlightShape: TLShapeInfo<TLHighlightShape>;

/** @public */
export declare class HighlightShapeUtil extends ShapeUtil<TLHighlightShape> {
    static type: "highlight";
    hideResizeHandles: (shape: TLHighlightShape) => boolean;
    hideRotateHandle: (shape: TLHighlightShape) => boolean;
    hideSelectionBoundsBg: (shape: TLHighlightShape) => boolean;
    hideSelectionBoundsFg: (shape: TLHighlightShape) => boolean;
    defaultProps(): TLHighlightShape['props'];
    getBounds(shape: TLHighlightShape): Box2d;
    getOutline(shape: TLHighlightShape): Vec2d[];
    getCenter(shape: TLHighlightShape): Vec2d;
    hitTestPoint(shape: TLHighlightShape, point: VecLike): boolean;
    hitTestLineSegment(shape: TLHighlightShape, A: VecLike, B: VecLike): boolean;
    component(shape: TLHighlightShape): JSX.Element;
    renderBackground(shape: TLHighlightShape): JSX.Element;
    indicator(shape: TLHighlightShape): JSX.Element;
    expandSelectionOutlinePx(shape: TLHighlightShape): number;
    toSvg(shape: TLHighlightShape, _font: string | undefined, colors: TLExportColors): SVGPathElement;
    toBackgroundSvg(shape: TLHighlightShape, font: string | undefined, colors: TLExportColors): SVGPathElement;
    onResize: TLOnResizeHandler<TLHighlightShape>;
}

declare class HistoryManager<CTX extends {
    emit: (name: 'change-history' | 'mark-history', ...args: any) => void;
}> {
    private readonly ctx;
    private readonly onBatchComplete;
    private readonly annotateError;
    _undos: Atom<Stack<TLHistoryEntry>, unknown>;
    _redos: Atom<Stack<TLHistoryEntry>, unknown>;
    _batchDepth: number;
    constructor(ctx: CTX, onBatchComplete: () => void, annotateError: (error: unknown) => void);
    private _commands;
    get numUndos(): number;
    get numRedos(): number;
    createCommand: <Name extends string, Constructor extends CommandFn<any>>(name: Name, constructor: Constructor, handle: TLCommandHandler<ExtractData<Constructor>>) => (...args: Parameters<Extract<Constructor, (...args: any[]) => any>>) => CTX;
    batch: (fn: () => void) => this;
    private ignoringUpdates;
    private _undo;
    undo: () => this;
    redo: () => this;
    bail: () => this;
    bailToMark: (id: string) => this;
    mark: (id?: string, onUndo?: boolean, onRedo?: boolean) => string;
    clear(): void;
}

/** @public */
export declare function HTMLContainer({ children, className, ...rest }: HTMLContainerProps): JSX.Element;

/** @public */
export declare type HTMLContainerProps = React_3.HTMLAttributes<HTMLDivElement>;

declare class Idle extends StateNode {
    static id: string;
    onEnter: () => void;
    onExit: TLExitEventHandler;
    onCancel: TLEventHandlers['onCancel'];
    onPointerDown: TLEventHandlers['onPointerDown'];
    onDoubleClick: TLEventHandlers['onDoubleClick'];
    onKeyDown: TLEventHandlers['onKeyDown'];
    onKeyRepeat: TLEventHandlers['onKeyRepeat'];
    onKeyUp: TLEventHandlers['onKeyUp'];
    private cancel;
    private cleanupCroppingState;
    private nudgeCroppingImage;
}

declare class Idle_2 extends StateNode {
    static id: string;
    isDarwin: boolean;
    onPointerEnter: TLEventHandlers['onPointerEnter'];
    onPointerLeave: TLEventHandlers['onPointerLeave'];
    onPointerDown: TLEventHandlers['onPointerDown'];
    onDoubleClick: TLEventHandlers['onDoubleClick'];
    onRightClick: TLEventHandlers['onRightClick'];
    onEnter: () => void;
    onCancel: TLEventHandlers['onCancel'];
    onKeyDown: TLEventHandlers['onKeyDown'];
    onKeyRepeat: TLEventHandlers['onKeyDown'];
    onKeyUp: (info: TLKeyboardEventInfo) => void;
    private shouldStartEditingShape;
    private shouldEnterCropMode;
    private startEditingShape;
    handleDoubleClickOnCanvas(info: TLClickEventInfo): void;
    private nudgeSelectedShapes;
}

declare class Idle_3 extends StateNode {
    static id: string;
    info: TLPointerEventInfo & {
        onInteractionEnd?: string | undefined;
    };
    onEnter: (info: TLPointerEventInfo & {
        onInteractionEnd: string;
    }) => void;
    onPointerDown: TLEventHandlers['onPointerUp'];
}

declare class Idle_4 extends StateNode {
    static id: string;
    onPointerDown: TLEventHandlers['onPointerDown'];
    onEnter: () => void;
    onCancel: () => void;
}

/** @public */
export declare const ImageShape: TLShapeInfo<TLImageShape>;

/** @public */
export declare class ImageShapeUtil extends BaseBoxShapeUtil<TLImageShape> {
    static type: "image";
    isAspectRatioLocked: () => boolean;
    canCrop: () => boolean;
    defaultProps(): TLImageShape['props'];
    component(shape: TLImageShape): JSX.Element;
    indicator(shape: TLImageShape): JSX.Element | null;
    toSvg(shape: TLImageShape): Promise<SVGGElement>;
    onDoubleClick: (shape: TLImageShape) => void;
    onDoubleClickEdge: TLOnDoubleClickHandler<TLImageShape>;
}

/**	@public */
export declare const INDENT = "  ";

/**
 * Checks if buffer contains animated GIF image
 *
 * @public
 */
export declare function isAnimated(buffer: ArrayBuffer): boolean;

/**
 * Checks if buffer contains GIF image
 *
 * @public
 */
export declare function isGIF(buffer: ArrayBuffer): boolean;

/** @public */
export declare const isImage: (ext: string) => boolean;

/**
 * Get whether a value is serializable.
 *
 * @example
 *
 * ```ts
 * const A = isSerializable(1) // true
 * const B = isSerializable('a') // true
 * const C = isSerializable(true) // true
 * const D = isSerializable(undefined) // false
 * ```
 *
 * @param value - The value to check.
 * @public
 */
export declare function isSerializable(value: any): boolean;

/** @public */
export declare const isSvgText: (text: string) => boolean;

/** @public */
export declare const isValidHttpURL: (url: string) => boolean;

/** @public */
export declare function isValidUrl(url: string): boolean;

/** @public */
export declare const LineShape: TLShapeInfo<TLLineShape>;

/** @public */
export declare class LineShapeUtil extends ShapeUtil<TLLineShape> {
    static type: "line";
    hideResizeHandles: () => boolean;
    hideRotateHandle: () => boolean;
    hideSelectionBoundsBg: () => boolean;
    hideSelectionBoundsFg: () => boolean;
    isClosed: () => boolean;
    defaultProps(): TLLineShape['props'];
    getBounds(shape: TLLineShape): Box2d;
    getCenter(shape: TLLineShape): Vec2d;
    getHandles(shape: TLLineShape): TLHandle[];
    getOutline(shape: TLLineShape): Vec2d[];
    getOutlineSegments(shape: TLLineShape): Vec2d[][];
    onResize: TLOnResizeHandler<TLLineShape>;
    onHandleChange: TLOnHandleChangeHandler<TLLineShape>;
    hitTestPoint(shape: TLLineShape, point: Vec2d): boolean;
    hitTestLineSegment(shape: TLLineShape, A: VecLike, B: VecLike): boolean;
    component(shape: TLLineShape): JSX.Element | undefined;
    indicator(shape: TLLineShape): JSX.Element;
    toSvg(shape: TLLineShape, _font: string, colors: TLExportColors): SVGGElement;
}

/** @public */
export declare function LoadingScreen({ children }: {
    children: any;
}): JSX.Element;

/**
 * Loads a snapshot of the editor's instance state into the store of a new editor instance.
 *
 * @public
 * @param store - The store to load the instance state into
 * @param snapshot - The instance state snapshot to load
 * @returns
 */
export declare function loadSessionStateSnapshotIntoStore(store: TLStore, snapshot: TLSessionStateSnapshot): void;

/** @public */
export declare function loopToHtmlElement(elm: Element): HTMLElement;

/* Excluded from this release type: MAJOR_NUDGE_FACTOR */

/** @public */
export declare function matchEmbedUrl(url: string): {
    definition: {
        readonly type: "codepen";
        readonly title: "Codepen";
        readonly hostnames: readonly ["codepen.io"];
        readonly minWidth: 300;
        readonly minHeight: 300;
        readonly width: 520;
        readonly height: 400;
        readonly doesResize: true;
        readonly canUnmount: false;
        readonly toEmbedUrl: (url: string) => string | undefined;
        readonly fromEmbedUrl: (url: string) => string | undefined;
    } | {
        readonly type: "codesandbox";
        readonly title: "CodeSandbox";
        readonly hostnames: readonly ["codesandbox.io"];
        readonly minWidth: 300;
        readonly minHeight: 300;
        readonly width: 720;
        readonly height: 500;
        readonly doesResize: true;
        readonly canUnmount: false;
        readonly toEmbedUrl: (url: string) => string | undefined;
        readonly fromEmbedUrl: (url: string) => string | undefined;
    } | {
        readonly type: "excalidraw";
        readonly title: "Excalidraw";
        readonly hostnames: readonly ["excalidraw.com"];
        readonly width: 720;
        readonly height: 500;
        readonly doesResize: true;
        readonly canUnmount: false;
        readonly isAspectRatioLocked: true;
        readonly toEmbedUrl: (url: string) => string | undefined;
        readonly fromEmbedUrl: (url: string) => string | undefined;
    } | {
        readonly type: "felt";
        readonly title: "Felt";
        readonly hostnames: readonly ["felt.com"];
        readonly width: 720;
        readonly height: 500;
        readonly doesResize: true;
        readonly canUnmount: false;
        readonly toEmbedUrl: (url: string) => string | undefined;
        readonly fromEmbedUrl: (url: string) => string | undefined;
    } | {
        readonly type: "figma";
        readonly title: "Figma";
        readonly hostnames: readonly ["figma.com"];
        readonly width: 720;
        readonly height: 500;
        readonly doesResize: true;
        readonly canUnmount: true;
        readonly toEmbedUrl: (url: string) => string | undefined;
        readonly fromEmbedUrl: (url: string) => string | undefined;
    } | {
        readonly type: "github_gist";
        readonly title: "GitHub Gist";
        readonly hostnames: readonly ["gist.github.com"];
        readonly width: 720;
        readonly height: 500;
        readonly doesResize: true;
        readonly canUnmount: true;
        readonly toEmbedUrl: (url: string) => string | undefined;
        readonly fromEmbedUrl: (url: string) => string | undefined;
    } | {
        readonly type: "google_calendar";
        readonly title: "Google Calendar";
        readonly hostnames: readonly ["calendar.google.*"];
        readonly width: 720;
        readonly height: 500;
        readonly minWidth: 460;
        readonly minHeight: 360;
        readonly doesResize: true;
        readonly canUnmount: false;
        readonly instructionLink: "https://support.google.com/calendar/answer/41207?hl=en";
        readonly toEmbedUrl: (url: string) => string | undefined;
        readonly fromEmbedUrl: (url: string) => string | undefined;
    } | {
        readonly type: "google_maps";
        readonly title: "Google Maps";
        readonly hostnames: readonly ["google.*"];
        readonly width: 720;
        readonly height: 500;
        readonly doesResize: true;
        readonly canUnmount: false;
        readonly toEmbedUrl: (url: string) => string | undefined;
        readonly fromEmbedUrl: (url: string) => string | undefined;
    } | {
        readonly type: "google_slides";
        readonly title: "Google Slides";
        readonly hostnames: readonly ["docs.google.*"];
        readonly width: 720;
        readonly height: 500;
        readonly minWidth: 460;
        readonly minHeight: 360;
        readonly doesResize: true;
        readonly canUnmount: false;
        readonly toEmbedUrl: (url: string) => string | undefined;
        readonly fromEmbedUrl: (url: string) => string | undefined;
    } | {
        readonly type: "observable";
        readonly title: "Observable";
        readonly hostnames: readonly ["observablehq.com"];
        readonly width: 720;
        readonly height: 500;
        readonly doesResize: true;
        readonly canUnmount: false;
        readonly isAspectRatioLocked: false;
        readonly backgroundColor: "#fff";
        readonly toEmbedUrl: (url: string) => string | undefined;
        readonly fromEmbedUrl: (url: string) => string | undefined;
    } | {
        readonly type: "replit";
        readonly title: "Replit";
        readonly hostnames: readonly ["replit.com"];
        readonly width: 720;
        readonly height: 500;
        readonly doesResize: true;
        readonly canUnmount: false;
        readonly toEmbedUrl: (url: string) => string | undefined;
        readonly fromEmbedUrl: (url: string) => string | undefined;
    } | {
        readonly type: "scratch";
        readonly title: "Scratch";
        readonly hostnames: readonly ["scratch.mit.edu"];
        readonly width: 520;
        readonly height: 400;
        readonly doesResize: false;
        readonly canUnmount: false;
        readonly toEmbedUrl: (url: string) => string | undefined;
        readonly fromEmbedUrl: (url: string) => string | undefined;
    } | {
        readonly type: "spotify";
        readonly title: "Spotify";
        readonly hostnames: readonly ["open.spotify.com"];
        readonly width: 720;
        readonly height: 500;
        readonly minHeight: 500;
        readonly overrideOutlineRadius: 12;
        readonly doesResize: true;
        readonly canUnmount: false;
        readonly toEmbedUrl: (url: string) => string | undefined;
        readonly fromEmbedUrl: (url: string) => string | undefined;
    } | {
        readonly type: "tldraw";
        readonly title: "tldraw";
        readonly hostnames: readonly ["beta.tldraw.com", "lite.tldraw.com", "www.tldraw.com"];
        readonly minWidth: 300;
        readonly minHeight: 300;
        readonly width: 720;
        readonly height: 500;
        readonly doesResize: true;
        readonly canUnmount: true;
        readonly toEmbedUrl: (url: string) => string | undefined;
        readonly fromEmbedUrl: (url: string) => string | undefined;
    } | {
        readonly type: "vimeo";
        readonly title: "Vimeo";
        readonly hostnames: readonly ["vimeo.com", "player.vimeo.com"];
        readonly width: 640;
        readonly height: 360;
        readonly doesResize: true;
        readonly canUnmount: false;
        readonly isAspectRatioLocked: true;
        readonly toEmbedUrl: (url: string) => string | undefined;
        readonly fromEmbedUrl: (url: string) => string | undefined;
    } | {
        readonly type: "youtube";
        readonly title: "YouTube";
        readonly hostnames: readonly ["*.youtube.com", "youtube.com", "youtu.be"];
        readonly width: 800;
        readonly height: 450;
        readonly doesResize: true;
        readonly canUnmount: false;
        readonly overridePermissions: {
            readonly 'allow-presentation': true;
        };
        readonly isAspectRatioLocked: true;
        readonly toEmbedUrl: (url: string) => string | undefined;
        readonly fromEmbedUrl: (url: string) => string | undefined;
    };
    url: string;
    embedUrl: string;
} | undefined;

/** @public */
export declare function matchUrl(url: string): {
    definition: {
        readonly type: "codepen";
        readonly title: "Codepen";
        readonly hostnames: readonly ["codepen.io"];
        readonly minWidth: 300;
        readonly minHeight: 300;
        readonly width: 520;
        readonly height: 400;
        readonly doesResize: true;
        readonly canUnmount: false;
        readonly toEmbedUrl: (url: string) => string | undefined;
        readonly fromEmbedUrl: (url: string) => string | undefined;
    } | {
        readonly type: "codesandbox";
        readonly title: "CodeSandbox";
        readonly hostnames: readonly ["codesandbox.io"];
        readonly minWidth: 300;
        readonly minHeight: 300;
        readonly width: 720;
        readonly height: 500;
        readonly doesResize: true;
        readonly canUnmount: false;
        readonly toEmbedUrl: (url: string) => string | undefined;
        readonly fromEmbedUrl: (url: string) => string | undefined;
    } | {
        readonly type: "excalidraw";
        readonly title: "Excalidraw";
        readonly hostnames: readonly ["excalidraw.com"];
        readonly width: 720;
        readonly height: 500;
        readonly doesResize: true;
        readonly canUnmount: false;
        readonly isAspectRatioLocked: true;
        readonly toEmbedUrl: (url: string) => string | undefined;
        readonly fromEmbedUrl: (url: string) => string | undefined;
    } | {
        readonly type: "felt";
        readonly title: "Felt";
        readonly hostnames: readonly ["felt.com"];
        readonly width: 720;
        readonly height: 500;
        readonly doesResize: true;
        readonly canUnmount: false;
        readonly toEmbedUrl: (url: string) => string | undefined;
        readonly fromEmbedUrl: (url: string) => string | undefined;
    } | {
        readonly type: "figma";
        readonly title: "Figma";
        readonly hostnames: readonly ["figma.com"];
        readonly width: 720;
        readonly height: 500;
        readonly doesResize: true;
        readonly canUnmount: true;
        readonly toEmbedUrl: (url: string) => string | undefined;
        readonly fromEmbedUrl: (url: string) => string | undefined;
    } | {
        readonly type: "github_gist";
        readonly title: "GitHub Gist";
        readonly hostnames: readonly ["gist.github.com"];
        readonly width: 720;
        readonly height: 500;
        readonly doesResize: true;
        readonly canUnmount: true;
        readonly toEmbedUrl: (url: string) => string | undefined;
        readonly fromEmbedUrl: (url: string) => string | undefined;
    } | {
        readonly type: "google_calendar";
        readonly title: "Google Calendar";
        readonly hostnames: readonly ["calendar.google.*"];
        readonly width: 720;
        readonly height: 500;
        readonly minWidth: 460;
        readonly minHeight: 360;
        readonly doesResize: true;
        readonly canUnmount: false;
        readonly instructionLink: "https://support.google.com/calendar/answer/41207?hl=en";
        readonly toEmbedUrl: (url: string) => string | undefined;
        readonly fromEmbedUrl: (url: string) => string | undefined;
    } | {
        readonly type: "google_maps";
        readonly title: "Google Maps";
        readonly hostnames: readonly ["google.*"];
        readonly width: 720;
        readonly height: 500;
        readonly doesResize: true;
        readonly canUnmount: false;
        readonly toEmbedUrl: (url: string) => string | undefined;
        readonly fromEmbedUrl: (url: string) => string | undefined;
    } | {
        readonly type: "google_slides";
        readonly title: "Google Slides";
        readonly hostnames: readonly ["docs.google.*"];
        readonly width: 720;
        readonly height: 500;
        readonly minWidth: 460;
        readonly minHeight: 360;
        readonly doesResize: true;
        readonly canUnmount: false;
        readonly toEmbedUrl: (url: string) => string | undefined;
        readonly fromEmbedUrl: (url: string) => string | undefined;
    } | {
        readonly type: "observable";
        readonly title: "Observable";
        readonly hostnames: readonly ["observablehq.com"];
        readonly width: 720;
        readonly height: 500;
        readonly doesResize: true;
        readonly canUnmount: false;
        readonly isAspectRatioLocked: false;
        readonly backgroundColor: "#fff";
        readonly toEmbedUrl: (url: string) => string | undefined;
        readonly fromEmbedUrl: (url: string) => string | undefined;
    } | {
        readonly type: "replit";
        readonly title: "Replit";
        readonly hostnames: readonly ["replit.com"];
        readonly width: 720;
        readonly height: 500;
        readonly doesResize: true;
        readonly canUnmount: false;
        readonly toEmbedUrl: (url: string) => string | undefined;
        readonly fromEmbedUrl: (url: string) => string | undefined;
    } | {
        readonly type: "scratch";
        readonly title: "Scratch";
        readonly hostnames: readonly ["scratch.mit.edu"];
        readonly width: 520;
        readonly height: 400;
        readonly doesResize: false;
        readonly canUnmount: false;
        readonly toEmbedUrl: (url: string) => string | undefined;
        readonly fromEmbedUrl: (url: string) => string | undefined;
    } | {
        readonly type: "spotify";
        readonly title: "Spotify";
        readonly hostnames: readonly ["open.spotify.com"];
        readonly width: 720;
        readonly height: 500;
        readonly minHeight: 500;
        readonly overrideOutlineRadius: 12;
        readonly doesResize: true;
        readonly canUnmount: false;
        readonly toEmbedUrl: (url: string) => string | undefined;
        readonly fromEmbedUrl: (url: string) => string | undefined;
    } | {
        readonly type: "tldraw";
        readonly title: "tldraw";
        readonly hostnames: readonly ["beta.tldraw.com", "lite.tldraw.com", "www.tldraw.com"];
        readonly minWidth: 300;
        readonly minHeight: 300;
        readonly width: 720;
        readonly height: 500;
        readonly doesResize: true;
        readonly canUnmount: true;
        readonly toEmbedUrl: (url: string) => string | undefined;
        readonly fromEmbedUrl: (url: string) => string | undefined;
    } | {
        readonly type: "vimeo";
        readonly title: "Vimeo";
        readonly hostnames: readonly ["vimeo.com", "player.vimeo.com"];
        readonly width: 640;
        readonly height: 360;
        readonly doesResize: true;
        readonly canUnmount: false;
        readonly isAspectRatioLocked: true;
        readonly toEmbedUrl: (url: string) => string | undefined;
        readonly fromEmbedUrl: (url: string) => string | undefined;
    } | {
        readonly type: "youtube";
        readonly title: "YouTube";
        readonly hostnames: readonly ["*.youtube.com", "youtube.com", "youtu.be"];
        readonly width: 800;
        readonly height: 450;
        readonly doesResize: true;
        readonly canUnmount: false;
        readonly overridePermissions: {
            readonly 'allow-presentation': true;
        };
        readonly isAspectRatioLocked: true;
        readonly toEmbedUrl: (url: string) => string | undefined;
        readonly fromEmbedUrl: (url: string) => string | undefined;
    };
    embedUrl: string;
    url: string;
} | undefined;

/* Excluded from this release type: MAX_ASSET_HEIGHT */

/* Excluded from this release type: MAX_ASSET_WIDTH */

/* Excluded from this release type: MAX_PAGES */

/* Excluded from this release type: MAX_SHAPES_PER_PAGE */

/* Excluded from this release type: MAX_ZOOM */

/* Excluded from this release type: MIN_ZOOM */

/* Excluded from this release type: MINOR_NUDGE_FACTOR */

declare interface MovingShapeSnapshot {
    shape: TLShape;
    pagePoint: Vec2d;
    parentTransform: Matrix2dModel | null;
}

/* Excluded from this release type: MULTI_CLICK_DURATION */

/** @public */
export declare function normalizeWheel(event: React.WheelEvent<HTMLElement> | WheelEvent): {
    x: number;
    y: number;
    z: number;
};

/** @public */
export declare const NoteShape: TLShapeInfo<TLNoteShape>;

/** @public */
export declare class NoteShapeUtil extends ShapeUtil<TLNoteShape> {
    static type: "note";
    canEdit: () => boolean;
    hideResizeHandles: () => boolean;
    hideSelectionBoundsBg: () => boolean;
    hideSelectionBoundsFg: () => boolean;
    defaultProps(): TLNoteShape['props'];
    getHeight(shape: TLNoteShape): number;
    getBounds(shape: TLNoteShape): Box2d;
    getOutline(shape: TLNoteShape): Vec2d[];
    getCenter(_shape: TLNoteShape): Vec2d;
    component(shape: TLNoteShape): JSX.Element;
    indicator(shape: TLNoteShape): JSX.Element;
    toSvg(shape: TLNoteShape, font: string, colors: TLExportColors): SVGGElement;
    onBeforeCreate: (next: TLNoteShape) => {
        props: {
            growY: number;
            color: "black" | "blue" | "green" | "grey" | "light-blue" | "light-green" | "light-red" | "light-violet" | "orange" | "red" | "violet" | "yellow";
            size: "l" | "m" | "s" | "xl";
            font: "draw" | "mono" | "sans" | "serif";
            align: "end-legacy" | "end" | "middle-legacy" | "middle" | "start-legacy" | "start";
            verticalAlign: "end" | "middle" | "start";
            url: string;
            text: string;
        };
        type: "note";
        x: number;
        y: number;
        rotation: number;
        index: string;
        parentId: TLParentId;
        isLocked: boolean;
        opacity: number;
        id: TLShapeId;
        typeName: "shape";
    } | undefined;
    onBeforeUpdate: (prev: TLNoteShape, next: TLNoteShape) => {
        props: {
            growY: number;
            color: "black" | "blue" | "green" | "grey" | "light-blue" | "light-green" | "light-red" | "light-violet" | "orange" | "red" | "violet" | "yellow";
            size: "l" | "m" | "s" | "xl";
            font: "draw" | "mono" | "sans" | "serif";
            align: "end-legacy" | "end" | "middle-legacy" | "middle" | "start-legacy" | "start";
            verticalAlign: "end" | "middle" | "start";
            url: string;
            text: string;
        };
        type: "note";
        x: number;
        y: number;
        rotation: number;
        index: string;
        parentId: TLParentId;
        isLocked: boolean;
        opacity: number;
        id: TLShapeId;
        typeName: "shape";
    } | undefined;
    onEditEnd: TLOnEditEndHandler<TLNoteShape>;
}

/** @public */
export declare function openWindow(url: string, target?: string): void;

/* Excluded from this release type: OptionalErrorBoundary */

/** @public */
export declare class PlopManager {
    editor: Editor;
    constructor(editor: Editor);
    handleContent: (info: TLExternalContent) => Promise<void>;
    /**
     * Handle svg text from an external source. Feeling lucky? Overwrite this at runtime to change the way this type of external content is handled.
     *
     * @example
     * ```ts
     * editor.this.handleSvgText = myCustomMethod
     * ```
     *
     * @param editor - The editor instance.
     * @param info - The info object describing the external content.
     *
     * @public
     */
    handleSvgText(editor: Editor, { point, text }: Extract<TLExternalContent, {
        type: 'svg-text';
    }>): Promise<void>;
    /**
     * Handle embed info from an external source. Feeling lucky? Overwrite this at runtime to change the way this type of external content is handled.
     *
     * @example
     * ```ts
     * editor.this.handleEmbed = myCustomMethod
     * ```
     *
     * @param editor - The editor instance
     * @param info - The info object describing the external content.
     *
     * @public
     */
    handleEmbed(editor: Editor, { point, url, embed }: Extract<TLExternalContent, {
        type: 'embed';
    }>): Promise<void>;
    /**
     * Handle files from an external source. Feeling lucky? Overwrite this at runtime to change the way this type of external content is handled.
     *
     * @example
     * ```ts
     * editor.this.handleFiles = myCustomMethod
     * ```
     *
     * @param editor - The editor instance
     * @param info - The info object describing the external content.
     *
     * @public
     */
    handleFiles(editor: Editor, { point, files }: Extract<TLExternalContent, {
        type: 'files';
    }>): Promise<void>;
    /**
     * Handle plain text from an external source. Feeling lucky? Overwrite this at runtime to change the way this type of external content is handled.
     *
     * @example
     * ```ts
     * editor.this.handleText = myCustomMethod
     * ```
     *
     * @param editor - The editor instance
     * @param info - The info object describing the external content.
     *
     * @public
     */
    handleText(editor: Editor, { point, text }: Extract<TLExternalContent, {
        type: 'text';
    }>): Promise<void>;
    /**
     * Handle urls from an external source. Feeling lucky? Overwrite this at runtime to change the way this type of external content is handled.
     *
     * @example
     * ```ts
     * editor.this.handleUrl = myCustomMethod
     * ```
     *
     * @param editor - The editor instance
     * @param info - The info object describing the external content.
     *
     * @public
     */
    handleUrl: (editor: Editor, { point, url }: Extract<TLExternalContent, {
        type: 'url';
    }>) => Promise<void>;
    createShapesForAssets(editor: Editor, assets: TLAsset[], position: VecLike): Promise<void>;
    /**
     * Override this method to change how assets are created from files.
     *
     * @param editor - The editor instance
     * @param file - The file to create the asset from.
     */
    createAssetFromFile(_editor: Editor, file: File): Promise<TLAsset>;
    /**
     * Override me to change the way assets are created from urls.
     *
     * @param editor - The editor instance
     * @param url - The url to create the asset from
     */
    createAssetFromUrl(_editor: Editor, url: string): Promise<TLAsset>;
}

declare class Pointing extends StateNode {
    static id: string;
    info: TLPointerEventInfo & {
        onInteractionEnd?: string | undefined;
    };
    onEnter: (info: TLPointerEventInfo & {
        onInteractionEnd: string;
    }) => void;
    onPointerUp: TLEventHandlers['onPointerUp'];
    onPointerMove: TLEventHandlers['onPointerUp'];
    onCancel: TLEventHandlers['onCancel'];
    private complete;
    private cancel;
}

declare class Pointing_2 extends StateNode {
    static id: string;
    markId: string;
    wasFocusedOnEnter: boolean;
    onEnter: () => void;
    onPointerMove: TLEventHandlers['onPointerMove'];
    onPointerUp: TLEventHandlers['onPointerUp'];
    onCancel: TLEventHandlers['onCancel'];
    onComplete: TLEventHandlers['onComplete'];
    onInterrupt: TLEventHandlers['onInterrupt'];
    complete(): void;
    cancel(): void;
}

declare class PointingCanvas extends StateNode {
    static id: string;
    onEnter: () => void;
    _clickWasInsideFocusedGroup(): boolean;
    onPointerMove: TLEventHandlers['onPointerMove'];
    onPointerUp: TLEventHandlers['onPointerUp'];
    onComplete: TLEventHandlers['onComplete'];
    onInterrupt: () => void;
    private complete;
}

declare class PointingCrop extends StateNode {
    static id: string;
    onCancel: TLEventHandlers['onCancel'];
    onPointerMove: TLPointerEvent;
    onPointerUp: TLPointerEvent;
}

declare class PointingCropHandle extends StateNode {
    static id: string;
    private info;
    private updateCursor;
    onEnter: (info: TLPointingCropHandleInfo) => void;
    onPointerMove: TLEventHandlers['onPointerMove'];
    onPointerUp: TLEventHandlers['onPointerUp'];
    onCancel: TLEventHandlers['onCancel'];
    onComplete: TLEventHandlers['onComplete'];
    onInterrupt: () => void;
    private cancel;
}

declare class PointingHandle extends StateNode {
    static id: string;
    info: TLBaseEventInfo & {
        type: "pointer";
        name: TLPointerEventName;
        point: VecLike;
        pointerId: number;
        button: number;
        isPen: boolean;
    } & {
        target: "handle";
        shape: TLShape;
        handle: TLHandle;
    } & {
        target: 'handle';
    };
    onEnter: (info: TLPointerEventInfo & {
        target: 'handle';
    }) => void;
    onExit: () => void;
    onPointerUp: TLEventHandlers['onPointerUp'];
    onPointerMove: TLEventHandlers['onPointerMove'];
    onCancel: TLEventHandlers['onCancel'];
    onComplete: TLEventHandlers['onComplete'];
    onInterrupt: () => void;
    private cancel;
}

declare class PointingResizeHandle extends StateNode {
    static id: string;
    private info;
    private updateCursor;
    onEnter: (info: PointingResizeHandleInfo) => void;
    onPointerMove: TLEventHandlers['onPointerMove'];
    onPointerUp: TLEventHandlers['onPointerUp'];
    onCancel: TLEventHandlers['onCancel'];
    onComplete: TLEventHandlers['onComplete'];
    onInterrupt: () => void;
    private complete;
    private cancel;
}

declare type PointingResizeHandleInfo = Extract<TLPointerEventInfo, {
    target: 'selection';
}> & {
    onInteractionEnd?: string;
};

declare class PointingRotateHandle extends StateNode {
    static id: string;
    private info;
    private updateCursor;
    onEnter: (info: PointingRotateHandleInfo) => void;
    onPointerMove: () => void;
    onPointerUp: () => void;
    onCancel: TLEventHandlers['onCancel'];
    onComplete: TLEventHandlers['onComplete'];
    onInterrupt: () => void;
    private complete;
    private cancel;
}

declare type PointingRotateHandleInfo = Extract<TLPointerEventInfo, {
    target: 'selection';
}> & {
    onInteractionEnd?: string;
};

declare class PointingSelection extends StateNode {
    static id: string;
    info: TLBaseEventInfo & {
        type: "pointer";
        name: TLPointerEventName;
        point: VecLike;
        pointerId: number;
        button: number;
        isPen: boolean;
    } & {
        target: "selection";
        handle?: TLSelectionHandle | undefined;
        shape?: undefined;
    } & {
        target: 'selection';
    };
    onEnter: (info: TLPointerEventInfo & {
        target: 'selection';
    }) => void;
    onPointerUp: TLEventHandlers['onPointerUp'];
    onPointerMove: TLEventHandlers['onPointerMove'];
    onCancel: TLEventHandlers['onCancel'];
    onComplete: TLEventHandlers['onComplete'];
    onInterrupt: () => void;
    private cancel;
}

declare class PointingShape extends StateNode {
    static id: string;
    eventTargetShape: TLShape;
    selectingShape: TLShape;
    didSelectOnEnter: boolean;
    onEnter: (info: TLPointerEventInfo & {
        target: 'shape';
    }) => void;
    onPointerUp: TLEventHandlers['onPointerUp'];
    onPointerMove: TLEventHandlers['onPointerMove'];
    onCancel: TLEventHandlers['onCancel'];
    onComplete: TLEventHandlers['onComplete'];
    onInterrupt: () => void;
    private cancel;
}

declare type PointsSnapLine = {
    id: string;
    type: 'points';
    points: VecLike[];
};

/**
 * This function calls `event.preventDefault()` for you. Why is that useful?
 *
 * Beacuase if you enable `window.preventDefaultLogging = true` it'll log out a message when it
 * happens. Because we use console.warn rather than (log) you'll get a stack trace in the inspector
 * telling you exactly where it happened. This is important because `e.preventDefault()` is the
 * source of many bugs, but unfortuantly it can't be avoided because it also stops a lot of default
 * behaviour which doesn't make sense in our UI
 *
 * @param event - To prevent default on
 * @public
 */
export declare function preventDefault(event: Event | React_2.BaseSyntheticEvent): void;

/** @public */
export declare class ReadonlySharedStyleMap {
    protected map: Map<StyleProp<unknown>, SharedStyle<unknown>>;
    constructor(entries?: Iterable<[StyleProp<unknown>, SharedStyle<unknown>]>);
    get<T>(prop: StyleProp<T>): SharedStyle<T> | undefined;
    getAsKnownValue<T>(prop: StyleProp<T>): T | undefined;
    get size(): number;
    equals(other: ReadonlySharedStyleMap): boolean;
    keys(): IterableIterator<StyleProp<unknown>>;
    values(): IterableIterator<SharedStyle<unknown>>;
    entries(): IterableIterator<[StyleProp<unknown>, SharedStyle<unknown>]>;
    [Symbol.iterator](): IterableIterator<[StyleProp<unknown>, SharedStyle<unknown>]>;
}

/** @public */
export declare function refreshPage(): void;

/** @public */
export declare function releasePointerCapture(element: Element, event: PointerEvent | React_2.PointerEvent<Element>): void;

/* Excluded from this release type: REMOVE_SYMBOL */

/** @public */
export declare type RequiredKeys<T, K extends keyof T> = Pick<T, K> & Partial<T>;

declare class Resizing extends StateNode {
    static id: string;
    info: TLBaseEventInfo & {
        type: "pointer";
        name: TLPointerEventName;
        point: VecLike;
        pointerId: number;
        button: number;
        isPen: boolean;
    } & {
        target: "selection";
        handle?: TLSelectionHandle | undefined;
        shape?: undefined;
    } & {
        target: "selection";
        handle: SelectionCorner | SelectionEdge;
        isCreating?: boolean | undefined;
        editAfterComplete?: boolean | undefined;
        creationCursorOffset?: undefined | VecLike;
        onInteractionEnd?: string | undefined;
    };
    markId: string;
    creationCursorOffset: VecLike;
    editAfterComplete: boolean;
    private snapshot;
    onEnter: TLEnterEventHandler;
    onPointerMove: TLEventHandlers['onPointerMove'];
    onKeyDown: TLEventHandlers['onKeyDown'];
    onKeyUp: TLEventHandlers['onKeyUp'];
    onPointerUp: TLEventHandlers['onPointerUp'];
    onComplete: TLEventHandlers['onComplete'];
    onCancel: TLEventHandlers['onCancel'];
    private cancel;
    private complete;
    private handleResizeStart;
    private handleResizeEnd;
    private updateShapes;
    private updateCursor;
    onExit: () => void;
    _createSnapshot: () => {
        shapeSnapshots: Map<TLShapeId, {
            shape: TLShape;
            bounds: Box2d;
            pageTransform: Matrix2d;
            pageRotation: number;
            isAspectRatioLocked: boolean;
        }>;
        selectionBounds: Box2d;
        cursorHandleOffset: Vec2d;
        selectionRotation: number;
        selectedIds: TLShapeId[];
        canShapesDeform: boolean;
        initialSelectionPageBounds: Box2d;
    };
    _createShapeSnapshot: (shape: TLShape) => {
        shape: TLShape;
        bounds: Box2d;
        pageTransform: Matrix2d;
        pageRotation: number;
        isAspectRatioLocked: boolean;
    };
}

/* Excluded from this release type: RICH_TYPES */

declare class RootState extends StateNode {
    static id: string;
    static initial: string;
    static children: () => (typeof SelectTool | typeof ZoomTool)[];
    onKeyDown: TLEventHandlers['onKeyDown'];
}

declare class Rotating extends StateNode {
    static id: string;
    snapshot: {
        selectionPageCenter: Vec2d;
        initialCursorAngle: number;
        initialSelectionRotation: number;
        shapeSnapshots: {
            shape: TLShape;
            initialPagePoint: Vec2d;
        }[];
    };
    info: TLBaseEventInfo & {
        type: "pointer";
        name: TLPointerEventName;
        point: VecLike;
        pointerId: number;
        button: number;
        isPen: boolean;
    } & {
        target: "selection";
        handle?: TLSelectionHandle | undefined;
        shape?: undefined;
    } & {
        onInteractionEnd?: string | undefined;
    };
    markId: string;
    onEnter: (info: Extract<TLPointerEventInfo, {
        target: 'selection';
        onInteractionEnd?: string;
    }>) => void;
    onExit: () => void;
    onPointerMove: () => void;
    onKeyDown: () => void;
    onKeyUp: () => void;
    onPointerUp: TLEventHandlers['onPointerUp'];
    onComplete: TLEventHandlers['onComplete'];
    onCancel: () => void;
    private update;
    private cancel;
    private complete;
    protected handleStart(): void;
    _getRotationFromPointerPosition({ snapToNearestDegree }: {
        snapToNearestDegree: boolean;
    }): number;
}

/** @public */
export declare const runtime: {
    openWindow: (url: string, target: string) => void;
    refreshPage: () => void;
    hardReset: () => void;
};

declare class ScribbleBrushing extends StateNode {
    static id: string;
    hits: Set<TLShapeId>;
    size: number;
    scribble: ScribbleManager;
    initialSelectedIds: Set<TLShapeId>;
    newlySelectedIds: Set<TLShapeId>;
    onEnter: () => void;
    onExit: () => void;
    onPointerMove: () => void;
    onPointerUp: () => void;
    onKeyDown: () => void;
    onKeyUp: () => void;
    private startScribble;
    private pushPointToScribble;
    private onScribbleUpdate;
    private onScribbleComplete;
    private updateBrushSelection;
    onCancel: TLEventHandlers['onCancel'];
    onComplete: TLEventHandlers['onComplete'];
    private complete;
    private cancel;
}

declare class ScribbleManager implements TLScribble {
    state: "active" | "paused" | "starting" | "stopping";
    points: Vec2dModel[];
    size: number;
    color: "accent" | "black" | "laser" | "muted-1" | "selection-fill" | "selection-stroke" | "white";
    opacity: number;
    delay: number;
    timeoutMs: number;
    delayRemaining: number;
    private onUpdate;
    private onComplete;
    private prev;
    private next;
    constructor(opts: {
        onUpdate: (scribble: TLScribble) => void;
        onComplete: () => void;
        size?: TLScribble['size'];
        color?: TLScribble['color'];
        opacity?: TLScribble['opacity'];
        delay?: TLScribble['delay'];
    });
    resume: () => void;
    pause: () => void;
    /**
     * Start stopping the scribble. The scribble won't be removed until its last point is cleared.
     *
     * @public
     */
    stop: () => void;
    /**
     * Set the scribble's next point.
     *
     * @param point - The point to add.
     * @public
     */
    addPoint: (x: number, y: number) => void;
    /**
     * Get the current TLScribble object from the scribble manager.
     *
     * @public
     */
    getScribble(): TLScribble;
    private updateScribble;
    tick: TLTickEvent;
}

declare class SelectTool extends StateNode {
    static id: string;
    static initial: string;
    static children: () => (typeof Brushing | typeof Crop | typeof Cropping | typeof DraggingHandle | typeof EditingShape | typeof Idle_2 | typeof PointingCanvas | typeof PointingCropHandle | typeof PointingHandle | typeof PointingResizeHandle | typeof PointingRotateHandle | typeof PointingSelection | typeof PointingShape | typeof Resizing | typeof Rotating | typeof ScribbleBrushing | typeof Translating)[];
    onExit: () => void;
}

/* Excluded from this release type: setDefaultEditorAssetUrls */

/** @public */
export declare function setPointerCapture(element: Element, event: PointerEvent | React_2.PointerEvent<Element>): void;

/** @public */
export declare function setRuntimeOverrides(input: Partial<typeof runtime>): void;

/** @public */
export declare function setUserPreferences(user: TLUserPreferences): void;

/** @public */
export declare abstract class ShapeUtil<Shape extends TLUnknownShape = TLUnknownShape> {
    editor: Editor;
    readonly type: Shape['type'];
    readonly styleProps: ReadonlyMap<StyleProp<unknown>, string>;
    constructor(editor: Editor, type: Shape['type'], styleProps: ReadonlyMap<StyleProp<unknown>, string>);
    hasStyle(style: StyleProp<unknown>): boolean;
    getStyleIfExists<T>(style: StyleProp<T>, shape: Shape | TLShapePartial<Shape>): T | undefined;
    iterateStyles(shape: Shape | TLShapePartial<Shape>): Generator<[StyleProp<unknown>, unknown], void, unknown>;
    setStyleInPartial<T>(style: StyleProp<T>, shape: TLShapePartial<Shape>, value: T): TLShapePartial<Shape>;
    /**
     * The type of the shape util, which should match the shape's type.
     *
     * @public
     */
    static type: string;
    /**
     * Whether the shape can be snapped to by another shape.
     *
     * @public
     */
    canSnap: TLShapeUtilFlag<Shape>;
    /**
     * Whether the shape can be scrolled while editing.
     *
     * @public
     */
    canScroll: TLShapeUtilFlag<Shape>;
    /**
     * Whether the shape should unmount when not visible in the editor. Consider keeping this to false if the shape's `component` has local state.
     *
     * @public
     */
    canUnmount: TLShapeUtilFlag<Shape>;
    /**
     * Whether the shape can be bound to by an arrow.
     *
     * @param _otherShape - The other shape attempting to bind to this shape.
     * @public
     */
    canBind: <K>(_shape: Shape, _otherShape?: K | undefined) => boolean;
    /**
     * Whether the shape can be double clicked to edit.
     *
     * @public
     */
    canEdit: TLShapeUtilFlag<Shape>;
    /**
     * Whether the shape can be resized.
     *
     * @public
     */
    canResize: TLShapeUtilFlag<Shape>;
    /**
     * Whether the shape can be cropped.
     *
     * @public
     */
    canCrop: TLShapeUtilFlag<Shape>;
    /**
     * Bounds of the shape to edit.
     *
     * Note: this could be a text area within a shape for example arrow labels.
     *
     * @public
     */
    getEditingBounds: (shape: Shape) => Box2d;
    /**
     * Whether the shape's outline is closed.
     *
     * @public
     */
    isClosed: TLShapeUtilFlag<Shape>;
    /**
     * Whether the shape should hide its resize handles when selected.
     *
     * @public
     */
    hideResizeHandles: TLShapeUtilFlag<Shape>;
    /**
     * Whether the shape should hide its resize handles when selected.
     *
     * @public
     */
    hideRotateHandle: TLShapeUtilFlag<Shape>;
    /**
     * Whether the shape should hide its selection bounds background when selected.
     *
     * @public
     */
    hideSelectionBoundsBg: TLShapeUtilFlag<Shape>;
    /**
     * Whether the shape should hide its selection bounds foreground when selected.
     *
     * @public
     */
    hideSelectionBoundsFg: TLShapeUtilFlag<Shape>;
    /**
     * Whether the shape's aspect ratio is locked.
     *
     * @public
     */
    isAspectRatioLocked: TLShapeUtilFlag<Shape>;
    /**
     * Get the default props for a shape.
     *
     * @public
     */
    abstract defaultProps(): Shape['props'];
    /**
     * Get a JSX element for the shape (as an HTML element).
     *
     * @param shape - The shape.
     * @public
     */
    abstract component(shape: Shape): any;
    /**
     * Get JSX describing the shape's indicator (as an SVG element).
     *
     * @param shape - The shape.
     * @public
     */
    abstract indicator(shape: Shape): any;
    /* Excluded from this release type: renderBackground */
    /**
     * Get an array of handle models for the shape. This is an optional method.
     *
     * @example
     *
     * ```ts
     * util.getHandles?.(myShape)
     * ```
     *
     * @param shape - The shape.
     * @public
     */
    protected getHandles?(shape: Shape): TLHandle[];
    private get handlesCache();
    /**
     * Get the cached handles (this should not be overridden!)
     *
     * @param shape - The shape.
     * @public
     */
    handles(shape: Shape): TLHandle[];
    /**
     * Get an array of outline segments for the shape. For most shapes,
     * this will be a single segment that includes the entire outline.
     * For shapes with handles, this might be segments of the outline
     * between each handle.
     *
     * @example
     *
     * ```ts
     * util.getOutlineSegments(myShape)
     * ```
     *
     * @param shape - The shape.
     * @public
     */
    protected getOutlineSegments(shape: Shape): Vec2d[][];
    private get outlineSegmentsCache();
    /**
     * Get the cached outline segments (this should not be overridden!)
     *
     * @param shape - The shape.
     * @public
     */
    outlineSegments(shape: Shape): Vec2d[][];
    /**
     * Get the (not cached) bounds for the shape.
     *
     * @param shape - The shape.
     * @public
     */
    protected abstract getBounds(shape: Shape): Box2d;
    private get boundsCache();
    /**
     * Get the cached bounds for the shape.
     *
     * @param shape - The shape.
     * @public
     */
    bounds(shape: Shape): Box2d;
    /**
     * Get the shape's (not cached) outline. Do not override this method!
     *
     * @param shape - The shape.
     * @public
     */
    protected abstract getOutline(shape: Shape): Vec2d[];
    private get outlineCache();
    /**
     * Get the shape's outline. Do not override this method!
     *
     * @param shape - The shape.
     * @public
     */
    outline(shape: Shape): Vec2d[];
    /**
     * Get the shape's snap points.
     *
     * @param shape - The shape.
     * @public
     */
    snapPoints(shape: Shape): Vec2d[];
    /**
     * Get the shape's cached center.
     *
     * @param shape - The shape.
     * @public
     */
    center(shape: Shape): Vec2d;
    /**
     * Get the shape's (not cached) center.
     *
     * @param shape - The shape.
     * @public
     */
    abstract getCenter(shape: Shape): Vec2d;
    /**
     * Get whether the shape can receive children of a given type.
     *
     * @param type - The shape type.
     * @public
     */
    canReceiveNewChildrenOfType(shape: Shape, type: TLShape['type']): boolean;
    /**
     * Get whether the shape can receive children of a given type.
     *
     * @param shape - The shape type.
     * @param shapes - The shapes that are being dropped.
     * @public
     */
    canDropShapes(shape: Shape, shapes: TLShape[]): boolean;
    /**
     * Get the shape as an SVG object.
     *
     * @param shape - The shape.
     * @param color - The shape's CSS color (actual).
     * @param font - The shape's CSS font (actual).
     * @returns An SVG element.
     * @public
     */
    toSvg?(shape: Shape, font: string | undefined, colors: TLExportColors): Promise<SVGElement> | SVGElement;
    /**
     * Get the shape's background layer as an SVG object.
     *
     * @param shape - The shape.
     * @param color - The shape's CSS color (actual).
     * @param font - The shape's CSS font (actual).
     * @returns An SVG element.
     * @public
     */
    toBackgroundSvg?(shape: Shape, font: string | undefined, colors: TLExportColors): null | Promise<SVGElement> | SVGElement;
    /**
     * Get whether a point intersects the shape.
     *
     * @param shape - The shape.
     * @param point - The point to test.
     * @returns Whether the point intersects the shape.
     * @public
     */
    hitTestPoint(shape: Shape, point: VecLike): boolean;
    /**
     * Get whether a point intersects the shape.
     *
     * @param shape - The shape.
     * @param A - The line segment's first point.
     * @param B - The line segment's second point.
     * @returns Whether the line segment intersects the shape.
     * @public
     */
    hitTestLineSegment(shape: Shape, A: VecLike, B: VecLike): boolean;
    /* Excluded from this release type: expandSelectionOutlinePx */
    /* Excluded from this release type: providesBackgroundForChildren */
    /**
     * A callback called just before a shape is created. This method provides a last chance to modify
     * the created shape.
     *
     * @example
     *
     * ```ts
     * onBeforeCreate = (next) => {
     * 	return { ...next, x: next.x + 1 }
     * }
     * ```
     *
     * @param next - The next shape.
     * @returns The next shape or void.
     * @public
     */
    onBeforeCreate?: TLOnBeforeCreateHandler<Shape>;
    /**
     * A callback called just before a shape is updated. This method provides a last chance to modify
     * the updated shape.
     *
     * @example
     *
     * ```ts
     * onBeforeUpdate = (prev, next) => {
     * 	if (prev.x === next.x) {
     * 		return { ...next, x: next.x + 1 }
     * 	}
     * }
     * ```
     *
     * @param prev - The previous shape.
     * @param next - The next shape.
     * @returns The next shape or void.
     * @public
     */
    onBeforeUpdate?: TLOnBeforeUpdateHandler<Shape>;
    /**
     * A callback called when some other shapes are dragged over this one.
     *
     * @example
     *
     * ```ts
     * onDragShapesOver = (shape, shapes) => {
     * 	return { shouldHint: true }
     * }
     * ```
     *
     * @param shape - The shape.
     * @param shapes - The shapes that are being dragged over this one.
     * @returns An object specifying whether the shape should hint that it can receive the dragged shapes.
     * @public
     */
    onDragShapesOver?: TLOnDragHandler<Shape, {
        shouldHint: boolean;
    }>;
    /**
     * A callback called when some other shapes are dragged out of this one.
     *
     * @param shape - The shape.
     * @param shapes - The shapes that are being dragged out.
     * @public
     */
    onDragShapesOut?: TLOnDragHandler<Shape>;
    /**
     * A callback called when some other shapes are dropped over this one.
     *
     * @param shape - The shape.
     * @param shapes - The shapes that are being dropped over this one.
     * @public
     */
    onDropShapesOver?: TLOnDragHandler<Shape>;
    /**
     * A callback called when a shape starts being resized.
     *
     * @param shape - The shape.
     * @returns A change to apply to the shape, or void.
     * @public
     */
    onResizeStart?: TLOnResizeStartHandler<Shape>;
    /**
     * A callback called when a shape changes from a resize.
     *
     * @param shape - The shape at the start of the resize.
     * @param info - Info about the resize.
     * @returns A change to apply to the shape, or void.
     * @public
     */
    onResize?: TLOnResizeHandler<Shape>;
    /**
     * A callback called when a shape finishes resizing.
     *
     * @param initial - The shape at the start of the resize.
     * @param current - The current shape.
     * @returns A change to apply to the shape, or void.
     * @public
     */
    onResizeEnd?: TLOnResizeEndHandler<Shape>;
    /**
     * A callback called when a shape starts being translated.
     *
     * @param shape - The shape.
     * @returns A change to apply to the shape, or void.
     * @public
     */
    onTranslateStart?: TLOnTranslateStartHandler<Shape>;
    /**
     * A callback called when a shape changes from a translation.
     *
     * @param initial - The shape at the start of the translation.
     * @param current - The current shape.
     * @returns A change to apply to the shape, or void.
     * @public
     */
    onTranslate?: TLOnTranslateHandler<Shape>;
    /**
     * A callback called when a shape finishes translating.
     *
     * @param initial - The shape at the start of the translation.
     * @param current - The current shape.
     * @returns A change to apply to the shape, or void.
     * @public
     */
    onTranslateEnd?: TLOnTranslateEndHandler<Shape>;
    /**
     * A callback called when a shape starts being rotated.
     *
     * @param shape - The shape.
     * @returns A change to apply to the shape, or void.
     * @public
     */
    onRotateStart?: TLOnRotateStartHandler<Shape>;
    /**
     * A callback called when a shape changes from a rotation.
     *
     * @param initial - The shape at the start of the rotation.
     * @param current - The current shape.
     * @returns A change to apply to the shape, or void.
     * @public
     */
    onRotate?: TLOnRotateHandler<Shape>;
    /**
     * A callback called when a shape finishes rotating.
     *
     * @param initial - The shape at the start of the rotation.
     * @param current - The current shape.
     * @returns A change to apply to the shape, or void.
     * @public
     */
    onRotateEnd?: TLOnRotateEndHandler<Shape>;
    /**
     * A callback called when a shape's handle changes.
     *
     * @param shape - The shape.
     * @param info - An object containing the handle and whether the handle is 'precise' or not.
     * @returns A change to apply to the shape, or void.
     * @public
     */
    onHandleChange?: TLOnHandleChangeHandler<Shape>;
    /* Excluded from this release type: onBindingChange */
    /**
     * A callback called when a shape's children change.
     *
     * @param shape - The shape.
     * @returns An array of shape updates, or void.
     * @public
     */
    onChildrenChange?: TLOnChildrenChangeHandler<Shape>;
    /**
     * A callback called when a shape's handle is double clicked.
     *
     * @param shape - The shape.
     * @param handle - The handle that is double-clicked.
     * @returns A change to apply to the shape, or void.
     * @public
     */
    onDoubleClickHandle?: TLOnDoubleClickHandleHandler<Shape>;
    /**
     * A callback called when a shape's edge is double clicked.
     *
     * @param shape - The shape.
     * @returns A change to apply to the shape, or void.
     * @public
     */
    onDoubleClickEdge?: TLOnDoubleClickHandler<Shape>;
    /**
     * A callback called when a shape is double clicked.
     *
     * @param shape - The shape.
     * @returns A change to apply to the shape, or void.
     * @public
     */
    onDoubleClick?: TLOnDoubleClickHandler<Shape>;
    /**
     * A callback called when a shape is clicked.
     *
     * @param shape - The shape.
     * @returns A change to apply to the shape, or void.
     * @public
     */
    onClick?: TLOnClickHandler<Shape>;
    /**
     * A callback called when a shape finishes being editing.
     *
     * @param shape - The shape.
     * @public
     */
    onEditEnd?: TLOnEditEndHandler<Shape>;
}

/** @public */
export declare type SharedStyle<T> = {
    readonly type: 'mixed';
} | {
    readonly type: 'shared';
    readonly value: T;
};

/* Excluded from this release type: SharedStyleMap */

declare interface SnapData {
    nudge: Vec2d;
}

declare type SnapLine = GapsSnapLine | PointsSnapLine;

declare class SnapManager {
    readonly editor: Editor;
    private _snapLines;
    get lines(): SnapLine[];
    clear(): void;
    setLines(lines: SnapLine[]): void;
    constructor(editor: Editor);
    get snapPointsCache(): ComputedCache<SnapPoint[], TLShape>;
    get snapThreshold(): number;
    get snappableShapes(): GapNode[];
    get currentCommonAncestor(): TLShapeId | undefined;
    get snappablePoints(): SnapPoint[];
    get visibleGaps(): {
        horizontal: Gap[];
        vertical: Gap[];
    };
    snapTranslate({ lockedAxis, initialSelectionPageBounds, initialSelectionSnapPoints, dragDelta, }: {
        lockedAxis: 'x' | 'y' | null;
        initialSelectionSnapPoints: SnapPoint[];
        initialSelectionPageBounds: Box2d;
        dragDelta: Vec2d;
    }): SnapData;
    get outlinesInPageSpace(): Vec2d[][];
    getSnappingHandleDelta({ handlePoint, additionalSegments, }: {
        handlePoint: Vec2d;
        additionalSegments: Vec2d[][];
    }): null | Vec2d;
    snapResize({ initialSelectionPageBounds, dragDelta, handle: originalHandle, isAspectRatioLocked, isResizingFromCenter, }: {
        initialSelectionPageBounds: Box2d;
        dragDelta: Vec2d;
        handle: SelectionCorner | SelectionEdge;
        isAspectRatioLocked: boolean;
        isResizingFromCenter: boolean;
    }): SnapData;
    private collectPointSnaps;
    private collectGapSnaps;
    private getPointSnapLines;
    private getGapSnapLines;
}

declare interface SnapPoint {
    id: string;
    x: number;
    y: number;
    handle?: SelectionCorner;
}

/** @public */
export declare function snapToGrid(n: number, gridSize: number): number;

declare type Stack<T> = EmptyStackItem<T> | StackItem<T>;

declare class StackItem<T> implements Iterable<T> {
    readonly head: T;
    readonly tail: Stack<T>;
    length: number;
    constructor(head: T, tail: Stack<T>);
    push(head: T): Stack<T>;
    toArray(): (NonNullable<T> | undefined)[];
    [Symbol.iterator](): {
        next(): {
            value: NonNullable<T>;
            done: false;
        } | {
            value: undefined;
            done: true;
        };
    };
}

/** @public */
export declare abstract class StateNode implements Partial<TLEventHandlers> {
    editor: Editor;
    constructor(editor: Editor, parent?: StateNode);
    path: Computed<string>;
    static id: string;
    static initial?: string;
    static children?: () => TLStateNodeConstructor[];
    id: string;
    current: Atom<StateNode | undefined>;
    type: TLStateNodeType;
    shapeType?: TLShapeUtilConstructor<TLBaseShape<any, any>>;
    initial?: string;
    children?: Record<string, StateNode>;
    parent: StateNode;
    isActive: boolean;
    transition(id: string, info: any): this;
    handleEvent(info: Exclude<TLEventInfo, TLPinchEventInfo>): void;
    enter(info: any, from: string): void;
    exit(info: any, from: string): void;
    onWheel?: TLEventHandlers['onWheel'];
    onPointerEnter?: TLEventHandlers['onPointerEnter'];
    onPointerLeave?: TLEventHandlers['onPointerLeave'];
    onPointerDown?: TLEventHandlers['onPointerDown'];
    onPointerMove?: TLEventHandlers['onPointerMove'];
    onPointerUp?: TLEventHandlers['onPointerUp'];
    onDoubleClick?: TLEventHandlers['onDoubleClick'];
    onTripleClick?: TLEventHandlers['onTripleClick'];
    onQuadrupleClick?: TLEventHandlers['onQuadrupleClick'];
    onRightClick?: TLEventHandlers['onRightClick'];
    onMiddleClick?: TLEventHandlers['onMiddleClick'];
    onKeyDown?: TLEventHandlers['onKeyDown'];
    onKeyUp?: TLEventHandlers['onKeyUp'];
    onKeyRepeat?: TLEventHandlers['onKeyRepeat'];
    onCancel?: TLEventHandlers['onCancel'];
    onComplete?: TLEventHandlers['onComplete'];
    onInterrupt?: TLEventHandlers['onInterrupt'];
    onEnter?: TLEnterEventHandler;
    onExit?: TLExitEventHandler;
}

/* Excluded from this release type: SVG_PADDING */

/** @public */
export declare function SVGContainer({ children, className, ...rest }: SVGContainerProps): JSX.Element;

/** @public */
export declare type SVGContainerProps = React_3.HTMLAttributes<SVGElement>;

/**
 * A string that is unique per browser tab
 * @public
 */
export declare const TAB_ID: string;

declare class TextManager {
    editor: Editor;
    constructor(editor: Editor);
    getTextElement(): HTMLDivElement;
    measureText: (textToMeasure: string, opts: {
        fontStyle: string;
        fontWeight: string;
        fontFamily: string;
        fontSize: number;
        lineHeight: number;
        width: string;
        minWidth?: string;
        maxWidth: string;
        padding: string;
    }) => Box2dModel;
    /**
     * Given an html element, measure the position of each span of unbroken
     * word/white-space characters within any text nodes it contains.
     */
    measureElementTextNodeSpans(element: HTMLElement, { shouldTruncateToFirstLine }?: {
        shouldTruncateToFirstLine?: boolean;
    }): {
        spans: {
            box: Box2dModel;
            text: string;
        }[];
        didTruncate: boolean;
    };
    /**
     * Measure text into individual spans. Spans are created by rendering the
     * text, then dividing it up according to line breaks and word boundaries.
     *
     * It works by having the browser render the text, then measuring the
     * position of each character. You can use this to replicate the text-layout
     * algorithm of the current browser in e.g. an SVG export.
     */
    measureTextSpans(textToMeasure: string, opts: TLMeasureTextSpanOpts): {
        text: string;
        box: Box2dModel;
    }[];
}

/** @public */
export declare const TextShape: TLShapeInfo<TLTextShape>;

/** @public */
export declare class TextShapeUtil extends ShapeUtil<TLTextShape> {
    static type: "text";
    canEdit: () => boolean;
    isAspectRatioLocked: TLShapeUtilFlag<TLTextShape>;
    defaultProps(): TLTextShape['props'];
    getMinDimensions(shape: TLTextShape): {
        height: number;
        width: number;
    };
    getBounds(shape: TLTextShape): Box2d;
    getOutline(shape: TLTextShape): Vec2d[];
    getCenter(shape: TLTextShape): Vec2d;
    component(shape: TLTextShape): JSX.Element;
    indicator(shape: TLTextShape): JSX.Element;
    toSvg(shape: TLTextShape, font: string | undefined, colors: TLExportColors): SVGGElement;
    onResize: TLOnResizeHandler<TLTextShape>;
    onBeforeCreate: (shape: TLTextShape) => {
        x: number;
        y: number;
        type: "text";
        rotation: number;
        index: string;
        parentId: TLParentId;
        isLocked: boolean;
        opacity: number;
        props: {
            color: "black" | "blue" | "green" | "grey" | "light-blue" | "light-green" | "light-red" | "light-violet" | "orange" | "red" | "violet" | "yellow";
            size: "l" | "m" | "s" | "xl";
            font: "draw" | "mono" | "sans" | "serif";
            align: "end-legacy" | "end" | "middle-legacy" | "middle" | "start-legacy" | "start";
            w: number;
            text: string;
            scale: number;
            autoSize: boolean;
        };
        id: TLShapeId;
        typeName: "shape";
    } | undefined;
    onEditEnd: TLOnEditEndHandler<TLTextShape>;
    onBeforeUpdate: (prev: TLTextShape, next: TLTextShape) => {
        x: number;
        y: number;
        props: {
            w: number;
            color: "black" | "blue" | "green" | "grey" | "light-blue" | "light-green" | "light-red" | "light-violet" | "orange" | "red" | "violet" | "yellow";
            size: "l" | "m" | "s" | "xl";
            font: "draw" | "mono" | "sans" | "serif";
            align: "end-legacy" | "end" | "middle-legacy" | "middle" | "start-legacy" | "start";
            text: string;
            scale: number;
            autoSize: boolean;
        };
        type: "text";
        rotation: number;
        index: string;
        parentId: TLParentId;
        isLocked: boolean;
        opacity: number;
        id: TLShapeId;
        typeName: "shape";
    } | undefined;
    onDoubleClickEdge: (shape: TLTextShape) => {
        id: TLShapeId;
        type: "text";
        props: {
            autoSize: boolean;
            scale?: undefined;
        };
    } | {
        id: TLShapeId;
        type: "text";
        props: {
            scale: number;
            autoSize?: undefined;
        };
    } | undefined;
}

/** @public */
export declare type TLAnimationOptions = Partial<{
    duration: number;
    easing: typeof EASINGS.easeInOutCubic;
}>;

/** @public */
declare type TLBackgroundComponent = () => JSX.Element | null;

/** @public */
export declare type TLBaseBoxShape = TLBaseShape<string, {
    w: number;
    h: number;
}>;

/** @public */
export declare interface TLBaseEventInfo {
    type: UiEventType;
    shiftKey: boolean;
    altKey: boolean;
    ctrlKey: boolean;
}

/** @public */
declare type TLBrushComponent = (props: {
    brush: Box2dModel;
    color?: string;
    opacity?: number;
    className?: string;
}) => any | null;

/** @public */
export declare type TLCancelEvent = (info: TLCancelEventInfo) => void;

/** @public */
export declare type TLCancelEventInfo = {
    type: 'misc';
    name: 'cancel';
};

/** @public */
export declare type TLClickEvent = (info: TLClickEventInfo) => void;

/** @public */
export declare type TLClickEventInfo = TLBaseEventInfo & {
    type: 'click';
    name: TLCLickEventName;
    point: VecLike;
    pointerId: number;
    button: number;
    phase: 'down' | 'settle' | 'up';
} & TLPointerEventTarget;

/** @public */
export declare type TLCLickEventName = 'double_click' | 'quadruple_click' | 'triple_click';

declare type TLClickState = 'idle' | 'overflow' | 'pendingDouble' | 'pendingOverflow' | 'pendingQuadruple' | 'pendingTriple';

declare type TLCollaboratorHintComponent = (props: {
    className?: string;
    point: Vec2dModel;
    viewport: Box2d;
    zoom: number;
    opacity?: number;
    color: string;
}) => JSX.Element | null;

/** @public */
export declare type TLCommand<Name extends string = any, Data = any> = {
    type: 'command';
    id: string;
    data: Data;
    name: Name;
    /**
     * Allows for commands that change state and should be undoable, but are 'inconsequential' and
     * should not clear the redo stack. e.g. modifying the set of selected ids.
     */
    preservesRedoStack?: boolean;
};

/** @public */
export declare type TLCommandHandler<Data> = {
    do: (data: Data) => void;
    undo: (data: Data) => void;
    redo?: (data: Data) => void;
    /**
     * Allow to combine the next command with the previous one if possible. Useful for, e.g. combining
     * a series of shape translation commands into one command in the undo stack
     */
    squash?: (prevData: Data, nextData: Data) => Data;
};

/** @public */
export declare type TLCompleteEvent = (info: TLCompleteEventInfo) => void;

/** @public */
export declare type TLCompleteEventInfo = {
    type: 'misc';
    name: 'complete';
};

/** @public */
export declare interface TLContent {
    shapes: TLShape[];
    rootShapeIds: TLShapeId[];
    assets: TLAsset[];
    schema: SerializedSchema;
}

/** @public */
export declare type TLCopyType = 'jpeg' | 'json' | 'png' | 'svg';

/** @public */
declare type TLCursorComponent = (props: {
    className?: string;
    point: null | Vec2dModel;
    zoom: number;
    color?: string;
    name: null | string;
    chatMessage: string;
}) => any | null;

/** @public */
export declare const TldrawEditor: React_2.NamedExoticComponent<TldrawEditorProps>;

/** @public */
export declare type TldrawEditorProps = {
    children?: any;
    /** An array of shape utils to use in the editor. */
    shapes?: readonly AnyTLShapeInfo[];
    /** An array of tools to use in the editor. */
    tools?: readonly TLStateNodeConstructor[];
    /** Urls for where to find fonts and other assets. */
    assetUrls?: RecursivePartial<TLEditorAssetUrls>;
    /** Whether to automatically focus the editor when it mounts. */
    autoFocus?: boolean;
    /** Overrides for the tldraw user interface components. */
    components?: Partial<TLEditorComponents>;
    /**
     * Called when the editor has mounted.
     * @example
     * ```ts
     * function TldrawEditor() {
     * 	return <Editor onMount={(editor) => editor.selectAll()} />
     * }
     * ```
     * @param editor - The editor instance.
     */
    onMount?: (editor: Editor) => (() => void) | undefined | void;
} & ({
    /**
     * The Store instance to use for keeping the editor's data. This may be prepopulated, e.g. by loading
     * from a server or database.
     */
    store: TLStore | TLStoreWithStatus;
} | {
    store?: undefined;
    /**
     * The editor's initial data.
     */
    initialData?: StoreSnapshot<TLRecord>;
    /**
     * The id under which to sync and persist the editor's data. If none is given tldraw will not sync or persist
     * the editor's data.
     */
    persistenceKey?: string;
    /**
     * When tldraw reloads a document from local persistence, it will try to bring back the
     * editor UI state (e.g. camera position, which shapes are selected). It does this using a sessionId,
     * which by default is unique per browser tab. If you wish to have more fine-grained
     * control over this behavior, you can provide your own sessionId.
     *
     * If it can't find saved UI state for the given sessionId, it will use the most recently saved
     * UI state for the given persistenceKey if available.
     */
    sessionId?: string;
    /**
     * The default initial document name. e.g. 'Untitled Document'
     */
    defaultName?: string;
});

/** @public */
export declare type TLEditorAssetUrls = {
    fonts: {
        monospace: string;
        serif: string;
        sansSerif: string;
        draw: string;
    };
};

/** @public */
export declare interface TLEditorComponents {
    Background: null | TLBackgroundComponent;
    SvgDefs: null | TLSvgDefsComponent;
    Brush: null | TLBrushComponent;
    ZoomBrush: null | TLBrushComponent;
    Cursor: null | TLCursorComponent;
    CollaboratorBrush: null | TLBrushComponent;
    CollaboratorCursor: null | TLCursorComponent;
    CollaboratorHint: null | TLCollaboratorHintComponent;
    CollaboratorShapeIndicator: null | TLShapeIndicatorComponent;
    Grid: null | TLGridComponent;
    Scribble: null | TLScribbleComponent;
    CollaboratorScribble: null | TLScribbleComponent;
    SnapLine: null | TLSnapLineComponent;
    Handle: null | TLHandleComponent;
    ErrorFallback: null | TLErrorFallbackComponent;
    ShapeErrorFallback: null | TLShapeErrorFallbackComponent;
    ShapeIndicatorErrorFallback: null | TLShapeIndicatorErrorFallback;
    Spinner: null | TLSpinnerComponent;
}

/** @public */
export declare interface TLEditorOptions {
    /**
     * The Store instance to use for keeping the app's data. This may be prepopulated, e.g. by loading
     * from a server or database.
     */
    store: TLStore;
    /**
     * An array of shapes to use in the editor. These will be used to create and manage shapes in the editor.
     */
    shapes: readonly AnyTLShapeInfo[];
    /**
     * An array of tools to use in the editor. These will be used to handle events and manage user interactions in the editor.
     */
    tools: readonly TLStateNodeConstructor[];
    /**
     * A user defined externally to replace the default user.
     */
    user?: TLUser;
    /**
     * Should return a containing html element which has all the styles applied to the editor. If not
     * given, the body element will be used.
     */
    getContainer: () => HTMLElement;
}

/** @public */
export declare type TLEmbedResult = {
    definition: EmbedDefinition;
    url: string;
    embedUrl: string;
} | undefined;

/** @public */
export declare type TLEnterEventHandler = (info: any, from: string) => void;

/** @public */
export declare interface TLErrorBoundaryProps {
    children: React_3.ReactNode;
    onError?: ((error: unknown) => void) | null;
    fallback: (error: unknown) => React_3.ReactNode;
}

declare type TLErrorBoundaryState = {
    error: Error | null;
};

/** @public */
declare type TLErrorFallbackComponent = (props: {
    error: unknown;
    editor?: Editor;
}) => any | null;

declare type TLEventChangeHandler<T extends TLShape> = (initial: T, current: T) => TLShapePartial<T> | void;

/** @public */
export declare interface TLEventHandlers {
    onPointerEnter: TLPointerEvent;
    onPointerLeave: TLPointerEvent;
    onPointerDown: TLPointerEvent;
    onPointerMove: TLPointerEvent;
    onRightClick: TLPointerEvent;
    onDoubleClick: TLClickEvent;
    onTripleClick: TLClickEvent;
    onQuadrupleClick: TLClickEvent;
    onMiddleClick: TLPointerEvent;
    onPointerUp: TLPointerEvent;
    onKeyDown: TLKeyboardEvent;
    onKeyUp: TLKeyboardEvent;
    onKeyRepeat: TLKeyboardEvent;
    onWheel: TLWheelEvent;
    onCancel: TLCancelEvent;
    onComplete: TLCompleteEvent;
    onInterrupt: TLInterruptEvent;
}

/** @public */
export declare type TLEventInfo = TLCancelEventInfo | TLClickEventInfo | TLCompleteEventInfo | TLInterruptEventInfo | TLKeyboardEventInfo | TLPinchEventInfo | TLPointerEventInfo | TLWheelEventInfo;

/** @public */
export declare interface TLEventMap {
    mount: [];
    'max-shapes': [{
        name: string;
        pageId: TLPageId;
        count: number;
    }];
    change: [HistoryEntry<TLRecord>];
    update: [];
    crash: [{
        error: unknown;
    }];
    'stop-camera-animation': [];
    'stop-following': [];
    event: [TLEventInfo];
    tick: [number];
    frame: [number];
    'change-history': [{
        reason: 'bail';
        markId?: string;
    } | {
        reason: 'push' | 'redo' | 'undo';
    }];
    'mark-history': [{
        id: string;
    }];
}

/** @public */
export declare type TLEventMapHandler<T extends keyof TLEventMap> = (...args: TLEventMap[T]) => void;

/** @public */
export declare type TLEventName = 'cancel' | 'complete' | 'interrupt' | 'wheel' | TLCLickEventName | TLKeyboardEventName | TLPinchEventName | TLPointerEventName;

declare type TLEventStartHandler<T extends TLShape> = (shape: T) => TLShapePartial<T> | void;

/** @public */
export declare type TLExitEventHandler = (info: any, to: string) => void;

declare type TLExportColors = {
    fill: Record<TLDefaultColorStyle, string>;
    pattern: Record<TLDefaultColorStyle, string>;
    semi: Record<TLDefaultColorStyle, string>;
    highlight: Record<TLDefaultColorStyle, string>;
    solid: string;
    text: string;
    background: string;
};

/** @public */
export declare type TLExportType = 'jpeg' | 'json' | 'png' | 'svg' | 'webp';

/** @public */
export declare type TLExternalContent = {
    type: 'embed';
    url: string;
    point?: VecLike;
    embed: EmbedDefinition;
} | {
    type: 'files';
    files: File[];
    point?: VecLike;
    ignoreParent: boolean;
} | {
    type: 'svg-text';
    text: string;
    point?: VecLike;
} | {
    type: 'text';
    point?: VecLike;
    text: string;
} | {
    type: 'url';
    url: string;
    point?: VecLike;
};

/** @public */
declare type TLGridComponent = (props: {
    x: number;
    y: number;
    z: number;
    size: number;
}) => JSX.Element | null;

declare type TLHandleComponent = (props: {
    shapeId: TLShapeId;
    handle: TLHandle;
    className?: string;
}) => any | null;

/** @public */
export declare type TLHistoryEntry = TLCommand | TLHistoryMark;

/** @public */
export declare type TLHistoryMark = {
    type: 'STOP';
    id: string;
    onUndo: boolean;
    onRedo: boolean;
};

/** @public */
export declare type TLInterruptEvent = (info: TLInterruptEventInfo) => void;

/** @public */
export declare type TLInterruptEventInfo = {
    type: 'misc';
    name: 'interrupt';
};

/** @public */
export declare type TLKeyboardEvent = (info: TLKeyboardEventInfo) => void;

/** @public */
export declare type TLKeyboardEventInfo = TLBaseEventInfo & {
    type: 'keyboard';
    name: TLKeyboardEventName;
    key: string;
    code: string;
};

/** @public */
export declare type TLKeyboardEventName = 'key_down' | 'key_repeat' | 'key_up';

declare type TLMeasureTextSpanOpts = {
    overflow: TLOverflowMode;
    width: number;
    height: number;
    padding: number;
    fontSize: number;
    fontWeight: string;
    fontFamily: string;
    fontStyle: string;
    lineHeight: number;
    textAlign: TLDefaultHorizontalAlignStyle;
};

/** @public */
export declare type TLOnBeforeCreateHandler<T extends TLShape> = (next: T) => T | void;

/** @public */
export declare type TLOnBeforeUpdateHandler<T extends TLShape> = (prev: T, next: T) => T | void;

/* Excluded from this release type: TLOnBindingChangeHandler */

/** @public */
export declare type TLOnChildrenChangeHandler<T extends TLShape> = (shape: T) => TLShapePartial[] | void;

/** @public */
export declare type TLOnClickHandler<T extends TLShape> = (shape: T) => TLShapePartial<T> | void;

/** @public */
export declare type TLOnDoubleClickHandleHandler<T extends TLShape> = (shape: T, handle: TLHandle) => TLShapePartial<T> | void;

/** @public */
export declare type TLOnDoubleClickHandler<T extends TLShape> = (shape: T) => TLShapePartial<T> | void;

/** @public */
export declare type TLOnDragHandler<T extends TLShape, R = void> = (shape: T, shapes: TLShape[]) => R;

/** @public */
export declare type TLOnEditEndHandler<T extends TLShape> = (shape: T) => void;

/** @public */
export declare type TLOnHandleChangeHandler<T extends TLShape> = (shape: T, info: {
    handle: TLHandle;
    isPrecise: boolean;
}) => TLShapePartial<T> | void;

/** @public */
export declare type TLOnResizeEndHandler<T extends TLShape> = TLEventChangeHandler<T>;

/** @public */
export declare type TLOnResizeHandler<T extends TLShape> = (shape: T, info: TLResizeInfo<T>) => Partial<TLShapePartial<T>> | undefined | void;

/** @public */
export declare type TLOnResizeStartHandler<T extends TLShape> = TLEventStartHandler<T>;

/** @public */
export declare type TLOnRotateEndHandler<T extends TLShape> = TLEventChangeHandler<T>;

/** @public */
export declare type TLOnRotateHandler<T extends TLShape> = TLEventChangeHandler<T>;

/** @public */
export declare type TLOnRotateStartHandler<T extends TLShape> = TLEventStartHandler<T>;

/** @public */
export declare type TLOnTranslateEndHandler<T extends TLShape> = TLEventChangeHandler<T>;

/** @public */
export declare type TLOnTranslateHandler<T extends TLShape> = TLEventChangeHandler<T>;

/** @public */
export declare type TLOnTranslateStartHandler<T extends TLShape> = TLEventStartHandler<T>;

declare type TLOverflowMode = 'truncate-clip' | 'truncate-ellipsis' | 'wrap';

/** @public */
export declare type TLPinchEvent = (info: TLPinchEventInfo) => void;

/** @public */
export declare type TLPinchEventInfo = TLBaseEventInfo & {
    type: 'pinch';
    name: TLPinchEventName;
    point: Vec2dModel;
    delta: Vec2dModel;
};

/** @public */
export declare type TLPinchEventName = 'pinch_end' | 'pinch_start' | 'pinch';

/** @public */
export declare type TLPointerEvent = (info: TLPointerEventInfo) => void;

/** @public */
export declare type TLPointerEventInfo = TLBaseEventInfo & {
    type: 'pointer';
    name: TLPointerEventName;
    point: VecLike;
    pointerId: number;
    button: number;
    isPen: boolean;
} & TLPointerEventTarget;

/** @public */
export declare type TLPointerEventName = 'middle_click' | 'pointer_down' | 'pointer_enter' | 'pointer_leave' | 'pointer_move' | 'pointer_up' | 'right_click';

/** @public */
export declare type TLPointerEventTarget = {
    target: 'canvas';
    shape?: undefined;
} | {
    target: 'handle';
    shape: TLShape;
    handle: TLHandle;
} | {
    target: 'selection';
    handle?: TLSelectionHandle;
    shape?: undefined;
} | {
    target: 'shape';
    shape: TLShape;
};

declare type TLPointingCropHandleInfo = Extract<TLPointerEventInfo, {
    target: 'selection';
}> & {
    onInteractionEnd?: string;
};

/** @public */
export declare type TLResizeHandle = SelectionCorner | SelectionEdge;

/**
 * Info about a resize.
 * @param newPoint - The new local position of the shape.
 * @param handle - The handle being dragged.
 * @param mode - The type of resize.
 * @param scaleX - The scale in the x-axis.
 * @param scaleY - The scale in the y-axis.
 * @param initialBounds - The bounds of the shape at the start of the resize.
 * @param initialShape - The shape at the start of the resize.
 * @public
 */
export declare type TLResizeInfo<T extends TLShape> = {
    newPoint: Vec2d;
    handle: TLResizeHandle;
    mode: TLResizeMode;
    scaleX: number;
    scaleY: number;
    initialBounds: Box2d;
    initialShape: T;
};

/**
 * The type of resize.
 *
 * 'scale_shape' - The shape is being scaled, usually as part of a larger selection.
 *
 * 'resize_bounds' - The user is directly manipulating an individual shape's bounds using a resize
 * handle. It is up to shape util implementers to decide how they want to handle the two
 * situations.
 *
 * @public
 */
export declare type TLResizeMode = 'resize_bounds' | 'scale_shape';

/** @public */
declare type TLScribbleComponent = (props: {
    scribble: TLScribble;
    zoom: number;
    color?: string;
    opacity?: number;
    className?: string;
}) => any;

/** @public */
export declare type TLSelectionHandle = RotateCorner | SelectionCorner | SelectionEdge;

/**
 * The state of the editor instance, not including any document state.
 *
 * @public
 */
export declare interface TLSessionStateSnapshot {
    version: number;
    currentPageId: TLPageId;
    isFocusMode: boolean;
    exportBackground: boolean;
    isDebugMode: boolean;
    isToolLocked: boolean;
    isGridMode: boolean;
    pageStates: Array<{
        pageId: TLPageId;
        camera: {
            x: number;
            y: number;
            z: number;
        };
        selectedIds: TLShapeId[];
        focusLayerId: null | TLShapeId;
    }>;
}

/** @public */
declare type TLShapeErrorFallbackComponent = (props: {
    error: unknown;
}) => any | null;

declare type TLShapeIndicatorComponent = (props: {
    id: TLShapeId;
    color?: string | undefined;
    opacity?: number;
    className?: string;
}) => JSX.Element | null;

/** @public */
declare type TLShapeIndicatorErrorFallback = (props: {
    error: unknown;
}) => any | null;

/** @public */
export declare type TLShapeInfo<T extends TLUnknownShape = TLUnknownShape> = {
    type: T['type'];
    util: TLShapeUtilConstructor<T>;
    props?: ShapeProps<T>;
    migrations?: Migrations;
    tool?: TLStateNodeConstructor;
};

/** @public */
export declare interface TLShapeUtilConstructor<T extends TLUnknownShape, U extends ShapeUtil<T> = ShapeUtil<T>> {
    new (editor: Editor, type: T['type'], styleProps: ReadonlyMap<StyleProp<unknown>, string>): U;
    type: T['type'];
}

/** @public */
export declare type TLShapeUtilFlag<T> = (shape: T) => boolean;

declare type TLSnapLineComponent = (props: {
    className?: string;
    line: SnapLine;
    zoom: number;
}) => any;

declare type TLSpinnerComponent = () => any | null;

/** @public */
export declare interface TLStateNodeConstructor {
    new (editor: Editor, parent?: StateNode): StateNode;
    id: string;
    initial?: string;
    children?: () => TLStateNodeConstructor[];
}

declare type TLStateNodeType = 'branch' | 'leaf' | 'root';

/** @public */
export declare type TLStoreEventInfo = HistoryEntry<TLRecord>;

/** @public */
export declare type TLStoreOptions = {
    initialData?: StoreSnapshot<TLRecord>;
    defaultName?: string;
} & ({
    schema: StoreSchema<TLRecord, TLStoreProps>;
} | {
    shapes: readonly AnyTLShapeInfo[];
});

/** @public */
export declare type TLStoreWithStatus = {
    readonly status: 'error';
    readonly store?: undefined;
    readonly error: Error;
} | {
    readonly status: 'loading';
    readonly store?: undefined;
    readonly error?: undefined;
} | {
    readonly status: 'not-synced';
    readonly store: TLStore;
    readonly error?: undefined;
} | {
    readonly status: 'synced-local';
    readonly store: TLStore;
    readonly error?: undefined;
} | {
    readonly status: 'synced-remote';
    readonly connectionStatus: 'offline' | 'online';
    readonly store: TLStore;
    readonly error?: undefined;
};

/** @public */
declare type TLSvgDefsComponent = () => any;

/** @public */
export declare type TLTickEvent = (elapsed: number) => void;

/** @public */
declare interface TLUser {
    readonly derivePresenceState: (store: TLStore) => Signal<null | TLInstancePresence>;
    readonly userPreferences: Signal<TLUserPreferences>;
    readonly setUserPreferences: (userPreferences: TLUserPreferences) => void;
}

/**
 * A user of tldraw
 *
 * @public
 */
export declare interface TLUserPreferences {
    id: string;
    name: string;
    locale: string;
    color: string;
    isDarkMode: boolean;
    animationSpeed: number;
    isSnapMode: boolean;
}

/** @public */
declare type TLViewportOptions = Partial<{
    /** Whether to animate the viewport change or not. Defaults to true. */
    stopFollowing: boolean;
}>;

/** @public */
export declare type TLWheelEvent = (info: TLWheelEventInfo) => void;

/** @public */
export declare type TLWheelEventInfo = TLBaseEventInfo & {
    type: 'wheel';
    name: 'wheel';
    delta: Vec2dModel;
};

declare class Translating extends StateNode {
    static id: string;
    info: TLBaseEventInfo & {
        type: "pointer";
        name: TLPointerEventName;
        point: VecLike;
        pointerId: number;
        button: number;
        isPen: boolean;
    } & {
        target: "shape";
        shape: TLShape;
    } & {
        target: 'shape';
        isCreating?: boolean | undefined;
        editAfterComplete?: boolean | undefined;
        onInteractionEnd?: string | undefined;
    };
    selectionSnapshot: TranslatingSnapshot;
    snapshot: TranslatingSnapshot;
    markId: string;
    isCloning: boolean;
    isCreating: boolean;
    editAfterComplete: boolean;
    dragAndDropManager: DragAndDropManager;
    onEnter: (info: TLPointerEventInfo & {
        target: 'shape';
        isCreating?: boolean;
        editAfterComplete?: boolean;
        onInteractionEnd?: string;
    }) => void;
    updateParent: () => void;
    onExit: () => void;
    onPointerMove: () => void;
    onKeyDown: () => void;
    onKeyUp: TLEventHandlers['onKeyUp'];
    onPointerUp: TLEventHandlers['onPointerUp'];
    onComplete: TLEventHandlers['onComplete'];
    onCancel: TLEventHandlers['onCancel'];
    reset(): void;
    protected startCloning(): void;
    protected stopCloning(): void;
    protected complete(): void;
    private cancel;
    protected handleEnter(info: TLPointerEventInfo & {
        target: 'shape';
    }): void;
    protected handleStart(): void;
    protected handleEnd(): void;
    protected handleChange(): void;
    protected updateShapes(): void;
    protected updateParentTransforms: () => void;
}

declare class TranslatingCrop extends StateNode {
    static id: string;
    info: TLBaseEventInfo & {
        type: "pointer";
        name: TLPointerEventName;
        point: VecLike;
        pointerId: number;
        button: number;
        isPen: boolean;
    } & {
        target: "shape";
        shape: TLShape;
    } & {
        target: 'shape';
        isCreating?: boolean | undefined;
        onInteractionEnd?: string | undefined;
    };
    markId: string;
    private snapshot;
    onEnter: (info: TLPointerEventInfo & {
        target: 'shape';
        isCreating?: boolean;
        onInteractionEnd?: string;
    }) => void;
    onExit: () => void;
    onPointerMove: () => void;
    onPointerUp: TLEventHandlers['onPointerUp'];
    onComplete: TLEventHandlers['onComplete'];
    onCancel: TLEventHandlers['onCancel'];
    onKeyDown: TLEventHandlers['onKeyDown'];
    onKeyUp: TLEventHandlers['onKeyUp'];
    protected complete(): void;
    private cancel;
    private createSnapshot;
    protected updateShapes(): void;
}

declare type TranslatingSnapshot = ReturnType<typeof getTranslatingSnapshot>;

/** @public */
export declare const truncateStringWithEllipsis: (str: string, maxLength: number) => string;

/** @public */
export declare type UiEvent = TLCancelEvent | TLClickEvent | TLCompleteEvent | TLKeyboardEvent | TLPinchEvent | TLPointerEvent;

/** @public */
export declare type UiEventType = 'click' | 'keyboard' | 'pinch' | 'pointer' | 'wheel' | 'zoom';

/**
 * Generate a unique id.
 *
 * @example
 *
 * ```ts
 * const id = uniqueId()
 * ```
 *
 * @public
 */
export declare function uniqueId(): string;

/** @public */
export declare function useContainer(): HTMLDivElement;

/** @public */
export declare const useEditor: () => Editor;

/* Excluded from this release type: useLocalStore */

/* Excluded from this release type: usePeerIds */

/** @public */
export declare function usePrefersReducedMotion(): boolean;

/* Excluded from this release type: usePresence */

/** @public */
export declare function useQuickReactor(name: string, reactFn: () => void, deps?: any[]): void;

/* Excluded from this release type: USER_COLORS */

/** @public */
export declare function useReactor(name: string, reactFn: () => void, deps?: any[] | undefined): void;

declare class UserPreferencesManager {
    private readonly user;
    constructor(user: TLUser);
    updateUserPreferences: (userPreferences: Partial<TLUserPreferences>) => void;
    get userPreferences(): Signal<TLUserPreferences, unknown>;
    get isDarkMode(): boolean;
    get animationSpeed(): number;
    get id(): string;
    get name(): string;
    get locale(): string;
    get color(): string;
    get isSnapMode(): boolean;
}

/** @public */
export declare function useTLStore(opts: TLStoreOptions): TLStore;

/** @public */
export declare const VideoShape: TLShapeInfo<TLVideoShape>;

/** @public */
export declare class VideoShapeUtil extends BaseBoxShapeUtil<TLVideoShape> {
    static type: "video";
    canEdit: () => boolean;
    isAspectRatioLocked: () => boolean;
    defaultProps(): TLVideoShape['props'];
    component(shape: TLVideoShape): JSX.Element;
    indicator(shape: TLVideoShape): JSX.Element;
    toSvg(shape: TLVideoShape): SVGGElement;
}

/** @public */
export declare class WeakMapCache<T extends object, K> {
    items: WeakMap<T, K>;
    get<P extends T>(item: P, cb: (item: P) => K): NonNullable<K>;
    access(item: T): K | undefined;
    set(item: T, value: K): void;
    has(item: T): boolean;
    invalidate(item: T): void;
    bust(): void;
}

declare class ZoomBrushing extends StateNode {
    static id: string;
    info: TLPointerEventInfo & {
        onInteractionEnd?: string | undefined;
    };
    zoomBrush: Box2d;
    onEnter: (info: TLPointerEventInfo & {
        onInteractionEnd: string;
    }) => void;
    onExit: () => void;
    onPointerMove: () => void;
    onPointerUp: TLEventHandlers['onPointerUp'];
    onCancel: TLEventHandlers['onCancel'];
    private update;
    private cancel;
    private complete;
}

/* Excluded from this release type: ZOOMS */

declare class ZoomTool extends StateNode {
    static id: string;
    static initial: string;
    static children: () => (typeof Idle_3 | typeof Pointing | typeof ZoomBrushing)[];
    info: TLPointerEventInfo & {
        onInteractionEnd?: string | undefined;
    };
    onEnter: (info: TLPointerEventInfo & {
        onInteractionEnd: string;
    }) => void;
    updateCursor(): void;
    onExit: () => void;
    onKeyDown: TLKeyboardEvent | undefined;
    onKeyUp: TLKeyboardEvent;
    onInterrupt: TLInterruptEvent;
    private complete;
}


export * from "@tldraw/indices";
export * from "@tldraw/tlschema";

export { }
