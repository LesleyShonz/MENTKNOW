// AUTOGENERATED, DO NOT EDIT!
 /* eslint-disable */
import Worker from "__WORKER__";
function assert(condition, msg) {
  if (!condition) {
    throw new Error(msg);
  }
}
function getRoomIdFromPathname(pathname) {
  const getRoomId = new RegExp(/\/party\/(.*)/g);
  return getRoomId.exec(pathname)?.[1];
}
if (Worker.onConnect && typeof Worker.onConnect !== "function") {
  throw new Error(".onConnect is not a function");
}
if (Worker.onBeforeConnect && typeof Worker.onBeforeConnect !== "function") {
  throw new Error(".onBeforeConnect should be a function");
}
if (Worker.onRequest && typeof Worker.onRequest !== "function") {
  throw new Error(".onRequest is not a function");
}
if (Worker.onBeforeRequest && typeof Worker.onBeforeRequest !== "function") {
  throw new Error(".onBeforeRequest should be a function");
}
if (Worker.onAlarm && typeof Worker.onAlarm !== "function") {
  throw new Error(".onAlarm should be a function");
}
let didWarnAboutMissingConnectionId = false;
const MAX_CONNECTIONS = 100;
class MainDO {
  controller;
  room;
  constructor(controller, env) {
    this.controller = controller;
    this.room = {
      id: "UNDEFINED",
      // using a string here because we're guaranteed to have set it before we use it
      // TODO: probably want to rename this to something else
      // "sockets"? "connections"? "clients"?
      internalID: this.controller.id.toString(),
      connections: /* @__PURE__ */ new Map(),
      env,
      storage: this.controller.storage
    };
  }
  async fetch(request) {
    const url = new URL(request.url);
    try {
      if (this.room.connections.size >= MAX_CONNECTIONS) {
        return new Response("Room is full", {
          status: 503
        });
      }
      const roomId = getRoomIdFromPathname(url.pathname);
      assert(roomId, "No room id found in request url");
      this.room.id = roomId;
      if (request.headers.get("upgrade")?.toLowerCase() !== "websocket") {
        if (Worker.onRequest) {
          if (typeof Worker.onRequest === "function") {
            return await Worker.onRequest(request, this.room);
          } else {
            return new Response("Invalid onRequest handler", {
              status: 500
            });
          }
        }
      }
    } catch (e) {
      const errMessage = e instanceof Error ? e.message : `${e}`;
      const errCode = "code" in e ? e.code : 500;
      return new Response(
        errMessage || "Uncaught exception when making a request",
        {
          status: errCode
        }
      );
    }
    try {
      if (!Worker.onConnect) {
        throw new Error("No onConnect handler");
      }
      const { 0: clientWebSocket, 1: serverWebSocket } = new WebSocketPair();
      let connectionId = url.searchParams.get("_pk");
      if (!connectionId) {
        if (!didWarnAboutMissingConnectionId) {
          didWarnAboutMissingConnectionId = true;
        }
        connectionId = crypto.randomUUID();
      }
      const rawInitial = request.headers.get("x-pk-initial");
      const unstable_initial = rawInitial ? JSON.parse(rawInitial) : void 0;
      const connection = {
        id: connectionId,
        socket: serverWebSocket,
        unstable_initial
      };
      this.room.connections.set(connectionId, connection);
      serverWebSocket.accept();
      await this.handleConnection(this.room, connection);
      return new Response(null, { status: 101, webSocket: clientWebSocket });
    } catch (e) {
      const errMessage = e instanceof Error ? e.message : `${e}`;
      const pair = new WebSocketPair();
      pair[1].accept();
      pair[1].close(1011, errMessage || "Uncaught exception when connecting");
      return new Response(null, { status: 101, webSocket: pair[0] });
    }
  }
  async handleConnection(room, connection) {
    assert(
      "onConnect" in Worker && typeof Worker.onConnect === "function",
      "No onConnect handler"
    );
    const handleCloseOrErrorFromClient = () => {
      this.room.connections.delete(connection.id);
      connection.socket.removeEventListener(
        "close",
        handleCloseOrErrorFromClient
      );
      connection.socket.removeEventListener(
        "error",
        handleCloseOrErrorFromClient
      );
      if (room.connections.size === 0) {
      }
    };
    connection.socket.addEventListener("close", handleCloseOrErrorFromClient);
    connection.socket.addEventListener("error", handleCloseOrErrorFromClient);
    return Worker.onConnect(connection.socket, room);
  }
  async alarm() {
    if (Worker.onAlarm) {
      return Worker.onAlarm(this.room);
    }
  }
}
var source_default = {
  async fetch(request, env, ctx) {
    try {
      const url = new URL(request.url);
      const roomId = getRoomIdFromPathname(url.pathname);
      if (roomId) {
        if (request.headers.get("upgrade")?.toLowerCase() === "websocket") {
          let connectionId = url.searchParams.get("_pk");
          if (!connectionId) {
            if (!didWarnAboutMissingConnectionId) {
              didWarnAboutMissingConnectionId = true;
            }
            connectionId = crypto.randomUUID();
          }
          let onBeforeConnectResponse;
          if (Worker.onBeforeConnect) {
            if (typeof Worker.onBeforeConnect === "function") {
              try {
                onBeforeConnectResponse = await Worker.onBeforeConnect(
                  request,
                  {
                    id: roomId,
                    env
                  },
                  ctx
                );
              } catch (e) {
                return new Response(
                  e instanceof Error ? e.message : `${e}` || "Unauthorised",
                  {
                    status: 401
                  }
                );
              }
            } else {
              throw new Error(".onBeforeConnect must be a function");
            }
          }
          const docId = env.MAIN_DO.idFromName(roomId).toString();
          const id = env.MAIN_DO.idFromString(docId);
          if (onBeforeConnectResponse) {
            return await env.MAIN_DO.get(id).fetch(
              new Request(request, {
                headers: {
                  ...Object.fromEntries(request.headers.entries()),
                  "x-pk-initial": JSON.stringify(onBeforeConnectResponse)
                }
              })
            );
          }
          return await env.MAIN_DO.get(id).fetch(request);
        } else {
          let onBeforeRequestResponse = request;
          if (Worker.onBeforeRequest) {
            if (typeof Worker.onBeforeRequest === "function") {
              try {
                onBeforeRequestResponse = await Worker.onBeforeRequest(
                  request,
                  {
                    id: roomId,
                    env
                  },
                  ctx
                );
              } catch (e) {
                return new Response(
                  e instanceof Error ? e.message : `${e}` || "Unauthorised",
                  {
                    status: 401
                  }
                );
              }
            } else {
              throw new Error(".onBeforeRequest must be a function");
            }
          }
          if (onBeforeRequestResponse instanceof Response) {
            return onBeforeRequestResponse;
          }
          if (!Worker.onRequest) {
            throw new Error("No onRequest handler");
          }
          const docId = env.MAIN_DO.idFromName(roomId).toString();
          const id = env.MAIN_DO.idFromString(docId);
          return await env.MAIN_DO.get(id).fetch(onBeforeRequestResponse);
        }
      }
      return new Response("Not found", {
        status: 404
      });
    } catch (e) {
      return new Response(e instanceof Error ? e.message : `${e}`, {
        status: 500
      });
    }
  }
};
export {
  MainDO,
  source_default as default
};
