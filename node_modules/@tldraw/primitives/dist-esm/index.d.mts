import { Box2dModel } from '@tldraw/tlschema';
import { Vec2dModel } from '@tldraw/tlschema';

/**
 * Get the short distance between two angles.
 *
 * @param a0 - The first angle.
 * @param a1 - The second angle.
 * @public
 */
export declare function angleDelta(a0: number, a1: number): number;

/**
 * Whether two numbers numbers a and b are approximately equal.
 *
 * @param a - The first point.
 * @param b - The second point.
 * @public
 */
export declare function approximately(a: number, b: number, precision?: number): boolean;

/**
 * Checks whether two angles are approximately at right-angles or parallel to each other
 *
 * @param a - Angle a (radians)
 * @param b - Angle b (radians)
 * @returns True iff the angles are approximately at right-angles or parallel to each other
 * @public
 */
export declare function areAnglesCompatible(a: number, b: number): boolean;

/**
 * A base segment used for cubic and quadradic curves.
 *
 * @public
 */
declare abstract class BaseSegment2d<T extends {
    p: number;
}> {
    constructor(values: T);
    /* Excluded from this release type: _values */
    /* Excluded from this release type: _computed */
    /**
     * The values for the curve segment.
     *
     * @public
     */
    get values(): T;
    set values(values: T);
    /**
     * The length of the curve segment.
     *
     * @public
     */
    get length(): number;
    /**
     * The bounding box containing the curve segment.
     *
     * @public
     */
    get bounds(): Box2d;
    /**
     * A lookup table consisting of values.p points along the segment. Used to compute lengths,
     * closest points, etc. This should only be _computed once (when first requested) per set of
     * values.
     *
     * @public
     */
    get lut(): Vec2d[];
    /**
     * A point half-way along the length of the segment.
     *
     * @public
     */
    get midPoint(): Vec2d;
    /**
     * An SVG path for the segment.
     *
     * @public
     */
    get path(): string;
    /**
     * Evaluate a point at a length along the curve segment.
     *
     * @param length - The length to find the point value.
     * @public
     */
    getPointAtLength(length: number): Vec2d;
    /**
     * Get the normal at distance t along the curve segment.
     *
     * @param t - The distance (0-1) to find the normal.
     * @public
     */
    getNormal(t: number): Vec2d;
    /**
     * Get the normal at a length along the curve segment.
     *
     * @param length - The length to find the normal.
     * @public
     */
    getNormalAtLength(length: number): Vec2d;
    /**
     * Get the closest point on the segment to an arbitrary point.
     *
     * @param point - The arbitrary point.
     * @public
     */
    getClosestPointTo(point: VecLike): {
        point: Vec2d;
        distance: number;
    };
    /**
     * Set one or more values. Updating the segment will clear cached values.
     *
     * @param values - A partial of the segment's values object.
     * @public
     */
    update(values: Partial<T>): void;
    /**
     * Get the SVG path data for the segment.
     *
     * @public
     */
    abstract getPath(head?: boolean): string;
    /**
     * Evaluate a point at distance t along the curve segment.
     *
     * @param t - The distance (0-1) to find the point.
     * @public
     */
    abstract getPoint(t: number): Vec2d;
    /**
     * Evaluate a x value at distance t along the curve segment.
     *
     * @param t - The distance (0-1) to find the x value.
     * @public
     */
    abstract getX(t: number): number;
    /**
     * Evaluate a y value at distance t along the curve segment.
     *
     * @param t - The distance (0-1) to find the y value.
     * @public
     */
    abstract getY(t: number): number;
}

declare abstract class BaseSpline2d<T extends {
    p: number;
}> {
    points: VecLike[];
    p: number;
    k: number;
    constructor(points: VecLike[], p?: number, k?: number);
    abstract segments: BaseSegment2d<T>[];
    abstract getSegmentsFromPoints(points: VecLike[], p: number, k: number): BaseSegment2d<T>[];
    protected computed: {
        length?: number;
        bounds?: Box2d;
        path?: string;
        lut?: Vec2d[];
    };
    get length(): number;
    get bounds(): Box2d;
    get head(): VecLike;
    get tail(): VecLike;
    get path(): string;
    addPoint(point: Vec2d): this;
    removePoint(point: number | Vec2d): this;
    getPointAtLength(length: number): Vec2d;
    getPoint(t: number): Vec2d;
    getNormal(t: number): Vec2d;
    getNormalAtLength(t: number): Vec2d;
    getClosestPointTo(point: Vec2d): {
        point: VecLike;
        distance: number;
    };
}

/** @public */
export declare class Box2d {
    constructor(x?: number, y?: number, w?: number, h?: number);
    x: number;
    y: number;
    w: number;
    h: number;
    get point(): Vec2d;
    set point(val: Vec2d);
    get minX(): number;
    set minX(n: number);
    get midX(): number;
    get maxX(): number;
    get minY(): number;
    set minY(n: number);
    get midY(): number;
    get maxY(): number;
    get width(): number;
    set width(n: number);
    get height(): number;
    set height(n: number);
    get aspectRatio(): number;
    get center(): Vec2d;
    set center(v: Vec2d);
    get corners(): Vec2d[];
    get snapPoints(): Vec2d[];
    get sides(): Array<[Vec2d, Vec2d]>;
    get size(): Vec2d;
    toFixed(): this;
    setTo(B: Box2d): this;
    set(x?: number, y?: number, w?: number, h?: number): this;
    expand(A: Box2d): this;
    expandBy(n: number): this;
    scale(n: number): this;
    clone(): Box2d;
    translate(delta: VecLike): this;
    snapToGrid(size: number): void;
    collides(B: Box2d): boolean;
    contains(B: Box2d): boolean;
    includes(B: Box2d): boolean;
    containsPoint(V: number | VecLike, y?: number): boolean;
    getHandlePoint(handle: SelectionCorner | SelectionEdge): Vec2d;
    toJson(): Box2dModel;
    resize(handle: SelectionCorner | SelectionEdge | string, dx: number, dy: number): void;
    union(box: Box2dModel): this;
    static From(box: Box2dModel): Box2d;
    static FromPoints(points: VecLike[]): Box2d;
    static Expand(A: Box2d, B: Box2d): Box2d;
    static ExpandBy(A: Box2d, n: number): Box2d;
    static Collides: (A: Box2d, B: Box2d) => boolean;
    static Contains: (A: Box2d, B: Box2d) => boolean;
    static Includes: (A: Box2d, B: Box2d) => boolean;
    static ContainsPoint: (A: Box2d, B: number | VecLike, y?: number) => boolean;
    static Common: (boxes: Box2d[]) => Box2d;
    static Sides: (A: Box2d, inset?: number) => Vec2d[][];
    static Resize(box: Box2d, handle: SelectionCorner | SelectionEdge | string, dx: number, dy: number, isAspectRatioLocked?: boolean): {
        box: Box2d;
        scaleX: number;
        scaleY: number;
    };
    equals(other: Box2d | Box2dModel): boolean;
    static Equals(a: Box2d | Box2dModel, b: Box2d | Box2dModel): boolean;
}

/**
 * @param a - Any angle in radians
 * @returns A number between 0 and 2 * PI
 * @public
 */
export declare function canolicalizeRotation(a: number): number;

/**
 * Clamp a value into a range.
 *
 * @example
 *
 * ```ts
 * const A = clamp(0, 1) // 1
 * ```
 *
 * @param n - The number to clamp.
 * @param min - The minimum value.
 * @public
 */
export declare function clamp(n: number, min: number): number;

/**
 * Clamp a value into a range.
 *
 * @example
 *
 * ```ts
 * const A = clamp(0, 1, 10) // 1
 * const B = clamp(11, 1, 10) // 10
 * const C = clamp(5, 1, 10) // 5
 * ```
 *
 * @param n - The number to clamp.
 * @param min - The minimum value.
 * @param max - The maximum value.
 * @public
 */
export declare function clamp(n: number, min: number, max: number): number;

/**
 * Clamp radians within 0 and 2PI
 *
 * @param r - The radian value.
 * @public
 */
export declare function clampRadians(r: number): number;

/** @public */
export declare class CubicSegment2d extends BaseSegment2d<CubicSegment2dModel> {
    constructor(a: VecLike, b: VecLike, c: VecLike, d: VecLike, p?: number);
    [Symbol.iterator]: (this: InstanceType<typeof CubicSegment2d>) => Generator<VecLike, void, undefined>;
    getPath(head?: boolean): string;
    getPoint(t: number): Vec2d;
    getX(t: number): number;
    getY(t: number): number;
}

/** @public */
export declare interface CubicSegment2dModel {
    a: VecLike;
    b: VecLike;
    c: VecLike;
    d: VecLike;
    p: number;
}

/** @public */
export declare class CubicSpline2d extends BaseSpline2d<CubicSegment2dModel> {
    constructor(points: VecLike[], k?: number, p?: number);
    segments: CubicSegment2d[];
    getSegmentsFromPoints(points: VecLike[], k?: number, p?: number): CubicSegment2d[];
    static FromPoints(points: Vec2d[]): CubicSpline2d;
}

/** @public */
export declare function decomposeMatrix2d(m: MatLike): {
    x: number;
    y: number;
    scaleX: number;
    scaleY: number;
    rotation: number;
};

/**
 * Convert degrees to radians.
 *
 * @param d - The degree in degrees.
 * @public
 */
export declare function degreesToRadians(d: number): number;

/** @public */
export declare const EASINGS: {
    readonly linear: (t: number) => number;
    readonly easeInQuad: (t: number) => number;
    readonly easeOutQuad: (t: number) => number;
    readonly easeInOutQuad: (t: number) => number;
    readonly easeInCubic: (t: number) => number;
    readonly easeOutCubic: (t: number) => number;
    readonly easeInOutCubic: (t: number) => number;
    readonly easeInQuart: (t: number) => number;
    readonly easeOutQuart: (t: number) => number;
    readonly easeInOutQuart: (t: number) => number;
    readonly easeInQuint: (t: number) => number;
    readonly easeOutQuint: (t: number) => number;
    readonly easeInOutQuint: (t: number) => number;
    readonly easeInSine: (t: number) => number;
    readonly easeOutSine: (t: number) => number;
    readonly easeInOutSine: (t: number) => number;
    readonly easeInExpo: (t: number) => number;
    readonly easeOutExpo: (t: number) => number;
    readonly easeInOutExpo: (t: number) => number;
};

/** @public */
export declare type EasingType = keyof typeof EASINGS;

/** @public */
export declare const EPSILON: number;

/** @public */
export declare function flipSelectionHandleX(handle: SelectionHandle): "bottom_left" | "bottom_right" | "bottom" | "left" | "right" | "top_left" | "top_right" | "top";

/** @public */
export declare function flipSelectionHandleY(handle: SelectionHandle): "bottom_left" | "bottom_right" | "bottom" | "left" | "right" | "top_left" | "top_right" | "top";

/**
 * Get the length of an arc between two points on a circle's perimeter.
 *
 * @param C - The circle's center as [x, y].
 * @param r - The circle's radius.
 * @param A - The first point.
 * @param B - The second point.
 * @public
 */
export declare function getArcLength(C: VecLike, r: number, A: VecLike, B: VecLike): number;

/** @public */
export declare function getDrawLinePathData(id: string, outline: VecLike[], strokeWidth: number): string[];

/** @public */
export declare function getHeight(pts: VecLike[]): number;

/** @public */
export declare function getMaxX(pts: VecLike[]): number;

/** @public */
export declare function getMaxY(pts: VecLike[]): number;

/** @public */
export declare function getMidX(pts: VecLike[]): number;

/** @public */
export declare function getMidY(pts: VecLike[]): number;

/** @public */
export declare function getMinX(pts: VecLike[]): number;

/** @public */
export declare function getMinY(pts: VecLike[]): number;

/**
 * Get a point on the perimeter of a circle.
 *
 * @param cx - The center x of the circle.
 * @param cy - The center y of the circle.
 * @param r - The radius of the circle.
 * @param a - The normalized point on the circle.
 * @public
 */
export declare function getPointOnCircle(cx: number, cy: number, r: number, a: number): Vec2d;

/** @public */
export declare function getPolygonVertices(width: number, height: number, sides: number): Vec2d[];

/** @public */
export declare function getRoundedInkyPolygonPath(points: VecLike[]): string;

/** @public */
export declare function getRoundedPolygonPoints(id: string, outline: VecLike[], offset: number, roundness: number, passes: number): VecLike[];

/**
 * Gets the width/height of a star given its input bounds.
 *
 * @param sides - Number of sides
 * @param w - T target width
 * @param h - Target height
 * @returns Box2d
 * @public
 */
export declare const getStarBounds: (sides: number, w: number, h: number) => Box2d;

/**
 * ## getStroke
 *
 * Get an array of points describing a polygon that surrounds the input points.
 *
 * @param points - An array of points (as `[x, y, pressure]` or `{x, y, pressure}`). Pressure is
 *   optional in both cases.
 * @param options - An object with options.
 * @public
 */
export declare function getStroke(points: VecLike[], options?: StrokeOptions): Vec2d[];

/**
 * ## getStrokeOutlinePoints
 *
 * Get an array of points (as `[x, y]`) representing the outline of a stroke.
 *
 * @param points - An array of StrokePoints as returned from `getStrokePoints`.
 * @param options - An object with options.
 * @public
 */
export declare function getStrokeOutlinePoints(strokePoints: StrokePoint[], options?: StrokeOptions): Vec2d[];

/**
 * ## getStrokePoints
 *
 * Get an array of points as objects with an adjusted point, pressure, vector, distance, and
 * runningLength.
 *
 * @param points - An array of points (as `[x, y, pressure]` or `{x, y, pressure}`). Pressure is
 *   optional in both cases.
 * @param options - An object with options.
 * @public
 */
export declare function getStrokePoints(rawInputPoints: VecLike[], options?: StrokeOptions): StrokePoint[];

/**
 * Get the "sweep" or short distance between two points on a circle's perimeter.
 *
 * @param C - The center of the circle.
 * @param A - The first point.
 * @param B - The second point.
 * @public
 */
export declare function getSweep(C: VecLike, A: VecLike, B: VecLike): number;

/** @public */
export declare function getWidth(pts: VecLike[]): number;

/**
 * Find the intersections between a circle and a circle.
 *
 * @param c1 - The first circle's center.
 * @param r1 - The first circle's radius.
 * @param c2 - The second circle's center.
 * @param r2 - The second circle's radius.
 * @public
 */
export declare function intersectCircleCircle(c1: VecLike, r1: number, c2: VecLike, r2: number): Vec2d[];

/**
 * Find the intersections between a circle and a bounding box.
 *
 * @param c - The circle's center.
 * @param r - The circle's radius.
 * @param points - The points in the polygon.
 * @public
 */
export declare function intersectCirclePolygon(c: VecLike, r: number, points: VecLike[]): null | VecLike[];

/**
 * Find the intersections between a circle and a bounding box.
 *
 * @param c - The circle's center.
 * @param r - The circle's radius.
 * @param points - The points in the polyline.
 * @public
 */
export declare function intersectCirclePolyline(c: VecLike, r: number, points: VecLike[]): null | VecLike[];

/**
 * Find the intersections between a line segment and a circle.
 *
 * @param a1 - The segment's first point.
 * @param a2 - The segment's second point.
 * @param c - The circle's center.
 * @param r - The circle's radius.
 * @public
 */
export declare function intersectLineSegmentCircle(a1: VecLike, a2: VecLike, c: VecLike, r: number): null | VecLike[];

/**
 * Find the intersection between a line segment and a line segment.
 *
 * @param a1 - The first segment's first point.
 * @param a2 - The first segment's second point.
 * @param b1 - The second segment's first point.
 * @param b2 - The second segment's second point.
 * @public
 */
export declare function intersectLineSegmentLineSegment(a1: VecLike, a2: VecLike, b1: VecLike, b2: VecLike): null | Vec2d;

/**
 * Find the intersections between a line segment and a closed polygon.
 *
 * @param a1 - The segment's first point.
 * @param a2 - The segment's second point.
 * @param points - The points in the polygon.
 * @public
 */
export declare function intersectLineSegmentPolygon(a1: VecLike, a2: VecLike, points: VecLike[]): null | VecLike[];

/**
 * Find the intersections between a line segment and a polyline.
 *
 * @param a1 - The segment's first point.
 * @param a2 - The segment's second point.
 * @param points - The points in the polyline.
 * @public
 */
export declare function intersectLineSegmentPolyline(a1: VecLike, a2: VecLike, points: VecLike[]): null | VecLike[];

/**
 * Find the intersections between a polygon and a bounding box.
 *
 * @public
 */
export declare function intersectPolygonBounds(points: VecLike[], bounds: Box2d): null | VecLike[];

/**
 * Create a new convex polygon as the intersection of two convex polygons.
 *
 * @param polygonA - An array of points representing the first polygon.
 * @param polygonB - An array of points representing the second polygon.
 * @public
 */
export declare function intersectPolygonPolygon(polygonA: VecLike[], polygonB: VecLike[]): null | VecLike[];

/**
 * Is angle c between angles a and b?
 *
 * @param a - The first angle.
 * @param b - The second angle.
 * @param c - The third angle.
 * @public
 */
export declare function isAngleBetween(a: number, b: number, c: number): boolean;

/**
 * Check if a float is safe to use. ie: Not too big or small.
 * @public
 */
export declare const isSafeFloat: (n: number) => boolean;

/** @public */
export declare function isSelectionCorner(selection: string): selection is SelectionCorner;

/**
 * Interpolate an angle between two angles.
 *
 * @param a0 - The first angle.
 * @param a1 - The second angle.
 * @param t - The interpolation value.
 * @public
 */
export declare function lerpAngles(a0: number, a1: number, t: number): number;

/** @public */
export declare class LineSegment2d extends BaseSegment2d<LineSegment2dModel> {
    a: VecLike;
    b: VecLike;
    constructor(a: VecLike, b: VecLike, p?: number);
    get length(): number;
    get tangent(): Vec2d;
    get angle(): number;
    get bounds(): Box2d;
    getX(t: number): number;
    getY(t: number): number;
    getPoint(t: number): Vec2d;
    getPath(head?: boolean): string;
    getNormal(): Vec2d;
    /**
     * Get the closest point on the segment to an arbitrary point.
     *
     * @param point - The arbitrary point.
     * @public
     */
    getClosestPointTo(point: VecLike): {
        point: Vec2d;
        distance: number;
    };
    static Length(A: LineSegment2d): number;
    static Tangent(A: LineSegment2d): Vec2d;
    static Angle(A: LineSegment2d): number;
}

/** @public */
export declare interface LineSegment2dModel {
    a: VecLike;
    b: VecLike;
    p: number;
}

/** @public */
export declare function linesIntersect(A: VecLike, B: VecLike, C: VecLike, D: VecLike): boolean;

/**
 * Get the long angle distance between two angles.
 *
 * @param a0 - The first angle.
 * @param a1 - The second angle.
 * @public
 */
export declare function longAngleDist(a0: number, a1: number): number;

/** @public */
export declare type MatLike = Matrix2d | Matrix2dModel;

/** @public */
export declare class Matrix2d {
    constructor(a: number, b: number, c: number, d: number, e: number, f: number);
    a: number;
    b: number;
    c: number;
    d: number;
    e: number;
    f: number;
    equals(m: Matrix2d | Matrix2dModel): boolean;
    identity(): this;
    multiply(m: Matrix2d | Matrix2dModel): this;
    rotate(r: number, cx?: number, cy?: number): Matrix2d;
    translate(x: number, y: number): Matrix2d;
    scale(x: number, y: number): this;
    invert(): this;
    applyToPoint(point: VecLike): Vec2d;
    applyToPoints(points: VecLike[]): Vec2d[];
    decomposed(): MatrixInfo;
    toCssString(): string;
    setTo(model: Matrix2dModel): this;
    decompose(): MatrixInfo;
    clone(): Matrix2d;
    static Identity(): Matrix2d;
    static Translate(x: number, y: number): Matrix2d;
    static Rotate(r: number, cx?: number, cy?: number): Matrix2d;
    static Scale: {
        (x: number, y: number): Matrix2dModel;
        (x: number, y: number, cx: number, cy: number): Matrix2dModel;
    };
    static Multiply(m1: Matrix2dModel, m2: Matrix2dModel): Matrix2dModel;
    static Inverse(m: Matrix2dModel): Matrix2dModel;
    static Absolute(m: MatLike): Matrix2dModel;
    static Compose(...matrices: MatLike[]): Matrix2d;
    static Decompose(m: MatLike): MatrixInfo;
    static Smooth(m: MatLike, precision?: number): MatLike;
    static toCssString(m: MatLike): string;
    static applyToPoint(m: MatLike, point: VecLike): Vec2d;
    static applyToXY(m: MatLike, x: number, y: number): number[];
    static applyToPoints(m: MatLike, points: VecLike[]): Vec2d[];
    static applyToBounds(m: MatLike, box: Box2d): Box2d;
    static From(m: MatLike): Matrix2d;
}

/** @public */
export declare interface Matrix2dModel {
    a: number;
    b: number;
    c: number;
    d: number;
    e: number;
    f: number;
}

/** @public */
export declare interface MatrixInfo {
    x: number;
    y: number;
    scaleX: number;
    scaleY: number;
    rotation: number;
}

/**
 * Find the approximate perimeter of an ellipse.
 *
 * @param rx - The ellipse's x radius.
 * @param ry - The ellipse's y radius.
 * @public
 */
export declare function perimeterOfEllipse(rx: number, ry: number): number;

/** @public */
export declare const PI: number;

/** @public */
export declare const PI2: number;

/**
 * Get whether a point is inside of a bounds.
 *
 * @param A - The point to check.
 * @param b - The bounds to check.
 * @returns Boolean
 * @public
 */
export declare function pointInBounds(A: VecLike, b: Box2d): boolean;

/**
 * Utils for working with points.
 *
 * @public
 */
/**
 * Get whether a point is inside of a circle.
 *
 * @param A - The point to check.
 * @param C - The circle's center point as [x, y].
 * @param r - The circle's radius.
 * @returns Boolean
 * @public
 */
export declare function pointInCircle(A: VecLike, C: VecLike, r: number): boolean;

/**
 * Get whether a point is inside of an ellipse.
 *
 * @param point - The point to check.
 * @param center - The ellipse's center point as [x, y].
 * @param rx - The ellipse's x radius.
 * @param ry - The ellipse's y radius.
 * @param rotation - The ellipse's rotation.
 * @returns Boolean
 * @public
 */
export declare function pointInEllipse(A: VecLike, C: VecLike, rx: number, ry: number, rotation?: number): boolean;

/**
 * Get whether a point is inside of a polygon.
 *
 * ```ts
 * const result = pointInPolygon(myPoint, myPoints)
 * ```
 *
 * @public
 */
export declare function pointInPolygon(A: VecLike, points: VecLike[]): boolean;

/**
 * Hit test a point and a polyline using a minimum distance.
 *
 * @param A - The point to check.
 * @param points - The points that make up the polyline.
 * @param distance - The mininum distance that qualifies a hit.
 * @returns Boolean
 * @public
 */
export declare function pointInPolyline(A: VecLike, points: VecLike[], distance?: number): boolean;

/**
 * Get whether a point is inside of a rectangle.
 *
 * @param A - The point to check.
 * @param point - The rectangle's top left point as [x, y].
 * @param size - The rectangle's size as [width, height].
 * @public
 */
export declare function pointInRect(A: VecLike, point: VecLike, size: VecLike): boolean;

/**
 * Get whether a point is within a certain distance from a line segment.
 *
 * @param A - The point to check.
 * @param p1 - The polyline's first point.
 * @param p2 - The polyline's second point.
 * @param distance - The mininum distance that qualifies a hit.
 * @public
 */
export declare function pointNearToLineSegment(A: VecLike, p1: VecLike, p2: VecLike, distance?: number): boolean;

/**
 * Get whether a point is within a certain distance from a polyline.
 *
 * @param A - The point to check.
 * @param points - The points that make up the polyline.
 * @param distance - The mininum distance that qualifies a hit.
 * @public
 */
export declare function pointNearToPolyline(A: VecLike, points: VecLike[], distance?: number): boolean;

/** @public */
export declare function polygonsIntersect(a: VecLike[], b: VecLike[]): boolean;

/** @public */
export declare class Polyline2d extends BaseSpline2d<LineSegment2dModel> {
    constructor(points: VecLike[], k?: number, p?: number);
    segments: LineSegment2d[];
    getSegmentsFromPoints(points: VecLike[], p?: number): LineSegment2d[];
    static FromPoints(points: VecLike[]): Polyline2d;
}

/**
 * Convert radians to degrees.
 *
 * @param r - The degree in radians.
 * @public
 */
export declare function radiansToDegrees(r: number): number;

/**
 * Finds the intersection of two ranges.
 *
 * @param a0 - The start point in the A range
 * @param a1 - The end point in the A range
 * @param b0 - The start point in the B range
 * @param b1 - The end point in the B range
 * @returns The intersection of the ranges, or null if no intersection
 * @public
 */
export declare function rangeIntersection(a0: number, a1: number, b0: number, b1: number): [number, number] | null;

/**
 * @param a0 - The start point in the A range
 * @param a1 - The end point in the A range
 * @param b0 - The start point in the B range
 * @param b1 - The end point in the B range
 * @returns True if the ranges overlap
 * @public
 */
export declare function rangesOverlap(a0: number, a1: number, b0: number, b1: number): boolean;

/** @public */
export declare const ROTATE_CORNER_TO_SELECTION_CORNER: {
    readonly top_left_rotate: "top_left";
    readonly top_right_rotate: "top_right";
    readonly bottom_right_rotate: "bottom_right";
    readonly bottom_left_rotate: "bottom_left";
    readonly mobile_rotate: "top_left";
};

/** @public */
export declare type RotateCorner = 'bottom_left_rotate' | 'bottom_right_rotate' | 'mobile_rotate' | 'top_left_rotate' | 'top_right_rotate';

/** @public */
export declare function rotateSelectionHandle(handle: SelectionHandle, rotation: number): SelectionHandle;

/** @public */
export declare type SelectionCorner = 'bottom_left' | 'bottom_right' | 'top_left' | 'top_right';

/** @public */
export declare type SelectionEdge = 'bottom' | 'left' | 'right' | 'top';

/** @public */
export declare type SelectionHandle = SelectionCorner | SelectionEdge;

/** @public */
export declare function setStrokePointRadii(strokePoints: StrokePoint[], options: StrokeOptions): StrokePoint[];

/**
 * Get the short angle distance between two angles.
 *
 * @param a0 - The first angle.
 * @param a1 - The second angle.
 * @public
 */
export declare function shortAngleDist(a0: number, a1: number): number;

/**
 * Simplify a line (using Ramer-Douglas-Peucker algorithm).
 *
 * @param points - An array of points as [x, y, ...][]
 * @param tolerance - The minimum line distance (also called epsilon).
 * @returns Simplified array as [x, y, ...][]
 * @public
 */
export declare function simplify(points: VecLike[], tolerance?: number): VecLike[];

/** @public */
export declare function simplify2(points: VecLike[], tolerance?: number): VecLike[];

/** @public */
export declare const SIN: (x: number) => number;

/**
 * Clamp rotation to even segments.
 *
 * @param r - The rotation in radians.
 * @param segments - The number of segments.
 * @public
 */
export declare function snapAngle(r: number, segments: number): number;

/**
 * The options object for `getStroke` or `getStrokePoints`.
 *
 * @public
 */
export declare interface StrokeOptions {
    /** The base size (diameter) of the stroke. */
    size?: number;
    /** The effect of pressure on the stroke's size. */
    thinning?: number;
    /** How much to soften the stroke's edges. */
    smoothing?: number;
    streamline?: number;
    /** An easing function to apply to each point's pressure. */
    easing?: (pressure: number) => number;
    /** Whether to simulate pressure based on velocity. */
    simulatePressure?: boolean;
    /** Cap, taper and easing for the start of the line. */
    start?: {
        cap?: boolean;
        taper?: boolean | number;
        easing?: (distance: number) => number;
    };
    /** Cap, taper and easing for the end of the line. */
    end?: {
        cap?: boolean;
        taper?: boolean | number;
        easing?: (distance: number) => number;
    };
    /** Whether to handle the points as a completed stroke. */
    last?: boolean;
}

/**
 * The points returned by `getStrokePoints`, and the input for `getStrokeOutlinePoints`
 *
 * @public
 */
export declare interface StrokePoint {
    point: Vec2d;
    input: Vec2d;
    vector: Vec2d;
    pressure: number;
    distance: number;
    runningLength: number;
    radius: number;
}

/** @public */
export declare const TAU: number;

/**
 * The DOM likes values to be fixed to 3 decimal places
 *
 * @public
 */
export declare function toDomPrecision(v: number): number;

/**
 * @public
 */
export declare function toFixed(v: number): number;

/**
 * Get a number to a precision.
 *
 * @param n - The number.
 * @param precision - The precision.
 * @public
 */
export declare function toPrecision(n: number, precision?: number): number;

/** @public */
export declare class Vec2d {
    x: number;
    y: number;
    z: number;
    constructor(x?: number, y?: number, z?: number);
    get pressure(): number;
    set(x?: number, y?: number, z?: number): this;
    setTo({ x, y, z }: VecLike): this;
    rot(r: number): this;
    rotWith(C: VecLike, r: number): this;
    clone(): Vec2d;
    sub(V: VecLike): this;
    subXY(x: number, y: number): this;
    subScalar(n: number): this;
    add(V: VecLike): this;
    addXY(x: number, y: number): this;
    addScalar(n: number): this;
    clamp(min: number, max?: number): this;
    div(t: number): this;
    divV(V: VecLike): this;
    mul(t: number): this;
    mulV(V: VecLike): this;
    abs(): this;
    nudge(B: VecLike, distance: number): this;
    neg(): this;
    cross(V: VecLike): this;
    dpr(V: VecLike): number;
    cpr(V: VecLike): number;
    len2(): number;
    len(): number;
    pry(V: VecLike): number;
    per(): this;
    uni(): Vec2d;
    tan(V: VecLike): Vec2d;
    dist(V: VecLike): number;
    distanceToLineSegment(A: VecLike, B: VecLike): number;
    slope(B: VecLike): number;
    snapToGrid(gridSize: number): this;
    angle(B: VecLike): number;
    toAngle(): number;
    lrp(B: VecLike, t: number): Vec2d;
    equals(B: VecLike): boolean;
    equalsXY(x: number, y: number): boolean;
    norm(): this;
    toFixed(): Vec2d;
    toString(): string;
    toJson(): Vec2dModel;
    toArray(): number[];
    static Add(A: VecLike, B: VecLike): Vec2d;
    static AddXY(A: VecLike, x: number, y: number): Vec2d;
    static Sub(A: VecLike, B: VecLike): Vec2d;
    static SubXY(A: VecLike, x: number, y: number): Vec2d;
    static AddScalar(A: VecLike, n: number): Vec2d;
    static SubScalar(A: VecLike, n: number): Vec2d;
    static Div(A: VecLike, t: number): Vec2d;
    static Mul(A: VecLike, t: number): Vec2d;
    static DivV(A: VecLike, B: VecLike): Vec2d;
    static MulV(A: VecLike, B: VecLike): Vec2d;
    static Neg(A: VecLike): Vec2d;
    static Per(A: VecLike): Vec2d;
    static Dist2(A: VecLike, B: VecLike): number;
    static Abs(A: VecLike): Vec2d;
    static Dist(A: VecLike, B: VecLike): number;
    static Dpr(A: VecLike, B: VecLike): number;
    static Cross(A: VecLike, V: VecLike): Vec2d;
    static Cpr(A: VecLike, B: VecLike): number;
    static Len2(A: VecLike): number;
    static Len(A: VecLike): number;
    static Pry(A: VecLike, B: VecLike): number;
    static Uni(A: VecLike): Vec2d;
    static Tan(A: VecLike, B: VecLike): Vec2d;
    static Min(A: VecLike, B: VecLike): Vec2d;
    static Max(A: VecLike, B: VecLike): Vec2d;
    static From({ x, y, z }: Vec2dModel): Vec2d;
    static FromArray(v: number[]): Vec2d;
    static Rot(A: VecLike, r?: number): Vec2d;
    static RotWith(A: VecLike, C: VecLike, r: number): Vec2d;
    /**
     * Get the nearest point on a line with a known unit vector that passes through point A
     *
     * ```ts
     * Vec.nearestPointOnLineThroughPoint(A, u, Point)
     * ```
     *
     * @param A - Any point on the line
     * @param u - The unit vector for the line.
     * @param P - A point not on the line to test.
     */
    static NearestPointOnLineThroughPoint(A: VecLike, u: VecLike, P: VecLike): Vec2d;
    static NearestPointOnLineSegment(A: VecLike, B: VecLike, P: VecLike, clamp?: boolean): Vec2d;
    static DistanceToLineThroughPoint(A: VecLike, u: VecLike, P: VecLike): number;
    static DistanceToLineSegment(A: VecLike, B: VecLike, P: VecLike, clamp?: boolean): number;
    static Snap(A: VecLike, step?: number): Vec2d;
    static Cast(A: VecLike): Vec2d;
    static Slope(A: VecLike, B: VecLike): number;
    static Angle(A: VecLike, B: VecLike): number;
    static Lrp(A: VecLike, B: VecLike, t: number): Vec2d;
    static Med(A: VecLike, B: VecLike): Vec2d;
    static Equals(A: VecLike, B: VecLike): boolean;
    static EqualsXY(A: VecLike, x: number, y: number): boolean;
    static Clockwise(A: VecLike, B: VecLike, C: VecLike): boolean;
    static Rescale(A: VecLike, n: number): Vec2d;
    static ScaleWithOrigin(A: VecLike, scale: number, origin: VecLike): Vec2d;
    static ToFixed(A: VecLike, n?: number): Vec2d;
    static Nudge(A: VecLike, B: VecLike, distance: number): Vec2d;
    static ToString(A: VecLike): string;
    static ToAngle(A: VecLike): number;
    static ToArray(A: VecLike): number[];
    static ToJson(A: VecLike): {
        x: number;
        y: number;
        z: number | undefined;
    };
    static Average(arr: VecLike[]): Vec2d;
    static Clamp(A: Vec2d, min: number, max?: number): Vec2d;
    /**
     * Get an array of points (with simulated pressure) between two points.
     *
     * @param A - The first point.
     * @param B - The second point.
     * @param steps - The number of points to return.
     */
    static PointsBetween(A: Vec2dModel, B: Vec2dModel, steps?: number): Vec2d[];
    static SnapToGrid(A: VecLike, gridSize?: number): Vec2d;
}

/** @public */
export declare type VecLike = Vec2d | Vec2dModel;

export { }
