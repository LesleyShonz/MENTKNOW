{"ast":null,"code":"import { Box2d, getArcLength, getPointOnCircle, intersectCirclePolygon, intersectCirclePolyline, isSafeFloat, lerpAngles, Matrix2d, PI, PI2, shortAngleDist, Vec2d } from \"@tldraw/primitives\";\nimport { STROKE_SIZES } from \"../../shared/default-shape-constants.mjs\";\nimport { BOUND_ARROW_OFFSET, getArrowTerminalsInArrowSpace, getBoundShapeInfoForTerminal, MIN_ARROW_LENGTH, WAY_TOO_BIG_ARROW_BEND_FACTOR } from \"./shared.mjs\";\nimport { getStraightArrowInfo } from \"./straight-arrow.mjs\";\nfunction getCurvedArrowInfo(editor, shape) {\n  var extraBend = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var _shape$props = shape.props,\n    arrowheadEnd = _shape$props.arrowheadEnd,\n    arrowheadStart = _shape$props.arrowheadStart;\n  var bend = shape.props.bend + extraBend;\n  if (Math.abs(bend) > Math.abs(shape.props.bend * WAY_TOO_BIG_ARROW_BEND_FACTOR)) {\n    return getStraightArrowInfo(editor, shape);\n  }\n  var terminalsInArrowSpace = getArrowTerminalsInArrowSpace(editor, shape);\n  var med = Vec2d.Med(terminalsInArrowSpace.start, terminalsInArrowSpace.end);\n  var u = Vec2d.Sub(terminalsInArrowSpace.end, terminalsInArrowSpace.start).uni();\n  var middle = Vec2d.Add(med, u.per().mul(-bend));\n  var startShapeInfo = getBoundShapeInfoForTerminal(editor, shape.props.start);\n  var endShapeInfo = getBoundShapeInfoForTerminal(editor, shape.props.end);\n  var a = terminalsInArrowSpace.start.clone();\n  var b = terminalsInArrowSpace.end.clone();\n  var c = middle.clone();\n  var handleArc = getArcInfo(a, b, c);\n  if (handleArc.length === 0 || handleArc.size === 0 || !isSafeFloat(handleArc.length) || !isSafeFloat(handleArc.size)) {\n    return getStraightArrowInfo(editor, shape);\n  }\n  var arrowPageTransform = editor.getPageTransform(shape);\n  if (startShapeInfo && !startShapeInfo.isExact) {\n    var startInPageSpace = Matrix2d.applyToPoint(arrowPageTransform, a);\n    var endInPageSpace = Matrix2d.applyToPoint(arrowPageTransform, b);\n    var centerInPageSpace = Matrix2d.applyToPoint(arrowPageTransform, handleArc.center);\n    var inverseTransform = Matrix2d.Inverse(startShapeInfo.transform);\n    var startInStartShapeLocalSpace = Matrix2d.applyToPoint(inverseTransform, startInPageSpace);\n    var endInStartShapeLocalSpace = Matrix2d.applyToPoint(inverseTransform, endInPageSpace);\n    var centerInStartShapeLocalSpace = Matrix2d.applyToPoint(inverseTransform, centerInPageSpace);\n    var isClosed = startShapeInfo.util.isClosed(startShapeInfo.shape);\n    var fn = isClosed ? intersectCirclePolygon : intersectCirclePolyline;\n    var point;\n    var intersections = fn(centerInStartShapeLocalSpace, handleArc.radius, startShapeInfo.util.outline(startShapeInfo.shape));\n    if (intersections) {\n      var _intersections$;\n      intersections = intersections.filter(function (pt) {\n        return +Vec2d.Clockwise(startInStartShapeLocalSpace, pt, endInStartShapeLocalSpace) === handleArc.sweepFlag;\n      });\n      var angleToMiddle = Vec2d.Angle(handleArc.center, middle);\n      var angleToStart = Vec2d.Angle(handleArc.center, terminalsInArrowSpace.start);\n      var comparisonAngle = lerpAngles(angleToMiddle, angleToStart, 0.5);\n      intersections.sort(function (p0, p1) {\n        return Math.abs(shortAngleDist(comparisonAngle, centerInStartShapeLocalSpace.angle(p0))) - Math.abs(shortAngleDist(comparisonAngle, centerInStartShapeLocalSpace.angle(p1)));\n      });\n      point = (_intersections$ = intersections[0]) !== null && _intersections$ !== void 0 ? _intersections$ : isClosed ? void 0 : startInStartShapeLocalSpace;\n    } else {\n      point = isClosed ? void 0 : startInStartShapeLocalSpace;\n    }\n    if (point) {\n      a.setTo(editor.getPointInShapeSpace(shape, Matrix2d.applyToPoint(startShapeInfo.transform, point)));\n      startShapeInfo.didIntersect = true;\n      if (arrowheadStart !== \"none\") {\n        var offset = BOUND_ARROW_OFFSET + STROKE_SIZES[shape.props.size] / 2 + (\"size\" in startShapeInfo.shape.props ? STROKE_SIZES[startShapeInfo.shape.props.size] / 2 : 0);\n        a.setTo(getPointOnCircle(handleArc.center.x, handleArc.center.y, handleArc.radius, lerpAngles(Vec2d.Angle(handleArc.center, a), Vec2d.Angle(handleArc.center, middle), offset / Math.abs(getArcLength(handleArc.center, handleArc.radius, a, middle)))));\n      }\n    }\n  }\n  if (endShapeInfo && !endShapeInfo.isExact) {\n    var _startInPageSpace = Matrix2d.applyToPoint(arrowPageTransform, a);\n    var _endInPageSpace = Matrix2d.applyToPoint(arrowPageTransform, b);\n    var _centerInPageSpace = Matrix2d.applyToPoint(arrowPageTransform, handleArc.center);\n    var _inverseTransform = Matrix2d.Inverse(endShapeInfo.transform);\n    var startInEndShapeLocalSpace = Matrix2d.applyToPoint(_inverseTransform, _startInPageSpace);\n    var endInEndShapeLocalSpace = Matrix2d.applyToPoint(_inverseTransform, _endInPageSpace);\n    var centerInEndShapeLocalSpace = Matrix2d.applyToPoint(_inverseTransform, _centerInPageSpace);\n    var _isClosed = endShapeInfo.util.isClosed(endShapeInfo.shape);\n    var _fn = _isClosed ? intersectCirclePolygon : intersectCirclePolyline;\n    var _angleToMiddle = Vec2d.Angle(handleArc.center, middle);\n    var angleToEnd = Vec2d.Angle(handleArc.center, terminalsInArrowSpace.end);\n    var _comparisonAngle = lerpAngles(_angleToMiddle, angleToEnd, 0.5);\n    var _point;\n    var _intersections = _fn(centerInEndShapeLocalSpace, handleArc.radius, endShapeInfo.util.outline(endShapeInfo.shape));\n    if (_intersections) {\n      var _intersections$2;\n      _intersections = _intersections.filter(function (pt) {\n        return +Vec2d.Clockwise(startInEndShapeLocalSpace, pt, endInEndShapeLocalSpace) === handleArc.sweepFlag;\n      });\n      _intersections.sort(function (p0, p1) {\n        return Math.abs(shortAngleDist(_comparisonAngle, centerInEndShapeLocalSpace.angle(p0))) - Math.abs(shortAngleDist(_comparisonAngle, centerInEndShapeLocalSpace.angle(p1)));\n      });\n      _point = (_intersections$2 = _intersections[0]) !== null && _intersections$2 !== void 0 ? _intersections$2 : _isClosed ? void 0 : endInEndShapeLocalSpace;\n    } else {\n      _point = _isClosed ? void 0 : endInEndShapeLocalSpace;\n    }\n    if (_point) {\n      b.setTo(editor.getPointInShapeSpace(shape, Matrix2d.applyToPoint(endShapeInfo.transform, _point)));\n      endShapeInfo.didIntersect = true;\n      if (arrowheadEnd !== \"none\") {\n        var _offset = BOUND_ARROW_OFFSET + STROKE_SIZES[shape.props.size] / 2 + (\"size\" in endShapeInfo.shape.props ? STROKE_SIZES[endShapeInfo.shape.props.size] / 2 : 0);\n        if (Vec2d.Dist(a, b) < MIN_ARROW_LENGTH) {\n          _offset *= -2;\n        }\n        b.setTo(getPointOnCircle(handleArc.center.x, handleArc.center.y, handleArc.radius, lerpAngles(Vec2d.Angle(handleArc.center, b), Vec2d.Angle(handleArc.center, middle), _offset / Math.abs(getArcLength(handleArc.center, handleArc.radius, b, middle)))));\n      }\n    }\n  }\n  var length = Math.abs(getArcLength(handleArc.center, handleArc.radius, a, b));\n  if (length < MIN_ARROW_LENGTH / 2) {\n    a.setTo(terminalsInArrowSpace.start);\n    b.setTo(terminalsInArrowSpace.end);\n  }\n  if (startShapeInfo && endShapeInfo && startShapeInfo.shape !== endShapeInfo.shape && !startShapeInfo.isExact && !endShapeInfo.isExact) {\n    var startAngle = Vec2d.Angle(handleArc.center, a);\n    var endAngle = Vec2d.Angle(handleArc.center, b);\n    var _offset2 = handleArc.sweepFlag ? MIN_ARROW_LENGTH : -MIN_ARROW_LENGTH;\n    var arcLength = getArcLength(handleArc.center, handleArc.radius, b, a);\n    var _handleArc$center = handleArc.center,\n      x = _handleArc$center.x,\n      y = _handleArc$center.y,\n      radius = handleArc.radius;\n    if (startShapeInfo && !startShapeInfo.didIntersect) {\n      a.setTo(getPointOnCircle(x, y, radius, lerpAngles(startAngle, endAngle, _offset2 / arcLength)));\n    }\n    if (endShapeInfo && !endShapeInfo.didIntersect) {\n      b.setTo(getPointOnCircle(x, y, radius, lerpAngles(startAngle, endAngle, -_offset2 / arcLength)));\n    }\n  }\n  var midAngle = lerpAngles(Vec2d.Angle(handleArc.center, a), Vec2d.Angle(handleArc.center, b), 0.5);\n  var midPoint = getPointOnCircle(handleArc.center.x, handleArc.center.y, handleArc.radius, midAngle);\n  if (+Vec2d.Clockwise(a, midPoint, b) !== handleArc.sweepFlag) {\n    midAngle += PI;\n    midPoint = getPointOnCircle(handleArc.center.x, handleArc.center.y, handleArc.radius, midAngle);\n  }\n  c.setTo(midPoint);\n  var bodyArc = getArcInfo(a, b, c);\n  return {\n    isStraight: false,\n    start: {\n      point: a,\n      handle: terminalsInArrowSpace.start,\n      arrowhead: shape.props.arrowheadStart\n    },\n    end: {\n      point: b,\n      handle: terminalsInArrowSpace.end,\n      arrowhead: shape.props.arrowheadEnd\n    },\n    middle: c,\n    handleArc: handleArc,\n    bodyArc: bodyArc,\n    isValid: bodyArc.length !== 0 && isFinite(bodyArc.center.x) && isFinite(bodyArc.center.y)\n  };\n}\nfunction getCurvedArrowHandlePath(info) {\n  var start = info.start,\n    end = info.end,\n    _info$handleArc = info.handleArc,\n    radius = _info$handleArc.radius,\n    largeArcFlag = _info$handleArc.largeArcFlag,\n    sweepFlag = _info$handleArc.sweepFlag;\n  return \"M\".concat(start.handle.x, \",\").concat(start.handle.y, \" A\").concat(radius, \" \").concat(radius, \" 0 \").concat(largeArcFlag, \" \").concat(sweepFlag, \" \").concat(end.handle.x, \",\").concat(end.handle.y);\n}\nfunction getSolidCurvedArrowPath(info) {\n  var start = info.start,\n    end = info.end,\n    _info$bodyArc = info.bodyArc,\n    radius = _info$bodyArc.radius,\n    largeArcFlag = _info$bodyArc.largeArcFlag,\n    sweepFlag = _info$bodyArc.sweepFlag;\n  return \"M\".concat(start.point.x, \",\").concat(start.point.y, \" A\").concat(radius, \" \").concat(radius, \" 0 \").concat(largeArcFlag, \" \").concat(sweepFlag, \" \").concat(end.point.x, \",\").concat(end.point.y);\n}\nfunction getPointOnArc(center, radius, startAngle, size, t) {\n  var angle = startAngle + size * t;\n  return new Vec2d(center.x + radius * Math.cos(angle), center.y + radius * Math.sin(angle));\n}\nfunction getArcBoundingBox(center, radius, start, size) {\n  var minX = Infinity;\n  var minY = Infinity;\n  var maxX = -Infinity;\n  var maxY = -Infinity;\n  var startAngle = Vec2d.Angle(center, start);\n  for (var i = 0; i < 20; i++) {\n    var angle = startAngle + size * (i / 19);\n    var x = center.x + radius * Math.cos(angle);\n    var y = center.y + radius * Math.sin(angle);\n    minX = Math.min(x, minX);\n    minY = Math.min(y, minY);\n    maxX = Math.max(x, maxX);\n    maxY = Math.max(y, maxY);\n  }\n  return new Box2d(minX, minY, maxX - minX, maxY - minY);\n}\nfunction getArcInfo(a, b, c) {\n  var u = -2 * (a.x * (b.y - c.y) - a.y * (b.x - c.x) + b.x * c.y - c.x * b.y);\n  var center = {\n    x: ((a.x * a.x + a.y * a.y) * (c.y - b.y) + (b.x * b.x + b.y * b.y) * (a.y - c.y) + (c.x * c.x + c.y * c.y) * (b.y - a.y)) / u,\n    y: ((a.x * a.x + a.y * a.y) * (b.x - c.x) + (b.x * b.x + b.y * b.y) * (c.x - a.x) + (c.x * c.x + c.y * c.y) * (a.x - b.x)) / u\n  };\n  var radius = Vec2d.Dist(center, a);\n  var sweepFlag = +Vec2d.Clockwise(a, c, b);\n  var ab = Math.hypot(a.y - b.y, a.x - b.x);\n  var bc = Math.hypot(b.y - c.y, b.x - c.x);\n  var ca = Math.hypot(c.y - a.y, c.x - a.x);\n  var theta = Math.acos((bc * bc + ca * ca - ab * ab) / (2 * bc * ca)) * 2;\n  var largeArcFlag = +(PI > theta);\n  var size = (PI2 - theta) * (sweepFlag ? 1 : -1);\n  var length = size * radius;\n  return {\n    center: center,\n    radius: radius,\n    size: size,\n    length: length,\n    largeArcFlag: largeArcFlag,\n    sweepFlag: sweepFlag\n  };\n}\nexport { getArcBoundingBox, getArcInfo, getCurvedArrowHandlePath, getCurvedArrowInfo, getPointOnArc, getSolidCurvedArrowPath };","map":{"version":3,"names":["Box2d","getArcLength","getPointOnCircle","intersectCirclePolygon","intersectCirclePolyline","isSafeFloat","lerpAngles","Matrix2d","PI","PI2","shortAngleDist","Vec2d","STROKE_SIZES","BOUND_ARROW_OFFSET","getArrowTerminalsInArrowSpace","getBoundShapeInfoForTerminal","MIN_ARROW_LENGTH","WAY_TOO_BIG_ARROW_BEND_FACTOR","getStraightArrowInfo","getCurvedArrowInfo","editor","shape","extraBend","arguments","length","undefined","_shape$props","props","arrowheadEnd","arrowheadStart","bend","Math","abs","terminalsInArrowSpace","med","Med","start","end","u","Sub","uni","middle","Add","per","mul","startShapeInfo","endShapeInfo","a","clone","b","c","handleArc","getArcInfo","size","arrowPageTransform","getPageTransform","isExact","startInPageSpace","applyToPoint","endInPageSpace","centerInPageSpace","center","inverseTransform","Inverse","transform","startInStartShapeLocalSpace","endInStartShapeLocalSpace","centerInStartShapeLocalSpace","isClosed","util","fn","point","intersections","radius","outline","_intersections$","filter","pt","Clockwise","sweepFlag","angleToMiddle","Angle","angleToStart","comparisonAngle","sort","p0","p1","angle","setTo","getPointInShapeSpace","didIntersect","offset","x","y","startInEndShapeLocalSpace","endInEndShapeLocalSpace","centerInEndShapeLocalSpace","angleToEnd","_intersections$2","Dist","startAngle","endAngle","arcLength","_handleArc$center","midAngle","midPoint","bodyArc","isStraight","handle","arrowhead","isValid","isFinite","getCurvedArrowHandlePath","info","_info$handleArc","largeArcFlag","concat","getSolidCurvedArrowPath","_info$bodyArc","getPointOnArc","t","cos","sin","getArcBoundingBox","minX","Infinity","minY","maxX","maxY","i","min","max","ab","hypot","bc","ca","theta","acos"],"sources":["/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@tldraw/editor/src/lib/editor/shapes/arrow/arrow/curved-arrow.ts"],"sourcesContent":["import {\n\tBox2d,\n\tgetArcLength,\n\tgetPointOnCircle,\n\tintersectCirclePolygon,\n\tintersectCirclePolyline,\n\tisSafeFloat,\n\tlerpAngles,\n\tMatrix2d,\n\tPI,\n\tPI2,\n\tshortAngleDist,\n\tVec2d,\n\tVecLike,\n} from '@tldraw/primitives'\nimport { TLArrowShape } from '@tldraw/tlschema'\nimport type { Editor } from '../../../Editor'\nimport { STROKE_SIZES } from '../../shared/default-shape-constants'\nimport { ArcInfo, ArrowInfo } from './arrow-types'\nimport {\n\tBOUND_ARROW_OFFSET,\n\tgetArrowTerminalsInArrowSpace,\n\tgetBoundShapeInfoForTerminal,\n\tMIN_ARROW_LENGTH,\n\tWAY_TOO_BIG_ARROW_BEND_FACTOR,\n} from './shared'\nimport { getStraightArrowInfo } from './straight-arrow'\n\nexport function getCurvedArrowInfo(editor: Editor, shape: TLArrowShape, extraBend = 0): ArrowInfo {\n\tconst { arrowheadEnd, arrowheadStart } = shape.props\n\tconst bend = shape.props.bend + extraBend\n\n\tif (Math.abs(bend) > Math.abs(shape.props.bend * WAY_TOO_BIG_ARROW_BEND_FACTOR)) {\n\t\treturn getStraightArrowInfo(editor, shape)\n\t}\n\n\tconst terminalsInArrowSpace = getArrowTerminalsInArrowSpace(editor, shape)\n\n\tconst med = Vec2d.Med(terminalsInArrowSpace.start, terminalsInArrowSpace.end) // point between start and end\n\tconst u = Vec2d.Sub(terminalsInArrowSpace.end, terminalsInArrowSpace.start).uni() // unit vector between start and end\n\tconst middle = Vec2d.Add(med, u.per().mul(-bend)) // middle handle\n\n\tconst startShapeInfo = getBoundShapeInfoForTerminal(editor, shape.props.start)\n\tconst endShapeInfo = getBoundShapeInfoForTerminal(editor, shape.props.end)\n\n\t// The positions of the body of the arrow, which may be different\n\t// than the arrow's start / end points if the arrow is bound to shapes\n\tconst a = terminalsInArrowSpace.start.clone()\n\tconst b = terminalsInArrowSpace.end.clone()\n\tconst c = middle.clone()\n\n\tconst handleArc = getArcInfo(a, b, c)\n\n\tif (\n\t\thandleArc.length === 0 ||\n\t\thandleArc.size === 0 ||\n\t\t!isSafeFloat(handleArc.length) ||\n\t\t!isSafeFloat(handleArc.size)\n\t) {\n\t\treturn getStraightArrowInfo(editor, shape)\n\t}\n\n\tconst arrowPageTransform = editor.getPageTransform(shape)!\n\n\tif (startShapeInfo && !startShapeInfo.isExact) {\n\t\t// Points in page space\n\t\tconst startInPageSpace = Matrix2d.applyToPoint(arrowPageTransform, a)\n\t\tconst endInPageSpace = Matrix2d.applyToPoint(arrowPageTransform, b)\n\t\tconst centerInPageSpace = Matrix2d.applyToPoint(arrowPageTransform, handleArc.center)\n\n\t\t// Points in local space of the start shape\n\t\tconst inverseTransform = Matrix2d.Inverse(startShapeInfo.transform)\n\t\tconst startInStartShapeLocalSpace = Matrix2d.applyToPoint(inverseTransform, startInPageSpace)\n\t\tconst endInStartShapeLocalSpace = Matrix2d.applyToPoint(inverseTransform, endInPageSpace)\n\t\tconst centerInStartShapeLocalSpace = Matrix2d.applyToPoint(inverseTransform, centerInPageSpace)\n\n\t\tconst isClosed = startShapeInfo.util.isClosed(startShapeInfo.shape)\n\t\tconst fn = isClosed ? intersectCirclePolygon : intersectCirclePolyline\n\n\t\tlet point: VecLike | undefined\n\n\t\tlet intersections = fn(\n\t\t\tcenterInStartShapeLocalSpace,\n\t\t\thandleArc.radius,\n\t\t\tstartShapeInfo.util.outline(startShapeInfo.shape)\n\t\t)\n\n\t\tif (intersections) {\n\t\t\tintersections = intersections.filter(\n\t\t\t\t(pt) =>\n\t\t\t\t\t+Vec2d.Clockwise(startInStartShapeLocalSpace, pt, endInStartShapeLocalSpace) ===\n\t\t\t\t\thandleArc.sweepFlag\n\t\t\t)\n\n\t\t\tconst angleToMiddle = Vec2d.Angle(handleArc.center, middle)\n\t\t\tconst angleToStart = Vec2d.Angle(handleArc.center, terminalsInArrowSpace.start)\n\t\t\tconst comparisonAngle = lerpAngles(angleToMiddle, angleToStart, 0.5)\n\n\t\t\tintersections.sort(\n\t\t\t\t(p0, p1) =>\n\t\t\t\t\tMath.abs(shortAngleDist(comparisonAngle, centerInStartShapeLocalSpace.angle(p0))) -\n\t\t\t\t\tMath.abs(shortAngleDist(comparisonAngle, centerInStartShapeLocalSpace.angle(p1)))\n\t\t\t)\n\n\t\t\tpoint = intersections[0] ?? (isClosed ? undefined : startInStartShapeLocalSpace)\n\t\t} else {\n\t\t\tpoint = isClosed ? undefined : startInStartShapeLocalSpace\n\t\t}\n\n\t\tif (point) {\n\t\t\ta.setTo(\n\t\t\t\teditor.getPointInShapeSpace(shape, Matrix2d.applyToPoint(startShapeInfo.transform, point))\n\t\t\t)\n\n\t\t\tstartShapeInfo.didIntersect = true\n\n\t\t\tif (arrowheadStart !== 'none') {\n\t\t\t\tconst offset =\n\t\t\t\t\tBOUND_ARROW_OFFSET +\n\t\t\t\t\tSTROKE_SIZES[shape.props.size] / 2 +\n\t\t\t\t\t('size' in startShapeInfo.shape.props\n\t\t\t\t\t\t? STROKE_SIZES[startShapeInfo.shape.props.size] / 2\n\t\t\t\t\t\t: 0)\n\n\t\t\t\ta.setTo(\n\t\t\t\t\tgetPointOnCircle(\n\t\t\t\t\t\thandleArc.center.x,\n\t\t\t\t\t\thandleArc.center.y,\n\t\t\t\t\t\thandleArc.radius,\n\t\t\t\t\t\tlerpAngles(\n\t\t\t\t\t\t\tVec2d.Angle(handleArc.center, a),\n\t\t\t\t\t\t\tVec2d.Angle(handleArc.center, middle),\n\t\t\t\t\t\t\toffset / Math.abs(getArcLength(handleArc.center, handleArc.radius, a, middle))\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t}\n\t\t}\n\t}\n\n\tif (endShapeInfo && !endShapeInfo.isExact) {\n\t\t// get points in shape's coordinates?\n\t\tconst startInPageSpace = Matrix2d.applyToPoint(arrowPageTransform, a)\n\t\tconst endInPageSpace = Matrix2d.applyToPoint(arrowPageTransform, b)\n\t\tconst centerInPageSpace = Matrix2d.applyToPoint(arrowPageTransform, handleArc.center)\n\n\t\tconst inverseTransform = Matrix2d.Inverse(endShapeInfo.transform)\n\n\t\tconst startInEndShapeLocalSpace = Matrix2d.applyToPoint(inverseTransform, startInPageSpace)\n\t\tconst endInEndShapeLocalSpace = Matrix2d.applyToPoint(inverseTransform, endInPageSpace)\n\t\tconst centerInEndShapeLocalSpace = Matrix2d.applyToPoint(inverseTransform, centerInPageSpace)\n\n\t\tconst isClosed = endShapeInfo.util.isClosed(endShapeInfo.shape)\n\t\tconst fn = isClosed ? intersectCirclePolygon : intersectCirclePolyline\n\n\t\tconst angleToMiddle = Vec2d.Angle(handleArc.center, middle)\n\t\tconst angleToEnd = Vec2d.Angle(handleArc.center, terminalsInArrowSpace.end)\n\t\tconst comparisonAngle = lerpAngles(angleToMiddle, angleToEnd, 0.5)\n\n\t\tlet point: VecLike | undefined\n\n\t\tlet intersections = fn(\n\t\t\tcenterInEndShapeLocalSpace,\n\t\t\thandleArc.radius,\n\t\t\tendShapeInfo.util.outline(endShapeInfo.shape)\n\t\t)\n\n\t\tif (intersections) {\n\t\t\tintersections = intersections.filter(\n\t\t\t\t(pt) =>\n\t\t\t\t\t+Vec2d.Clockwise(startInEndShapeLocalSpace, pt, endInEndShapeLocalSpace) ===\n\t\t\t\t\thandleArc.sweepFlag\n\t\t\t)\n\n\t\t\tintersections.sort(\n\t\t\t\t(p0, p1) =>\n\t\t\t\t\tMath.abs(shortAngleDist(comparisonAngle, centerInEndShapeLocalSpace.angle(p0))) -\n\t\t\t\t\tMath.abs(shortAngleDist(comparisonAngle, centerInEndShapeLocalSpace.angle(p1)))\n\t\t\t)\n\n\t\t\tpoint = intersections[0] ?? (isClosed ? undefined : endInEndShapeLocalSpace)\n\t\t} else {\n\t\t\tpoint = isClosed ? undefined : endInEndShapeLocalSpace\n\t\t}\n\n\t\tif (point) {\n\t\t\t// Set b to target local point -> page point -> shape local point\n\t\t\tb.setTo(\n\t\t\t\teditor.getPointInShapeSpace(shape, Matrix2d.applyToPoint(endShapeInfo.transform, point))\n\t\t\t)\n\n\t\t\tendShapeInfo.didIntersect = true\n\n\t\t\tif (arrowheadEnd !== 'none') {\n\t\t\t\tlet offset =\n\t\t\t\t\tBOUND_ARROW_OFFSET +\n\t\t\t\t\tSTROKE_SIZES[shape.props.size] / 2 +\n\t\t\t\t\t('size' in endShapeInfo.shape.props ? STROKE_SIZES[endShapeInfo.shape.props.size] / 2 : 0)\n\n\t\t\t\tif (Vec2d.Dist(a, b) < MIN_ARROW_LENGTH) {\n\t\t\t\t\toffset *= -2\n\t\t\t\t}\n\n\t\t\t\tb.setTo(\n\t\t\t\t\tgetPointOnCircle(\n\t\t\t\t\t\thandleArc.center.x,\n\t\t\t\t\t\thandleArc.center.y,\n\t\t\t\t\t\thandleArc.radius,\n\t\t\t\t\t\tlerpAngles(\n\t\t\t\t\t\t\tVec2d.Angle(handleArc.center, b),\n\t\t\t\t\t\t\tVec2d.Angle(handleArc.center, middle),\n\t\t\t\t\t\t\toffset / Math.abs(getArcLength(handleArc.center, handleArc.radius, b, middle))\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t}\n\t\t}\n\t}\n\n\tconst length = Math.abs(getArcLength(handleArc.center, handleArc.radius, a, b))\n\n\tif (length < MIN_ARROW_LENGTH / 2) {\n\t\ta.setTo(terminalsInArrowSpace.start)\n\t\tb.setTo(terminalsInArrowSpace.end)\n\t}\n\n\tif (\n\t\tstartShapeInfo &&\n\t\tendShapeInfo &&\n\t\tstartShapeInfo.shape !== endShapeInfo.shape &&\n\t\t!startShapeInfo.isExact &&\n\t\t!endShapeInfo.isExact\n\t) {\n\t\t// If we missed an intersection, then try\n\t\tconst startAngle = Vec2d.Angle(handleArc.center, a)\n\t\tconst endAngle = Vec2d.Angle(handleArc.center, b)\n\n\t\tconst offset = handleArc.sweepFlag ? MIN_ARROW_LENGTH : -MIN_ARROW_LENGTH\n\t\tconst arcLength = getArcLength(handleArc.center, handleArc.radius, b, a)\n\t\tconst {\n\t\t\tcenter: { x, y },\n\t\t\tradius,\n\t\t} = handleArc\n\n\t\tif (startShapeInfo && !startShapeInfo.didIntersect) {\n\t\t\ta.setTo(getPointOnCircle(x, y, radius, lerpAngles(startAngle, endAngle, offset / arcLength)))\n\t\t}\n\n\t\tif (endShapeInfo && !endShapeInfo.didIntersect) {\n\t\t\tb.setTo(getPointOnCircle(x, y, radius, lerpAngles(startAngle, endAngle, -offset / arcLength)))\n\t\t}\n\t}\n\n\tlet midAngle = lerpAngles(Vec2d.Angle(handleArc.center, a), Vec2d.Angle(handleArc.center, b), 0.5)\n\tlet midPoint = getPointOnCircle(\n\t\thandleArc.center.x,\n\t\thandleArc.center.y,\n\t\thandleArc.radius,\n\t\tmidAngle\n\t)\n\n\tif (+Vec2d.Clockwise(a, midPoint, b) !== handleArc.sweepFlag) {\n\t\tmidAngle += PI\n\t\tmidPoint = getPointOnCircle(handleArc.center.x, handleArc.center.y, handleArc.radius, midAngle)\n\t}\n\n\tc.setTo(midPoint)\n\n\tconst bodyArc = getArcInfo(a, b, c)\n\n\treturn {\n\t\tisStraight: false,\n\t\tstart: {\n\t\t\tpoint: a,\n\t\t\thandle: terminalsInArrowSpace.start,\n\t\t\tarrowhead: shape.props.arrowheadStart,\n\t\t},\n\t\tend: {\n\t\t\tpoint: b,\n\t\t\thandle: terminalsInArrowSpace.end,\n\t\t\tarrowhead: shape.props.arrowheadEnd,\n\t\t},\n\t\tmiddle: c,\n\t\thandleArc,\n\t\tbodyArc,\n\t\tisValid: bodyArc.length !== 0 && isFinite(bodyArc.center.x) && isFinite(bodyArc.center.y),\n\t}\n}\n\n/**\n * Get a solid path for a curved arrow's handles.\n *\n * @param info - The arrow info.\n */\nexport function getCurvedArrowHandlePath(info: ArrowInfo & { isStraight: false }) {\n\tconst {\n\t\tstart,\n\t\tend,\n\t\thandleArc: { radius, largeArcFlag, sweepFlag },\n\t} = info\n\treturn `M${start.handle.x},${start.handle.y} A${radius} ${radius} 0 ${largeArcFlag} ${sweepFlag} ${end.handle.x},${end.handle.y}`\n}\n\n/**\n * Get a solid path for a curved arrow's body.\n *\n * @param info - The arrow info.\n */\nexport function getSolidCurvedArrowPath(info: ArrowInfo & { isStraight: false }) {\n\tconst {\n\t\tstart,\n\t\tend,\n\t\tbodyArc: { radius, largeArcFlag, sweepFlag },\n\t} = info\n\treturn `M${start.point.x},${start.point.y} A${radius} ${radius} 0 ${largeArcFlag} ${sweepFlag} ${end.point.x},${end.point.y}`\n}\n\n/**\n * Get a point along an arc.\n *\n * @param center - The arc's center.\n * @param radius - The arc's radius.\n * @param startAngle - The start point of the arc.\n * @param size - The size of the arc.\n * @param t - The point along the arc to get.\n */\nexport function getPointOnArc(\n\tcenter: VecLike,\n\tradius: number,\n\tstartAngle: number,\n\tsize: number,\n\tt: number\n) {\n\tconst angle = startAngle + size * t\n\treturn new Vec2d(center.x + radius * Math.cos(angle), center.y + radius * Math.sin(angle))\n}\n\n/**\n * Get a bounding box for an arc.\n *\n * @param center - The arc's center.\n * @param radius - The arc's radius.\n * @param start - The start point of the arc.\n * @param size - The size of the arc.\n */\nexport function getArcBoundingBox(center: VecLike, radius: number, start: VecLike, size: number) {\n\tlet minX = Infinity\n\tlet minY = Infinity\n\tlet maxX = -Infinity\n\tlet maxY = -Infinity\n\n\tconst startAngle = Vec2d.Angle(center, start)\n\n\t// Test 20 points along the arc\n\tfor (let i = 0; i < 20; i++) {\n\t\tconst angle = startAngle + size * (i / 19)\n\t\tconst x = center.x + radius * Math.cos(angle)\n\t\tconst y = center.y + radius * Math.sin(angle)\n\n\t\tminX = Math.min(x, minX)\n\t\tminY = Math.min(y, minY)\n\t\tmaxX = Math.max(x, maxX)\n\t\tmaxY = Math.max(y, maxY)\n\t}\n\n\treturn new Box2d(minX, minY, maxX - minX, maxY - minY)\n}\n\n/**\n * Get info about an arc formed by three points.\n *\n * @param a - The start of the arc\n * @param b - The end of the arc\n * @param c - A point on the arc\n */\nexport function getArcInfo(a: VecLike, b: VecLike, c: VecLike): ArcInfo {\n\t// find a circle from the three points\n\tconst u = -2 * (a.x * (b.y - c.y) - a.y * (b.x - c.x) + b.x * c.y - c.x * b.y)\n\n\tconst center = {\n\t\tx:\n\t\t\t((a.x * a.x + a.y * a.y) * (c.y - b.y) +\n\t\t\t\t(b.x * b.x + b.y * b.y) * (a.y - c.y) +\n\t\t\t\t(c.x * c.x + c.y * c.y) * (b.y - a.y)) /\n\t\t\tu,\n\t\ty:\n\t\t\t((a.x * a.x + a.y * a.y) * (b.x - c.x) +\n\t\t\t\t(b.x * b.x + b.y * b.y) * (c.x - a.x) +\n\t\t\t\t(c.x * c.x + c.y * c.y) * (a.x - b.x)) /\n\t\t\tu,\n\t}\n\n\tconst radius = Vec2d.Dist(center, a)\n\n\t// Whether to draw the arc clockwise or counter-clockwise (are the points clockwise?)\n\tconst sweepFlag = +Vec2d.Clockwise(a, c, b)\n\n\t// The base angle of the arc in radians\n\tconst ab = Math.hypot(a.y - b.y, a.x - b.x)\n\tconst bc = Math.hypot(b.y - c.y, b.x - c.x)\n\tconst ca = Math.hypot(c.y - a.y, c.x - a.x)\n\n\tconst theta = Math.acos((bc * bc + ca * ca - ab * ab) / (2 * bc * ca)) * 2\n\n\t// Whether to draw the long arc or short arc\n\tconst largeArcFlag = +(PI > theta)\n\n\t// The size of the arc to draw in radians\n\tconst size = (PI2 - theta) * (sweepFlag ? 1 : -1)\n\n\t// The length of the arc to draw in distance units\n\tconst length = size * radius\n\n\treturn {\n\t\tcenter,\n\t\tradius,\n\t\tsize,\n\t\tlength,\n\t\tlargeArcFlag,\n\t\tsweepFlag,\n\t}\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}