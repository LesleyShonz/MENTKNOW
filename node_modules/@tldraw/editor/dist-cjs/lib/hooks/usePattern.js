"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var usePattern_exports = {};
__export(usePattern_exports, {
  exportPatternSvgDefs: () => exportPatternSvgDefs,
  usePattern: () => usePattern
});
module.exports = __toCommonJS(usePattern_exports);
var import_jsx_runtime = require("react/jsx-runtime");
var import_react = require("react");
var import_constants = require("../constants");
var import_debug_flags = require("../utils/debug-flags");
var import_useEditor = require("./useEditor");
const TILE_PATTERN_SIZE = 8;
const generateImage = (dpr, currentZoom, darkMode) => {
  return new Promise((resolve, reject) => {
    const size = TILE_PATTERN_SIZE * currentZoom * dpr;
    const canvasEl = document.createElement("canvas");
    canvasEl.width = size;
    canvasEl.height = size;
    const ctx = canvasEl.getContext("2d");
    if (!ctx)
      return;
    ctx.fillStyle = darkMode ? "#212529" : "#f8f9fa";
    ctx.fillRect(0, 0, size, size);
    ctx.globalCompositeOperation = "destination-out";
    ctx.lineCap = "round";
    ctx.lineWidth = 1.25 * currentZoom * dpr;
    const t2 = 8 / 12;
    const s = (v) => v * currentZoom * dpr;
    ctx.beginPath();
    ctx.moveTo(s(t2 * 1), s(t2 * 3));
    ctx.lineTo(s(t2 * 3), s(t2 * 1));
    ctx.moveTo(s(t2 * 5), s(t2 * 7));
    ctx.lineTo(s(t2 * 7), s(t2 * 5));
    ctx.moveTo(s(t2 * 9), s(t2 * 11));
    ctx.lineTo(s(t2 * 11), s(t2 * 9));
    ctx.stroke();
    canvasEl.toBlob((blob) => {
      if (!blob || import_debug_flags.debugFlags.throwToBlob.value) {
        reject();
      } else {
        resolve(blob);
      }
    });
  });
};
const canvasBlob = (size, fn) => {
  const canvas = document.createElement("canvas");
  canvas.width = size[0];
  canvas.height = size[1];
  const ctx = canvas.getContext("2d");
  if (!ctx)
    return "";
  fn(ctx);
  return canvas.toDataURL();
};
const getDefaultPatterns = () => {
  const defaultPatterns = [];
  for (let i = 1; i <= Math.ceil(import_constants.MAX_ZOOM); i++) {
    const whitePixelBlob = canvasBlob([1, 1], (ctx) => {
      ctx.fillStyle = "#e8e8e8";
      ctx.fillRect(0, 0, 1, 1);
    });
    const blackPixelBlob = canvasBlob([1, 1], (ctx) => {
      ctx.fillStyle = "#2c3036";
      ctx.fillRect(0, 0, 1, 1);
    });
    defaultPatterns.push({
      zoom: i,
      url: whitePixelBlob,
      darkMode: false
    });
    defaultPatterns.push({
      zoom: i,
      url: blackPixelBlob,
      darkMode: true
    });
  }
  return defaultPatterns;
};
const usePattern = () => {
  const editor = (0, import_useEditor.useEditor)();
  const dpr = editor.devicePixelRatio;
  const [isReady, setIsReady] = (0, import_react.useState)(false);
  const defaultPatterns = (0, import_react.useMemo)(() => getDefaultPatterns(), []);
  const [backgroundUrls, setBackgroundUrls] = (0, import_react.useState)(defaultPatterns);
  (0, import_react.useEffect)(() => {
    const promises = [];
    for (let i = 1; i <= Math.ceil(import_constants.MAX_ZOOM); i++) {
      promises.push(
        generateImage(dpr, i, false).then((blob) => ({
          zoom: i,
          url: URL.createObjectURL(blob),
          darkMode: false
        }))
      );
      promises.push(
        generateImage(dpr, i, true).then((blob) => ({
          zoom: i,
          url: URL.createObjectURL(blob),
          darkMode: true
        }))
      );
    }
    let isCancelled = false;
    Promise.all(promises).then((urls) => {
      if (isCancelled)
        return;
      setBackgroundUrls(urls);
      setIsReady(true);
    });
    return () => {
      isCancelled = true;
      setIsReady(false);
    };
  }, [dpr]);
  const context = /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: backgroundUrls.map((item) => {
    const key = item.zoom + (item.darkMode ? "_dark" : "_light");
    return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
      "pattern",
      {
        id: import_constants.HASH_PATERN_ZOOM_NAMES[key],
        width: TILE_PATTERN_SIZE,
        height: TILE_PATTERN_SIZE,
        patternUnits: "userSpaceOnUse",
        children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("image", { href: item.url, width: TILE_PATTERN_SIZE, height: TILE_PATTERN_SIZE })
      },
      key
    );
  }) });
  return { context, isReady };
};
const t = 8 / 12;
function exportPatternSvgDefs(backgroundColor) {
  const divEl = document.createElement("div");
  divEl.innerHTML = `
		<svg>
			<defs>
				<mask id="hash_pattern_mask">
					<rect x="0" y="0" width="8" height="8" fill="white" />
					<g
						strokeLinecap="round"
						stroke="black"
					>
						<line x1="${t * 1}" y1="${t * 3}" x2="${t * 3}" y2="${t * 1}" />
						<line x1="${t * 5}" y1="${t * 7}" x2="${t * 7}" y2="${t * 5}" />
						<line x1="${t * 9}" y1="${t * 11}" x2="${t * 11}" y2="${t * 9}" />
					</g>
				</mask>
				<pattern
					id="hash_pattern"
					width="8"
					height="8"
					patternUnits="userSpaceOnUse"
				>
					<rect x="0" y="0" width="8" height="8" fill="${backgroundColor}" mask="url(#hash_pattern_mask)" />
				</pattern>
			</defs>
		</svg>
	`;
  return divEl.querySelectorAll("defs > *");
}
//# sourceMappingURL=usePattern.js.map
