import { AssetRecordType } from "@tldraw/tlschema";
import { getHashForString } from "@tldraw/utils";
import uniq from "lodash.uniq";
import { MAX_ASSET_HEIGHT, MAX_ASSET_WIDTH } from "../constants.mjs";
import { isAnimated } from "./is-gif-animated.mjs";
import { findChunk, isPng, parsePhys } from "./png.mjs";
const ACCEPTED_IMG_TYPE = ["image/jpeg", "image/png", "image/gif", "image/svg+xml"];
const ACCEPTED_VID_TYPE = ["video/mp4", "video/quicktime"];
const ACCEPTED_ASSET_TYPE = ACCEPTED_IMG_TYPE.concat(ACCEPTED_VID_TYPE).join(", ");
const isImage = (ext) => ACCEPTED_IMG_TYPE.includes(ext);
async function getVideoSizeFromSrc(src) {
  return await new Promise((resolve, reject) => {
    const video = document.createElement("video");
    video.onloadeddata = () => resolve({ w: video.videoWidth, h: video.videoHeight });
    video.onerror = (e) => {
      console.error(e);
      reject(new Error("Could not get video size"));
    };
    video.crossOrigin = "anonymous";
    video.src = src;
  });
}
async function base64ToFile(dataURL) {
  return fetch(dataURL).then(function(result) {
    return result.arrayBuffer();
  });
}
async function getImageSizeFromSrc(dataURL) {
  return await new Promise((resolve, reject) => {
    const img = new Image();
    img.onload = async () => {
      try {
        const blob = await base64ToFile(dataURL);
        const view = new DataView(blob);
        if (isPng(view, 0)) {
          const physChunk = findChunk(view, "pHYs");
          if (physChunk) {
            const physData = parsePhys(view, physChunk.dataOffset);
            if (physData.unit === 0 && physData.ppux === physData.ppuy) {
              const pixelRatio = Math.round(physData.ppux / 2834.5);
              resolve({ w: img.width / pixelRatio, h: img.height / pixelRatio });
              return;
            }
          }
        }
        resolve({ w: img.width, h: img.height });
      } catch (err) {
        console.error(err);
        resolve({ w: img.width, h: img.height });
      }
    };
    img.onerror = (err) => {
      console.error(err);
      reject(new Error("Could not get image size"));
    };
    img.crossOrigin = "anonymous";
    img.src = dataURL;
  });
}
async function getResizedImageDataUrl(dataURLForImage, width, height) {
  return await new Promise((resolve) => {
    const img = new Image();
    img.onload = () => {
      const canvas = document.createElement("canvas");
      const ctx = canvas.getContext("2d");
      if (!ctx)
        return;
      canvas.width = width * 2;
      canvas.height = height * 2;
      ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
      const newDataURL = canvas.toDataURL();
      resolve(newDataURL);
    };
    img.crossOrigin = "anonymous";
    img.src = dataURLForImage;
  });
}
async function getMediaAssetFromFile(file) {
  return await new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onerror = () => reject(reader.error);
    reader.onload = async () => {
      let dataUrl = reader.result;
      const isImageType = isImage(file.type);
      const sizeFn = isImageType ? getImageSizeFromSrc : getVideoSizeFromSrc;
      if (file.type === "video/quicktime" && dataUrl.includes("video/quicktime")) {
        dataUrl = dataUrl.replace("video/quicktime", "video/mp4");
      }
      const originalSize = await sizeFn(dataUrl);
      const size = containBoxSize(originalSize, { w: MAX_ASSET_WIDTH, h: MAX_ASSET_HEIGHT });
      if (size !== originalSize && (file.type === "image/jpeg" || file.type === "image/png")) {
        dataUrl = await getResizedImageDataUrl(dataUrl, size.w, size.h);
      }
      const assetId = AssetRecordType.createId(getHashForString(dataUrl));
      const metadata = await getFileMetaData(file);
      const asset = {
        id: assetId,
        type: isImageType ? "image" : "video",
        typeName: "asset",
        props: {
          name: file.name,
          src: dataUrl,
          w: size.w,
          h: size.h,
          mimeType: file.type,
          isAnimated: metadata.isAnimated
        }
      };
      resolve(asset);
    };
    reader.readAsDataURL(file);
  });
}
async function getFileMetaData(file) {
  if (file.type === "image/gif") {
    return await new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onerror = () => reject(reader.error);
      reader.onload = () => {
        resolve({
          isAnimated: reader.result ? isAnimated(reader.result) : false
        });
      };
      reader.readAsArrayBuffer(file);
    });
  }
  return {
    isAnimated: isImage(file.type) ? false : true
  };
}
function containBoxSize(originalSize, containBoxSize2) {
  const overByXScale = originalSize.w / containBoxSize2.w;
  const overByYScale = originalSize.h / containBoxSize2.h;
  if (overByXScale <= 1 && overByYScale <= 1) {
    return originalSize;
  } else if (overByXScale > overByYScale) {
    return {
      w: originalSize.w / overByXScale,
      h: originalSize.h / overByXScale
    };
  } else {
    return {
      w: originalSize.w / overByYScale,
      h: originalSize.h / overByYScale
    };
  }
}
const isValidHttpURL = (url) => {
  try {
    const u = new URL(url);
    return u.protocol === "http:" || u.protocol === "https:";
  } catch (e) {
    return false;
  }
};
const getValidHttpURLList = (url) => {
  const urls = url.split(/[\n\s]/);
  for (const url2 of urls) {
    try {
      const u = new URL(url2);
      if (!(u.protocol === "http:" || u.protocol === "https:")) {
        return;
      }
    } catch (e) {
      return;
    }
  }
  return uniq(urls);
};
const isSvgText = (text) => {
  return /^<svg/.test(text);
};
function dataUrlToFile(url, filename, mimeType) {
  return fetch(url).then(function(res) {
    return res.arrayBuffer();
  }).then(function(buf) {
    return new File([buf], filename, { type: mimeType });
  });
}
export {
  ACCEPTED_ASSET_TYPE,
  ACCEPTED_IMG_TYPE,
  ACCEPTED_VID_TYPE,
  base64ToFile,
  containBoxSize,
  dataUrlToFile,
  getFileMetaData,
  getImageSizeFromSrc,
  getMediaAssetFromFile,
  getResizedImageDataUrl,
  getValidHttpURLList,
  getVideoSizeFromSrc,
  isImage,
  isSvgText,
  isValidHttpURL
};
//# sourceMappingURL=assets.mjs.map
