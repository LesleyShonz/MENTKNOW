{"ast":null,"code":"import _defineProperty from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _createClass from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\n// src/Computed.ts\nimport { RESET_VALUE } from \"./types.mjs\";\nimport { maybeCaptureParent, startCapturingParents, stopCapturingParents } from \"./capture.mjs\";\nimport { ArraySet } from \"./ArraySet.mjs\";\nimport { GLOBAL_START_EPOCH } from \"./constants.mjs\";\nimport { EMPTY_ARRAY, equals, haveParentsChanged } from \"./helpers.mjs\";\nimport { HistoryBuffer } from \"./HistoryBuffer.mjs\";\nimport { globalEpoch } from \"./transactions.mjs\";\nvar UNINITIALIZED = Symbol(\"UNINITIALIZED\");\nvar isUninitialized = function isUninitialized(value) {\n  return value === UNINITIALIZED;\n};\nvar WithDiff = /*#__PURE__*/_createClass(function WithDiff(value, diff) {\n  _classCallCheck(this, WithDiff);\n  this.value = value;\n  this.diff = diff;\n});\nfunction withDiff(value, diff) {\n  return new WithDiff(value, diff);\n}\nvar _Computed = /*#__PURE__*/function () {\n  function _Computed(name, derive, options) {\n    var _options$isEqual;\n    _classCallCheck(this, _Computed);\n    _defineProperty(this, \"lastChangedEpoch\", GLOBAL_START_EPOCH);\n    _defineProperty(this, \"lastTraversedEpoch\", GLOBAL_START_EPOCH);\n    /**\n     * The epoch when the reactor was last checked.\n     */\n    _defineProperty(this, \"lastCheckedEpoch\", GLOBAL_START_EPOCH);\n    _defineProperty(this, \"parents\", []);\n    _defineProperty(this, \"parentEpochs\", []);\n    _defineProperty(this, \"children\", new ArraySet());\n    _defineProperty(this, \"historyBuffer\", void 0);\n    // The last-computed value of this signal.\n    _defineProperty(this, \"state\", UNINITIALIZED);\n    _defineProperty(this, \"computeDiff\", void 0);\n    _defineProperty(this, \"isEqual\", void 0);\n    this.name = name;\n    this.derive = derive;\n    if (options !== null && options !== void 0 && options.historyLength) {\n      this.historyBuffer = new HistoryBuffer(options.historyLength);\n    }\n    this.computeDiff = options === null || options === void 0 ? void 0 : options.computeDiff;\n    this.isEqual = (_options$isEqual = options === null || options === void 0 ? void 0 : options.isEqual) !== null && _options$isEqual !== void 0 ? _options$isEqual : null;\n  }\n  _createClass(_Computed, [{\n    key: \"isActivelyListening\",\n    get: function get() {\n      return !this.children.isEmpty;\n    }\n  }, {\n    key: \"__unsafe__getWithoutCapture\",\n    value: function __unsafe__getWithoutCapture() {\n      var isNew = this.lastChangedEpoch === GLOBAL_START_EPOCH;\n      if (!isNew && (this.lastCheckedEpoch === globalEpoch || !haveParentsChanged(this))) {\n        this.lastCheckedEpoch = globalEpoch;\n        return this.state;\n      }\n      try {\n        var _this$isEqual, _this$isEqual2;\n        startCapturingParents(this);\n        var result = this.derive(this.state, this.lastCheckedEpoch);\n        var newState = result instanceof WithDiff ? result.value : result;\n        if (!((_this$isEqual = (_this$isEqual2 = this.isEqual) === null || _this$isEqual2 === void 0 ? void 0 : _this$isEqual2.call(this, newState, this.state)) !== null && _this$isEqual !== void 0 ? _this$isEqual : equals(newState, this.state))) {\n          if (this.historyBuffer && !isNew) {\n            var _ref, _this$computeDiff;\n            var diff = result instanceof WithDiff ? result.diff : void 0;\n            this.historyBuffer.pushEntry(this.lastChangedEpoch, globalEpoch, (_ref = diff !== null && diff !== void 0 ? diff : (_this$computeDiff = this.computeDiff) === null || _this$computeDiff === void 0 ? void 0 : _this$computeDiff.call(this, this.state, newState, this.lastCheckedEpoch, globalEpoch)) !== null && _ref !== void 0 ? _ref : RESET_VALUE);\n          }\n          this.lastChangedEpoch = globalEpoch;\n          this.state = newState;\n        }\n        this.lastCheckedEpoch = globalEpoch;\n        return this.state;\n      } finally {\n        stopCapturingParents();\n      }\n    }\n  }, {\n    key: \"value\",\n    get: function get() {\n      var value = this.__unsafe__getWithoutCapture();\n      maybeCaptureParent(this);\n      return value;\n    }\n  }, {\n    key: \"getDiffSince\",\n    value: function getDiffSince(epoch) {\n      var _this$historyBuffer$g, _this$historyBuffer;\n      this.value;\n      if (epoch >= this.lastChangedEpoch) {\n        return EMPTY_ARRAY;\n      }\n      return (_this$historyBuffer$g = (_this$historyBuffer = this.historyBuffer) === null || _this$historyBuffer === void 0 ? void 0 : _this$historyBuffer.getChangesSince(epoch)) !== null && _this$historyBuffer$g !== void 0 ? _this$historyBuffer$g : RESET_VALUE;\n    }\n  }]);\n  return _Computed;\n}();\nfunction computedAnnotation() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var _target = arguments.length > 1 ? arguments[1] : undefined;\n  var key = arguments.length > 2 ? arguments[2] : undefined;\n  var descriptor = arguments.length > 3 ? arguments[3] : undefined;\n  var originalMethod = descriptor.get;\n  var derivationKey = Symbol.for(\"__signia__computed__\" + key);\n  descriptor.get = function () {\n    var d = this[derivationKey];\n    if (!d) {\n      d = new _Computed(key, originalMethod.bind(this), options);\n      Object.defineProperty(this, derivationKey, {\n        enumerable: false,\n        configurable: false,\n        writable: false,\n        value: d\n      });\n    }\n    return d.value;\n  };\n  return descriptor;\n}\nfunction getComputedInstance(obj, propertyName) {\n  var key = Symbol.for(\"__signia__computed__\" + propertyName.toString());\n  var inst = obj[key];\n  if (!inst) {\n    obj[propertyName];\n    inst = obj[key];\n  }\n  return inst;\n}\nfunction computed() {\n  if (arguments.length === 1) {\n    var options = arguments[0];\n    return function (target, key, descriptor) {\n      return computedAnnotation(options, target, key, descriptor);\n    };\n  } else if (typeof arguments[0] === \"string\") {\n    return new _Computed(arguments[0], arguments[1], arguments[2]);\n  } else {\n    return computedAnnotation(void 0, arguments[0], arguments[1], arguments[2]);\n  }\n}\nfunction isComputed(value) {\n  return value && value instanceof _Computed;\n}\nexport { _Computed, computed, getComputedInstance, isComputed, isUninitialized, withDiff };","map":{"version":3,"names":["RESET_VALUE","maybeCaptureParent","startCapturingParents","stopCapturingParents","ArraySet","GLOBAL_START_EPOCH","EMPTY_ARRAY","equals","haveParentsChanged","HistoryBuffer","globalEpoch","UNINITIALIZED","Symbol","isUninitialized","value","WithDiff","_createClass","diff","_classCallCheck","withDiff","_Computed","name","derive","options","_options$isEqual","_defineProperty","historyLength","historyBuffer","computeDiff","isEqual","key","get","children","isEmpty","__unsafe__getWithoutCapture","isNew","lastChangedEpoch","lastCheckedEpoch","state","_this$isEqual","_this$isEqual2","result","newState","call","_ref","_this$computeDiff","pushEntry","getDiffSince","epoch","_this$historyBuffer$g","_this$historyBuffer","getChangesSince","computedAnnotation","arguments","length","undefined","_target","descriptor","originalMethod","derivationKey","for","d","bind","Object","defineProperty","enumerable","configurable","writable","getComputedInstance","obj","propertyName","toString","inst","computed","target","isComputed"],"sources":["/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/signia/src/Computed.ts"],"sourcesContent":["/* eslint-disable prefer-rest-params */\nimport { Child, ComputeDiff, RESET_VALUE, Signal } from './types.js'\n\nimport { maybeCaptureParent, startCapturingParents, stopCapturingParents } from './capture.js'\n\nimport { ArraySet } from './ArraySet.js'\nimport { GLOBAL_START_EPOCH } from './constants.js'\nimport { EMPTY_ARRAY, equals, haveParentsChanged } from './helpers.js'\nimport { HistoryBuffer } from './HistoryBuffer.js'\nimport { globalEpoch } from './transactions.js'\n\nconst UNINITIALIZED = Symbol('UNINITIALIZED')\n/**\n * The type of the first value passed to a computed signal function as the 'prevValue' parameter.\n *\n * @see [[isUninitialized]].\n * @public\n */\ntype UNINITIALIZED = typeof UNINITIALIZED\n\n/**\n * Call this inside a computed signal function to determine whether it is the first time the function is being called.\n *\n * Mainly useful for incremental signal computation.\n *\n * @example\n * ```ts\n * const count = atom('count', 0)\n * const double = computed('double', (prevValue) => {\n *   if (isUninitialized(prevValue)) {\n *     console.log('First time!')\n *   }\n *   return count.value * 2\n * })\n *\n * @param value - The value to check.\n * @public\n */\nexport const isUninitialized = (value: any): value is UNINITIALIZED => {\n\treturn value === UNINITIALIZED\n}\n\nclass WithDiff<Value, Diff> {\n\tconstructor(public value: Value, public diff: Diff) {}\n}\n\n/**\n * When writing incrementally-computed signals it is convenient (and usually more performant) to incrementally compute the diff too.\n *\n * You can use this function to wrap the return value of a computed signal function to indicate that the diff should be used instead of calculating a new one with [[AtomOptions.computeDiff]].\n *\n * @example\n * ```ts\n * const count = atom('count', 0)\n * const double = computed('double', (prevValue) => {\n *   const nextValue = count.value * 2\n *   if (isUninitialized(prevValue)) {\n *     return nextValue\n *   }\n *   return withDiff(nextValue, nextValue - prevValue)\n * }, { historyLength: 10 })\n * ```\n *\n *\n * @param value - The value.\n * @param diff - The diff.\n * @public\n */\nexport function withDiff<Value, Diff>(value: Value, diff: Diff): WithDiff<Value, Diff> {\n\treturn new WithDiff(value, diff)\n}\n\n/**\n * Options for creating computed signals. Used when calling [[computed]].\n * @public\n */\nexport interface ComputedOptions<Value, Diff> {\n\t/**\n\t * The maximum number of diffs to keep in the history buffer.\n\t *\n\t * If you don't need to compute diffs, or if you will supply diffs manually via [[Atom.set]], you can leave this as `undefined` and no history buffer will be created.\n\t *\n\t * If you expect the value to be part of an active effect subscription all the time, and to not change multiple times inside of a single transaction, you can set this to a relatively low number (e.g. 10).\n\t *\n\t * Otherwise, set this to a higher number based on your usage pattern and memory constraints.\n\t *\n\t */\n\thistoryLength?: number\n\t/**\n\t * A method used to compute a diff between the atom's old and new values. If provided, it will not be used unless you also specify [[AtomOptions.historyLength]].\n\t */\n\tcomputeDiff?: ComputeDiff<Value, Diff>\n\t/**\n\t * If provided, this will be used to compare the old and new values of the atom to determine if the value has changed.\n\t * By default, values are compared using first using strict equality (`===`), then `Object.is`, and finally any `.equals` method present in the object's prototype chain.\n\t * @param a\n\t * @param b\n\t * @returns\n\t */\n\tisEqual?: (a: any, b: any) => boolean\n}\n\n/**\n * A computed signal created via [[computed]].\n *\n * @public\n */\nexport interface Computed<Value, Diff = unknown> extends Signal<Value, Diff> {\n\t/**\n\t * Whether this computed child is involved in an actively-running effect graph.\n\t * @public\n\t */\n\treadonly isActivelyListening: boolean\n\n\t/** @internal */\n\treadonly parents: Signal<any, any>[]\n\t/** @internal */\n\treadonly parentEpochs: number[]\n}\n\n/**\n * @internal\n */\nexport class _Computed<Value, Diff = unknown> implements Computed<Value, Diff> {\n\tlastChangedEpoch = GLOBAL_START_EPOCH\n\tlastTraversedEpoch = GLOBAL_START_EPOCH\n\n\t/**\n\t * The epoch when the reactor was last checked.\n\t */\n\tprivate lastCheckedEpoch = GLOBAL_START_EPOCH\n\n\tparents: Signal<any, any>[] = []\n\tparentEpochs: number[] = []\n\n\tchildren = new ArraySet<Child>()\n\n\tget isActivelyListening(): boolean {\n\t\treturn !this.children.isEmpty\n\t}\n\n\thistoryBuffer?: HistoryBuffer<Diff>\n\n\t// The last-computed value of this signal.\n\tprivate state: Value = UNINITIALIZED as unknown as Value\n\n\tprivate computeDiff?: ComputeDiff<Value, Diff>\n\n\tprivate readonly isEqual: null | ((a: any, b: any) => boolean)\n\n\tconstructor(\n\t\t/**\n\t\t * The name of the signal. This is used for debugging and performance profiling purposes. It does not need to be globally unique.\n\t\t */\n\t\tpublic readonly name: string,\n\t\t/**\n\t\t * The function that computes the value of the signal.\n\t\t */\n\t\tprivate readonly derive: (\n\t\t\tpreviousValue: Value | UNINITIALIZED,\n\t\t\tlastComputedEpoch: number\n\t\t) => Value | WithDiff<Value, Diff>,\n\t\toptions?: ComputedOptions<Value, Diff>\n\t) {\n\t\tif (options?.historyLength) {\n\t\t\tthis.historyBuffer = new HistoryBuffer(options.historyLength)\n\t\t}\n\t\tthis.computeDiff = options?.computeDiff\n\t\tthis.isEqual = options?.isEqual ?? null\n\t}\n\n\t__unsafe__getWithoutCapture(): Value {\n\t\tconst isNew = this.lastChangedEpoch === GLOBAL_START_EPOCH\n\n\t\tif (!isNew && (this.lastCheckedEpoch === globalEpoch || !haveParentsChanged(this))) {\n\t\t\tthis.lastCheckedEpoch = globalEpoch\n\t\t\treturn this.state\n\t\t}\n\n\t\ttry {\n\t\t\tstartCapturingParents(this)\n\t\t\tconst result = this.derive(this.state, this.lastCheckedEpoch)\n\t\t\tconst newState = result instanceof WithDiff ? result.value : result\n\t\t\tif (!(this.isEqual?.(newState, this.state) ?? equals(newState, this.state))) {\n\t\t\t\tif (this.historyBuffer && !isNew) {\n\t\t\t\t\tconst diff = result instanceof WithDiff ? result.diff : undefined\n\t\t\t\t\tthis.historyBuffer.pushEntry(\n\t\t\t\t\t\tthis.lastChangedEpoch,\n\t\t\t\t\t\tglobalEpoch,\n\t\t\t\t\t\tdiff ??\n\t\t\t\t\t\t\tthis.computeDiff?.(this.state, newState, this.lastCheckedEpoch, globalEpoch) ??\n\t\t\t\t\t\t\tRESET_VALUE\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t\tthis.lastChangedEpoch = globalEpoch\n\t\t\t\tthis.state = newState\n\t\t\t}\n\t\t\tthis.lastCheckedEpoch = globalEpoch\n\n\t\t\treturn this.state\n\t\t} finally {\n\t\t\tstopCapturingParents()\n\t\t}\n\t}\n\n\tget value(): Value {\n\t\tconst value = this.__unsafe__getWithoutCapture()\n\t\tmaybeCaptureParent(this)\n\t\treturn value\n\t}\n\n\tgetDiffSince(epoch: number): RESET_VALUE | Diff[] {\n\t\t// need to call .value to ensure both that this derivation is up to date\n\t\t// and that tracking happens correctly\n\t\tthis.value\n\n\t\tif (epoch >= this.lastChangedEpoch) {\n\t\t\treturn EMPTY_ARRAY\n\t\t}\n\n\t\treturn this.historyBuffer?.getChangesSince(epoch) ?? RESET_VALUE\n\t}\n}\n\nfunction computedAnnotation(\n\toptions: ComputedOptions<any, any> = {},\n\t_target: any,\n\tkey: string,\n\tdescriptor: PropertyDescriptor\n) {\n\tconst originalMethod = descriptor.get\n\tconst derivationKey = Symbol.for('__signia__computed__' + key)\n\n\tdescriptor.get = function (this: any) {\n\t\tlet d = this[derivationKey] as _Computed<any> | undefined\n\n\t\tif (!d) {\n\t\t\td = new _Computed(key, originalMethod!.bind(this) as any, options)\n\t\t\tObject.defineProperty(this, derivationKey, {\n\t\t\t\tenumerable: false,\n\t\t\t\tconfigurable: false,\n\t\t\t\twritable: false,\n\t\t\t\tvalue: d,\n\t\t\t})\n\t\t}\n\t\treturn d.value\n\t}\n\n\treturn descriptor\n}\n\n/**\n * Retrieves the underlying computed instance for a given property created with the [[computed]]\n * decorator.\n *\n * @example\n * ```ts\n * class Counter {\n *   max = 100\n *   count = atom(0)\n *\n *   @computed get remaining() {\n *     return this.max - this.count.value\n *   }\n * }\n *\n * const c = new Counter()\n * const remaining = getComputedInstance(c, 'remaining')\n * remaining.value === 100 // true\n * c.count.set(13)\n * remaining.value === 87 // true\n * ```\n *\n * @param obj\n * @param propertyName\n * @public\n */\nexport function getComputedInstance<Obj extends object, Prop extends keyof Obj>(\n\tobj: Obj,\n\tpropertyName: Prop\n): Computed<Obj[Prop]> {\n\t// deref to make sure it exists first\n\tconst key = Symbol.for('__signia__computed__' + propertyName.toString())\n\tlet inst = obj[key as keyof typeof obj] as _Computed<Obj[Prop]> | undefined\n\tif (!inst) {\n\t\t// deref to make sure it exists first\n\t\tobj[propertyName]\n\t\tinst = obj[key as keyof typeof obj] as _Computed<Obj[Prop]> | undefined\n\t}\n\treturn inst as any\n}\n\n/**\n * Creates a computed signal.\n *\n * @example\n * ```ts\n * const name = atom('name', 'John')\n * const greeting = computed('greeting', () => `Hello ${name.value}!`)\n * console.log(greeting.value) // 'Hello John!'\n * ```\n *\n * `computed` may also be used as a decorator for creating computed class properties.\n *\n * @example\n * ```ts\n * class Counter {\n *   max = 100\n *   count = atom<number>(0)\n *\n *   @computed get remaining() {\n *     return this.max - this.count.value\n *   }\n * }\n * ```\n *\n * You may optionally pass in a [[ComputedOptions]] when used as a decorator:\n *\n * @example\n * ```ts\n * class Counter {\n *   max = 100\n *   count = atom<number>(0)\n *\n *   @computed({isEqual: (a, b) => a === b})\n *   get remaining() {\n *     return this.max - this.count.value\n *   }\n * }\n * ```\n *\n * @param name - The name of the signal.\n * @param compute - The function that computes the value of the signal.\n * @param options - Options for the signal.\n *\n * @public\n */\nexport function computed<Value, Diff = unknown>(\n\tname: string,\n\tcompute: (\n\t\tpreviousValue: Value | typeof UNINITIALIZED,\n\t\tlastComputedEpoch: number\n\t) => Value | WithDiff<Value, Diff>,\n\toptions?: ComputedOptions<Value, Diff>\n): Computed<Value, Diff>\n\n/** @public */\nexport function computed(\n\ttarget: any,\n\tkey: string,\n\tdescriptor: PropertyDescriptor\n): PropertyDescriptor\n/** @public */\nexport function computed<Value, Diff = unknown>(\n\toptions?: ComputedOptions<Value, Diff>\n): (target: any, key: string, descriptor: PropertyDescriptor) => PropertyDescriptor\n/** @public */\nexport function computed() {\n\tif (arguments.length === 1) {\n\t\tconst options = arguments[0]\n\t\treturn (target: any, key: string, descriptor: PropertyDescriptor) =>\n\t\t\tcomputedAnnotation(options, target, key, descriptor)\n\t} else if (typeof arguments[0] === 'string') {\n\t\treturn new _Computed(arguments[0], arguments[1], arguments[2])\n\t} else {\n\t\treturn computedAnnotation(undefined, arguments[0], arguments[1], arguments[2])\n\t}\n}\n\n/**\n * Returns true if the given value is a computed signal.\n *\n * @param value\n * @returns {value is Computed<any>}\n * @public\n */\nexport function isComputed(value: any): value is Computed<any> {\n\treturn value && value instanceof _Computed\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}