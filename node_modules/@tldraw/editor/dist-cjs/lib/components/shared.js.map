{
  "version": 3,
  "sources": ["../../../src/lib/components/shared.ts"],
  "sourcesContent": ["import { StrokePoint, toDomPrecision, Vec2d, VecLike } from '@tldraw/primitives'\n\nexport function getPointerInfo(e: React.PointerEvent | PointerEvent) {\n\t;(e as any).isKilled = true\n\n\treturn {\n\t\tpoint: {\n\t\t\tx: e.clientX,\n\t\t\ty: e.clientY,\n\t\t\tz: e.pressure,\n\t\t},\n\t\tshiftKey: e.shiftKey,\n\t\taltKey: e.altKey,\n\t\tctrlKey: e.metaKey || e.ctrlKey,\n\t\tpointerId: e.pointerId,\n\t\tbutton: e.button,\n\t\tisPen: e.pointerType === 'pen',\n\t}\n}\n\nfunction precise(A: VecLike) {\n\treturn `${toDomPrecision(A.x)},${toDomPrecision(A.y)} `\n}\n\nfunction average(A: VecLike, B: VecLike) {\n\treturn `${toDomPrecision((A.x + B.x) / 2)},${toDomPrecision((A.y + B.y) / 2)} `\n}\n\n/**\n * Turn an array of points into a path of quadradic curves.\n *\n * @param points - The points returned from perfect-freehand\n * @param closed - Whether the stroke is closed\n */\nexport function getSvgPathFromStroke(points: Vec2d[], closed = true): string {\n\tconst len = points.length\n\n\tif (len < 2) {\n\t\treturn ''\n\t}\n\n\tlet a = points[0]\n\tlet b = points[1]\n\n\tif (len === 2) {\n\t\t// If only two points, just draw a line\n\t\treturn `M${precise(a)}L${precise(b)}`\n\t}\n\n\tlet result = ''\n\n\tfor (let i = 2, max = len - 1; i < max; i++) {\n\t\ta = points[i]\n\t\tb = points[i + 1]\n\t\tresult += average(a, b)\n\t}\n\n\tif (closed) {\n\t\t// If closed, draw a curve from the last point to the first\n\t\treturn `M${average(points[0], points[1])}Q${precise(points[1])}${average(\n\t\t\tpoints[1],\n\t\t\tpoints[2]\n\t\t)}T${result}${average(points[len - 1], points[0])}${average(points[0], points[1])}Z`\n\t} else {\n\t\t// If not closed, draw a curve starting at the first point and\n\t\t// ending at the midpoint of the last and second-last point, then\n\t\t// complete the curve with a line segment to the last point.\n\t\treturn `M${precise(points[0])}Q${precise(points[1])}${average(points[1], points[2])}${\n\t\t\tpoints.length > 3 ? 'T' : ''\n\t\t}${result}L${precise(points[len - 1])}`\n\t}\n}\n\n/**\n * Turn an array of stroke points into a path of quadradic curves.\n *\n * @param points - The stroke points returned from perfect-freehand\n * @param closed - Whether the shape is closed\n */\nexport function getSvgPathFromStrokePoints(points: StrokePoint[], closed = false): string {\n\tconst len = points.length\n\n\tif (len < 2) {\n\t\treturn ''\n\t}\n\n\tlet a = points[0].point\n\tlet b = points[1].point\n\n\tif (len === 2) {\n\t\treturn `M${precise(a)}L${precise(b)}`\n\t}\n\n\tlet result = ''\n\n\tfor (let i = 2, max = len - 1; i < max; i++) {\n\t\ta = points[i].point\n\t\tb = points[i + 1].point\n\t\tresult += average(a, b)\n\t}\n\n\tif (closed) {\n\t\t// If closed, draw a curve from the last point to the first\n\t\treturn `M${average(points[0].point, points[1].point)}Q${precise(points[1].point)}${average(\n\t\t\tpoints[1].point,\n\t\t\tpoints[2].point\n\t\t)}T${result}${average(points[len - 1].point, points[0].point)}${average(\n\t\t\tpoints[0].point,\n\t\t\tpoints[1].point\n\t\t)}Z`\n\t} else {\n\t\t// If not closed, draw a curve starting at the first point and\n\t\t// ending at the midpoint of the last and second-last point, then\n\t\t// complete the curve with a line segment to the last point.\n\t\treturn `M${precise(points[0].point)}Q${precise(points[1].point)}${average(\n\t\t\tpoints[1].point,\n\t\t\tpoints[2].point\n\t\t)}${points.length > 3 ? 'T' : ''}${result}L${precise(points[len - 1].point)}`\n\t}\n}\n"],
  "mappings": "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",
  "names": []
}
