{
  "version": 3,
  "sources": ["../../../../../../src/lib/editor/tools/SelectTool/children/Brushing.ts"],
  "sourcesContent": ["import {\n\tBox2d,\n\tMatrix2d,\n\tpointInPolygon,\n\tpolygonsIntersect,\n\tVec2d,\n\tVecLike,\n} from '@tldraw/primitives'\nimport { TLPageId, TLShape, TLShapeId } from '@tldraw/tlschema'\nimport { FrameShapeUtil } from '../../../shapes/frame/FrameShapeUtil'\nimport { GroupShapeUtil } from '../../../shapes/group/GroupShapeUtil'\nimport { ShapeUtil } from '../../../shapes/ShapeUtil'\nimport {\n\tTLCancelEvent,\n\tTLEventHandlers,\n\tTLInterruptEvent,\n\tTLKeyboardEvent,\n\tTLPointerEventInfo,\n} from '../../../types/event-types'\nimport { StateNode } from '../../StateNode'\n\nexport class Brushing extends StateNode {\n\tstatic override id = 'brushing'\n\n\tinfo = {} as TLPointerEventInfo & { target: 'canvas' }\n\n\tbrush = new Box2d()\n\tinitialSelectedIds: TLShapeId[] = []\n\texcludedShapeIds = new Set<TLShapeId>()\n\n\t// The shape that the brush started on\n\tinitialStartShape: TLShape | null = null\n\n\tonEnter = (info: TLPointerEventInfo & { target: 'canvas' }) => {\n\t\tconst { altKey, currentPagePoint } = this.editor.inputs\n\n\t\tif (altKey) {\n\t\t\tthis.parent.transition('scribble_brushing', info)\n\t\t\treturn\n\t\t}\n\n\t\tthis.excludedShapeIds = new Set(\n\t\t\tthis.editor.shapesArray\n\t\t\t\t.filter(\n\t\t\t\t\t(shape) =>\n\t\t\t\t\t\tthis.editor.isShapeOfType(shape, GroupShapeUtil) ||\n\t\t\t\t\t\tthis.editor.isShapeOrAncestorLocked(shape)\n\t\t\t\t)\n\t\t\t\t.map((shape) => shape.id)\n\t\t)\n\n\t\tthis.info = info\n\t\tthis.initialSelectedIds = this.editor.selectedIds.slice()\n\t\tthis.initialStartShape = this.editor.getShapesAtPoint(currentPagePoint)[0]\n\t\tthis.onPointerMove()\n\t}\n\n\tonExit = () => {\n\t\tthis.initialSelectedIds = []\n\t\tthis.editor.setBrush(null)\n\t}\n\n\tonPointerMove = () => {\n\t\tthis.hitTestShapes()\n\t}\n\n\tonPointerUp: TLEventHandlers['onPointerUp'] = () => {\n\t\tthis.complete()\n\t}\n\n\tonComplete: TLEventHandlers['onComplete'] = () => {\n\t\tthis.complete()\n\t}\n\n\tonCancel?: TLCancelEvent | undefined = (info) => {\n\t\tthis.editor.setSelectedIds(this.initialSelectedIds, true)\n\t\tthis.parent.transition('idle', info)\n\t}\n\n\tonKeyDown: TLEventHandlers['onKeyDown'] = (info) => {\n\t\tif (this.editor.inputs.altKey) {\n\t\t\tthis.parent.transition('scribble_brushing', info)\n\t\t} else {\n\t\t\tthis.hitTestShapes()\n\t\t}\n\t}\n\n\tonKeyUp?: TLKeyboardEvent | undefined = () => {\n\t\tthis.hitTestShapes()\n\t}\n\n\tprivate complete() {\n\t\tthis.parent.transition('idle', {})\n\t}\n\n\tprivate hitTestShapes() {\n\t\tconst {\n\t\t\tcurrentPageId,\n\t\t\tshapesArray,\n\t\t\tinputs: { originPagePoint, currentPagePoint, shiftKey, ctrlKey },\n\t\t} = this.editor\n\n\t\t// Set the brush to contain the current and origin points\n\t\tthis.brush.setTo(Box2d.FromPoints([originPagePoint, currentPagePoint]))\n\n\t\t// We'll be collecting shape ids\n\t\tconst results = new Set(shiftKey ? this.initialSelectedIds : [])\n\n\t\tlet A: VecLike,\n\t\t\tB: VecLike,\n\t\t\tshape: TLShape,\n\t\t\tutil: ShapeUtil<TLShape>,\n\t\t\tpageBounds: Box2d | undefined,\n\t\t\tpageTransform: Matrix2d | undefined,\n\t\t\tlocalCorners: VecLike[]\n\n\t\t// We'll be testing the corners of the brush against the shapes\n\t\tconst { corners } = this.brush\n\n\t\tconst { excludedShapeIds } = this\n\n\t\ttestAllShapes: for (let i = 0, n = shapesArray.length; i < n; i++) {\n\t\t\tshape = shapesArray[i]\n\t\t\tif (excludedShapeIds.has(shape.id)) continue testAllShapes\n\t\t\tif (results.has(shape.id)) continue testAllShapes\n\n\t\t\tpageBounds = this.editor.getPageBounds(shape)\n\t\t\tif (!pageBounds) continue testAllShapes\n\n\t\t\t// If the brush fully wraps a shape, it's almost certainly a hit\n\t\t\tif (this.brush.contains(pageBounds)) {\n\t\t\t\tthis.handleHit(shape, currentPagePoint, currentPageId, results, corners)\n\t\t\t\tcontinue testAllShapes\n\t\t\t}\n\n\t\t\t// Should we even test for a single segment intersections? Only if\n\t\t\t// we're not holding the ctrl key for alternate selection mode\n\t\t\t// (only wraps count!), or if the shape is a frame.\n\t\t\tif (ctrlKey || this.editor.isShapeOfType(shape, FrameShapeUtil)) {\n\t\t\t\tcontinue testAllShapes\n\t\t\t}\n\n\t\t\t// If the brush collides the page bounds, then do hit tests against\n\t\t\t// each of the brush's four sides.\n\t\t\tif (this.brush.collides(pageBounds)) {\n\t\t\t\t// Shapes expect to hit test line segments in their own coordinate system,\n\t\t\t\t// so we first need to get the brush corners in the shape's local space.\n\t\t\t\tutil = this.editor.getShapeUtil(shape)\n\n\t\t\t\tpageTransform = this.editor.getPageTransform(shape)\n\n\t\t\t\tif (!pageTransform) {\n\t\t\t\t\tcontinue testAllShapes\n\t\t\t\t}\n\n\t\t\t\t// Check whether any of the the brush edges intersect the shape\n\t\t\t\tlocalCorners = Matrix2d.applyToPoints(Matrix2d.Inverse(pageTransform), corners)\n\n\t\t\t\thitTestBrushEdges: for (let i = 0; i < localCorners.length; i++) {\n\t\t\t\t\tA = localCorners[i]\n\t\t\t\t\tB = localCorners[(i + 1) % localCorners.length]\n\n\t\t\t\t\tif (util.hitTestLineSegment(shape, A, B)) {\n\t\t\t\t\t\tthis.handleHit(shape, currentPagePoint, currentPageId, results, corners)\n\t\t\t\t\t\tbreak hitTestBrushEdges\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.editor.setBrush({ ...this.brush.toJson() })\n\t\tthis.editor.setSelectedIds(Array.from(results), true)\n\t}\n\n\tonInterrupt: TLInterruptEvent = () => {\n\t\tthis.editor.setBrush(null)\n\t}\n\n\tprivate handleHit(\n\t\tshape: TLShape,\n\t\tcurrentPagePoint: Vec2d,\n\t\tcurrentPageId: TLPageId,\n\t\tresults: Set<TLShapeId>,\n\t\tcorners: Vec2d[]\n\t) {\n\t\tif (shape.parentId === currentPageId) {\n\t\t\tresults.add(shape.id)\n\t\t\treturn\n\t\t}\n\n\t\t// Find the outermost selectable shape, check to see if it has a\n\t\t// page mask; and if so, check to see if the brush intersects it\n\t\tconst selectedShape = this.editor.getOutermostSelectableShape(shape)\n\t\tconst pageMask = this.editor.getPageMaskById(selectedShape.id)\n\n\t\tif (\n\t\t\tpageMask &&\n\t\t\tpolygonsIntersect(pageMask, corners) !== null &&\n\t\t\t!pointInPolygon(currentPagePoint, pageMask)\n\t\t) {\n\t\t\treturn\n\t\t}\n\n\t\tresults.add(selectedShape.id)\n\t}\n}\n"],
  "mappings": "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",
  "names": ["i"]
}
