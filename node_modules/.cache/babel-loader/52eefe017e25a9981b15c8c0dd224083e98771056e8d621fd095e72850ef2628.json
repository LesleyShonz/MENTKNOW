{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _defineProperty from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport { uniqueId } from \"../../utils/data.mjs\";\nimport { TextHelpers } from \"../shapes/text/TextHelpers.mjs\";\nvar textAlignmentsForLtr = {\n  start: \"left\",\n  \"start-legacy\": \"left\",\n  middle: \"center\",\n  \"middle-legacy\": \"center\",\n  end: \"right\",\n  \"end-legacy\": \"right\"\n};\nvar spaceCharacterRegex = /\\s/;\nvar TextManager = /*#__PURE__*/function () {\n  function TextManager(editor) {\n    var _this = this;\n    _classCallCheck(this, TextManager);\n    _defineProperty(this, \"measureText\", function (textToMeasure, opts) {\n      var _opts$minWidth;\n      var elm = _this.getTextElement();\n      elm.setAttribute(\"dir\", \"ltr\");\n      elm.style.setProperty(\"font-family\", opts.fontFamily);\n      elm.style.setProperty(\"font-style\", opts.fontStyle);\n      elm.style.setProperty(\"font-weight\", opts.fontWeight);\n      elm.style.setProperty(\"font-size\", opts.fontSize + \"px\");\n      elm.style.setProperty(\"line-height\", opts.lineHeight * opts.fontSize + \"px\");\n      elm.style.setProperty(\"width\", opts.width);\n      elm.style.setProperty(\"min-width\", (_opts$minWidth = opts.minWidth) !== null && _opts$minWidth !== void 0 ? _opts$minWidth : null);\n      elm.style.setProperty(\"max-width\", opts.maxWidth);\n      elm.style.setProperty(\"padding\", opts.padding);\n      elm.textContent = TextHelpers.normalizeTextForDom(textToMeasure);\n      var rect = elm.getBoundingClientRect();\n      return {\n        x: 0,\n        y: 0,\n        w: rect.width,\n        h: rect.height\n      };\n    });\n    this.editor = editor;\n  }\n  _createClass(TextManager, [{\n    key: \"getTextElement\",\n    value: function getTextElement() {\n      var oldElm = document.querySelector(\".tl-text-measure\");\n      oldElm === null || oldElm === void 0 || oldElm.remove();\n      var elm = document.createElement(\"div\");\n      this.editor.getContainer().appendChild(elm);\n      elm.id = \"__textMeasure_\".concat(uniqueId());\n      elm.classList.add(\"tl-text\");\n      elm.classList.add(\"tl-text-measure\");\n      elm.tabIndex = -1;\n      return elm;\n    }\n  }, {\n    key: \"measureElementTextNodeSpans\",\n    value:\n    /**\n     * Given an html element, measure the position of each span of unbroken\n     * word/white-space characters within any text nodes it contains.\n     */\n    function measureElementTextNodeSpans(element) {\n      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        _ref$shouldTruncateTo = _ref.shouldTruncateToFirstLine,\n        shouldTruncateToFirstLine = _ref$shouldTruncateTo === void 0 ? false : _ref$shouldTruncateTo;\n      var spans = [];\n      var elmBounds = element.getBoundingClientRect();\n      var offsetX = -elmBounds.left;\n      var offsetY = -elmBounds.top;\n      var range = new Range();\n      var textNode = element.childNodes[0];\n      var idx = 0;\n      var currentSpan = null;\n      var prevCharWasSpaceCharacter = null;\n      var prevCharTop = 0;\n      var didTruncate = false;\n      var _iterator = _createForOfIteratorHelper(element.childNodes),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var _childNode$textConten;\n          var childNode = _step.value;\n          if (childNode.nodeType !== Node.TEXT_NODE) continue;\n          var _iterator2 = _createForOfIteratorHelper((_childNode$textConten = childNode.textContent) !== null && _childNode$textConten !== void 0 ? _childNode$textConten : \"\"),\n            _step2;\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var char = _step2.value;\n              range.setStart(textNode, idx);\n              range.setEnd(textNode, idx + char.length);\n              var rects = range.getClientRects();\n              var rect = rects[rects.length - 1];\n              var top = rect.top + offsetY;\n              var left = rect.left + offsetX;\n              var right = rect.right + offsetX;\n              var isSpaceCharacter = spaceCharacterRegex.test(char);\n              if (\n              // If we're at a word boundary...\n              isSpaceCharacter !== prevCharWasSpaceCharacter ||\n              // ...or we're on a different line...\n              top !== prevCharTop ||\n              // ...or we're at the start of the text and haven't created a span yet...\n              !currentSpan) {\n                if (currentSpan) {\n                  if (shouldTruncateToFirstLine && top !== prevCharTop) {\n                    didTruncate = true;\n                    break;\n                  }\n                  spans.push(currentSpan);\n                }\n                currentSpan = {\n                  box: {\n                    x: left,\n                    y: top,\n                    w: rect.width,\n                    h: rect.height\n                  },\n                  text: char\n                };\n              } else {\n                currentSpan.box.w = right - currentSpan.box.x;\n                currentSpan.text += char;\n              }\n              prevCharWasSpaceCharacter = isSpaceCharacter;\n              prevCharTop = top;\n              idx += char.length;\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      if (currentSpan) {\n        spans.push(currentSpan);\n      }\n      return {\n        spans: spans,\n        didTruncate: didTruncate\n      };\n    }\n    /**\n     * Measure text into individual spans. Spans are created by rendering the\n     * text, then dividing it up according to line breaks and word boundaries.\n     *\n     * It works by having the browser render the text, then measuring the\n     * position of each character. You can use this to replicate the text-layout\n     * algorithm of the current browser in e.g. an SVG export.\n     */\n  }, {\n    key: \"measureTextSpans\",\n    value: function measureTextSpans(textToMeasure, opts) {\n      var shouldTruncateToFirstLine = opts.overflow === \"truncate-ellipsis\" || opts.overflow === \"truncate-clip\";\n      var element = this.getTextElement();\n      var elementWidth = Math.ceil(opts.width - opts.padding * 2);\n      element.style.setProperty(\"width\", \"\".concat(elementWidth, \"px\"));\n      element.style.setProperty(\"height\", \"min-content\");\n      element.style.setProperty(\"dir\", \"ltr\");\n      element.style.setProperty(\"font-size\", \"\".concat(opts.fontSize, \"px\"));\n      element.style.setProperty(\"font-family\", opts.fontFamily);\n      element.style.setProperty(\"font-weight\", opts.fontWeight);\n      element.style.setProperty(\"line-height\", \"\".concat(opts.lineHeight * opts.fontSize, \"px\"));\n      element.style.setProperty(\"text-align\", textAlignmentsForLtr[opts.textAlign]);\n      if (shouldTruncateToFirstLine) {\n        element.style.setProperty(\"overflow-wrap\", \"anywhere\");\n        element.style.setProperty(\"word-break\", \"break-all\");\n      }\n      element.textContent = textToMeasure;\n      var _this$measureElementT = this.measureElementTextNodeSpans(element, {\n          shouldTruncateToFirstLine: shouldTruncateToFirstLine\n        }),\n        spans = _this$measureElementT.spans,\n        didTruncate = _this$measureElementT.didTruncate;\n      if (opts.overflow === \"truncate-ellipsis\" && didTruncate) {\n        element.textContent = \"\\u2026\";\n        var ellipsisWidth = Math.ceil(this.measureElementTextNodeSpans(element).spans[0].box.w);\n        element.style.setProperty(\"width\", \"\".concat(elementWidth - ellipsisWidth, \"px\"));\n        element.textContent = textToMeasure;\n        var truncatedSpans = this.measureElementTextNodeSpans(element, {\n          shouldTruncateToFirstLine: true\n        }).spans;\n        var lastSpan = truncatedSpans[truncatedSpans.length - 1];\n        truncatedSpans.push({\n          text: \"\\u2026\",\n          box: {\n            x: Math.min(lastSpan.box.x + lastSpan.box.w, opts.width - opts.padding - ellipsisWidth),\n            y: lastSpan.box.y,\n            w: ellipsisWidth,\n            h: lastSpan.box.h\n          }\n        });\n        return truncatedSpans;\n      }\n      element.remove();\n      return spans;\n    }\n  }]);\n  return TextManager;\n}();\nexport { TextManager };","map":{"version":3,"names":["uniqueId","TextHelpers","textAlignmentsForLtr","start","middle","end","spaceCharacterRegex","TextManager","editor","_this","_classCallCheck","_defineProperty","textToMeasure","opts","_opts$minWidth","elm","getTextElement","setAttribute","style","setProperty","fontFamily","fontStyle","fontWeight","fontSize","lineHeight","width","minWidth","maxWidth","padding","textContent","normalizeTextForDom","rect","getBoundingClientRect","x","y","w","h","height","_createClass","key","value","oldElm","document","querySelector","remove","createElement","getContainer","appendChild","id","concat","classList","add","tabIndex","measureElementTextNodeSpans","element","_ref","arguments","length","undefined","_ref$shouldTruncateTo","shouldTruncateToFirstLine","spans","elmBounds","offsetX","left","offsetY","top","range","Range","textNode","childNodes","idx","currentSpan","prevCharWasSpaceCharacter","prevCharTop","didTruncate","_iterator","_createForOfIteratorHelper","_step","s","n","done","_childNode$textConten","childNode","nodeType","Node","TEXT_NODE","_iterator2","_step2","char","setStart","setEnd","rects","getClientRects","right","isSpaceCharacter","test","push","box","text","err","e","f","measureTextSpans","overflow","elementWidth","Math","ceil","textAlign","_this$measureElementT","ellipsisWidth","truncatedSpans","lastSpan","min"],"sources":["/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@tldraw/editor/src/lib/editor/managers/TextManager.ts"],"sourcesContent":["import { Box2dModel, TLDefaultHorizontalAlignStyle } from '@tldraw/tlschema'\nimport { uniqueId } from '../../utils/data'\nimport { Editor } from '../Editor'\nimport { TextHelpers } from '../shapes/text/TextHelpers'\n\nconst textAlignmentsForLtr = {\n\tstart: 'left',\n\t'start-legacy': 'left',\n\tmiddle: 'center',\n\t'middle-legacy': 'center',\n\tend: 'right',\n\t'end-legacy': 'right',\n}\n\ntype TLOverflowMode = 'wrap' | 'truncate-ellipsis' | 'truncate-clip'\ntype TLMeasureTextSpanOpts = {\n\toverflow: TLOverflowMode\n\twidth: number\n\theight: number\n\tpadding: number\n\tfontSize: number\n\tfontWeight: string\n\tfontFamily: string\n\tfontStyle: string\n\tlineHeight: number\n\ttextAlign: TLDefaultHorizontalAlignStyle\n}\n\nconst spaceCharacterRegex = /\\s/\n\nexport class TextManager {\n\tconstructor(public editor: Editor) {}\n\n\tgetTextElement() {\n\t\tconst oldElm = document.querySelector('.tl-text-measure')\n\t\toldElm?.remove()\n\n\t\tconst elm = document.createElement('div')\n\t\tthis.editor.getContainer().appendChild(elm)\n\n\t\telm.id = `__textMeasure_${uniqueId()}`\n\t\telm.classList.add('tl-text')\n\t\telm.classList.add('tl-text-measure')\n\t\telm.tabIndex = -1\n\n\t\treturn elm\n\t}\n\n\tmeasureText = (\n\t\ttextToMeasure: string,\n\t\topts: {\n\t\t\tfontStyle: string\n\t\t\tfontWeight: string\n\t\t\tfontFamily: string\n\t\t\tfontSize: number\n\t\t\tlineHeight: number\n\t\t\twidth: string\n\t\t\tminWidth?: string\n\t\t\tmaxWidth: string\n\t\t\tpadding: string\n\t\t}\n\t): Box2dModel => {\n\t\tconst elm = this.getTextElement()\n\n\t\telm.setAttribute('dir', 'ltr')\n\t\telm.style.setProperty('font-family', opts.fontFamily)\n\t\telm.style.setProperty('font-style', opts.fontStyle)\n\t\telm.style.setProperty('font-weight', opts.fontWeight)\n\t\telm.style.setProperty('font-size', opts.fontSize + 'px')\n\t\telm.style.setProperty('line-height', opts.lineHeight * opts.fontSize + 'px')\n\t\telm.style.setProperty('width', opts.width)\n\t\telm.style.setProperty('min-width', opts.minWidth ?? null)\n\t\telm.style.setProperty('max-width', opts.maxWidth)\n\t\telm.style.setProperty('padding', opts.padding)\n\n\t\telm.textContent = TextHelpers.normalizeTextForDom(textToMeasure)\n\n\t\tconst rect = elm.getBoundingClientRect()\n\n\t\treturn {\n\t\t\tx: 0,\n\t\t\ty: 0,\n\t\t\tw: rect.width,\n\t\t\th: rect.height,\n\t\t}\n\t}\n\n\t/**\n\t * Given an html element, measure the position of each span of unbroken\n\t * word/white-space characters within any text nodes it contains.\n\t */\n\tmeasureElementTextNodeSpans(\n\t\telement: HTMLElement,\n\t\t{ shouldTruncateToFirstLine = false }: { shouldTruncateToFirstLine?: boolean } = {}\n\t): { spans: { box: Box2dModel; text: string }[]; didTruncate: boolean } {\n\t\tconst spans = []\n\n\t\t// Measurements of individual spans are relative to the containing element\n\t\tconst elmBounds = element.getBoundingClientRect()\n\t\tconst offsetX = -elmBounds.left\n\t\tconst offsetY = -elmBounds.top\n\n\t\t// we measure by creating a range that spans each character in the elements text node\n\t\tconst range = new Range()\n\t\tconst textNode = element.childNodes[0]\n\t\tlet idx = 0\n\n\t\tlet currentSpan = null\n\t\tlet prevCharWasSpaceCharacter = null\n\t\tlet prevCharTop = 0\n\t\tlet didTruncate = false\n\t\tfor (const childNode of element.childNodes) {\n\t\t\tif (childNode.nodeType !== Node.TEXT_NODE) continue\n\n\t\t\tfor (const char of childNode.textContent ?? '') {\n\t\t\t\t// place the range around the characters we're interested in\n\t\t\t\trange.setStart(textNode, idx)\n\t\t\t\trange.setEnd(textNode, idx + char.length)\n\t\t\t\t// measure the range. some browsers return multiple rects for the\n\t\t\t\t// first char in a new line - one for the line break, and one for\n\t\t\t\t// the character itself. we're only interested in the character.\n\t\t\t\tconst rects = range.getClientRects()\n\t\t\t\tconst rect = rects[rects.length - 1]!\n\n\t\t\t\t// calculate the position of the character relative to the element\n\t\t\t\tconst top = rect.top + offsetY\n\t\t\t\tconst left = rect.left + offsetX\n\t\t\t\tconst right = rect.right + offsetX\n\n\t\t\t\tconst isSpaceCharacter = spaceCharacterRegex.test(char)\n\t\t\t\tif (\n\t\t\t\t\t// If we're at a word boundary...\n\t\t\t\t\tisSpaceCharacter !== prevCharWasSpaceCharacter ||\n\t\t\t\t\t// ...or we're on a different line...\n\t\t\t\t\ttop !== prevCharTop ||\n\t\t\t\t\t// ...or we're at the start of the text and haven't created a span yet...\n\t\t\t\t\t!currentSpan\n\t\t\t\t) {\n\t\t\t\t\t// ...then we're at a span boundary!\n\n\t\t\t\t\tif (currentSpan) {\n\t\t\t\t\t\t// if we're truncating to a single line & we just finished the first line, stop there\n\t\t\t\t\t\tif (shouldTruncateToFirstLine && top !== prevCharTop) {\n\t\t\t\t\t\t\tdidTruncate = true\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// otherwise add the span to the list ready to start a new one\n\t\t\t\t\t\tspans.push(currentSpan)\n\t\t\t\t\t}\n\n\t\t\t\t\t// start a new span\n\t\t\t\t\tcurrentSpan = {\n\t\t\t\t\t\tbox: { x: left, y: top, w: rect.width, h: rect.height },\n\t\t\t\t\t\ttext: char,\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// otherwise we just need to extend the current span with the next character\n\t\t\t\t\tcurrentSpan.box.w = right - currentSpan.box.x\n\t\t\t\t\tcurrentSpan.text += char\n\t\t\t\t}\n\n\t\t\t\tprevCharWasSpaceCharacter = isSpaceCharacter\n\t\t\t\tprevCharTop = top\n\t\t\t\tidx += char.length\n\t\t\t}\n\t\t}\n\n\t\t// Add the last span\n\t\tif (currentSpan) {\n\t\t\tspans.push(currentSpan)\n\t\t}\n\n\t\treturn { spans, didTruncate }\n\t}\n\n\t/**\n\t * Measure text into individual spans. Spans are created by rendering the\n\t * text, then dividing it up according to line breaks and word boundaries.\n\t *\n\t * It works by having the browser render the text, then measuring the\n\t * position of each character. You can use this to replicate the text-layout\n\t * algorithm of the current browser in e.g. an SVG export.\n\t */\n\tmeasureTextSpans(\n\t\ttextToMeasure: string,\n\t\topts: TLMeasureTextSpanOpts\n\t): { text: string; box: Box2dModel }[] {\n\t\tconst shouldTruncateToFirstLine =\n\t\t\topts.overflow === 'truncate-ellipsis' || opts.overflow === 'truncate-clip'\n\n\t\t// Create a measurement element:\n\t\tconst element = this.getTextElement()\n\t\tconst elementWidth = Math.ceil(opts.width - opts.padding * 2)\n\t\telement.style.setProperty('width', `${elementWidth}px`)\n\t\telement.style.setProperty('height', 'min-content')\n\t\telement.style.setProperty('dir', 'ltr')\n\t\telement.style.setProperty('font-size', `${opts.fontSize}px`)\n\t\telement.style.setProperty('font-family', opts.fontFamily)\n\t\telement.style.setProperty('font-weight', opts.fontWeight)\n\t\telement.style.setProperty('line-height', `${opts.lineHeight * opts.fontSize}px`)\n\t\telement.style.setProperty('text-align', textAlignmentsForLtr[opts.textAlign])\n\n\t\tif (shouldTruncateToFirstLine) {\n\t\t\telement.style.setProperty('overflow-wrap', 'anywhere')\n\t\t\telement.style.setProperty('word-break', 'break-all')\n\t\t}\n\n\t\t// Render the text into the measurement element:\n\t\telement.textContent = textToMeasure\n\n\t\t// actually measure the text:\n\t\tconst { spans, didTruncate } = this.measureElementTextNodeSpans(element, {\n\t\t\tshouldTruncateToFirstLine,\n\t\t})\n\n\t\tif (opts.overflow === 'truncate-ellipsis' && didTruncate) {\n\t\t\t// we need to measure the ellipsis to know how much space it takes up\n\t\t\telement.textContent = '…'\n\t\t\tconst ellipsisWidth = Math.ceil(this.measureElementTextNodeSpans(element).spans[0].box.w)\n\n\t\t\t// then, we need to subtract that space from the width we have and measure again:\n\t\t\telement.style.setProperty('width', `${elementWidth - ellipsisWidth}px`)\n\t\t\telement.textContent = textToMeasure\n\t\t\tconst truncatedSpans = this.measureElementTextNodeSpans(element, {\n\t\t\t\tshouldTruncateToFirstLine: true,\n\t\t\t}).spans\n\n\t\t\t// Finally, we add in our ellipsis at the end of the last span. We\n\t\t\t// have to do this after measuring, not before, because adding the\n\t\t\t// ellipsis changes how whitespace might be getting collapsed by the\n\t\t\t// browser.\n\t\t\tconst lastSpan = truncatedSpans[truncatedSpans.length - 1]!\n\t\t\ttruncatedSpans.push({\n\t\t\t\ttext: '…',\n\t\t\t\tbox: {\n\t\t\t\t\tx: Math.min(lastSpan.box.x + lastSpan.box.w, opts.width - opts.padding - ellipsisWidth),\n\t\t\t\t\ty: lastSpan.box.y,\n\t\t\t\t\tw: ellipsisWidth,\n\t\t\t\t\th: lastSpan.box.h,\n\t\t\t\t},\n\t\t\t})\n\t\t\treturn truncatedSpans\n\t\t}\n\n\t\telement.remove()\n\n\t\treturn spans\n\t}\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}