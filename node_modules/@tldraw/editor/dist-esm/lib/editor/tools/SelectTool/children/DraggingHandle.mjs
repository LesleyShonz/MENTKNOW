import { sortByIndex } from "@tldraw/indices";
import { Matrix2d, snapAngle, Vec2d } from "@tldraw/primitives";
import { deepCopy } from "@tldraw/utils";
import { StateNode } from "../../StateNode.mjs";
class DraggingHandle extends StateNode {
  static id = "dragging_handle";
  shapeId = "";
  initialHandle = {};
  initialAdjacentHandle = null;
  markId = "";
  initialPageTransform;
  initialPageRotation;
  info = {};
  isPrecise = false;
  isPreciseId = null;
  pointingId = null;
  onEnter = (info) => {
    const { shape, isCreating, handle } = info;
    this.info = info;
    this.shapeId = shape.id;
    this.markId = isCreating ? "creating" : this.editor.mark("dragging handle");
    this.initialHandle = deepCopy(handle);
    this.initialPageTransform = this.editor.getPageTransform(shape);
    this.initialPageRotation = this.editor.getPageRotation(shape);
    this.editor.setCursor({ type: isCreating ? "cross" : "grabbing", rotation: 0 });
    const handles = this.editor.getShapeUtil(shape).handles(shape).sort(sortByIndex);
    const index = handles.findIndex((h) => h.id === info.handle.id);
    this.initialAdjacentHandle = null;
    for (let i = index + 1; i < handles.length; i++) {
      const handle2 = handles[i];
      if (handle2.type === "vertex" && handle2.id !== "middle" && handle2.id !== info.handle.id) {
        this.initialAdjacentHandle = handle2;
        break;
      }
    }
    if (!this.initialAdjacentHandle) {
      for (let i = handles.length - 1; i >= 0; i--) {
        const handle2 = handles[i];
        if (handle2.type === "vertex" && handle2.id !== "middle" && handle2.id !== info.handle.id) {
          this.initialAdjacentHandle = handle2;
          break;
        }
      }
    }
    const initialTerminal = shape.props[info.handle.id];
    this.isPrecise = false;
    if (initialTerminal?.type === "binding") {
      this.editor.setHintingIds([initialTerminal.boundShapeId]);
      this.isPrecise = !Vec2d.Equals(initialTerminal.normalizedAnchor, { x: 0.5, y: 0.5 });
      if (this.isPrecise) {
        this.isPreciseId = initialTerminal.boundShapeId;
      } else {
        this.resetExactTimeout();
      }
    }
    this.update();
  };
  // Only relevant to arrows
  exactTimeout = -1;
  // Only relevant to arrows
  resetExactTimeout() {
    if (this.exactTimeout !== -1) {
      this.clearExactTimeout();
    }
    this.exactTimeout = setTimeout(() => {
      if (this.isActive && !this.isPrecise) {
        this.isPrecise = true;
        this.isPreciseId = this.pointingId;
        this.update();
      }
      this.exactTimeout = -1;
    }, 750);
  }
  // Only relevant to arrows
  clearExactTimeout() {
    if (this.exactTimeout !== -1) {
      clearTimeout(this.exactTimeout);
      this.exactTimeout = -1;
    }
  }
  onPointerMove = () => {
    this.update();
  };
  onKeyDown = () => {
    this.update();
  };
  onKeyUp = () => {
    this.update();
  };
  onPointerUp = () => {
    this.complete();
  };
  onComplete = () => {
    this.complete();
  };
  onCancel = () => {
    this.cancel();
  };
  onExit = () => {
    this.editor.setHintingIds([]);
    this.editor.snaps.clear();
    this.editor.setCursor({ type: "default" });
  };
  complete() {
    this.editor.snaps.clear();
    const { onInteractionEnd } = this.info;
    if (this.editor.instanceState.isToolLocked && onInteractionEnd) {
      this.editor.setSelectedTool(onInteractionEnd, { shapeId: this.shapeId });
      return;
    }
    this.parent.transition("idle", {});
  }
  cancel() {
    this.editor.bailToMark(this.markId);
    this.editor.snaps.clear();
    const { onInteractionEnd } = this.info;
    if (onInteractionEnd) {
      this.editor.setSelectedTool(onInteractionEnd, { shapeId: this.shapeId });
      return;
    }
    this.parent.transition("idle", {});
  }
  update() {
    const { editor, shapeId } = this;
    const { initialHandle, initialPageRotation, initialAdjacentHandle } = this;
    const {
      isSnapMode,
      hintingIds,
      snaps,
      inputs: { currentPagePoint, originPagePoint, shiftKey, ctrlKey, altKey, pointerVelocity }
    } = editor;
    const shape = editor.getShapeById(shapeId);
    if (!shape)
      return;
    const util = editor.getShapeUtil(shape);
    let point = currentPagePoint.clone().sub(originPagePoint).rot(-initialPageRotation).add(initialHandle);
    if (shiftKey && initialAdjacentHandle && initialHandle.id !== "middle") {
      const angle = Vec2d.Angle(initialAdjacentHandle, point);
      const snappedAngle = snapAngle(angle, 24);
      const angleDifference = snappedAngle - angle;
      point = Vec2d.RotWith(point, initialAdjacentHandle, angleDifference);
    }
    editor.snaps.clear();
    if (isSnapMode ? !ctrlKey : ctrlKey) {
      const pageTransform = editor.getPageTransformById(shape.id);
      if (!pageTransform)
        throw Error("Expected a page transform");
      const additionalSegments = util.outlineSegments(shape).map((segment) => Matrix2d.applyToPoints(pageTransform, segment));
      const handleIndex = util.handles(shape).filter(({ type }) => type === "vertex").sort(sortByIndex).findIndex(({ index }) => initialHandle.index === index);
      additionalSegments.splice(handleIndex - 1, 2);
      const snapDelta = snaps.getSnappingHandleDelta({
        additionalSegments,
        handlePoint: Matrix2d.applyToPoint(pageTransform, point)
      });
      if (snapDelta) {
        point.add(editor.getDeltaInShapeSpace(shape, snapDelta));
      }
    }
    const changes = util.onHandleChange?.(shape, {
      handle: {
        ...initialHandle,
        x: point.x,
        y: point.y
      },
      isPrecise: this.isPrecise || altKey
    });
    const next = { ...shape, ...changes };
    if (initialHandle.canBind) {
      const bindingAfter = next.props[initialHandle.id];
      if (bindingAfter?.type === "binding") {
        if (hintingIds[0] !== bindingAfter.boundShapeId) {
          editor.setHintingIds([bindingAfter.boundShapeId]);
          this.pointingId = bindingAfter.boundShapeId;
          this.isPrecise = pointerVelocity.len() < 0.5 || altKey;
          this.isPreciseId = this.isPrecise ? bindingAfter.boundShapeId : null;
          this.resetExactTimeout();
        }
      } else {
        if (hintingIds.length > 0) {
          editor.setHintingIds([]);
          this.pointingId = null;
          this.isPrecise = false;
          this.isPreciseId = null;
          this.resetExactTimeout();
        }
      }
    }
    if (changes) {
      editor.updateShapes([next], true);
    }
  }
}
export {
  DraggingHandle
};
//# sourceMappingURL=DraggingHandle.mjs.map
