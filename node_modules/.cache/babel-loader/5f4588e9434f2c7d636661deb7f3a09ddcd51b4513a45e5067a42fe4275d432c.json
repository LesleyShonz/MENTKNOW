{"ast":null,"code":"import _objectSpread from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _createForOfIteratorHelper from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _inherits from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _defineProperty from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport { jsx } from \"react/jsx-runtime\";\nimport { Box2d, getStrokePoints, linesIntersect, Vec2d } from \"@tldraw/primitives\";\nimport { last, rng } from \"@tldraw/utils\";\nimport { SVGContainer } from \"../../../components/SVGContainer.mjs\";\nimport { getSvgPathFromStrokePoints } from \"../../../utils/svg.mjs\";\nimport { getHighlightFreehandSettings, getPointsFromSegments } from \"../draw/getPath.mjs\";\nimport { ShapeUtil } from \"../ShapeUtil.mjs\";\nimport { FONT_SIZES } from \"../shared/default-shape-constants.mjs\";\nimport { useForceSolid } from \"../shared/useForceSolid.mjs\";\nvar OVERLAY_OPACITY = 0.35;\nvar UNDERLAY_OPACITY = 0.82;\nvar HighlightShapeUtil = /*#__PURE__*/function (_ShapeUtil) {\n  _inherits(HighlightShapeUtil, _ShapeUtil);\n  var _super = _createSuper(HighlightShapeUtil);\n  function HighlightShapeUtil() {\n    var _this;\n    _classCallCheck(this, HighlightShapeUtil);\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    _this = _super.call.apply(_super, [this].concat(args));\n    _defineProperty(_assertThisInitialized(_this), \"hideResizeHandles\", function (shape) {\n      return getIsDot(shape);\n    });\n    _defineProperty(_assertThisInitialized(_this), \"hideRotateHandle\", function (shape) {\n      return getIsDot(shape);\n    });\n    _defineProperty(_assertThisInitialized(_this), \"hideSelectionBoundsBg\", function (shape) {\n      return getIsDot(shape);\n    });\n    _defineProperty(_assertThisInitialized(_this), \"hideSelectionBoundsFg\", function (shape) {\n      return getIsDot(shape);\n    });\n    _defineProperty(_assertThisInitialized(_this), \"onResize\", function (shape, info) {\n      var scaleX = info.scaleX,\n        scaleY = info.scaleY;\n      var newSegments = [];\n      var _iterator = _createForOfIteratorHelper(shape.props.segments),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var segment = _step.value;\n          newSegments.push(_objectSpread(_objectSpread({}, segment), {}, {\n            points: segment.points.map(function (_ref) {\n              var x = _ref.x,\n                y = _ref.y,\n                z = _ref.z;\n              return {\n                x: scaleX * x,\n                y: scaleY * y,\n                z: z\n              };\n            })\n          }));\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return {\n        props: {\n          segments: newSegments\n        }\n      };\n    });\n    return _this;\n  }\n  _createClass(HighlightShapeUtil, [{\n    key: \"defaultProps\",\n    value: function defaultProps() {\n      return {\n        segments: [],\n        color: \"black\",\n        size: \"m\",\n        isComplete: false,\n        isPen: false\n      };\n    }\n  }, {\n    key: \"getBounds\",\n    value: function getBounds(shape) {\n      return Box2d.FromPoints(this.outline(shape));\n    }\n  }, {\n    key: \"getOutline\",\n    value: function getOutline(shape) {\n      return getPointsFromSegments(shape.props.segments);\n    }\n  }, {\n    key: \"getCenter\",\n    value: function getCenter(shape) {\n      return this.bounds(shape).center;\n    }\n  }, {\n    key: \"hitTestPoint\",\n    value: function hitTestPoint(shape, point) {\n      var outline = this.outline(shape);\n      var zoomLevel = this.editor.zoomLevel;\n      var offsetDist = getStrokeWidth(shape) / zoomLevel;\n      if (shape.props.segments.length === 1 && shape.props.segments[0].points.length < 4) {\n        if (shape.props.segments[0].points.some(function (pt) {\n          return Vec2d.Dist(point, pt) < offsetDist * 1.5;\n        })) {\n          return true;\n        }\n      }\n      if (this.bounds(shape).containsPoint(point)) {\n        for (var i = 0; i < outline.length; i++) {\n          var C = outline[i];\n          var D = outline[(i + 1) % outline.length];\n          if (Vec2d.DistanceToLineSegment(C, D, point) < offsetDist) return true;\n        }\n      }\n      return false;\n    }\n  }, {\n    key: \"hitTestLineSegment\",\n    value: function hitTestLineSegment(shape, A, B) {\n      var outline = this.outline(shape);\n      if (shape.props.segments.length === 1 && shape.props.segments[0].points.length < 4) {\n        var zoomLevel = this.editor.zoomLevel;\n        var offsetDist = getStrokeWidth(shape) / zoomLevel;\n        if (shape.props.segments[0].points.some(function (pt) {\n          return Vec2d.DistanceToLineSegment(A, B, pt) < offsetDist * 1.5;\n        })) {\n          return true;\n        }\n      }\n      for (var i = 0; i < outline.length - 1; i++) {\n        var C = outline[i];\n        var D = outline[i + 1];\n        if (linesIntersect(A, B, C, D)) return true;\n      }\n      return false;\n    }\n  }, {\n    key: \"component\",\n    value: function component(shape) {\n      return /* @__PURE__ */jsx(HighlightRenderer, {\n        strokeWidth: getStrokeWidth(shape),\n        shape: shape,\n        opacity: OVERLAY_OPACITY\n      });\n    }\n  }, {\n    key: \"renderBackground\",\n    value: function renderBackground(shape) {\n      return /* @__PURE__ */jsx(HighlightRenderer, {\n        strokeWidth: getStrokeWidth(shape),\n        shape: shape,\n        opacity: UNDERLAY_OPACITY\n      });\n    }\n  }, {\n    key: \"indicator\",\n    value: function indicator(shape) {\n      var _last;\n      var forceSolid = useForceSolid();\n      var strokeWidth = getStrokeWidth(shape);\n      var allPointsFromSegments = getPointsFromSegments(shape.props.segments);\n      var sw = strokeWidth;\n      if (!forceSolid && !shape.props.isPen && allPointsFromSegments.length === 1) {\n        sw += rng(shape.id)() * (strokeWidth / 6);\n      }\n      var showAsComplete = shape.props.isComplete || ((_last = last(shape.props.segments)) === null || _last === void 0 ? void 0 : _last.type) === \"straight\";\n      var options = getHighlightFreehandSettings({\n        strokeWidth: strokeWidth,\n        showAsComplete: showAsComplete,\n        isPen: shape.props.isPen\n      });\n      var strokePoints = getStrokePoints(allPointsFromSegments, options);\n      var strokePath;\n      if (strokePoints.length < 2) {\n        strokePath = getIndicatorDot(allPointsFromSegments[0], sw);\n      } else {\n        strokePath = getSvgPathFromStrokePoints(strokePoints, false);\n      }\n      return /* @__PURE__ */jsx(\"path\", {\n        d: strokePath\n      });\n    }\n  }, {\n    key: \"expandSelectionOutlinePx\",\n    value: function expandSelectionOutlinePx(shape) {\n      return getStrokeWidth(shape) / 2;\n    }\n  }, {\n    key: \"toSvg\",\n    value: function toSvg(shape, _font, colors) {\n      return highlighterToSvg(getStrokeWidth(shape), shape, OVERLAY_OPACITY, colors);\n    }\n  }, {\n    key: \"toBackgroundSvg\",\n    value: function toBackgroundSvg(shape, font, colors) {\n      return highlighterToSvg(getStrokeWidth(shape), shape, UNDERLAY_OPACITY, colors);\n    }\n  }]);\n  return HighlightShapeUtil;\n}(ShapeUtil);\n_defineProperty(HighlightShapeUtil, \"type\", \"highlight\");\nfunction getShapeDot(point) {\n  var r = 0.1;\n  return \"M \".concat(point.x, \" \").concat(point.y, \" m -\").concat(r, \", 0 a \").concat(r, \",\").concat(r, \" 0 1,0 \").concat(r * 2, \",0 a \").concat(r, \",\").concat(r, \" 0 1,0 -\").concat(r * 2, \",0\");\n}\nfunction getIndicatorDot(point, sw) {\n  var r = sw / 2;\n  return \"M \".concat(point.x, \" \").concat(point.y, \" m -\").concat(r, \", 0 a \").concat(r, \",\").concat(r, \" 0 1,0 \").concat(r * 2, \",0 a \").concat(r, \",\").concat(r, \" 0 1,0 -\").concat(r * 2, \",0\");\n}\nfunction getHighlightSvgPath(shape, strokeWidth, forceSolid) {\n  var _last2;\n  var allPointsFromSegments = getPointsFromSegments(shape.props.segments);\n  var showAsComplete = shape.props.isComplete || ((_last2 = last(shape.props.segments)) === null || _last2 === void 0 ? void 0 : _last2.type) === \"straight\";\n  var sw = strokeWidth;\n  if (!forceSolid && !shape.props.isPen && allPointsFromSegments.length === 1) {\n    sw += rng(shape.id)() * (strokeWidth / 6);\n  }\n  var options = getHighlightFreehandSettings({\n    strokeWidth: sw,\n    showAsComplete: showAsComplete,\n    isPen: shape.props.isPen\n  });\n  var strokePoints = getStrokePoints(allPointsFromSegments, options);\n  var solidStrokePath = strokePoints.length > 1 ? getSvgPathFromStrokePoints(strokePoints, false) : getShapeDot(allPointsFromSegments[0]);\n  return {\n    solidStrokePath: solidStrokePath,\n    sw: sw\n  };\n}\nfunction HighlightRenderer(_ref2) {\n  var strokeWidth = _ref2.strokeWidth,\n    shape = _ref2.shape,\n    opacity = _ref2.opacity;\n  var forceSolid = useForceSolid();\n  var _getHighlightSvgPath = getHighlightSvgPath(shape, strokeWidth, forceSolid),\n    solidStrokePath = _getHighlightSvgPath.solidStrokePath,\n    sw = _getHighlightSvgPath.sw;\n  return /* @__PURE__ */jsx(SVGContainer, {\n    id: shape.id,\n    style: {\n      opacity: opacity\n    },\n    children: /* @__PURE__ */jsx(\"path\", {\n      d: solidStrokePath,\n      strokeLinecap: \"round\",\n      fill: \"none\",\n      pointerEvents: \"all\",\n      stroke: \"var(--palette-\".concat(shape.props.color, \"-highlight)\"),\n      strokeWidth: sw\n    })\n  });\n}\nfunction highlighterToSvg(strokeWidth, shape, opacity, colors) {\n  var _getHighlightSvgPath2 = getHighlightSvgPath(shape, strokeWidth, false),\n    solidStrokePath = _getHighlightSvgPath2.solidStrokePath,\n    sw = _getHighlightSvgPath2.sw;\n  var path = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n  path.setAttribute(\"d\", solidStrokePath);\n  path.setAttribute(\"fill\", \"none\");\n  path.setAttribute(\"stroke\", colors.highlight[shape.props.color]);\n  path.setAttribute(\"stroke-width\", \"\".concat(sw));\n  path.setAttribute(\"opacity\", \"\".concat(opacity));\n  return path;\n}\nfunction getStrokeWidth(shape) {\n  return FONT_SIZES[shape.props.size] * 1.12;\n}\nfunction getIsDot(shape) {\n  return shape.props.segments.length === 1 && shape.props.segments[0].points.length < 2;\n}\nexport { HighlightShapeUtil };","map":{"version":3,"names":["jsx","Box2d","getStrokePoints","linesIntersect","Vec2d","last","rng","SVGContainer","getSvgPathFromStrokePoints","getHighlightFreehandSettings","getPointsFromSegments","ShapeUtil","FONT_SIZES","useForceSolid","OVERLAY_OPACITY","UNDERLAY_OPACITY","HighlightShapeUtil","_ShapeUtil","_inherits","_super","_createSuper","_this","_classCallCheck","_len","arguments","length","args","Array","_key","call","apply","concat","_defineProperty","_assertThisInitialized","shape","getIsDot","info","scaleX","scaleY","newSegments","_iterator","_createForOfIteratorHelper","props","segments","_step","s","n","done","segment","value","push","_objectSpread","points","map","_ref","x","y","z","err","e","f","_createClass","key","defaultProps","color","size","isComplete","isPen","getBounds","FromPoints","outline","getOutline","getCenter","bounds","center","hitTestPoint","point","zoomLevel","editor","offsetDist","getStrokeWidth","some","pt","Dist","containsPoint","i","C","D","DistanceToLineSegment","hitTestLineSegment","A","B","component","HighlightRenderer","strokeWidth","opacity","renderBackground","indicator","_last","forceSolid","allPointsFromSegments","sw","id","showAsComplete","type","options","strokePoints","strokePath","getIndicatorDot","d","expandSelectionOutlinePx","toSvg","_font","colors","highlighterToSvg","toBackgroundSvg","font","getShapeDot","r","getHighlightSvgPath","_last2","solidStrokePath","_ref2","_getHighlightSvgPath","style","children","strokeLinecap","fill","pointerEvents","stroke","_getHighlightSvgPath2","path","document","createElementNS","setAttribute","highlight"],"sources":["/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@tldraw/editor/src/lib/editor/shapes/highlight/HighlightShapeUtil.tsx"],"sourcesContent":["/* eslint-disable react-hooks/rules-of-hooks */\nimport { Box2d, getStrokePoints, linesIntersect, Vec2d, VecLike } from '@tldraw/primitives'\nimport { TLDrawShapeSegment, TLHighlightShape } from '@tldraw/tlschema'\nimport { last, rng } from '@tldraw/utils'\nimport { SVGContainer } from '../../../components/SVGContainer'\nimport { getSvgPathFromStrokePoints } from '../../../utils/svg'\nimport { getHighlightFreehandSettings, getPointsFromSegments } from '../draw/getPath'\nimport { ShapeUtil, TLOnResizeHandler } from '../ShapeUtil'\nimport { FONT_SIZES } from '../shared/default-shape-constants'\nimport { TLExportColors } from '../shared/TLExportColors'\nimport { useForceSolid } from '../shared/useForceSolid'\n\nconst OVERLAY_OPACITY = 0.35\nconst UNDERLAY_OPACITY = 0.82\n\n/** @public */\nexport class HighlightShapeUtil extends ShapeUtil<TLHighlightShape> {\n\tstatic type = 'highlight' as const\n\n\thideResizeHandles = (shape: TLHighlightShape) => getIsDot(shape)\n\thideRotateHandle = (shape: TLHighlightShape) => getIsDot(shape)\n\thideSelectionBoundsBg = (shape: TLHighlightShape) => getIsDot(shape)\n\thideSelectionBoundsFg = (shape: TLHighlightShape) => getIsDot(shape)\n\n\toverride defaultProps(): TLHighlightShape['props'] {\n\t\treturn {\n\t\t\tsegments: [],\n\t\t\tcolor: 'black',\n\t\t\tsize: 'm',\n\t\t\tisComplete: false,\n\t\t\tisPen: false,\n\t\t}\n\t}\n\n\tgetBounds(shape: TLHighlightShape) {\n\t\treturn Box2d.FromPoints(this.outline(shape))\n\t}\n\n\tgetOutline(shape: TLHighlightShape) {\n\t\treturn getPointsFromSegments(shape.props.segments)\n\t}\n\n\tgetCenter(shape: TLHighlightShape): Vec2d {\n\t\treturn this.bounds(shape).center\n\t}\n\n\thitTestPoint(shape: TLHighlightShape, point: VecLike): boolean {\n\t\tconst outline = this.outline(shape)\n\t\tconst zoomLevel = this.editor.zoomLevel\n\t\tconst offsetDist = getStrokeWidth(shape) / zoomLevel\n\n\t\tif (shape.props.segments.length === 1 && shape.props.segments[0].points.length < 4) {\n\t\t\tif (shape.props.segments[0].points.some((pt) => Vec2d.Dist(point, pt) < offsetDist * 1.5)) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\n\t\tif (this.bounds(shape).containsPoint(point)) {\n\t\t\tfor (let i = 0; i < outline.length; i++) {\n\t\t\t\tconst C = outline[i]\n\t\t\t\tconst D = outline[(i + 1) % outline.length]\n\n\t\t\t\tif (Vec2d.DistanceToLineSegment(C, D, point) < offsetDist) return true\n\t\t\t}\n\t\t}\n\n\t\treturn false\n\t}\n\n\thitTestLineSegment(shape: TLHighlightShape, A: VecLike, B: VecLike): boolean {\n\t\tconst outline = this.outline(shape)\n\n\t\tif (shape.props.segments.length === 1 && shape.props.segments[0].points.length < 4) {\n\t\t\tconst zoomLevel = this.editor.zoomLevel\n\t\t\tconst offsetDist = getStrokeWidth(shape) / zoomLevel\n\n\t\t\tif (\n\t\t\t\tshape.props.segments[0].points.some(\n\t\t\t\t\t(pt) => Vec2d.DistanceToLineSegment(A, B, pt) < offsetDist * 1.5\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\n\t\tfor (let i = 0; i < outline.length - 1; i++) {\n\t\t\tconst C = outline[i]\n\t\t\tconst D = outline[i + 1]\n\t\t\tif (linesIntersect(A, B, C, D)) return true\n\t\t}\n\n\t\treturn false\n\t}\n\n\tcomponent(shape: TLHighlightShape) {\n\t\treturn (\n\t\t\t<HighlightRenderer\n\t\t\t\tstrokeWidth={getStrokeWidth(shape)}\n\t\t\t\tshape={shape}\n\t\t\t\topacity={OVERLAY_OPACITY}\n\t\t\t/>\n\t\t)\n\t}\n\n\trenderBackground(shape: TLHighlightShape) {\n\t\treturn (\n\t\t\t<HighlightRenderer\n\t\t\t\tstrokeWidth={getStrokeWidth(shape)}\n\t\t\t\tshape={shape}\n\t\t\t\topacity={UNDERLAY_OPACITY}\n\t\t\t/>\n\t\t)\n\t}\n\n\tindicator(shape: TLHighlightShape) {\n\t\tconst forceSolid = useForceSolid()\n\t\tconst strokeWidth = getStrokeWidth(shape)\n\t\tconst allPointsFromSegments = getPointsFromSegments(shape.props.segments)\n\n\t\tlet sw = strokeWidth\n\t\tif (!forceSolid && !shape.props.isPen && allPointsFromSegments.length === 1) {\n\t\t\tsw += rng(shape.id)() * (strokeWidth / 6)\n\t\t}\n\n\t\tconst showAsComplete = shape.props.isComplete || last(shape.props.segments)?.type === 'straight'\n\t\tconst options = getHighlightFreehandSettings({\n\t\t\tstrokeWidth,\n\t\t\tshowAsComplete,\n\t\t\tisPen: shape.props.isPen,\n\t\t})\n\t\tconst strokePoints = getStrokePoints(allPointsFromSegments, options)\n\n\t\tlet strokePath\n\t\tif (strokePoints.length < 2) {\n\t\t\tstrokePath = getIndicatorDot(allPointsFromSegments[0], sw)\n\t\t} else {\n\t\t\tstrokePath = getSvgPathFromStrokePoints(strokePoints, false)\n\t\t}\n\n\t\treturn <path d={strokePath} />\n\t}\n\n\toverride expandSelectionOutlinePx(shape: TLHighlightShape): number {\n\t\treturn getStrokeWidth(shape) / 2\n\t}\n\n\toverride toSvg(shape: TLHighlightShape, _font: string | undefined, colors: TLExportColors) {\n\t\treturn highlighterToSvg(getStrokeWidth(shape), shape, OVERLAY_OPACITY, colors)\n\t}\n\n\toverride toBackgroundSvg(\n\t\tshape: TLHighlightShape,\n\t\tfont: string | undefined,\n\t\tcolors: TLExportColors\n\t) {\n\t\treturn highlighterToSvg(getStrokeWidth(shape), shape, UNDERLAY_OPACITY, colors)\n\t}\n\n\toverride onResize: TLOnResizeHandler<TLHighlightShape> = (shape, info) => {\n\t\tconst { scaleX, scaleY } = info\n\n\t\tconst newSegments: TLDrawShapeSegment[] = []\n\n\t\tfor (const segment of shape.props.segments) {\n\t\t\tnewSegments.push({\n\t\t\t\t...segment,\n\t\t\t\tpoints: segment.points.map(({ x, y, z }) => {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tx: scaleX * x,\n\t\t\t\t\t\ty: scaleY * y,\n\t\t\t\t\t\tz,\n\t\t\t\t\t}\n\t\t\t\t}),\n\t\t\t})\n\t\t}\n\n\t\treturn {\n\t\t\tprops: {\n\t\t\t\tsegments: newSegments,\n\t\t\t},\n\t\t}\n\t}\n}\n\nfunction getShapeDot(point: VecLike) {\n\tconst r = 0.1\n\treturn `M ${point.x} ${point.y} m -${r}, 0 a ${r},${r} 0 1,0 ${r * 2},0 a ${r},${r} 0 1,0 -${\n\t\tr * 2\n\t},0`\n}\n\nfunction getIndicatorDot(point: VecLike, sw: number) {\n\tconst r = sw / 2\n\treturn `M ${point.x} ${point.y} m -${r}, 0 a ${r},${r} 0 1,0 ${r * 2},0 a ${r},${r} 0 1,0 -${\n\t\tr * 2\n\t},0`\n}\n\nfunction getHighlightSvgPath(shape: TLHighlightShape, strokeWidth: number, forceSolid: boolean) {\n\tconst allPointsFromSegments = getPointsFromSegments(shape.props.segments)\n\tconst showAsComplete = shape.props.isComplete || last(shape.props.segments)?.type === 'straight'\n\n\tlet sw = strokeWidth\n\tif (!forceSolid && !shape.props.isPen && allPointsFromSegments.length === 1) {\n\t\tsw += rng(shape.id)() * (strokeWidth / 6)\n\t}\n\n\tconst options = getHighlightFreehandSettings({\n\t\tstrokeWidth: sw,\n\t\tshowAsComplete,\n\t\tisPen: shape.props.isPen,\n\t})\n\tconst strokePoints = getStrokePoints(allPointsFromSegments, options)\n\tconst solidStrokePath =\n\t\tstrokePoints.length > 1\n\t\t\t? getSvgPathFromStrokePoints(strokePoints, false)\n\t\t\t: getShapeDot(allPointsFromSegments[0])\n\n\treturn { solidStrokePath, sw }\n}\n\nfunction HighlightRenderer({\n\tstrokeWidth,\n\tshape,\n\topacity,\n}: {\n\tstrokeWidth: number\n\tshape: TLHighlightShape\n\topacity?: number\n}) {\n\tconst forceSolid = useForceSolid()\n\tconst { solidStrokePath, sw } = getHighlightSvgPath(shape, strokeWidth, forceSolid)\n\n\treturn (\n\t\t<SVGContainer id={shape.id} style={{ opacity }}>\n\t\t\t<path\n\t\t\t\td={solidStrokePath}\n\t\t\t\tstrokeLinecap=\"round\"\n\t\t\t\tfill=\"none\"\n\t\t\t\tpointerEvents=\"all\"\n\t\t\t\tstroke={`var(--palette-${shape.props.color}-highlight)`}\n\t\t\t\tstrokeWidth={sw}\n\t\t\t/>\n\t\t</SVGContainer>\n\t)\n}\n\nfunction highlighterToSvg(\n\tstrokeWidth: number,\n\tshape: TLHighlightShape,\n\topacity: number,\n\tcolors: TLExportColors\n) {\n\tconst { solidStrokePath, sw } = getHighlightSvgPath(shape, strokeWidth, false)\n\n\tconst path = document.createElementNS('http://www.w3.org/2000/svg', 'path')\n\tpath.setAttribute('d', solidStrokePath)\n\tpath.setAttribute('fill', 'none')\n\tpath.setAttribute('stroke', colors.highlight[shape.props.color])\n\tpath.setAttribute('stroke-width', `${sw}`)\n\tpath.setAttribute('opacity', `${opacity}`)\n\n\treturn path\n}\n\nfunction getStrokeWidth(shape: TLHighlightShape) {\n\treturn FONT_SIZES[shape.props.size] * 1.12\n}\n\nfunction getIsDot(shape: TLHighlightShape) {\n\treturn shape.props.segments.length === 1 && shape.props.segments[0].points.length < 2\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}