{"ast":null,"code":"// src/track.ts\nimport { forwardRef, memo } from \"react\";\nimport { useStateTracking } from \"./useStateTracking.mjs\";\nvar ProxyHandlers = {\n  /**\n   * This is a function call trap for functional components. When this is called, we know it means\n   * React did run 'Component()', that means we can use any hooks here to setup our effect and\n   * store.\n   *\n   * With the native Proxy, all other calls such as access/setting to/of properties will be\n   * forwarded to the target Component, so we don't need to copy the Component's own or inherited\n   * properties.\n   *\n   * @see https://github.com/facebook/react/blob/2d80a0cd690bb5650b6c8a6c079a87b5dc42bd15/packages/react-reconciler/src/ReactFiberHooks.old.js#L460\n   */\n  apply: function apply(Component, thisArg, argumentsList) {\n    var _ref, _Component$displayNam;\n    return useStateTracking((_ref = (_Component$displayNam = Component.displayName) !== null && _Component$displayNam !== void 0 ? _Component$displayNam : Component.name) !== null && _ref !== void 0 ? _ref : \"tracked(???)\", function () {\n      return Component.apply(thisArg, argumentsList);\n    });\n  }\n};\nvar ReactMemoSymbol = Symbol.for(\"react.memo\");\nvar ReactForwardRefSymbol = Symbol.for(\"react.forward_ref\");\nfunction track(baseComponent) {\n  var compare = null;\n  var $$typeof = baseComponent[\"$$typeof\"];\n  if ($$typeof === ReactMemoSymbol) {\n    baseComponent = baseComponent.type;\n    compare = baseComponent.compare;\n  }\n  if ($$typeof === ReactForwardRefSymbol) {\n    return memo(forwardRef(new Proxy(baseComponent.render, ProxyHandlers)));\n  }\n  return memo(new Proxy(baseComponent, ProxyHandlers), compare);\n}\nexport { ProxyHandlers, ReactForwardRefSymbol, ReactMemoSymbol, track };","map":{"version":3,"names":["forwardRef","memo","useStateTracking","ProxyHandlers","apply","Component","thisArg","argumentsList","_ref","_Component$displayNam","displayName","name","ReactMemoSymbol","Symbol","for","ReactForwardRefSymbol","track","baseComponent","compare","$$typeof","type","Proxy","render"],"sources":["/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/signia-react/src/track.ts"],"sourcesContent":["import React, { forwardRef, FunctionComponent, memo } from 'react'\nimport { useStateTracking } from './useStateTracking.js'\n\nexport const ProxyHandlers = {\n\t/**\n\t * This is a function call trap for functional components. When this is called, we know it means\n\t * React did run 'Component()', that means we can use any hooks here to setup our effect and\n\t * store.\n\t *\n\t * With the native Proxy, all other calls such as access/setting to/of properties will be\n\t * forwarded to the target Component, so we don't need to copy the Component's own or inherited\n\t * properties.\n\t *\n\t * @see https://github.com/facebook/react/blob/2d80a0cd690bb5650b6c8a6c079a87b5dc42bd15/packages/react-reconciler/src/ReactFiberHooks.old.js#L460\n\t */\n\tapply(Component: FunctionComponent, thisArg: any, argumentsList: any) {\n\t\treturn useStateTracking(Component.displayName ?? Component.name ?? 'tracked(???)', () =>\n\t\t\tComponent.apply(thisArg, argumentsList)\n\t\t)\n\t},\n}\n\nexport const ReactMemoSymbol = Symbol.for('react.memo')\nexport const ReactForwardRefSymbol = Symbol.for('react.forward_ref')\n\n/**\n * Returns a tracked version of the given component.\n * Any signals whose values are read while the component renders will be tracked.\n * If any of the tracked signals change later it will cause the component to re-render.\n *\n * This also wraps the component in a React.memo() call, so it will only re-render if the props change.\n *\n * @example\n * ```ts\n * const Counter = track(function Counter(props: CounterProps) {\n *   const count = useAtom('count', 0)\n *   const increment = useCallback(() => count.set(count.value + 1), [count])\n *   return <button onClick={increment}>{count.value}</button>\n * })\n * ```\n *\n * @param baseComponent\n * @public\n */\nexport function track<T extends FunctionComponent<any>>(\n\tbaseComponent: T\n): T extends React.MemoExoticComponent<any> ? T : React.MemoExoticComponent<T> {\n\tlet compare = null\n\tconst $$typeof = baseComponent['$$typeof' as keyof typeof baseComponent]\n\tif ($$typeof === ReactMemoSymbol) {\n\t\tbaseComponent = (baseComponent as any).type\n\t\tcompare = (baseComponent as any).compare\n\t}\n\tif ($$typeof === ReactForwardRefSymbol) {\n\t\treturn memo(forwardRef(new Proxy((baseComponent as any).render, ProxyHandlers) as any)) as any\n\t}\n\n\treturn memo(new Proxy(baseComponent, ProxyHandlers) as any, compare) as any\n}\n"],"mappings":";AAAA,SAAgBA,UAAA,EAA+BC,IAAA,QAAY;AAC3D,SAASC,gBAAA,QAAwB;AAE1B,IAAMC,aAAA,GAAgB;EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;EAY5BC,KAAA,WAAAA,MAAMC,SAAA,EAA8BC,OAAA,EAAcC,aAAA,EAAoB;IAAA,IAAAC,IAAA,EAAAC,qBAAA;IACrE,OAAOP,gBAAA,EAAAM,IAAA,IAAAC,qBAAA,GAAiBJ,SAAA,CAAUK,WAAA,cAAAD,qBAAA,cAAAA,qBAAA,GAAeJ,SAAA,CAAUM,IAAA,cAAAH,IAAA,cAAAA,IAAA,GAAQ,gBAAgB;MAAA,OAClFH,SAAA,CAAUD,KAAA,CAAME,OAAA,EAASC,aAAa;IAAA,CACvC;EACD;AACD;AAEO,IAAMK,eAAA,GAAkBC,MAAA,CAAOC,GAAA,CAAI,YAAY;AAC/C,IAAMC,qBAAA,GAAwBF,MAAA,CAAOC,GAAA,CAAI,mBAAmB;AAqB5D,SAASE,MACfC,aAAA,EAC8E;EAC9E,IAAIC,OAAA,GAAU;EACd,IAAMC,QAAA,GAAWF,aAAA,CAAc,UAAwC;EACvE,IAAIE,QAAA,KAAaP,eAAA,EAAiB;IACjCK,aAAA,GAAiBA,aAAA,CAAsBG,IAAA;IACvCF,OAAA,GAAWD,aAAA,CAAsBC,OAAA;EAClC;EACA,IAAIC,QAAA,KAAaJ,qBAAA,EAAuB;IACvC,OAAOd,IAAA,CAAKD,UAAA,CAAW,IAAIqB,KAAA,CAAOJ,aAAA,CAAsBK,MAAA,EAAQnB,aAAa,CAAQ,CAAC;EACvF;EAEA,OAAOF,IAAA,CAAK,IAAIoB,KAAA,CAAMJ,aAAA,EAAed,aAAa,GAAUe,OAAO;AACpE"},"metadata":{},"sourceType":"module","externalDependencies":[]}