import { Matrix2d, Vec2d } from "@tldraw/primitives";
function getIsArrowStraight(shape) {
  return Math.abs(shape.props.bend) < 8;
}
function getBoundShapeInfoForTerminal(editor, terminal) {
  if (terminal.type === "point") {
    return;
  }
  const shape = editor.getShapeById(terminal.boundShapeId);
  const util = editor.getShapeUtil(shape);
  const transform = editor.getPageTransform(shape);
  return {
    shape,
    util,
    transform,
    isExact: terminal.isExact,
    didIntersect: false
  };
}
function getArrowTerminalInArrowSpace(editor, arrowPageTransform, terminal) {
  if (terminal.type === "point") {
    return Vec2d.From(terminal);
  }
  const boundShape = editor.getShapeById(terminal.boundShapeId);
  if (!boundShape) {
    return new Vec2d(0, 0);
  } else {
    const { point, size } = editor.getBounds(boundShape);
    const shapePoint = Vec2d.Add(point, Vec2d.MulV(terminal.normalizedAnchor, size));
    const pagePoint = Matrix2d.applyToPoint(editor.getPageTransform(boundShape), shapePoint);
    const arrowPoint = Matrix2d.applyToPoint(Matrix2d.Inverse(arrowPageTransform), pagePoint);
    return arrowPoint;
  }
}
function getArrowTerminalsInArrowSpace(editor, shape) {
  const arrowPageTransform = editor.getPageTransform(shape);
  const start = getArrowTerminalInArrowSpace(editor, arrowPageTransform, shape.props.start);
  const end = getArrowTerminalInArrowSpace(editor, arrowPageTransform, shape.props.end);
  return { start, end };
}
const MIN_ARROW_LENGTH = 48;
const BOUND_ARROW_OFFSET = 10;
const WAY_TOO_BIG_ARROW_BEND_FACTOR = 10;
export {
  BOUND_ARROW_OFFSET,
  MIN_ARROW_LENGTH,
  WAY_TOO_BIG_ARROW_BEND_FACTOR,
  getArrowTerminalInArrowSpace,
  getArrowTerminalsInArrowSpace,
  getBoundShapeInfoForTerminal,
  getIsArrowStraight
};
//# sourceMappingURL=shared.mjs.map
