import { Fragment, jsx, jsxs } from "react/jsx-runtime";
import { Box2d, toDomPrecision, Vec2d } from "@tldraw/primitives";
import { ShapeUtil } from "../ShapeUtil.mjs";
import { FONT_FAMILIES, LABEL_FONT_SIZES, TEXT_PROPS } from "../shared/default-shape-constants.mjs";
import { getTextLabelSvgElement } from "../shared/getTextLabelSvgElement.mjs";
import { HyperlinkButton } from "../shared/HyperlinkButton.mjs";
import { TextLabel } from "../shared/TextLabel.mjs";
const NOTE_SIZE = 200;
class NoteShapeUtil extends ShapeUtil {
  static type = "note";
  canEdit = () => true;
  hideResizeHandles = () => true;
  hideSelectionBoundsBg = () => true;
  hideSelectionBoundsFg = () => true;
  defaultProps() {
    return {
      color: "black",
      size: "m",
      text: "",
      font: "draw",
      align: "middle",
      verticalAlign: "middle",
      growY: 0,
      url: ""
    };
  }
  getHeight(shape) {
    return NOTE_SIZE + shape.props.growY;
  }
  getBounds(shape) {
    const height = this.getHeight(shape);
    return new Box2d(0, 0, NOTE_SIZE, height);
  }
  getOutline(shape) {
    return this.bounds(shape).corners;
  }
  getCenter(_shape) {
    return new Vec2d(NOTE_SIZE / 2, this.getHeight(_shape) / 2);
  }
  component(shape) {
    const {
      id,
      type,
      props: { color, font, size, align, text, verticalAlign }
    } = shape;
    const adjustedColor = color === "black" ? "yellow" : color;
    return /* @__PURE__ */ jsxs(Fragment, { children: [
      /* @__PURE__ */ jsx(
        "div",
        {
          style: {
            position: "absolute",
            width: NOTE_SIZE,
            height: this.getHeight(shape)
          },
          children: /* @__PURE__ */ jsxs(
            "div",
            {
              className: "tl-note__container tl-hitarea-fill",
              style: {
                color: `var(--palette-${adjustedColor})`,
                backgroundColor: `var(--palette-${adjustedColor})`
              },
              children: [
                /* @__PURE__ */ jsx("div", { className: "tl-note__scrim" }),
                /* @__PURE__ */ jsx(
                  TextLabel,
                  {
                    id,
                    type,
                    font,
                    size,
                    align,
                    verticalAlign,
                    text,
                    labelColor: adjustedColor,
                    wrap: true
                  }
                )
              ]
            }
          )
        }
      ),
      "url" in shape.props && shape.props.url && /* @__PURE__ */ jsx(HyperlinkButton, { url: shape.props.url, zoomLevel: this.editor.zoomLevel })
    ] });
  }
  indicator(shape) {
    return /* @__PURE__ */ jsx(
      "rect",
      {
        rx: "7",
        width: toDomPrecision(NOTE_SIZE),
        height: toDomPrecision(this.getHeight(shape))
      }
    );
  }
  toSvg(shape, font, colors) {
    const bounds = this.bounds(shape);
    const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
    const adjustedColor = shape.props.color === "black" ? "yellow" : shape.props.color;
    const rect1 = document.createElementNS("http://www.w3.org/2000/svg", "rect");
    rect1.setAttribute("rx", "10");
    rect1.setAttribute("width", NOTE_SIZE.toString());
    rect1.setAttribute("height", bounds.height.toString());
    rect1.setAttribute("fill", colors.fill[adjustedColor]);
    rect1.setAttribute("stroke", colors.fill[adjustedColor]);
    rect1.setAttribute("stroke-width", "1");
    g.appendChild(rect1);
    const rect2 = document.createElementNS("http://www.w3.org/2000/svg", "rect");
    rect2.setAttribute("rx", "10");
    rect2.setAttribute("width", NOTE_SIZE.toString());
    rect2.setAttribute("height", bounds.height.toString());
    rect2.setAttribute("fill", colors.background);
    rect2.setAttribute("opacity", ".28");
    g.appendChild(rect2);
    const textElm = getTextLabelSvgElement({
      editor: this.editor,
      shape,
      font,
      bounds
    });
    textElm.setAttribute("fill", colors.text);
    textElm.setAttribute("stroke", "none");
    g.appendChild(textElm);
    return g;
  }
  onBeforeCreate = (next) => {
    return getGrowY(this.editor, next, next.props.growY);
  };
  onBeforeUpdate = (prev, next) => {
    if (prev.props.text === next.props.text && prev.props.font === next.props.font && prev.props.size === next.props.size) {
      return;
    }
    return getGrowY(this.editor, next, prev.props.growY);
  };
  onEditEnd = (shape) => {
    const {
      id,
      type,
      props: { text }
    } = shape;
    if (text.trimEnd() !== shape.props.text) {
      this.editor.updateShapes([
        {
          id,
          type,
          props: {
            text: text.trimEnd()
          }
        }
      ]);
    }
  };
}
function getGrowY(editor, shape, prevGrowY = 0) {
  const PADDING = 17;
  const nextTextSize = editor.textMeasure.measureText(shape.props.text, {
    ...TEXT_PROPS,
    fontFamily: FONT_FAMILIES[shape.props.font],
    fontSize: LABEL_FONT_SIZES[shape.props.size],
    width: NOTE_SIZE - PADDING * 2 + "px"
  });
  const nextHeight = nextTextSize.h + PADDING * 2;
  let growY = null;
  if (nextHeight > NOTE_SIZE) {
    growY = nextHeight - NOTE_SIZE;
  } else {
    if (prevGrowY) {
      growY = 0;
    }
  }
  if (growY !== null) {
    return {
      ...shape,
      props: {
        ...shape.props,
        growY
      }
    };
  }
}
export {
  NoteShapeUtil
};
//# sourceMappingURL=NoteShapeUtil.mjs.map
