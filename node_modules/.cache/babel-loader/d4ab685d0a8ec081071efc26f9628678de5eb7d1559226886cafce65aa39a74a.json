{"ast":null,"code":"import _objectSpread from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _classCallCheck from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _inherits from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _defineProperty from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport { jsx, jsxs } from \"react/jsx-runtime\";\nimport { Box2d, toDomPrecision, Vec2d } from \"@tldraw/primitives\";\nimport { HTMLContainer } from \"../../../components/HTMLContainer.mjs\";\nimport { stopEventPropagation } from \"../../../utils/dom.mjs\";\nimport { WeakMapCache } from \"../../../utils/WeakMapCache.mjs\";\nimport { ShapeUtil } from \"../ShapeUtil.mjs\";\nimport { createTextSvgElementFromSpans } from \"../shared/createTextSvgElementFromSpans.mjs\";\nimport { FONT_FAMILIES, FONT_SIZES, TEXT_PROPS } from \"../shared/default-shape-constants.mjs\";\nimport { resizeScaled } from \"../shared/resizeScaled.mjs\";\nimport { useEditableText } from \"../shared/useEditableText.mjs\";\nimport { INDENT } from \"./TextHelpers.mjs\";\nvar sizeCache = new WeakMapCache();\nvar TextShapeUtil = /*#__PURE__*/function (_ShapeUtil) {\n  _inherits(TextShapeUtil, _ShapeUtil);\n  var _super = _createSuper(TextShapeUtil);\n  function TextShapeUtil() {\n    var _this;\n    _classCallCheck(this, TextShapeUtil);\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    _this = _super.call.apply(_super, [this].concat(args));\n    _defineProperty(_assertThisInitialized(_this), \"canEdit\", function () {\n      return true;\n    });\n    _defineProperty(_assertThisInitialized(_this), \"isAspectRatioLocked\", function () {\n      return true;\n    });\n    _defineProperty(_assertThisInitialized(_this), \"onResize\", function (shape, info) {\n      var initialBounds = info.initialBounds,\n        initialShape = info.initialShape,\n        scaleX = info.scaleX,\n        handle = info.handle;\n      if (info.mode === \"scale_shape\" || handle !== \"right\" && handle !== \"left\") {\n        return resizeScaled(shape, info);\n      } else {\n        var prevWidth = initialBounds.width;\n        var nextWidth = prevWidth * scaleX;\n        var offset = new Vec2d(0, 0);\n        nextWidth = Math.max(1, Math.abs(nextWidth));\n        if (handle === \"left\") {\n          offset.x = prevWidth - nextWidth;\n          if (scaleX < 0) {\n            offset.x += nextWidth;\n          }\n        } else {\n          if (scaleX < 0) {\n            offset.x -= nextWidth;\n          }\n        }\n        var _offset$rot$add = offset.rot(shape.rotation).add(initialShape),\n          x = _offset$rot$add.x,\n          y = _offset$rot$add.y;\n        return {\n          x: x,\n          y: y,\n          props: {\n            w: nextWidth / initialShape.props.scale,\n            autoSize: false\n          }\n        };\n      }\n    });\n    _defineProperty(_assertThisInitialized(_this), \"onBeforeCreate\", function (shape) {\n      if (!shape.props.autoSize) return;\n      if (shape.props.text.trim()) return;\n      var bounds = _this.getMinDimensions(shape);\n      return _objectSpread(_objectSpread({}, shape), {}, {\n        x: shape.x - bounds.width / 2,\n        y: shape.y - bounds.height / 2\n      });\n    });\n    _defineProperty(_assertThisInitialized(_this), \"onEditEnd\", function (shape) {\n      var id = shape.id,\n        type = shape.type,\n        text = shape.props.text;\n      var trimmedText = shape.props.text.trimEnd();\n      if (trimmedText.length === 0) {\n        _this.editor.deleteShapes([shape.id]);\n      } else {\n        if (trimmedText !== shape.props.text) {\n          _this.editor.updateShapes([{\n            id: id,\n            type: type,\n            props: {\n              text: text.trimEnd()\n            }\n          }]);\n        }\n      }\n    });\n    _defineProperty(_assertThisInitialized(_this), \"onBeforeUpdate\", function (prev, next) {\n      if (!next.props.autoSize) return;\n      var styleDidChange = prev.props.size !== next.props.size || prev.props.align !== next.props.align || prev.props.font !== next.props.font || prev.props.scale !== 1 && next.props.scale === 1;\n      var textDidChange = prev.props.text !== next.props.text;\n      if (!styleDidChange && !textDidChange) return;\n      var boundsA = _this.getMinDimensions(prev);\n      var boundsB = getTextSize(_this.editor, next.props);\n      var wA = boundsA.width * prev.props.scale;\n      var hA = boundsA.height * prev.props.scale;\n      var wB = boundsB.width * next.props.scale;\n      var hB = boundsB.height * next.props.scale;\n      var delta;\n      switch (next.props.align) {\n        case \"middle\":\n          {\n            delta = new Vec2d((wB - wA) / 2, textDidChange ? 0 : (hB - hA) / 2);\n            break;\n          }\n        case \"end\":\n          {\n            delta = new Vec2d(wB - wA, textDidChange ? 0 : (hB - hA) / 2);\n            break;\n          }\n        default:\n          {\n            if (textDidChange) break;\n            delta = new Vec2d(0, (hB - hA) / 2);\n            break;\n          }\n      }\n      if (delta) {\n        delta.rot(next.rotation);\n        var x = next.x,\n          y = next.y;\n        return _objectSpread(_objectSpread({}, next), {}, {\n          x: x - delta.x,\n          y: y - delta.y,\n          props: _objectSpread(_objectSpread({}, next.props), {}, {\n            w: wB\n          })\n        });\n      } else {\n        return _objectSpread(_objectSpread({}, next), {}, {\n          props: _objectSpread(_objectSpread({}, next.props), {}, {\n            w: wB\n          })\n        });\n      }\n    });\n    _defineProperty(_assertThisInitialized(_this), \"onDoubleClickEdge\", function (shape) {\n      if (!shape.props.autoSize) {\n        return {\n          id: shape.id,\n          type: shape.type,\n          props: {\n            autoSize: true\n          }\n        };\n      }\n      if (shape.props.scale !== 1) {\n        return {\n          id: shape.id,\n          type: shape.type,\n          props: {\n            scale: 1\n          }\n        };\n      }\n    });\n    return _this;\n  }\n  _createClass(TextShapeUtil, [{\n    key: \"defaultProps\",\n    value: function defaultProps() {\n      return {\n        color: \"black\",\n        size: \"m\",\n        w: 8,\n        text: \"\",\n        font: \"draw\",\n        align: \"middle\",\n        autoSize: true,\n        scale: 1\n      };\n    }\n    // @computed\n    // private get minDimensionsCache() {\n    // \treturn this.editor.store.createSelectedComputedCache<\n    // \t\tTLTextShape['props'],\n    // \t\t{ width: number; height: number },\n    // \t\tTLTextShape\n    // \t>(\n    // \t\t'text measure cache',\n    // \t\t(shape) => {\n    // \t\t\treturn shape.props\n    // \t\t},\n    // \t\t(props) => getTextSize(this.editor, props)\n    // \t)\n    // }\n  }, {\n    key: \"getMinDimensions\",\n    value: function getMinDimensions(shape) {\n      var _this2 = this;\n      return sizeCache.get(shape.props, function (props) {\n        return getTextSize(_this2.editor, props);\n      });\n    }\n  }, {\n    key: \"getBounds\",\n    value: function getBounds(shape) {\n      var scale = shape.props.scale;\n      var _this$getMinDimension = this.getMinDimensions(shape),\n        width = _this$getMinDimension.width,\n        height = _this$getMinDimension.height;\n      return new Box2d(0, 0, width * scale, height * scale);\n    }\n  }, {\n    key: \"getOutline\",\n    value: function getOutline(shape) {\n      var bounds = this.bounds(shape);\n      return [new Vec2d(0, 0), new Vec2d(bounds.width, 0), new Vec2d(bounds.width, bounds.height), new Vec2d(0, bounds.height)];\n    }\n  }, {\n    key: \"getCenter\",\n    value: function getCenter(shape) {\n      var bounds = this.bounds(shape);\n      return new Vec2d(bounds.width / 2, bounds.height / 2);\n    }\n  }, {\n    key: \"component\",\n    value: function component(shape) {\n      var id = shape.id,\n        type = shape.type,\n        text = shape.props.text;\n      var _this$getMinDimension2 = this.getMinDimensions(shape),\n        width = _this$getMinDimension2.width,\n        height = _this$getMinDimension2.height;\n      var _useEditableText = useEditableText(id, type, text),\n        rInput = _useEditableText.rInput,\n        isEmpty = _useEditableText.isEmpty,\n        isEditing = _useEditableText.isEditing,\n        isEditableFromHover = _useEditableText.isEditableFromHover,\n        handleFocus = _useEditableText.handleFocus,\n        handleChange = _useEditableText.handleChange,\n        handleKeyDown = _useEditableText.handleKeyDown,\n        handleBlur = _useEditableText.handleBlur;\n      return /* @__PURE__ */jsx(HTMLContainer, {\n        id: shape.id,\n        children: /* @__PURE__ */jsxs(\"div\", {\n          className: \"tl-text-shape__wrapper tl-text-shadow\",\n          \"data-font\": shape.props.font,\n          \"data-align\": shape.props.align,\n          \"data-hastext\": !isEmpty,\n          \"data-isediting\": isEditing || isEditableFromHover,\n          \"data-textwrap\": true,\n          style: {\n            fontSize: FONT_SIZES[shape.props.size],\n            lineHeight: FONT_SIZES[shape.props.size] * TEXT_PROPS.lineHeight + \"px\",\n            transform: \"scale(\".concat(shape.props.scale, \")\"),\n            transformOrigin: \"top left\",\n            width: Math.max(1, width),\n            height: Math.max(FONT_SIZES[shape.props.size] * TEXT_PROPS.lineHeight, height)\n          },\n          children: [/* @__PURE__ */jsx(\"div\", {\n            className: \"tl-text tl-text-content\",\n            dir: \"ltr\",\n            children: text\n          }), isEditing || isEditableFromHover ? /* @__PURE__ */jsx(\"textarea\", {\n            ref: rInput,\n            className: \"tl-text tl-text-input\",\n            name: \"text\",\n            tabIndex: -1,\n            autoComplete: \"false\",\n            autoCapitalize: \"false\",\n            autoCorrect: \"false\",\n            autoSave: \"false\",\n            autoFocus: isEditing,\n            placeholder: \"\",\n            spellCheck: \"true\",\n            wrap: \"off\",\n            dir: \"ltr\",\n            datatype: \"wysiwyg\",\n            defaultValue: text,\n            onFocus: handleFocus,\n            onChange: handleChange,\n            onKeyDown: handleKeyDown,\n            onBlur: handleBlur,\n            onTouchEnd: stopEventPropagation,\n            onContextMenu: stopEventPropagation\n          }) : null]\n        })\n      });\n    }\n  }, {\n    key: \"indicator\",\n    value: function indicator(shape) {\n      var bounds = this.bounds(shape);\n      return /* @__PURE__ */jsx(\"rect\", {\n        width: toDomPrecision(bounds.width),\n        height: toDomPrecision(bounds.height)\n      });\n    }\n  }, {\n    key: \"toSvg\",\n    value: function toSvg(shape, font, colors) {\n      var _shape$props$scale, _shape$props$scale2;\n      var bounds = this.bounds(shape);\n      var text = shape.props.text;\n      var width = bounds.width / ((_shape$props$scale = shape.props.scale) !== null && _shape$props$scale !== void 0 ? _shape$props$scale : 1);\n      var height = bounds.height / ((_shape$props$scale2 = shape.props.scale) !== null && _shape$props$scale2 !== void 0 ? _shape$props$scale2 : 1);\n      var opts = {\n        fontSize: FONT_SIZES[shape.props.size],\n        fontFamily: font,\n        textAlign: shape.props.align,\n        verticalTextAlign: \"middle\",\n        width: width,\n        height: height,\n        padding: 0,\n        // no padding?\n        lineHeight: TEXT_PROPS.lineHeight,\n        fontStyle: \"normal\",\n        fontWeight: \"normal\",\n        overflow: \"wrap\"\n      };\n      var color = colors.fill[shape.props.color];\n      var groupEl = document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\");\n      var textBgEl = createTextSvgElementFromSpans(this.editor, this.editor.textMeasure.measureTextSpans(text, opts), _objectSpread(_objectSpread({}, opts), {}, {\n        stroke: colors.background,\n        strokeWidth: 2,\n        fill: colors.background,\n        padding: 0\n      }));\n      var textElm = textBgEl.cloneNode(true);\n      textElm.setAttribute(\"fill\", color);\n      textElm.setAttribute(\"stroke\", \"none\");\n      groupEl.append(textBgEl);\n      groupEl.append(textElm);\n      return groupEl;\n    }\n  }]);\n  return TextShapeUtil;\n}(ShapeUtil);\n_defineProperty(TextShapeUtil, \"type\", \"text\");\nfunction getTextSize(editor, props) {\n  var font = props.font,\n    text = props.text,\n    autoSize = props.autoSize,\n    size = props.size,\n    w = props.w;\n  var minWidth = 16;\n  var fontSize = FONT_SIZES[size];\n  var cw = autoSize ? \"fit-content\" :\n  // `measureText` floors the number so we need to do the same here to avoid issues.\n  Math.floor(Math.max(minWidth, w)) + \"px\";\n  var result = editor.textMeasure.measureText(text, _objectSpread(_objectSpread({}, TEXT_PROPS), {}, {\n    fontFamily: FONT_FAMILIES[font],\n    fontSize: fontSize,\n    width: cw\n  }));\n  if (autoSize) {\n    result.w += 1;\n  }\n  return {\n    width: Math.max(minWidth, result.w),\n    height: Math.max(fontSize, result.h)\n  };\n}\nexport { INDENT, TextShapeUtil };","map":{"version":3,"names":["jsx","jsxs","Box2d","toDomPrecision","Vec2d","HTMLContainer","stopEventPropagation","WeakMapCache","ShapeUtil","createTextSvgElementFromSpans","FONT_FAMILIES","FONT_SIZES","TEXT_PROPS","resizeScaled","useEditableText","INDENT","sizeCache","TextShapeUtil","_ShapeUtil","_inherits","_super","_createSuper","_this","_classCallCheck","_len","arguments","length","args","Array","_key","call","apply","concat","_defineProperty","_assertThisInitialized","shape","info","initialBounds","initialShape","scaleX","handle","mode","prevWidth","width","nextWidth","offset","Math","max","abs","x","_offset$rot$add","rot","rotation","add","y","props","w","scale","autoSize","text","trim","bounds","getMinDimensions","_objectSpread","height","id","type","trimmedText","trimEnd","editor","deleteShapes","updateShapes","prev","next","styleDidChange","size","align","font","textDidChange","boundsA","boundsB","getTextSize","wA","hA","wB","hB","delta","_createClass","key","value","defaultProps","color","_this2","get","getBounds","_this$getMinDimension","getOutline","getCenter","component","_this$getMinDimension2","_useEditableText","rInput","isEmpty","isEditing","isEditableFromHover","handleFocus","handleChange","handleKeyDown","handleBlur","children","className","style","fontSize","lineHeight","transform","transformOrigin","dir","ref","name","tabIndex","autoComplete","autoCapitalize","autoCorrect","autoSave","autoFocus","placeholder","spellCheck","wrap","datatype","defaultValue","onFocus","onChange","onKeyDown","onBlur","onTouchEnd","onContextMenu","indicator","toSvg","colors","_shape$props$scale","_shape$props$scale2","opts","fontFamily","textAlign","verticalTextAlign","padding","fontStyle","fontWeight","overflow","fill","groupEl","document","createElementNS","textBgEl","textMeasure","measureTextSpans","stroke","background","strokeWidth","textElm","cloneNode","setAttribute","append","minWidth","cw","floor","result","measureText","h"],"sources":["/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@tldraw/editor/src/lib/editor/shapes/text/TextShapeUtil.tsx"],"sourcesContent":["/* eslint-disable react-hooks/rules-of-hooks */\nimport { Box2d, toDomPrecision, Vec2d } from '@tldraw/primitives'\nimport { TLTextShape } from '@tldraw/tlschema'\nimport { HTMLContainer } from '../../../components/HTMLContainer'\nimport { stopEventPropagation } from '../../../utils/dom'\nimport { WeakMapCache } from '../../../utils/WeakMapCache'\nimport { Editor } from '../../Editor'\nimport { ShapeUtil, TLOnEditEndHandler, TLOnResizeHandler, TLShapeUtilFlag } from '../ShapeUtil'\nimport { createTextSvgElementFromSpans } from '../shared/createTextSvgElementFromSpans'\nimport { FONT_FAMILIES, FONT_SIZES, TEXT_PROPS } from '../shared/default-shape-constants'\nimport { resizeScaled } from '../shared/resizeScaled'\nimport { TLExportColors } from '../shared/TLExportColors'\nimport { useEditableText } from '../shared/useEditableText'\n\nexport { INDENT } from './TextHelpers'\n\nconst sizeCache = new WeakMapCache<TLTextShape['props'], { height: number; width: number }>()\n\n/** @public */\nexport class TextShapeUtil extends ShapeUtil<TLTextShape> {\n\tstatic override type = 'text' as const\n\n\tcanEdit = () => true\n\n\tisAspectRatioLocked: TLShapeUtilFlag<TLTextShape> = () => true\n\n\tdefaultProps(): TLTextShape['props'] {\n\t\treturn {\n\t\t\tcolor: 'black',\n\t\t\tsize: 'm',\n\t\t\tw: 8,\n\t\t\ttext: '',\n\t\t\tfont: 'draw',\n\t\t\talign: 'middle',\n\t\t\tautoSize: true,\n\t\t\tscale: 1,\n\t\t}\n\t}\n\n\t// @computed\n\t// private get minDimensionsCache() {\n\t// \treturn this.editor.store.createSelectedComputedCache<\n\t// \t\tTLTextShape['props'],\n\t// \t\t{ width: number; height: number },\n\t// \t\tTLTextShape\n\t// \t>(\n\t// \t\t'text measure cache',\n\t// \t\t(shape) => {\n\t// \t\t\treturn shape.props\n\t// \t\t},\n\t// \t\t(props) => getTextSize(this.editor, props)\n\t// \t)\n\t// }\n\n\tgetMinDimensions(shape: TLTextShape) {\n\t\treturn sizeCache.get(shape.props, (props) => getTextSize(this.editor, props))\n\t}\n\n\tgetBounds(shape: TLTextShape) {\n\t\tconst { scale } = shape.props\n\t\tconst { width, height } = this.getMinDimensions(shape)!\n\t\treturn new Box2d(0, 0, width * scale, height * scale)\n\t}\n\n\tgetOutline(shape: TLTextShape) {\n\t\tconst bounds = this.bounds(shape)\n\n\t\treturn [\n\t\t\tnew Vec2d(0, 0),\n\t\t\tnew Vec2d(bounds.width, 0),\n\t\t\tnew Vec2d(bounds.width, bounds.height),\n\t\t\tnew Vec2d(0, bounds.height),\n\t\t]\n\t}\n\n\tgetCenter(shape: TLTextShape): Vec2d {\n\t\tconst bounds = this.bounds(shape)\n\t\treturn new Vec2d(bounds.width / 2, bounds.height / 2)\n\t}\n\n\tcomponent(shape: TLTextShape) {\n\t\tconst {\n\t\t\tid,\n\t\t\ttype,\n\t\t\tprops: { text },\n\t\t} = shape\n\n\t\tconst { width, height } = this.getMinDimensions(shape)\n\n\t\tconst {\n\t\t\trInput,\n\t\t\tisEmpty,\n\t\t\tisEditing,\n\t\t\tisEditableFromHover,\n\t\t\thandleFocus,\n\t\t\thandleChange,\n\t\t\thandleKeyDown,\n\t\t\thandleBlur,\n\t\t} = useEditableText(id, type, text)\n\n\t\treturn (\n\t\t\t<HTMLContainer id={shape.id}>\n\t\t\t\t<div\n\t\t\t\t\tclassName=\"tl-text-shape__wrapper tl-text-shadow\"\n\t\t\t\t\tdata-font={shape.props.font}\n\t\t\t\t\tdata-align={shape.props.align}\n\t\t\t\t\tdata-hastext={!isEmpty}\n\t\t\t\t\tdata-isediting={isEditing || isEditableFromHover}\n\t\t\t\t\tdata-textwrap={true}\n\t\t\t\t\tstyle={{\n\t\t\t\t\t\tfontSize: FONT_SIZES[shape.props.size],\n\t\t\t\t\t\tlineHeight: FONT_SIZES[shape.props.size] * TEXT_PROPS.lineHeight + 'px',\n\t\t\t\t\t\ttransform: `scale(${shape.props.scale})`,\n\t\t\t\t\t\ttransformOrigin: 'top left',\n\t\t\t\t\t\twidth: Math.max(1, width),\n\t\t\t\t\t\theight: Math.max(FONT_SIZES[shape.props.size] * TEXT_PROPS.lineHeight, height),\n\t\t\t\t\t}}\n\t\t\t\t>\n\t\t\t\t\t<div className=\"tl-text tl-text-content\" dir=\"ltr\">\n\t\t\t\t\t\t{text}\n\t\t\t\t\t</div>\n\t\t\t\t\t{isEditing || isEditableFromHover ? (\n\t\t\t\t\t\t<textarea\n\t\t\t\t\t\t\tref={rInput}\n\t\t\t\t\t\t\tclassName=\"tl-text tl-text-input\"\n\t\t\t\t\t\t\tname=\"text\"\n\t\t\t\t\t\t\ttabIndex={-1}\n\t\t\t\t\t\t\tautoComplete=\"false\"\n\t\t\t\t\t\t\tautoCapitalize=\"false\"\n\t\t\t\t\t\t\tautoCorrect=\"false\"\n\t\t\t\t\t\t\tautoSave=\"false\"\n\t\t\t\t\t\t\tautoFocus={isEditing}\n\t\t\t\t\t\t\tplaceholder=\"\"\n\t\t\t\t\t\t\tspellCheck=\"true\"\n\t\t\t\t\t\t\twrap=\"off\"\n\t\t\t\t\t\t\tdir=\"ltr\"\n\t\t\t\t\t\t\tdatatype=\"wysiwyg\"\n\t\t\t\t\t\t\tdefaultValue={text}\n\t\t\t\t\t\t\tonFocus={handleFocus}\n\t\t\t\t\t\t\tonChange={handleChange}\n\t\t\t\t\t\t\tonKeyDown={handleKeyDown}\n\t\t\t\t\t\t\tonBlur={handleBlur}\n\t\t\t\t\t\t\tonTouchEnd={stopEventPropagation}\n\t\t\t\t\t\t\tonContextMenu={stopEventPropagation}\n\t\t\t\t\t\t/>\n\t\t\t\t\t) : null}\n\t\t\t\t</div>\n\t\t\t</HTMLContainer>\n\t\t)\n\t}\n\n\tindicator(shape: TLTextShape) {\n\t\tconst bounds = this.bounds(shape)\n\t\treturn <rect width={toDomPrecision(bounds.width)} height={toDomPrecision(bounds.height)} />\n\t}\n\n\ttoSvg(shape: TLTextShape, font: string | undefined, colors: TLExportColors) {\n\t\tconst bounds = this.bounds(shape)\n\t\tconst text = shape.props.text\n\n\t\tconst width = bounds.width / (shape.props.scale ?? 1)\n\t\tconst height = bounds.height / (shape.props.scale ?? 1)\n\n\t\tconst opts = {\n\t\t\tfontSize: FONT_SIZES[shape.props.size],\n\t\t\tfontFamily: font!,\n\t\t\ttextAlign: shape.props.align,\n\t\t\tverticalTextAlign: 'middle' as const,\n\t\t\twidth,\n\t\t\theight,\n\t\t\tpadding: 0, // no padding?\n\t\t\tlineHeight: TEXT_PROPS.lineHeight,\n\t\t\tfontStyle: 'normal',\n\t\t\tfontWeight: 'normal',\n\t\t\toverflow: 'wrap' as const,\n\t\t}\n\n\t\tconst color = colors.fill[shape.props.color]\n\t\tconst groupEl = document.createElementNS('http://www.w3.org/2000/svg', 'g')\n\n\t\tconst textBgEl = createTextSvgElementFromSpans(\n\t\t\tthis.editor,\n\t\t\tthis.editor.textMeasure.measureTextSpans(text, opts),\n\t\t\t{\n\t\t\t\t...opts,\n\t\t\t\tstroke: colors.background,\n\t\t\t\tstrokeWidth: 2,\n\t\t\t\tfill: colors.background,\n\t\t\t\tpadding: 0,\n\t\t\t}\n\t\t)\n\n\t\tconst textElm = textBgEl.cloneNode(true) as SVGTextElement\n\t\ttextElm.setAttribute('fill', color)\n\t\ttextElm.setAttribute('stroke', 'none')\n\n\t\tgroupEl.append(textBgEl)\n\t\tgroupEl.append(textElm)\n\n\t\treturn groupEl\n\t}\n\n\tonResize: TLOnResizeHandler<TLTextShape> = (shape, info) => {\n\t\tconst { initialBounds, initialShape, scaleX, handle } = info\n\n\t\tif (info.mode === 'scale_shape' || (handle !== 'right' && handle !== 'left')) {\n\t\t\treturn resizeScaled(shape, info)\n\t\t} else {\n\t\t\tconst prevWidth = initialBounds.width\n\t\t\tlet nextWidth = prevWidth * scaleX\n\n\t\t\tconst offset = new Vec2d(0, 0)\n\n\t\t\tnextWidth = Math.max(1, Math.abs(nextWidth))\n\n\t\t\tif (handle === 'left') {\n\t\t\t\toffset.x = prevWidth - nextWidth\n\t\t\t\tif (scaleX < 0) {\n\t\t\t\t\toffset.x += nextWidth\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (scaleX < 0) {\n\t\t\t\t\toffset.x -= nextWidth\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst { x, y } = offset.rot(shape.rotation).add(initialShape)\n\n\t\t\treturn {\n\t\t\t\tx,\n\t\t\t\ty,\n\t\t\t\tprops: {\n\t\t\t\t\tw: nextWidth / initialShape.props.scale,\n\t\t\t\t\tautoSize: false,\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t}\n\n\tonBeforeCreate = (shape: TLTextShape) => {\n\t\t// When a shape is created, center the text at the created point.\n\n\t\t// Only center if the shape is set to autosize.\n\t\tif (!shape.props.autoSize) return\n\n\t\t// Only center if the shape is empty when created.\n\t\tif (shape.props.text.trim()) return\n\n\t\tconst bounds = this.getMinDimensions(shape)\n\n\t\treturn {\n\t\t\t...shape,\n\t\t\tx: shape.x - bounds.width / 2,\n\t\t\ty: shape.y - bounds.height / 2,\n\t\t}\n\t}\n\n\tonEditEnd: TLOnEditEndHandler<TLTextShape> = (shape) => {\n\t\tconst {\n\t\t\tid,\n\t\t\ttype,\n\t\t\tprops: { text },\n\t\t} = shape\n\n\t\tconst trimmedText = shape.props.text.trimEnd()\n\n\t\tif (trimmedText.length === 0) {\n\t\t\tthis.editor.deleteShapes([shape.id])\n\t\t} else {\n\t\t\tif (trimmedText !== shape.props.text) {\n\t\t\t\tthis.editor.updateShapes([\n\t\t\t\t\t{\n\t\t\t\t\t\tid,\n\t\t\t\t\t\ttype,\n\t\t\t\t\t\tprops: {\n\t\t\t\t\t\t\ttext: text.trimEnd(),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t])\n\t\t\t}\n\t\t}\n\t}\n\n\tonBeforeUpdate = (prev: TLTextShape, next: TLTextShape) => {\n\t\tif (!next.props.autoSize) return\n\n\t\tconst styleDidChange =\n\t\t\tprev.props.size !== next.props.size ||\n\t\t\tprev.props.align !== next.props.align ||\n\t\t\tprev.props.font !== next.props.font ||\n\t\t\t(prev.props.scale !== 1 && next.props.scale === 1)\n\n\t\tconst textDidChange = prev.props.text !== next.props.text\n\n\t\t// Only update position if either changed\n\t\tif (!styleDidChange && !textDidChange) return\n\n\t\t// Might return a cached value for the bounds\n\t\tconst boundsA = this.getMinDimensions(prev)\n\n\t\t// Will always be a fresh call to getTextSize\n\t\tconst boundsB = getTextSize(this.editor, next.props)\n\n\t\tconst wA = boundsA.width * prev.props.scale\n\t\tconst hA = boundsA.height * prev.props.scale\n\t\tconst wB = boundsB.width * next.props.scale\n\t\tconst hB = boundsB.height * next.props.scale\n\n\t\tlet delta: Vec2d | undefined\n\n\t\tswitch (next.props.align) {\n\t\t\tcase 'middle': {\n\t\t\t\tdelta = new Vec2d((wB - wA) / 2, textDidChange ? 0 : (hB - hA) / 2)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase 'end': {\n\t\t\t\tdelta = new Vec2d(wB - wA, textDidChange ? 0 : (hB - hA) / 2)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\tif (textDidChange) break\n\t\t\t\tdelta = new Vec2d(0, (hB - hA) / 2)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tif (delta) {\n\t\t\t// account for shape rotation when writing text:\n\t\t\tdelta.rot(next.rotation)\n\t\t\tconst { x, y } = next\n\t\t\treturn {\n\t\t\t\t...next,\n\t\t\t\tx: x - delta.x,\n\t\t\t\ty: y - delta.y,\n\t\t\t\tprops: { ...next.props, w: wB },\n\t\t\t}\n\t\t} else {\n\t\t\treturn {\n\t\t\t\t...next,\n\t\t\t\tprops: { ...next.props, w: wB },\n\t\t\t}\n\t\t}\n\t}\n\n\tonDoubleClickEdge = (shape: TLTextShape) => {\n\t\t// If the shape has a fixed width, set it to autoSize.\n\t\tif (!shape.props.autoSize) {\n\t\t\treturn {\n\t\t\t\tid: shape.id,\n\t\t\t\ttype: shape.type,\n\t\t\t\tprops: {\n\t\t\t\t\tautoSize: true,\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\n\t\t// If the shape is scaled, reset the scale to 1.\n\t\tif (shape.props.scale !== 1) {\n\t\t\treturn {\n\t\t\t\tid: shape.id,\n\t\t\t\ttype: shape.type,\n\t\t\t\tprops: {\n\t\t\t\t\tscale: 1,\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction getTextSize(editor: Editor, props: TLTextShape['props']) {\n\tconst { font, text, autoSize, size, w } = props\n\n\tconst minWidth = 16\n\tconst fontSize = FONT_SIZES[size]\n\n\tconst cw = autoSize\n\t\t? 'fit-content'\n\t\t: // `measureText` floors the number so we need to do the same here to avoid issues.\n\t\t  Math.floor(Math.max(minWidth, w)) + 'px'\n\n\tconst result = editor.textMeasure.measureText(text, {\n\t\t...TEXT_PROPS,\n\t\tfontFamily: FONT_FAMILIES[font],\n\t\tfontSize: fontSize,\n\t\twidth: cw,\n\t})\n\n\t// // If we're autosizing the measureText will essentially `Math.floor`\n\t// // the numbers so `19` rather than `19.3`, this means we must +1 to\n\t// // whatever we get to avoid wrapping.\n\tif (autoSize) {\n\t\tresult.w += 1\n\t}\n\n\treturn {\n\t\twidth: Math.max(minWidth, result.w),\n\t\theight: Math.max(fontSize, result.h),\n\t}\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}