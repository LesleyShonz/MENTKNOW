{"ast":null,"code":"import _classCallCheck from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _defineProperty from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nvar INDENT = \"  \";\nvar TextHelpers = /*#__PURE__*/function () {\n  function TextHelpers() {\n    _classCallCheck(this, TextHelpers);\n  }\n  _createClass(TextHelpers, null, [{\n    key: \"insertTextFirefox\",\n    value: function insertTextFirefox(field, text) {\n      field.setRangeText(text, field.selectionStart || 0, field.selectionEnd || 0, \"end\"\n      // Without this, the cursor is either at the beginning or text remains selected\n      );\n\n      field.dispatchEvent(new InputEvent(\"input\", {\n        data: text,\n        inputType: \"insertText\",\n        isComposing: false\n        // TODO: fix @types/jsdom, this shouldn't be required\n      }));\n    }\n    /**\n     * Inserts text at the cursorâ€™s position, replacing any selection, with **undo** support and by\n     * firing the input event.\n     */\n  }, {\n    key: \"insert\",\n    value: function insert(field, text) {\n      var document = field.ownerDocument;\n      var initialFocus = document.activeElement;\n      if (initialFocus !== field) {\n        field.focus();\n      }\n      if (!document.execCommand(\"insertText\", false, text)) {\n        TextHelpers.insertTextFirefox(field, text);\n      }\n      if (initialFocus === document.body) {\n        field.blur();\n      } else if (initialFocus instanceof HTMLElement && initialFocus !== field) {\n        initialFocus.focus();\n      }\n    }\n    /**\n     * Replaces the entire content, equivalent to field.value = text but with **undo** support and by\n     * firing the input event.\n     */\n  }, {\n    key: \"set\",\n    value: function set(field, text) {\n      field.select();\n      TextHelpers.insert(field, text);\n    }\n    /** Get the selected text in a field or an empty string if nothing is selected. */\n  }, {\n    key: \"getSelection\",\n    value: function getSelection(field) {\n      var selectionStart = field.selectionStart,\n        selectionEnd = field.selectionEnd;\n      return field.value.slice(selectionStart ? selectionStart : void 0, selectionEnd ? selectionEnd : void 0);\n    }\n    /**\n     * Adds the wrappingText before and after fieldâ€™s selection (or cursor). If endWrappingText is\n     * provided, it will be used instead of wrappingText at on the right.\n     */\n  }, {\n    key: \"wrapSelection\",\n    value: function wrapSelection(field, wrap, wrapEnd) {\n      var selectionStart = field.selectionStart,\n        selectionEnd = field.selectionEnd;\n      var selection = TextHelpers.getSelection(field);\n      TextHelpers.insert(field, wrap + selection + (wrapEnd !== null && wrapEnd !== void 0 ? wrapEnd : wrap));\n      field.selectionStart = (selectionStart || 0) + wrap.length;\n      field.selectionEnd = (selectionEnd || 0) + wrap.length;\n    }\n    /** Finds and replaces strings and regex in the fieldâ€™s value. */\n  }, {\n    key: \"replace\",\n    value: function replace(field, searchValue, replacer) {\n      var drift = 0;\n      field.value.replace(searchValue, function () {\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n        var matchStart = drift + args[args.length - 2];\n        var matchLength = args[0].length;\n        field.selectionStart = matchStart;\n        field.selectionEnd = matchStart + matchLength;\n        var replacement = typeof replacer === \"string\" ? replacer : replacer.apply(void 0, args);\n        TextHelpers.insert(field, replacement);\n        field.selectionStart = matchStart;\n        drift += replacement.length - matchLength;\n        return replacement;\n      });\n    }\n  }, {\n    key: \"findLineEnd\",\n    value: function findLineEnd(value, currentEnd) {\n      var lastLineStart = value.lastIndexOf(\"\\n\", currentEnd - 1) + 1;\n      if (value.charAt(lastLineStart) !== \"\t\") {\n        return currentEnd;\n      }\n      return lastLineStart + 1;\n    }\n  }, {\n    key: \"indent\",\n    value: function indent(element) {\n      var _exec;\n      var selectionStart = element.selectionStart,\n        selectionEnd = element.selectionEnd,\n        value = element.value;\n      var selectedContrast = value.slice(selectionStart, selectionEnd);\n      var lineBreakCount = (_exec = /\\n/g.exec(selectedContrast)) === null || _exec === void 0 ? void 0 : _exec.length;\n      if (lineBreakCount && lineBreakCount > 0) {\n        var firstLineStart = value.lastIndexOf(\"\\n\", selectionStart - 1) + 1;\n        var newSelection = element.value.slice(firstLineStart, selectionEnd - 1);\n        var indentedText = newSelection.replace(/^|\\n/g, // Match all line starts\n        \"$&\".concat(INDENT));\n        var replacementsCount = indentedText.length - newSelection.length;\n        element.setSelectionRange(firstLineStart, selectionEnd - 1);\n        TextHelpers.insert(element, indentedText);\n        element.setSelectionRange(selectionStart + 1, selectionEnd + replacementsCount);\n      } else {\n        TextHelpers.insert(element, INDENT);\n      }\n    }\n    // The first line should always be unindented\n    // The last line should only be unindented if the selection includes any characters after \\n\n  }, {\n    key: \"unindent\",\n    value: function unindent(element) {\n      var selectionStart = element.selectionStart,\n        selectionEnd = element.selectionEnd,\n        value = element.value;\n      var firstLineStart = value.lastIndexOf(\"\\n\", selectionStart - 1) + 1;\n      var minimumSelectionEnd = TextHelpers.findLineEnd(value, selectionEnd);\n      var newSelection = element.value.slice(firstLineStart, minimumSelectionEnd);\n      var indentedText = newSelection.replace(/(^|\\n)(\\t| {1,2})/g, \"$1\");\n      var replacementsCount = newSelection.length - indentedText.length;\n      element.setSelectionRange(firstLineStart, minimumSelectionEnd);\n      TextHelpers.insert(element, indentedText);\n      var firstLineIndentation = /\\t| {1,2}/.exec(value.slice(firstLineStart, selectionStart));\n      var difference = firstLineIndentation ? firstLineIndentation[0].length : 0;\n      var newSelectionStart = selectionStart - difference;\n      element.setSelectionRange(selectionStart - difference, Math.max(newSelectionStart, selectionEnd - replacementsCount));\n    }\n  }, {\n    key: \"indentCE\",\n    value: function indentCE(element) {\n      var _getCaretIndex, _getCaretIndex2, _exec2;\n      var selection = window.getSelection();\n      var value = element.innerText;\n      var selectionStart = (_getCaretIndex = getCaretIndex(element)) !== null && _getCaretIndex !== void 0 ? _getCaretIndex : 0;\n      var selectionEnd = (_getCaretIndex2 = getCaretIndex(element)) !== null && _getCaretIndex2 !== void 0 ? _getCaretIndex2 : 0;\n      var selectedContrast = value.slice(selectionStart, selectionEnd);\n      var lineBreakCount = (_exec2 = /\\n/g.exec(selectedContrast)) === null || _exec2 === void 0 ? void 0 : _exec2.length;\n      if (lineBreakCount && lineBreakCount > 0) {\n        var firstLineStart = value.lastIndexOf(\"\\n\", selectionStart - 1) + 1;\n        var newSelection = value.slice(firstLineStart, selectionEnd - 1);\n        var indentedText = newSelection.replace(/^|\\n/g, // Match all line starts\n        \"$&\".concat(INDENT));\n        var replacementsCount = indentedText.length - newSelection.length;\n        if (selection) {\n          selection.setBaseAndExtent(element, selectionStart + 1, element, selectionEnd + replacementsCount);\n        }\n      } else {\n        var selection2 = window.getSelection();\n        element.innerText = value.slice(0, selectionStart) + INDENT + value.slice(selectionStart);\n        selection2 === null || selection2 === void 0 || selection2.setBaseAndExtent(element, selectionStart + 1, element, selectionStart + 2);\n      }\n    }\n  }, {\n    key: \"unindentCE\",\n    value: function unindentCE(element) {\n      var _getCaretIndex3, _getCaretIndex4;\n      var selection = window.getSelection();\n      var value = element.innerText;\n      var selectionStart = (_getCaretIndex3 = getCaretIndex(element)) !== null && _getCaretIndex3 !== void 0 ? _getCaretIndex3 : 0;\n      var selectionEnd = (_getCaretIndex4 = getCaretIndex(element)) !== null && _getCaretIndex4 !== void 0 ? _getCaretIndex4 : 0;\n      var firstLineStart = value.lastIndexOf(\"\\n\", selectionStart - 1) + 1;\n      var minimumSelectionEnd = TextHelpers.findLineEnd(value, selectionEnd);\n      var newSelection = value.slice(firstLineStart, minimumSelectionEnd);\n      var indentedText = newSelection.replace(/(^|\\n)(\\t| {1,2})/g, \"$1\");\n      var replacementsCount = newSelection.length - indentedText.length;\n      if (selection) {\n        selection.setBaseAndExtent(element, firstLineStart, element, minimumSelectionEnd);\n        var firstLineIndentation = /\\t| {1,2}/.exec(value.slice(firstLineStart, selectionStart));\n        var difference = firstLineIndentation ? firstLineIndentation[0].length : 0;\n        var newSelectionStart = selectionStart - difference;\n        selection.setBaseAndExtent(element, selectionStart - difference, element, Math.max(newSelectionStart, selectionEnd - replacementsCount));\n      }\n    }\n  }, {\n    key: \"normalizeText\",\n    value: function normalizeText(text) {\n      return text.replace(TextHelpers.fixNewLines, \"\\n\");\n    }\n  }, {\n    key: \"normalizeTextForDom\",\n    value: function normalizeTextForDom(text) {\n      return text.replace(TextHelpers.fixNewLines, \"\\n\").split(\"\\n\").map(function (x) {\n        return x || \" \";\n      }).join(\"\\n\");\n    }\n  }]);\n  return TextHelpers;\n}();\n_defineProperty(TextHelpers, \"fixNewLines\", /\\r?\\n|\\r/g);\nfunction getCaretIndex(element) {\n  if (typeof window.getSelection === \"undefined\") return;\n  var selection = window.getSelection();\n  if (!selection) return;\n  var position = 0;\n  if (selection.rangeCount !== 0) {\n    var range = selection.getRangeAt(0);\n    var preCaretRange = range.cloneRange();\n    preCaretRange.selectNodeContents(element);\n    preCaretRange.setEnd(range.endContainer, range.endOffset);\n    position = preCaretRange.toString().length;\n  }\n  return position;\n}\nexport { INDENT, TextHelpers };","map":{"version":3,"names":["INDENT","TextHelpers","_classCallCheck","_createClass","key","value","insertTextFirefox","field","text","setRangeText","selectionStart","selectionEnd","dispatchEvent","InputEvent","data","inputType","isComposing","insert","document","ownerDocument","initialFocus","activeElement","focus","execCommand","body","blur","HTMLElement","set","select","getSelection","slice","wrapSelection","wrap","wrapEnd","selection","length","replace","searchValue","replacer","drift","_len","arguments","args","Array","_key","matchStart","matchLength","replacement","apply","findLineEnd","currentEnd","lastLineStart","lastIndexOf","charAt","indent","element","_exec","selectedContrast","lineBreakCount","exec","firstLineStart","newSelection","indentedText","concat","replacementsCount","setSelectionRange","unindent","minimumSelectionEnd","firstLineIndentation","difference","newSelectionStart","Math","max","indentCE","_getCaretIndex","_getCaretIndex2","_exec2","window","innerText","getCaretIndex","setBaseAndExtent","selection2","unindentCE","_getCaretIndex3","_getCaretIndex4","normalizeText","fixNewLines","normalizeTextForDom","split","map","x","join","_defineProperty","position","rangeCount","range","getRangeAt","preCaretRange","cloneRange","selectNodeContents","setEnd","endContainer","endOffset","toString"],"sources":["/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@tldraw/editor/src/lib/editor/shapes/text/TextHelpers.ts"],"sourcesContent":["// Adapted (mostly copied) the work of https://github.com/fregante\n// Copyright (c) Federico Brigante <opensource@bfred.it> (bfred.it)\n\n// TODO: Most of this file can be moved into a DOM utils library.\n\n/** @internal */\nexport type ReplacerCallback = (substring: string, ...args: unknown[]) => string\n\n/**\t@public */\nexport const INDENT = '  '\n\n/** @internal */\nexport class TextHelpers {\n\tstatic insertTextFirefox(field: HTMLTextAreaElement | HTMLInputElement, text: string): void {\n\t\t// Found on https://www.everythingfrontend.com/blog/insert-text-into-textarea-at-cursor-position.html ðŸŽˆ\n\t\tfield.setRangeText(\n\t\t\ttext,\n\t\t\tfield.selectionStart || 0,\n\t\t\tfield.selectionEnd || 0,\n\t\t\t'end' // Without this, the cursor is either at the beginning or text remains selected\n\t\t)\n\n\t\tfield.dispatchEvent(\n\t\t\tnew InputEvent('input', {\n\t\t\t\tdata: text,\n\t\t\t\tinputType: 'insertText',\n\t\t\t\tisComposing: false, // TODO: fix @types/jsdom, this shouldn't be required\n\t\t\t})\n\t\t)\n\t}\n\n\t/**\n\t * Inserts text at the cursorâ€™s position, replacing any selection, with **undo** support and by\n\t * firing the input event.\n\t */\n\tstatic insert(field: HTMLTextAreaElement | HTMLInputElement, text: string): void {\n\t\tconst document = field.ownerDocument\n\t\tconst initialFocus = document.activeElement\n\t\tif (initialFocus !== field) {\n\t\t\tfield.focus()\n\t\t}\n\n\t\tif (!document.execCommand('insertText', false, text)) {\n\t\t\tTextHelpers.insertTextFirefox(field, text)\n\t\t}\n\n\t\tif (initialFocus === document.body) {\n\t\t\tfield.blur()\n\t\t} else if (initialFocus instanceof HTMLElement && initialFocus !== field) {\n\t\t\tinitialFocus.focus()\n\t\t}\n\t}\n\n\t/**\n\t * Replaces the entire content, equivalent to field.value = text but with **undo** support and by\n\t * firing the input event.\n\t */\n\tstatic set(field: HTMLTextAreaElement | HTMLInputElement, text: string): void {\n\t\tfield.select()\n\t\tTextHelpers.insert(field, text)\n\t}\n\n\t/** Get the selected text in a field or an empty string if nothing is selected. */\n\tstatic getSelection(field: HTMLTextAreaElement | HTMLInputElement): string {\n\t\tconst { selectionStart, selectionEnd } = field\n\t\treturn field.value.slice(\n\t\t\tselectionStart ? selectionStart : undefined,\n\t\t\tselectionEnd ? selectionEnd : undefined\n\t\t)\n\t}\n\n\t/**\n\t * Adds the wrappingText before and after fieldâ€™s selection (or cursor). If endWrappingText is\n\t * provided, it will be used instead of wrappingText at on the right.\n\t */\n\tstatic wrapSelection(\n\t\tfield: HTMLTextAreaElement | HTMLInputElement,\n\t\twrap: string,\n\t\twrapEnd?: string\n\t): void {\n\t\tconst { selectionStart, selectionEnd } = field\n\t\tconst selection = TextHelpers.getSelection(field)\n\t\tTextHelpers.insert(field, wrap + selection + (wrapEnd ?? wrap))\n\n\t\t// Restore the selection around the previously-selected text\n\t\tfield.selectionStart = (selectionStart || 0) + wrap.length\n\t\tfield.selectionEnd = (selectionEnd || 0) + wrap.length\n\t}\n\n\t/** Finds and replaces strings and regex in the fieldâ€™s value. */\n\tstatic replace(\n\t\tfield: HTMLTextAreaElement | HTMLInputElement,\n\t\tsearchValue: string | RegExp,\n\t\treplacer: string | ReplacerCallback\n\t): void {\n\t\t/** Remembers how much each match offset should be adjusted */\n\t\tlet drift = 0\n\t\tfield.value.replace(searchValue, (...args): string => {\n\t\t\t// Select current match to replace it later\n\t\t\tconst matchStart = drift + (args[args.length - 2] as number)\n\t\t\tconst matchLength = args[0].length\n\t\t\tfield.selectionStart = matchStart\n\t\t\tfield.selectionEnd = matchStart + matchLength\n\t\t\tconst replacement = typeof replacer === 'string' ? replacer : replacer(...args)\n\t\t\tTextHelpers.insert(field, replacement)\n\t\t\t// Select replacement. Without this, the cursor would be after the replacement\n\t\t\tfield.selectionStart = matchStart\n\t\t\tdrift += replacement.length - matchLength\n\t\t\treturn replacement\n\t\t})\n\t}\n\n\tstatic findLineEnd(value: string, currentEnd: number): number {\n\t\t// Go to the beginning of the last line\n\t\tconst lastLineStart = value.lastIndexOf('\\n', currentEnd - 1) + 1\n\t\t// There's nothing to unindent after the last cursor, so leave it as is\n\t\tif (value.charAt(lastLineStart) !== '\\t') {\n\t\t\treturn currentEnd\n\t\t}\n\t\treturn lastLineStart + 1 // Include the first character, which will be a tab\n\t}\n\n\tstatic indent(element: HTMLTextAreaElement): void {\n\t\tconst { selectionStart, selectionEnd, value } = element\n\t\tconst selectedContrast = value.slice(selectionStart, selectionEnd)\n\t\t// The first line should be indented, even if it starts with \\n\n\t\t// The last line should only be indented if includes any character after \\n\n\t\tconst lineBreakCount = /\\n/g.exec(selectedContrast)?.length\n\n\t\tif (lineBreakCount && lineBreakCount > 0) {\n\t\t\t// Select full first line to replace everything at once\n\t\t\tconst firstLineStart = value.lastIndexOf('\\n', selectionStart - 1) + 1\n\n\t\t\tconst newSelection = element.value.slice(firstLineStart, selectionEnd - 1)\n\t\t\tconst indentedText = newSelection.replace(\n\t\t\t\t/^|\\n/g, // Match all line starts\n\t\t\t\t`$&${INDENT}`\n\t\t\t)\n\t\t\tconst replacementsCount = indentedText.length - newSelection.length\n\n\t\t\t// Replace newSelection with indentedText\n\t\t\telement.setSelectionRange(firstLineStart, selectionEnd - 1)\n\t\t\tTextHelpers.insert(element, indentedText)\n\n\t\t\t// Restore selection position, including the indentation\n\t\t\telement.setSelectionRange(selectionStart + 1, selectionEnd + replacementsCount)\n\t\t} else {\n\t\t\tTextHelpers.insert(element, INDENT)\n\t\t}\n\t}\n\n\t// The first line should always be unindented\n\t// The last line should only be unindented if the selection includes any characters after \\n\n\tstatic unindent(element: HTMLTextAreaElement): void {\n\t\tconst { selectionStart, selectionEnd, value } = element\n\n\t\t// Select the whole first line because it might contain \\t\n\t\tconst firstLineStart = value.lastIndexOf('\\n', selectionStart - 1) + 1\n\t\tconst minimumSelectionEnd = TextHelpers.findLineEnd(value, selectionEnd)\n\n\t\tconst newSelection = element.value.slice(firstLineStart, minimumSelectionEnd)\n\t\tconst indentedText = newSelection.replace(/(^|\\n)(\\t| {1,2})/g, '$1')\n\t\tconst replacementsCount = newSelection.length - indentedText.length\n\n\t\t// Replace newSelection with indentedText\n\t\telement.setSelectionRange(firstLineStart, minimumSelectionEnd)\n\t\tTextHelpers.insert(element, indentedText)\n\n\t\t// Restore selection position, including the indentation\n\t\tconst firstLineIndentation = /\\t| {1,2}/.exec(value.slice(firstLineStart, selectionStart))\n\n\t\tconst difference = firstLineIndentation ? firstLineIndentation[0].length : 0\n\n\t\tconst newSelectionStart = selectionStart - difference\n\t\telement.setSelectionRange(\n\t\t\tselectionStart - difference,\n\t\t\tMath.max(newSelectionStart, selectionEnd - replacementsCount)\n\t\t)\n\t}\n\n\tstatic indentCE(element: HTMLElement): void {\n\t\tconst selection = window.getSelection()\n\t\tconst value = element.innerText\n\t\tconst selectionStart = getCaretIndex(element) ?? 0\n\t\tconst selectionEnd = getCaretIndex(element) ?? 0\n\t\tconst selectedContrast = value.slice(selectionStart, selectionEnd)\n\t\t// The first line should be indented, even if it starts with \\n\n\t\t// The last line should only be indented if includes any character after \\n\n\t\tconst lineBreakCount = /\\n/g.exec(selectedContrast)?.length\n\n\t\tif (lineBreakCount && lineBreakCount > 0) {\n\t\t\t// Select full first line to replace everything at once\n\t\t\tconst firstLineStart = value.lastIndexOf('\\n', selectionStart - 1) + 1\n\n\t\t\tconst newSelection = value.slice(firstLineStart, selectionEnd - 1)\n\t\t\tconst indentedText = newSelection.replace(\n\t\t\t\t/^|\\n/g, // Match all line starts\n\t\t\t\t`$&${INDENT}`\n\t\t\t)\n\t\t\tconst replacementsCount = indentedText.length - newSelection.length\n\n\t\t\t// Replace newSelection with indentedText\n\n\t\t\tif (selection) {\n\t\t\t\tselection.setBaseAndExtent(\n\t\t\t\t\telement,\n\t\t\t\t\tselectionStart + 1,\n\t\t\t\t\telement,\n\t\t\t\t\tselectionEnd + replacementsCount\n\t\t\t\t)\n\t\t\t\t// element.setSelectionRange(firstLineStart, selectionEnd - 1)\n\t\t\t\t// TextHelpers.insert(element, indentedText)\n\n\t\t\t\t// Restore selection position, including the indentation\n\t\t\t\t// element.setSelectionRange(selectionStart + 1, selectionEnd + replacementsCount)\n\t\t\t}\n\t\t} else {\n\t\t\tconst selection = window.getSelection()\n\t\t\telement.innerText = value.slice(0, selectionStart) + INDENT + value.slice(selectionStart)\n\t\t\tselection?.setBaseAndExtent(element, selectionStart + 1, element, selectionStart + 2)\n\t\t\t// TextHelpers.insert(element, INDENT)\n\t\t}\n\t}\n\n\tstatic unindentCE(element: HTMLElement): void {\n\t\tconst selection = window.getSelection()\n\t\tconst value = element.innerText\n\t\t// const { selectionStart, selectionEnd } = element\n\t\tconst selectionStart = getCaretIndex(element) ?? 0\n\t\tconst selectionEnd = getCaretIndex(element) ?? 0\n\n\t\t// Select the whole first line because it might contain \\t\n\t\tconst firstLineStart = value.lastIndexOf('\\n', selectionStart - 1) + 1\n\t\tconst minimumSelectionEnd = TextHelpers.findLineEnd(value, selectionEnd)\n\n\t\tconst newSelection = value.slice(firstLineStart, minimumSelectionEnd)\n\t\tconst indentedText = newSelection.replace(/(^|\\n)(\\t| {1,2})/g, '$1')\n\t\tconst replacementsCount = newSelection.length - indentedText.length\n\n\t\tif (selection) {\n\t\t\t// Replace newSelection with indentedText\n\t\t\tselection.setBaseAndExtent(element, firstLineStart, element, minimumSelectionEnd)\n\t\t\t// TextHelpers.insert(element, indentedText)\n\n\t\t\t// Restore selection position, including the indentation\n\t\t\tconst firstLineIndentation = /\\t| {1,2}/.exec(value.slice(firstLineStart, selectionStart))\n\n\t\t\tconst difference = firstLineIndentation ? firstLineIndentation[0].length : 0\n\n\t\t\tconst newSelectionStart = selectionStart - difference\n\t\t\tselection.setBaseAndExtent(\n\t\t\t\telement,\n\t\t\t\tselectionStart - difference,\n\t\t\t\telement,\n\t\t\t\tMath.max(newSelectionStart, selectionEnd - replacementsCount)\n\t\t\t)\n\t\t}\n\t}\n\n\tstatic fixNewLines = /\\r?\\n|\\r/g\n\n\tstatic normalizeText(text: string) {\n\t\treturn text.replace(TextHelpers.fixNewLines, '\\n')\n\t}\n\n\tstatic normalizeTextForDom(text: string) {\n\t\treturn text\n\t\t\t.replace(TextHelpers.fixNewLines, '\\n')\n\t\t\t.split('\\n')\n\t\t\t.map((x) => x || ' ')\n\t\t\t.join('\\n')\n\t}\n}\n\nfunction getCaretIndex(element: HTMLElement) {\n\tif (typeof window.getSelection === 'undefined') return\n\tconst selection = window.getSelection()\n\tif (!selection) return\n\tlet position = 0\n\tif (selection.rangeCount !== 0) {\n\t\tconst range = selection.getRangeAt(0)\n\t\tconst preCaretRange = range.cloneRange()\n\t\tpreCaretRange.selectNodeContents(element)\n\t\tpreCaretRange.setEnd(range.endContainer, range.endOffset)\n\t\tposition = preCaretRange.toString().length\n\t}\n\treturn position\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}