{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _createClass from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _defineProperty from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\n// src/capture.ts\nimport { attach, detach } from \"./helpers.mjs\";\nvar signiaKey = Symbol.for(\"__signia__\");\nvar global = globalThis;\nif (global[signiaKey]) {\n  console.error('Multiple versions of signia detected. This will cause unexpected behavior. Please add \"resolutions\" (yarn/pnpm) or \"overrides\" (npm) in your package.json to ensure only one version of signia is loaded.');\n} else {\n  global[signiaKey] = true;\n}\nvar CaptureStackFrame = /*#__PURE__*/_createClass(function CaptureStackFrame(below, child) {\n  _classCallCheck(this, CaptureStackFrame);\n  _defineProperty(this, \"offset\", 0);\n  _defineProperty(this, \"numNewParents\", 0);\n  _defineProperty(this, \"maybeRemoved\", void 0);\n  this.below = below;\n  this.child = child;\n});\nvar stack = null;\nfunction unsafe__withoutCapture(fn) {\n  var oldStack = stack;\n  stack = null;\n  try {\n    return fn();\n  } finally {\n    stack = oldStack;\n  }\n}\nfunction startCapturingParents(child) {\n  stack = new CaptureStackFrame(stack, child);\n}\nfunction stopCapturingParents() {\n  var _stack;\n  var frame = stack;\n  stack = frame.below;\n  var didParentsChange = frame.numNewParents > 0 || frame.offset !== frame.child.parents.length;\n  if (!didParentsChange) {\n    return;\n  }\n  for (var i = frame.offset; i < frame.child.parents.length; i++) {\n    var p = frame.child.parents[i];\n    var parentWasRemoved = frame.child.parents.indexOf(p) >= frame.offset;\n    if (parentWasRemoved) {\n      detach(p, frame.child);\n    }\n  }\n  frame.child.parents.length = frame.offset;\n  frame.child.parentEpochs.length = frame.offset;\n  if ((_stack = stack) !== null && _stack !== void 0 && _stack.maybeRemoved) {\n    for (var _i = 0; _i < stack.maybeRemoved.length; _i++) {\n      var maybeRemovedParent = stack.maybeRemoved[_i];\n      if (frame.child.parents.indexOf(maybeRemovedParent) === -1) {\n        detach(maybeRemovedParent, frame.child);\n      }\n    }\n  }\n}\nfunction maybeCaptureParent(p) {\n  if (stack) {\n    var idx = stack.child.parents.indexOf(p);\n    if (idx < 0) {\n      stack.numNewParents++;\n      if (stack.child.isActivelyListening) {\n        attach(p, stack.child);\n      }\n    }\n    if (idx < 0 || idx >= stack.offset) {\n      if (idx !== stack.offset && idx > 0) {\n        var maybeRemovedParent = stack.child.parents[stack.offset];\n        if (!stack.maybeRemoved) {\n          stack.maybeRemoved = [maybeRemovedParent];\n        } else if (stack.maybeRemoved.indexOf(maybeRemovedParent) === -1) {\n          stack.maybeRemoved.push(maybeRemovedParent);\n        }\n      }\n      stack.child.parents[stack.offset] = p;\n      stack.child.parentEpochs[stack.offset] = p.lastChangedEpoch;\n      stack.offset++;\n    }\n  }\n}\nfunction whyAmIRunning() {\n  var _stack2;\n  var child = (_stack2 = stack) === null || _stack2 === void 0 ? void 0 : _stack2.child;\n  if (!child) {\n    throw new Error(\"whyAmIRunning() called outside of a reactive context\");\n  }\n  var changedParents = [];\n  for (var i = 0; i < child.parents.length; i++) {\n    var parent = child.parents[i];\n    if (parent.lastChangedEpoch > child.parentEpochs[i]) {\n      changedParents.push(parent);\n    }\n  }\n  if (changedParents.length === 0) {\n    console.log(child.name, \"is running but none of the parents changed\");\n  } else {\n    console.log(child.name, \"is running because:\");\n    var _iterator = _createForOfIteratorHelper(changedParents),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var changedParent = _step.value;\n        console.log(\"\t\", changedParent.name, \"changed =>\", changedParent.__unsafe__getWithoutCapture());\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  }\n}\nexport { maybeCaptureParent, startCapturingParents, stopCapturingParents, unsafe__withoutCapture, whyAmIRunning };","map":{"version":3,"names":["attach","detach","signiaKey","Symbol","for","global","globalThis","console","error","CaptureStackFrame","_createClass","below","child","_classCallCheck","_defineProperty","stack","unsafe__withoutCapture","fn","oldStack","startCapturingParents","stopCapturingParents","_stack","frame","didParentsChange","numNewParents","offset","parents","length","i","p","parentWasRemoved","indexOf","parentEpochs","maybeRemoved","maybeRemovedParent","maybeCaptureParent","idx","isActivelyListening","push","lastChangedEpoch","whyAmIRunning","_stack2","Error","changedParents","parent","log","name","_iterator","_createForOfIteratorHelper","_step","s","n","done","changedParent","value","__unsafe__getWithoutCapture","err","e","f"],"sources":["/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/signia/src/capture.ts"],"sourcesContent":["import { attach, detach } from './helpers.js'\nimport { Child, Signal } from './types.js'\n\nconst signiaKey = Symbol.for('__signia__')\nconst global = globalThis as { [signiaKey]?: true }\n\nif (global[signiaKey]) {\n\tconsole.error(\n\t\t'Multiple versions of signia detected. This will cause unexpected behavior. Please add \"resolutions\" (yarn/pnpm) or \"overrides\" (npm) in your package.json to ensure only one version of signia is loaded.'\n\t)\n} else {\n\tglobal[signiaKey] = true\n}\n\nclass CaptureStackFrame {\n\toffset = 0\n\tnumNewParents = 0\n\n\tmaybeRemoved?: Signal<any>[]\n\n\tconstructor(public readonly below: CaptureStackFrame | null, public readonly child: Child) {}\n}\n\nlet stack: CaptureStackFrame | null = null\n\n/**\n * Executes the given function without capturing any parents in the current capture context.\n *\n * This is mainly useful if you want to run an effect only when certain signals change while also\n * dereferencing other signals which should not cause the effect to rerun on their own.\n *\n * @example\n * ```ts\n * const name = atom('name', 'Sam')\n * const time = atom('time', () => new Date().getTime())\n *\n * setInterval(() => {\n *   time.set(new Date().getTime())\n * })\n *\n * react('log name changes', () => {\n * \t console.log(name.value, 'was changed at', unsafe__withoutCapture(() => time.value))\n * })\n *\n * ```\n *\n * @public\n */\nexport function unsafe__withoutCapture<T>(fn: () => T): T {\n\tconst oldStack = stack\n\tstack = null\n\ttry {\n\t\treturn fn()\n\t} finally {\n\t\tstack = oldStack\n\t}\n}\n\nexport function startCapturingParents(child: Child) {\n\tstack = new CaptureStackFrame(stack, child)\n}\n\nexport function stopCapturingParents() {\n\tconst frame = stack!\n\tstack = frame.below\n\n\tconst didParentsChange = frame.numNewParents > 0 || frame.offset !== frame.child.parents.length\n\n\tif (!didParentsChange) {\n\t\treturn\n\t}\n\n\tfor (let i = frame.offset; i < frame.child.parents.length; i++) {\n\t\tconst p = frame.child.parents[i]\n\t\tconst parentWasRemoved = frame.child.parents.indexOf(p) >= frame.offset\n\t\tif (parentWasRemoved) {\n\t\t\tdetach(p, frame.child)\n\t\t}\n\t}\n\n\tframe.child.parents.length = frame.offset\n\tframe.child.parentEpochs.length = frame.offset\n\n\tif (stack?.maybeRemoved) {\n\t\tfor (let i = 0; i < stack.maybeRemoved.length; i++) {\n\t\t\tconst maybeRemovedParent = stack.maybeRemoved[i]\n\t\t\tif (frame.child.parents.indexOf(maybeRemovedParent) === -1) {\n\t\t\t\tdetach(maybeRemovedParent, frame.child)\n\t\t\t}\n\t\t}\n\t}\n}\n\n// this must be called after the parent is up to date\nexport function maybeCaptureParent(p: Signal<any, any>) {\n\tif (stack) {\n\t\tconst idx = stack.child.parents.indexOf(p)\n\t\t// if the child didn't deref this parent last time it executed, then idx will be -1\n\t\t// if the child did deref this parent last time but in a different order relative to other parents, then idx will be greater than stack.offset\n\t\t// if the child did deref this parent last time in the same order, then idx will be the same as stack.offset\n\t\t// if the child did deref this parent already during this capture session then 0 <= idx < stack.offset\n\n\t\tif (idx < 0) {\n\t\t\tstack.numNewParents++\n\t\t\tif (stack.child.isActivelyListening) {\n\t\t\t\tattach(p, stack.child)\n\t\t\t}\n\t\t}\n\n\t\tif (idx < 0 || idx >= stack.offset) {\n\t\t\tif (idx !== stack.offset && idx > 0) {\n\t\t\t\tconst maybeRemovedParent = stack.child.parents[stack.offset]\n\n\t\t\t\tif (!stack.maybeRemoved) {\n\t\t\t\t\tstack.maybeRemoved = [maybeRemovedParent]\n\t\t\t\t} else if (stack.maybeRemoved.indexOf(maybeRemovedParent) === -1) {\n\t\t\t\t\tstack.maybeRemoved.push(maybeRemovedParent)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstack.child.parents[stack.offset] = p\n\t\t\tstack.child.parentEpochs[stack.offset] = p.lastChangedEpoch\n\t\t\tstack.offset++\n\t\t}\n\t}\n}\n\n/**\n * A debugging tool that tells you why a computed signal or effect is running.\n * Call in the body of a computed signal or effect function.\n *\n * @example\n * ```ts\n * const name = atom('name', 'Bob')\n * react('greeting', () => {\n * \twhyAmIRunning()\n *\tconsole.log('Hello', name.value)\n * })\n *\n * name.set('Alice')\n *\n * // 'greeting' is running because:\n * //     'name' changed => 'Alice'\n * ```\n *\n * @public\n */\nexport function whyAmIRunning() {\n\tconst child = stack?.child\n\tif (!child) {\n\t\tthrow new Error('whyAmIRunning() called outside of a reactive context')\n\t}\n\n\tconst changedParents = []\n\tfor (let i = 0; i < child.parents.length; i++) {\n\t\tconst parent = child.parents[i]\n\n\t\tif (parent.lastChangedEpoch > child.parentEpochs[i]) {\n\t\t\tchangedParents.push(parent)\n\t\t}\n\t}\n\n\tif (changedParents.length === 0) {\n\t\t// eslint-disable-next-line no-console\n\t\tconsole.log((child as any).name, 'is running but none of the parents changed')\n\t} else {\n\t\t// eslint-disable-next-line no-console\n\t\tconsole.log((child as any).name, 'is running because:')\n\t\tfor (const changedParent of changedParents) {\n\t\t\t// eslint-disable-next-line no-console\n\t\t\tconsole.log(\n\t\t\t\t'\\t',\n\t\t\t\t(changedParent as any).name,\n\t\t\t\t'changed =>',\n\t\t\t\tchangedParent.__unsafe__getWithoutCapture()\n\t\t\t)\n\t\t}\n\t}\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}