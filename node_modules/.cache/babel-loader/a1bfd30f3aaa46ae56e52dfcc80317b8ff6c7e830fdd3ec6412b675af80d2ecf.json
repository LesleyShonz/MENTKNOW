{"ast":null,"code":"import _slicedToArray from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _objectSpread from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _createForOfIteratorHelper from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { getOwnProperty, objectMapValues } from \"@tldraw/utils\";\nimport { MigrationFailureReason, migrate, migrateRecord } from \"./migrate.mjs\";\nvar StoreSchema = /*#__PURE__*/function () {\n  function StoreSchema(types, options) {\n    _classCallCheck(this, StoreSchema);\n    this.types = types;\n    this.options = options;\n  }\n  _createClass(StoreSchema, [{\n    key: \"currentStoreVersion\",\n    get: function get() {\n      var _this$options$snapsho, _this$options$snapsho2;\n      return (_this$options$snapsho = (_this$options$snapsho2 = this.options.snapshotMigrations) === null || _this$options$snapsho2 === void 0 ? void 0 : _this$options$snapsho2.currentVersion) !== null && _this$options$snapsho !== void 0 ? _this$options$snapsho : 0;\n    }\n  }, {\n    key: \"validateRecord\",\n    value: function validateRecord(store, record, phase, recordBefore) {\n      try {\n        var recordType = getOwnProperty(this.types, record.typeName);\n        if (!recordType) {\n          throw new Error(\"Missing definition for record type \".concat(record.typeName));\n        }\n        return recordType.validate(record);\n      } catch (error) {\n        if (this.options.onValidationFailure) {\n          return this.options.onValidationFailure({\n            store: store,\n            record: record,\n            phase: phase,\n            recordBefore: recordBefore,\n            error: error\n          });\n        } else {\n          throw error;\n        }\n      }\n    }\n  }, {\n    key: \"migratePersistedRecord\",\n    value: function migratePersistedRecord(record, persistedSchema) {\n      var _ourType$migrations$s;\n      var direction = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"up\";\n      var ourType = getOwnProperty(this.types, record.typeName);\n      var persistedType = persistedSchema.recordVersions[record.typeName];\n      if (!persistedType || !ourType) {\n        return {\n          type: \"error\",\n          reason: MigrationFailureReason.UnknownType\n        };\n      }\n      var ourVersion = ourType.migrations.currentVersion;\n      var persistedVersion = persistedType.version;\n      if (ourVersion !== persistedVersion) {\n        var result2 = direction === \"up\" ? migrateRecord({\n          record: record,\n          migrations: ourType.migrations,\n          fromVersion: persistedVersion,\n          toVersion: ourVersion\n        }) : migrateRecord({\n          record: record,\n          migrations: ourType.migrations,\n          fromVersion: ourVersion,\n          toVersion: persistedVersion\n        });\n        if (result2.type === \"error\") {\n          return result2;\n        }\n        record = result2.value;\n      }\n      if (!ourType.migrations.subTypeKey) {\n        return {\n          type: \"success\",\n          value: record\n        };\n      }\n      var ourSubTypeMigrations = (_ourType$migrations$s = ourType.migrations.subTypeMigrations) === null || _ourType$migrations$s === void 0 ? void 0 : _ourType$migrations$s[record[ourType.migrations.subTypeKey]];\n      var persistedSubTypeVersion = \"subTypeVersions\" in persistedType ? persistedType.subTypeVersions[record[ourType.migrations.subTypeKey]] : void 0;\n      if (ourSubTypeMigrations === void 0) {\n        return {\n          type: \"error\",\n          reason: MigrationFailureReason.UnrecognizedSubtype\n        };\n      }\n      if (persistedSubTypeVersion === void 0) {\n        return {\n          type: \"error\",\n          reason: MigrationFailureReason.IncompatibleSubtype\n        };\n      }\n      var result = direction === \"up\" ? migrateRecord({\n        record: record,\n        migrations: ourSubTypeMigrations,\n        fromVersion: persistedSubTypeVersion,\n        toVersion: ourSubTypeMigrations.currentVersion\n      }) : migrateRecord({\n        record: record,\n        migrations: ourSubTypeMigrations,\n        fromVersion: ourSubTypeMigrations.currentVersion,\n        toVersion: persistedSubTypeVersion\n      });\n      if (result.type === \"error\") {\n        return result;\n      }\n      return {\n        type: \"success\",\n        value: result.value\n      };\n    }\n  }, {\n    key: \"migrateStoreSnapshot\",\n    value: function migrateStoreSnapshot(storeSnapshot, persistedSchema) {\n      var _persistedSchema$stor;\n      var migrations = this.options.snapshotMigrations;\n      if (!migrations) {\n        return {\n          type: \"success\",\n          value: storeSnapshot\n        };\n      }\n      var ourStoreVersion = migrations.currentVersion;\n      var persistedStoreVersion = (_persistedSchema$stor = persistedSchema.storeVersion) !== null && _persistedSchema$stor !== void 0 ? _persistedSchema$stor : 0;\n      if (ourStoreVersion < persistedStoreVersion) {\n        return {\n          type: \"error\",\n          reason: MigrationFailureReason.TargetVersionTooOld\n        };\n      }\n      if (ourStoreVersion > persistedStoreVersion) {\n        var result = migrate({\n          value: storeSnapshot,\n          migrations: migrations,\n          fromVersion: persistedStoreVersion,\n          toVersion: ourStoreVersion\n        });\n        if (result.type === \"error\") {\n          return result;\n        }\n        storeSnapshot = result.value;\n      }\n      var updated = [];\n      var _iterator = _createForOfIteratorHelper(objectMapValues(storeSnapshot)),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var _r = _step.value;\n          var _result = this.migratePersistedRecord(_r, persistedSchema);\n          if (_result.type === \"error\") {\n            return _result;\n          } else if (_result.value && _result.value !== _r) {\n            updated.push(_result.value);\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      if (updated.length) {\n        storeSnapshot = _objectSpread({}, storeSnapshot);\n        var _iterator2 = _createForOfIteratorHelper(updated),\n          _step2;\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var r = _step2.value;\n            storeSnapshot[r.id] = r;\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      }\n      return {\n        type: \"success\",\n        value: storeSnapshot\n      };\n    }\n    /** @internal */\n  }, {\n    key: \"createIntegrityChecker\",\n    value: function createIntegrityChecker(store) {\n      var _this$options$createI, _this$options$createI2, _this$options;\n      return (_this$options$createI = (_this$options$createI2 = (_this$options = this.options).createIntegrityChecker) === null || _this$options$createI2 === void 0 ? void 0 : _this$options$createI2.call(_this$options, store)) !== null && _this$options$createI !== void 0 ? _this$options$createI : void 0;\n    }\n  }, {\n    key: \"serialize\",\n    value: function serialize() {\n      var _this$options$snapsho3, _this$options$snapsho4;\n      return {\n        schemaVersion: 1,\n        storeVersion: (_this$options$snapsho3 = (_this$options$snapsho4 = this.options.snapshotMigrations) === null || _this$options$snapsho4 === void 0 ? void 0 : _this$options$snapsho4.currentVersion) !== null && _this$options$snapsho3 !== void 0 ? _this$options$snapsho3 : 0,\n        recordVersions: Object.fromEntries(objectMapValues(this.types).map(function (type) {\n          return [type.typeName, type.migrations.subTypeKey && type.migrations.subTypeMigrations ? {\n            version: type.migrations.currentVersion,\n            subTypeKey: type.migrations.subTypeKey,\n            subTypeVersions: type.migrations.subTypeMigrations ? Object.fromEntries(Object.entries(type.migrations.subTypeMigrations).map(function (_ref) {\n              var _ref2 = _slicedToArray(_ref, 2),\n                k = _ref2[0],\n                v = _ref2[1];\n              return [k, v.currentVersion];\n            })) : void 0\n          } : {\n            version: type.migrations.currentVersion\n          }];\n        }))\n      };\n    }\n  }, {\n    key: \"serializeEarliestVersion\",\n    value: function serializeEarliestVersion() {\n      var _this$options$snapsho5, _this$options$snapsho6;\n      return {\n        schemaVersion: 1,\n        storeVersion: (_this$options$snapsho5 = (_this$options$snapsho6 = this.options.snapshotMigrations) === null || _this$options$snapsho6 === void 0 ? void 0 : _this$options$snapsho6.firstVersion) !== null && _this$options$snapsho5 !== void 0 ? _this$options$snapsho5 : 0,\n        recordVersions: Object.fromEntries(objectMapValues(this.types).map(function (type) {\n          return [type.typeName, type.migrations.subTypeKey && type.migrations.subTypeMigrations ? {\n            version: type.migrations.firstVersion,\n            subTypeKey: type.migrations.subTypeKey,\n            subTypeVersions: type.migrations.subTypeMigrations ? Object.fromEntries(Object.entries(type.migrations.subTypeMigrations).map(function (_ref3) {\n              var _ref4 = _slicedToArray(_ref3, 2),\n                k = _ref4[0],\n                v = _ref4[1];\n              return [k, v.firstVersion];\n            })) : void 0\n          } : {\n            version: type.migrations.firstVersion\n          }];\n        }))\n      };\n    }\n  }], [{\n    key: \"create\",\n    value: function create(types, options) {\n      return new StoreSchema(types, options !== null && options !== void 0 ? options : {});\n    }\n  }]);\n  return StoreSchema;\n}();\nexport { StoreSchema };","map":{"version":3,"names":["getOwnProperty","objectMapValues","MigrationFailureReason","migrate","migrateRecord","StoreSchema","types","options","_classCallCheck","_createClass","key","get","_this$options$snapsho","_this$options$snapsho2","snapshotMigrations","currentVersion","value","validateRecord","store","record","phase","recordBefore","recordType","typeName","Error","concat","validate","error","onValidationFailure","migratePersistedRecord","persistedSchema","_ourType$migrations$s","direction","arguments","length","undefined","ourType","persistedType","recordVersions","type","reason","UnknownType","ourVersion","migrations","persistedVersion","version","result2","fromVersion","toVersion","subTypeKey","ourSubTypeMigrations","subTypeMigrations","persistedSubTypeVersion","subTypeVersions","UnrecognizedSubtype","IncompatibleSubtype","result","migrateStoreSnapshot","storeSnapshot","_persistedSchema$stor","ourStoreVersion","persistedStoreVersion","storeVersion","TargetVersionTooOld","updated","_iterator","_createForOfIteratorHelper","_step","s","n","done","r","push","err","e","f","_objectSpread","_iterator2","_step2","id","createIntegrityChecker","_this$options$createI","_this$options$createI2","_this$options","call","serialize","_this$options$snapsho3","_this$options$snapsho4","schemaVersion","Object","fromEntries","map","entries","_ref","_ref2","_slicedToArray","k","v","serializeEarliestVersion","_this$options$snapsho5","_this$options$snapsho6","firstVersion","_ref3","_ref4","create"],"sources":["/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@tldraw/store/src/lib/StoreSchema.ts"],"sourcesContent":["import { getOwnProperty, objectMapValues } from '@tldraw/utils'\nimport { IdOf, UnknownRecord } from './BaseRecord'\nimport { RecordType } from './RecordType'\nimport { Store, StoreSnapshot } from './Store'\nimport {\n\tMigrationFailureReason,\n\tMigrationResult,\n\tMigrations,\n\tmigrate,\n\tmigrateRecord,\n} from './migrate'\n\n/** @public */\nexport interface SerializedSchema {\n\t/** Schema version is the version for this type you're looking at right now */\n\tschemaVersion: number\n\t/**\n\t * Store version is the version for the structure of the store. e.g. higher level structure like\n\t * removing or renaming a record type.\n\t */\n\tstoreVersion: number\n\t/** Record versions are the versions for each record type. e.g. adding a new field to a record */\n\trecordVersions: Record<\n\t\tstring,\n\t\t| {\n\t\t\t\tversion: number\n\t\t  }\n\t\t| {\n\t\t\t\t// subtypes are used for migrating shape and asset props\n\t\t\t\tversion: number\n\t\t\t\tsubTypeVersions: Record<string, number>\n\t\t\t\tsubTypeKey: string\n\t\t  }\n\t>\n}\n\n/** @public */\nexport type StoreSchemaOptions<R extends UnknownRecord, P> = {\n\t/** @public */\n\tsnapshotMigrations?: Migrations\n\t/** @public */\n\tonValidationFailure?: (data: {\n\t\terror: unknown\n\t\tstore: Store<R>\n\t\trecord: R\n\t\tphase: 'initialize' | 'createRecord' | 'updateRecord' | 'tests'\n\t\trecordBefore: R | null\n\t}) => R\n\t/** @internal */\n\tcreateIntegrityChecker?: (store: Store<R, P>) => void\n}\n\n/** @public */\nexport class StoreSchema<R extends UnknownRecord, P = unknown> {\n\tstatic create<R extends UnknownRecord, P = unknown>(\n\t\t// HACK: making this param work with RecordType is an enormous pain\n\t\t// let's just settle for making sure each typeName has a corresponding RecordType\n\t\t// and accept that this function won't be able to infer the record type from it's arguments\n\t\ttypes: { [TypeName in R['typeName']]: { createId: any } },\n\t\toptions?: StoreSchemaOptions<R, P>\n\t): StoreSchema<R, P> {\n\t\treturn new StoreSchema<R, P>(types as any, options ?? {})\n\t}\n\n\tprivate constructor(\n\t\tpublic readonly types: {\n\t\t\t[Record in R as Record['typeName']]: RecordType<R, any>\n\t\t},\n\t\tprivate readonly options: StoreSchemaOptions<R, P>\n\t) {}\n\n\tget currentStoreVersion(): number {\n\t\treturn this.options.snapshotMigrations?.currentVersion ?? 0\n\t}\n\n\tvalidateRecord(\n\t\tstore: Store<R>,\n\t\trecord: R,\n\t\tphase: 'initialize' | 'createRecord' | 'updateRecord' | 'tests',\n\t\trecordBefore: R | null\n\t): R {\n\t\ttry {\n\t\t\tconst recordType = getOwnProperty(this.types, record.typeName)\n\t\t\tif (!recordType) {\n\t\t\t\tthrow new Error(`Missing definition for record type ${record.typeName}`)\n\t\t\t}\n\t\t\treturn recordType.validate(record)\n\t\t} catch (error: unknown) {\n\t\t\tif (this.options.onValidationFailure) {\n\t\t\t\treturn this.options.onValidationFailure({\n\t\t\t\t\tstore,\n\t\t\t\t\trecord,\n\t\t\t\t\tphase,\n\t\t\t\t\trecordBefore,\n\t\t\t\t\terror,\n\t\t\t\t})\n\t\t\t} else {\n\t\t\t\tthrow error\n\t\t\t}\n\t\t}\n\t}\n\n\tmigratePersistedRecord(\n\t\trecord: R,\n\t\tpersistedSchema: SerializedSchema,\n\t\tdirection: 'up' | 'down' = 'up'\n\t): MigrationResult<R> {\n\t\tconst ourType = getOwnProperty(this.types, record.typeName)\n\t\tconst persistedType = persistedSchema.recordVersions[record.typeName]\n\t\tif (!persistedType || !ourType) {\n\t\t\treturn { type: 'error', reason: MigrationFailureReason.UnknownType }\n\t\t}\n\t\tconst ourVersion = ourType.migrations.currentVersion\n\t\tconst persistedVersion = persistedType.version\n\t\tif (ourVersion !== persistedVersion) {\n\t\t\tconst result =\n\t\t\t\tdirection === 'up'\n\t\t\t\t\t? migrateRecord<R>({\n\t\t\t\t\t\t\trecord,\n\t\t\t\t\t\t\tmigrations: ourType.migrations,\n\t\t\t\t\t\t\tfromVersion: persistedVersion,\n\t\t\t\t\t\t\ttoVersion: ourVersion,\n\t\t\t\t\t  })\n\t\t\t\t\t: migrateRecord<R>({\n\t\t\t\t\t\t\trecord,\n\t\t\t\t\t\t\tmigrations: ourType.migrations,\n\t\t\t\t\t\t\tfromVersion: ourVersion,\n\t\t\t\t\t\t\ttoVersion: persistedVersion,\n\t\t\t\t\t  })\n\t\t\tif (result.type === 'error') {\n\t\t\t\treturn result\n\t\t\t}\n\t\t\trecord = result.value\n\t\t}\n\n\t\tif (!ourType.migrations.subTypeKey) {\n\t\t\treturn { type: 'success', value: record }\n\t\t}\n\n\t\t// we've handled the main version migration, now we need to handle subtypes\n\t\t// subtypes are used by shape and asset types to migrate the props shape, which is configurable\n\t\t// by library consumers.\n\n\t\tconst ourSubTypeMigrations =\n\t\t\tourType.migrations.subTypeMigrations?.[\n\t\t\t\trecord[ourType.migrations.subTypeKey as keyof R] as string\n\t\t\t]\n\n\t\tconst persistedSubTypeVersion =\n\t\t\t'subTypeVersions' in persistedType\n\t\t\t\t? persistedType.subTypeVersions[record[ourType.migrations.subTypeKey as keyof R] as string]\n\t\t\t\t: undefined\n\n\t\t// if ourSubTypeMigrations is undefined then we don't have access to the migrations for this subtype\n\t\t// that is almost certainly because we are running on the server and this type was supplied by a 3rd party.\n\t\t// It could also be that we are running in a client that is outdated. Either way, we can't migrate this record\n\t\t// and we need to let the consumer know so they can handle it.\n\t\tif (ourSubTypeMigrations === undefined) {\n\t\t\treturn { type: 'error', reason: MigrationFailureReason.UnrecognizedSubtype }\n\t\t}\n\n\t\t// if the persistedSubTypeVersion is undefined then the record was either created after the schema\n\t\t// was persisted, or it was created in a different place to where the schema was persisted.\n\t\t// either way we don't know what to do with it safely, so let's return failure.\n\t\tif (persistedSubTypeVersion === undefined) {\n\t\t\treturn { type: 'error', reason: MigrationFailureReason.IncompatibleSubtype }\n\t\t}\n\n\t\tconst result =\n\t\t\tdirection === 'up'\n\t\t\t\t? migrateRecord<R>({\n\t\t\t\t\t\trecord,\n\t\t\t\t\t\tmigrations: ourSubTypeMigrations,\n\t\t\t\t\t\tfromVersion: persistedSubTypeVersion,\n\t\t\t\t\t\ttoVersion: ourSubTypeMigrations.currentVersion,\n\t\t\t\t  })\n\t\t\t\t: migrateRecord<R>({\n\t\t\t\t\t\trecord,\n\t\t\t\t\t\tmigrations: ourSubTypeMigrations,\n\t\t\t\t\t\tfromVersion: ourSubTypeMigrations.currentVersion,\n\t\t\t\t\t\ttoVersion: persistedSubTypeVersion,\n\t\t\t\t  })\n\n\t\tif (result.type === 'error') {\n\t\t\treturn result\n\t\t}\n\n\t\treturn { type: 'success', value: result.value }\n\t}\n\n\tmigrateStoreSnapshot(\n\t\tstoreSnapshot: StoreSnapshot<R>,\n\t\tpersistedSchema: SerializedSchema\n\t): MigrationResult<StoreSnapshot<R>> {\n\t\tconst migrations = this.options.snapshotMigrations\n\t\tif (!migrations) {\n\t\t\treturn { type: 'success', value: storeSnapshot }\n\t\t}\n\t\t// apply store migrations first\n\t\tconst ourStoreVersion = migrations.currentVersion\n\t\tconst persistedStoreVersion = persistedSchema.storeVersion ?? 0\n\n\t\tif (ourStoreVersion < persistedStoreVersion) {\n\t\t\treturn { type: 'error', reason: MigrationFailureReason.TargetVersionTooOld }\n\t\t}\n\n\t\tif (ourStoreVersion > persistedStoreVersion) {\n\t\t\tconst result = migrate<StoreSnapshot<R>>({\n\t\t\t\tvalue: storeSnapshot,\n\t\t\t\tmigrations,\n\t\t\t\tfromVersion: persistedStoreVersion,\n\t\t\t\ttoVersion: ourStoreVersion,\n\t\t\t})\n\n\t\t\tif (result.type === 'error') {\n\t\t\t\treturn result\n\t\t\t}\n\t\t\tstoreSnapshot = result.value\n\t\t}\n\n\t\tconst updated: R[] = []\n\t\tfor (const r of objectMapValues(storeSnapshot)) {\n\t\t\tconst result = this.migratePersistedRecord(r, persistedSchema)\n\t\t\tif (result.type === 'error') {\n\t\t\t\treturn result\n\t\t\t} else if (result.value && result.value !== r) {\n\t\t\t\tupdated.push(result.value)\n\t\t\t}\n\t\t}\n\t\tif (updated.length) {\n\t\t\tstoreSnapshot = { ...storeSnapshot }\n\t\t\tfor (const r of updated) {\n\t\t\t\tstoreSnapshot[r.id as IdOf<R>] = r\n\t\t\t}\n\t\t}\n\t\treturn { type: 'success', value: storeSnapshot }\n\t}\n\n\t/** @internal */\n\tcreateIntegrityChecker(store: Store<R, P>): (() => void) | undefined {\n\t\treturn this.options.createIntegrityChecker?.(store) ?? undefined\n\t}\n\n\tserialize(): SerializedSchema {\n\t\treturn {\n\t\t\tschemaVersion: 1,\n\t\t\tstoreVersion: this.options.snapshotMigrations?.currentVersion ?? 0,\n\t\t\trecordVersions: Object.fromEntries(\n\t\t\t\tobjectMapValues(this.types).map((type) => [\n\t\t\t\t\ttype.typeName,\n\t\t\t\t\ttype.migrations.subTypeKey && type.migrations.subTypeMigrations\n\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\tversion: type.migrations.currentVersion,\n\t\t\t\t\t\t\t\tsubTypeKey: type.migrations.subTypeKey,\n\t\t\t\t\t\t\t\tsubTypeVersions: type.migrations.subTypeMigrations\n\t\t\t\t\t\t\t\t\t? Object.fromEntries(\n\t\t\t\t\t\t\t\t\t\t\tObject.entries(type.migrations.subTypeMigrations).map(([k, v]) => [\n\t\t\t\t\t\t\t\t\t\t\t\tk,\n\t\t\t\t\t\t\t\t\t\t\t\tv.currentVersion,\n\t\t\t\t\t\t\t\t\t\t\t])\n\t\t\t\t\t\t\t\t\t  )\n\t\t\t\t\t\t\t\t\t: undefined,\n\t\t\t\t\t\t  }\n\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\tversion: type.migrations.currentVersion,\n\t\t\t\t\t\t  },\n\t\t\t\t])\n\t\t\t),\n\t\t}\n\t}\n\n\tserializeEarliestVersion(): SerializedSchema {\n\t\treturn {\n\t\t\tschemaVersion: 1,\n\t\t\tstoreVersion: this.options.snapshotMigrations?.firstVersion ?? 0,\n\t\t\trecordVersions: Object.fromEntries(\n\t\t\t\tobjectMapValues(this.types).map((type) => [\n\t\t\t\t\ttype.typeName,\n\t\t\t\t\ttype.migrations.subTypeKey && type.migrations.subTypeMigrations\n\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\tversion: type.migrations.firstVersion,\n\t\t\t\t\t\t\t\tsubTypeKey: type.migrations.subTypeKey,\n\t\t\t\t\t\t\t\tsubTypeVersions: type.migrations.subTypeMigrations\n\t\t\t\t\t\t\t\t\t? Object.fromEntries(\n\t\t\t\t\t\t\t\t\t\t\tObject.entries(type.migrations.subTypeMigrations).map(([k, v]) => [\n\t\t\t\t\t\t\t\t\t\t\t\tk,\n\t\t\t\t\t\t\t\t\t\t\t\tv.firstVersion,\n\t\t\t\t\t\t\t\t\t\t\t])\n\t\t\t\t\t\t\t\t\t  )\n\t\t\t\t\t\t\t\t\t: undefined,\n\t\t\t\t\t\t  }\n\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\tversion: type.migrations.firstVersion,\n\t\t\t\t\t\t  },\n\t\t\t\t])\n\t\t\t),\n\t\t}\n\t}\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}