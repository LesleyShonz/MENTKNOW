var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp(target, key, result);
  return result;
};
import { Fragment, jsx, jsxs } from "react/jsx-runtime";
import {
  Box2d,
  getPointOnCircle,
  linesIntersect,
  longAngleDist,
  Matrix2d,
  pointInPolygon,
  shortAngleDist,
  toDomPrecision,
  Vec2d
} from "@tldraw/primitives";
import { deepCopy, last, minBy } from "@tldraw/utils";
import * as React from "react";
import { computed, EMPTY_ARRAY } from "signia";
import { SVGContainer } from "../../../components/SVGContainer.mjs";
import {
  ShapeUtil
} from "../ShapeUtil.mjs";
import { createTextSvgElementFromSpans } from "../shared/createTextSvgElementFromSpans.mjs";
import {
  ARROW_LABEL_FONT_SIZES,
  FONT_FAMILIES,
  STROKE_SIZES,
  TEXT_PROPS
} from "../shared/default-shape-constants.mjs";
import { getPerfectDashProps } from "../shared/getPerfectDashProps.mjs";
import { getShapeFillSvg, ShapeFill } from "../shared/ShapeFill.mjs";
import { getArrowheadPathForType } from "./arrow/arrowheads.mjs";
import {
  getCurvedArrowHandlePath,
  getCurvedArrowInfo,
  getSolidCurvedArrowPath
} from "./arrow/curved-arrow.mjs";
import { getArrowTerminalsInArrowSpace, getIsArrowStraight } from "./arrow/shared.mjs";
import {
  getSolidStraightArrowPath,
  getStraightArrowHandlePath,
  getStraightArrowInfo
} from "./arrow/straight-arrow.mjs";
import { ArrowTextLabel } from "./components/ArrowTextLabel.mjs";
let globalRenderIndex = 0;
class ArrowShapeUtil extends ShapeUtil {
  static type = "arrow";
  canEdit = () => true;
  canBind = () => false;
  isClosed = () => false;
  canSnap = () => true;
  hideResizeHandles = () => true;
  hideRotateHandle = () => true;
  hideSelectionBoundsFg = () => true;
  hideSelectionBoundsBg = () => true;
  defaultProps() {
    return {
      dash: "draw",
      size: "m",
      fill: "none",
      color: "black",
      labelColor: "black",
      bend: 0,
      start: { type: "point", x: 0, y: 0 },
      end: { type: "point", x: 0, y: 0 },
      arrowheadStart: "none",
      arrowheadEnd: "arrow",
      text: "",
      font: "draw"
    };
  }
  getCenter(shape) {
    return this.bounds(shape).center;
  }
  getBounds(shape) {
    return Box2d.FromPoints(this.getOutlineWithoutLabel(shape));
  }
  getOutlineWithoutLabel(shape) {
    const info = this.getArrowInfo(shape);
    if (!info) {
      return [];
    }
    if (info.isStraight) {
      if (info.isValid) {
        return [Vec2d.From(info.start.point), Vec2d.From(info.end.point)];
      } else {
        return [new Vec2d(0, 0), new Vec2d(1, 1)];
      }
    }
    if (!info.isValid) {
      return [new Vec2d(0, 0), new Vec2d(1, 1)];
    }
    const pointsToPush = Math.max(5, Math.ceil(Math.abs(info.bodyArc.length) / 16));
    if (pointsToPush <= 0 && !isFinite(pointsToPush)) {
      return [new Vec2d(0, 0), new Vec2d(1, 1)];
    }
    const results = Array(pointsToPush);
    const startAngle = Vec2d.Angle(info.bodyArc.center, info.start.point);
    const endAngle = Vec2d.Angle(info.bodyArc.center, info.end.point);
    const a = info.bodyArc.sweepFlag ? endAngle : startAngle;
    const b = info.bodyArc.sweepFlag ? startAngle : endAngle;
    const l = info.bodyArc.largeArcFlag ? -longAngleDist(a, b) : shortAngleDist(a, b);
    const r = Math.max(1, info.bodyArc.radius);
    for (let i = 0; i < pointsToPush; i++) {
      const t = i / (pointsToPush - 1);
      const angle = a + l * t;
      const point = getPointOnCircle(info.bodyArc.center.x, info.bodyArc.center.y, r, angle);
      results[i] = point;
    }
    return results;
  }
  getOutline(shape) {
    const outlineWithoutLabel = this.getOutlineWithoutLabel(shape);
    const labelBounds = this.getLabelBounds(shape);
    if (!labelBounds) {
      return outlineWithoutLabel;
    }
    const sides = labelBounds.sides;
    const sideIndexes = [0, 1, 2, 3];
    let prevPoint = outlineWithoutLabel[0];
    let didAddLabel = false;
    const result = [prevPoint];
    for (let i = 1; i < outlineWithoutLabel.length; i++) {
      const nextPoint = outlineWithoutLabel[i];
      if (!didAddLabel) {
        const nearestIntersectingSideIndex = minBy(
          sideIndexes.filter(
            (sideIndex) => linesIntersect(sides[sideIndex][0], sides[sideIndex][1], prevPoint, nextPoint)
          ),
          (sideIndex) => Vec2d.DistanceToLineSegment(sides[sideIndex][0], sides[sideIndex][1], prevPoint)
        );
        if (nearestIntersectingSideIndex !== void 0) {
          const intersectingPoint = Vec2d.NearestPointOnLineSegment(
            sides[nearestIntersectingSideIndex][0],
            sides[nearestIntersectingSideIndex][1],
            prevPoint
          );
          result.push(intersectingPoint);
          for (let j = 0; j < 4; j++) {
            const sideIndex = (nearestIntersectingSideIndex + j) % 4;
            result.push(sides[sideIndex][1]);
          }
          result.push(intersectingPoint);
          didAddLabel = true;
        }
      }
      result.push(nextPoint);
      prevPoint = nextPoint;
    }
    return result;
  }
  snapPoints(_shape) {
    return EMPTY_ARRAY;
  }
  get infoCache() {
    return this.editor.store.createComputedCache(
      "arrow infoCache",
      (shape) => {
        return getIsArrowStraight(shape) ? getStraightArrowInfo(this.editor, shape) : getCurvedArrowInfo(this.editor, shape);
      }
    );
  }
  getArrowInfo(shape) {
    return this.infoCache.get(shape.id);
  }
  getHandles(shape) {
    const info = this.infoCache.get(shape.id);
    return [
      {
        id: "start",
        type: "vertex",
        index: "a0",
        x: info.start.handle.x,
        y: info.start.handle.y,
        canBind: true
      },
      {
        id: "middle",
        type: "vertex",
        index: "a2",
        x: info.middle.x,
        y: info.middle.y,
        canBind: false
      },
      {
        id: "end",
        type: "vertex",
        index: "a3",
        x: info.end.handle.x,
        y: info.end.handle.y,
        canBind: true
      }
    ];
  }
  onHandleChange = (shape, { handle, isPrecise: isPrecise2 }) => {
    const next = deepCopy(shape);
    switch (handle.id) {
      case "start":
      case "end": {
        const pageTransform = this.editor.getPageTransformById(next.id);
        const pointInPageSpace = Matrix2d.applyToPoint(pageTransform, handle);
        if (this.editor.inputs.ctrlKey) {
          next.props[handle.id] = {
            type: "point",
            x: handle.x,
            y: handle.y
          };
        } else {
          const target = last(
            this.editor.sortedShapesArray.filter((hitShape) => {
              if (hitShape.id === shape.id) {
                return;
              }
              const util = this.editor.getShapeUtil(hitShape);
              if (!util.canBind(hitShape)) {
                return;
              }
              const pageMask = this.editor.getPageMaskById(hitShape.id);
              if (pageMask) {
                if (!pointInPolygon(pointInPageSpace, pageMask))
                  return;
              }
              const pointInTargetSpace = this.editor.getPointInShapeSpace(
                hitShape,
                pointInPageSpace
              );
              if (util.isClosed(hitShape)) {
                return pointInPolygon(pointInTargetSpace, util.outline(hitShape));
              }
              return util.hitTestPoint(hitShape, pointInTargetSpace);
            })
          );
          if (target) {
            const targetBounds = this.editor.getBounds(target);
            const pointInTargetSpace = this.editor.getPointInShapeSpace(target, pointInPageSpace);
            const prevHandle = next.props[handle.id];
            const startBindingId = shape.props.start.type === "binding" && shape.props.start.boundShapeId;
            const endBindingId = shape.props.end.type === "binding" && shape.props.end.boundShapeId;
            let precise = (
              // If externally precise, then always precise
              (// If the other shape is not closed, then precise
              isPrecise2 || // If the other handle is bound to the same shape, then precise
              (startBindingId || endBindingId) && startBindingId === endBindingId || !this.editor.getShapeUtil(target).isClosed(next))
            );
            if (
              // If we're switching to a new bound shape, then precise only if moving slowly
              prevHandle.type === "point" || prevHandle.type === "binding" && target.id !== prevHandle.boundShapeId
            ) {
              precise = this.editor.inputs.pointerVelocity.len() < 0.5;
            }
            if (precise) {
              precise = Vec2d.Dist(pointInTargetSpace, targetBounds.center) > Math.max(
                4,
                Math.min(Math.min(targetBounds.width, targetBounds.height) * 0.15, 16)
              ) / this.editor.zoomLevel;
            }
            next.props[handle.id] = {
              type: "binding",
              boundShapeId: target.id,
              normalizedAnchor: precise ? {
                x: (pointInTargetSpace.x - targetBounds.minX) / targetBounds.width,
                y: (pointInTargetSpace.y - targetBounds.minY) / targetBounds.height
              } : { x: 0.5, y: 0.5 },
              isExact: this.editor.inputs.altKey
            };
          } else {
            next.props[handle.id] = {
              type: "point",
              x: handle.x,
              y: handle.y
            };
          }
        }
        break;
      }
      case "middle": {
        const { start, end } = getArrowTerminalsInArrowSpace(this.editor, next);
        const delta = Vec2d.Sub(end, start);
        const v = Vec2d.Per(delta);
        const med = Vec2d.Med(end, start);
        const A = Vec2d.Sub(med, v);
        const B = Vec2d.Add(med, v);
        const point = Vec2d.NearestPointOnLineSegment(A, B, handle, false);
        let bend = Vec2d.Dist(point, med);
        if (Vec2d.Clockwise(point, end, med))
          bend *= -1;
        next.props.bend = bend;
        break;
      }
    }
    return next;
  };
  onTranslateStart = (shape) => {
    let startBinding = shape.props.start.type === "binding" ? shape.props.start.boundShapeId : null;
    let endBinding = shape.props.end.type === "binding" ? shape.props.end.boundShapeId : null;
    if (startBinding && this.editor.isWithinSelection(startBinding) || endBinding && this.editor.isWithinSelection(endBinding)) {
      return;
    }
    startBinding = null;
    endBinding = null;
    const { start, end } = getArrowTerminalsInArrowSpace(this.editor, shape);
    return {
      id: shape.id,
      type: shape.type,
      props: {
        ...shape.props,
        start: {
          type: "point",
          x: start.x,
          y: start.y
        },
        end: {
          type: "point",
          x: end.x,
          y: end.y
        }
      }
    };
  };
  onResize = (shape, info) => {
    const { scaleX, scaleY } = info;
    const terminals = getArrowTerminalsInArrowSpace(this.editor, shape);
    const { start, end } = deepCopy(shape.props);
    let { bend } = shape.props;
    if (start.type === "point") {
      start.x = terminals.start.x * scaleX;
      start.y = terminals.start.y * scaleY;
    }
    if (end.type === "point") {
      end.x = terminals.end.x * scaleX;
      end.y = terminals.end.y * scaleY;
    }
    const mx = Math.abs(scaleX);
    const my = Math.abs(scaleY);
    if (scaleX < 0 && scaleY >= 0) {
      if (bend !== 0) {
        bend *= -1;
        bend *= Math.max(mx, my);
      }
      if (start.type === "binding") {
        start.normalizedAnchor.x = 1 - start.normalizedAnchor.x;
      }
      if (end.type === "binding") {
        end.normalizedAnchor.x = 1 - end.normalizedAnchor.x;
      }
    } else if (scaleX >= 0 && scaleY < 0) {
      if (bend !== 0) {
        bend *= -1;
        bend *= Math.max(mx, my);
      }
      if (start.type === "binding") {
        start.normalizedAnchor.y = 1 - start.normalizedAnchor.y;
      }
      if (end.type === "binding") {
        end.normalizedAnchor.y = 1 - end.normalizedAnchor.y;
      }
    } else if (scaleX >= 0 && scaleY >= 0) {
      if (bend !== 0) {
        bend *= Math.max(mx, my);
      }
    } else if (scaleX < 0 && scaleY < 0) {
      if (bend !== 0) {
        bend *= Math.max(mx, my);
      }
      if (start.type === "binding") {
        start.normalizedAnchor.x = 1 - start.normalizedAnchor.x;
        start.normalizedAnchor.y = 1 - start.normalizedAnchor.y;
      }
      if (end.type === "binding") {
        end.normalizedAnchor.x = 1 - end.normalizedAnchor.x;
        end.normalizedAnchor.y = 1 - end.normalizedAnchor.y;
      }
    }
    const next = {
      props: {
        start,
        end,
        bend
      }
    };
    return next;
  };
  onDoubleClickHandle = (shape, handle) => {
    switch (handle.id) {
      case "start": {
        return {
          id: shape.id,
          type: shape.type,
          props: {
            ...shape.props,
            arrowheadStart: shape.props.arrowheadStart === "none" ? "arrow" : "none"
          }
        };
      }
      case "end": {
        return {
          id: shape.id,
          type: shape.type,
          props: {
            ...shape.props,
            arrowheadEnd: shape.props.arrowheadEnd === "none" ? "arrow" : "none"
          }
        };
      }
    }
  };
  hitTestPoint(shape, point) {
    const outline = this.outline(shape);
    const zoomLevel = this.editor.zoomLevel;
    const offsetDist = STROKE_SIZES[shape.props.size] / zoomLevel;
    for (let i = 0; i < outline.length - 1; i++) {
      const C = outline[i];
      const D = outline[i + 1];
      if (Vec2d.DistanceToLineSegment(C, D, point) < offsetDist)
        return true;
    }
    return false;
  }
  hitTestLineSegment(shape, A, B) {
    const outline = this.outline(shape);
    for (let i = 0; i < outline.length - 1; i++) {
      const C = outline[i];
      const D = outline[i + 1];
      if (linesIntersect(A, B, C, D))
        return true;
    }
    return false;
  }
  component(shape) {
    const onlySelectedShape = this.editor.onlySelectedShape;
    const shouldDisplayHandles = this.editor.isInAny(
      "select.idle",
      "select.pointing_handle",
      "select.dragging_handle",
      "arrow.dragging"
    ) && !this.editor.isReadOnly;
    const info = this.getArrowInfo(shape);
    const bounds = this.bounds(shape);
    const labelSize = this.getLabelBounds(shape);
    const changeIndex = React.useMemo(() => {
      return this.editor.isSafari ? globalRenderIndex += 1 : 0;
    }, [shape]);
    if (!info?.isValid)
      return null;
    const strokeWidth = STROKE_SIZES[shape.props.size];
    const as = info.start.arrowhead && getArrowheadPathForType(info, "start", strokeWidth);
    const ae = info.end.arrowhead && getArrowheadPathForType(info, "end", strokeWidth);
    const path = info.isStraight ? getSolidStraightArrowPath(info) : getSolidCurvedArrowPath(info);
    let handlePath = null;
    if (onlySelectedShape === shape && shouldDisplayHandles) {
      const sw = 2;
      const { strokeDasharray: strokeDasharray2, strokeDashoffset: strokeDashoffset2 } = getPerfectDashProps(
        info.isStraight ? Vec2d.Dist(info.start.handle, info.end.handle) : Math.abs(info.handleArc.length),
        sw,
        {
          end: "skip",
          start: "skip",
          lengthRatio: 2.5
        }
      );
      handlePath = shape.props.start.type === "binding" || shape.props.end.type === "binding" ? /* @__PURE__ */ jsx(
        "path",
        {
          className: "tl-arrow-hint",
          d: info.isStraight ? getStraightArrowHandlePath(info) : getCurvedArrowHandlePath(info),
          strokeDasharray: strokeDasharray2,
          strokeDashoffset: strokeDashoffset2,
          strokeWidth: sw,
          markerStart: shape.props.start.type === "binding" ? shape.props.start.isExact ? "" : isPrecise(shape.props.start.normalizedAnchor) ? "url(#arrowhead-cross)" : "url(#arrowhead-dot)" : "",
          markerEnd: shape.props.end.type === "binding" ? shape.props.end.isExact ? "" : isPrecise(shape.props.end.normalizedAnchor) ? "url(#arrowhead-cross)" : "url(#arrowhead-dot)" : "",
          opacity: 0.16
        }
      ) : null;
    }
    const { strokeDasharray, strokeDashoffset } = getPerfectDashProps(
      info.isStraight ? info.length : Math.abs(info.bodyArc.length),
      strokeWidth,
      {
        style: shape.props.dash
      }
    );
    const maskStartArrowhead = !(info.start.arrowhead === "none" || info.start.arrowhead === "arrow");
    const maskEndArrowhead = !(info.end.arrowhead === "none" || info.end.arrowhead === "arrow");
    const includeMask = maskStartArrowhead || maskEndArrowhead || labelSize;
    const maskId = (shape.id + "_clip_" + changeIndex).replace(":", "_");
    return (
      /* @__PURE__ */ jsxs(Fragment, { children: [
        /* @__PURE__ */ jsxs(SVGContainer, { id: shape.id, style: { minWidth: 50, minHeight: 50 }, children: [
          includeMask && /* @__PURE__ */ jsx("defs", { children: /* @__PURE__ */ jsxs("mask", { id: maskId, children: [
            /* @__PURE__ */ jsx(
              "rect",
              {
                x: toDomPrecision(-100 + bounds.minX),
                y: toDomPrecision(-100 + bounds.minY),
                width: toDomPrecision(bounds.width + 200),
                height: toDomPrecision(bounds.height + 200),
                fill: "white"
              }
            ),
            labelSize && /* @__PURE__ */ jsx(
              "rect",
              {
                x: toDomPrecision(labelSize.x),
                y: toDomPrecision(labelSize.y),
                width: toDomPrecision(labelSize.w),
                height: toDomPrecision(labelSize.h),
                fill: "black",
                rx: 4,
                ry: 4
              }
            ),
            as && maskStartArrowhead && /* @__PURE__ */ jsx(
              "path",
              {
                d: as,
                fill: info.start.arrowhead === "arrow" ? "none" : "black",
                stroke: "none"
              }
            ),
            ae && maskEndArrowhead && /* @__PURE__ */ jsx(
              "path",
              {
                d: ae,
                fill: info.end.arrowhead === "arrow" ? "none" : "black",
                stroke: "none"
              }
            )
          ] }) }),
          /* @__PURE__ */ jsxs(
            "g",
            {
              fill: "none",
              stroke: `var(--palette-${shape.props.color})`,
              strokeWidth,
              strokeLinejoin: "round",
              strokeLinecap: "round",
              pointerEvents: "none",
              children: [
                handlePath,
                /* @__PURE__ */ jsxs("g", { ...(includeMask ? { mask: `url(#${maskId})` } : void 0), children: [
                  includeMask && /* @__PURE__ */ jsx(
                    "rect",
                    {
                      x: toDomPrecision(bounds.minX - 100),
                      y: toDomPrecision(bounds.minY - 100),
                      width: toDomPrecision(bounds.width + 200),
                      height: toDomPrecision(bounds.height + 200),
                      opacity: 0
                    }
                  ),
                  /* @__PURE__ */ jsx(
                    "path",
                    {
                      d: path,
                      strokeDasharray,
                      strokeDashoffset
                    }
                  )
                ] }),
                as && maskStartArrowhead && shape.props.fill !== "none" && /* @__PURE__ */ jsx(ShapeFill, { d: as, color: shape.props.color, fill: shape.props.fill }),
                ae && maskEndArrowhead && shape.props.fill !== "none" && /* @__PURE__ */ jsx(ShapeFill, { d: ae, color: shape.props.color, fill: shape.props.fill }),
                as && /* @__PURE__ */ jsx("path", { d: as }),
                ae && /* @__PURE__ */ jsx("path", { d: ae })
              ]
            }
          ),
          /* @__PURE__ */ jsx("path", { d: path, className: "tl-hitarea-stroke" })
        ] }),
        /* @__PURE__ */ jsx(
          ArrowTextLabel,
          {
            id: shape.id,
            text: shape.props.text,
            font: shape.props.font,
            size: shape.props.size,
            position: info.middle,
            width: labelSize?.w ?? 0,
            labelColor: shape.props.labelColor
          }
        )
      ] })
    );
  }
  indicator(shape) {
    const { start, end } = getArrowTerminalsInArrowSpace(this.editor, shape);
    const info = this.getArrowInfo(shape);
    const bounds = this.bounds(shape);
    const labelSize = this.getLabelBounds(shape);
    if (!info)
      return null;
    if (Vec2d.Equals(start, end))
      return null;
    const strokeWidth = STROKE_SIZES[shape.props.size];
    const as = info.start.arrowhead && getArrowheadPathForType(info, "start", strokeWidth);
    const ae = info.end.arrowhead && getArrowheadPathForType(info, "end", strokeWidth);
    const path = info.isStraight ? getSolidStraightArrowPath(info) : getSolidCurvedArrowPath(info);
    const includeMask = as && info.start.arrowhead !== "arrow" || ae && info.end.arrowhead !== "arrow" || labelSize !== null;
    const maskId = (shape.id + "_clip").replace(":", "_");
    return (
      /* @__PURE__ */ jsxs("g", { children: [
        includeMask && /* @__PURE__ */ jsx("defs", { children: /* @__PURE__ */ jsxs("mask", { id: maskId, children: [
          /* @__PURE__ */ jsx(
            "rect",
            {
              x: bounds.minX - 100,
              y: bounds.minY - 100,
              width: bounds.w + 200,
              height: bounds.h + 200,
              fill: "white"
            }
          ),
          labelSize && /* @__PURE__ */ jsx(
            "rect",
            {
              x: labelSize.x,
              y: labelSize.y,
              width: labelSize.w,
              height: labelSize.h,
              fill: "black",
              rx: 4,
              ry: 4
            }
          ),
          as && /* @__PURE__ */ jsx(
            "path",
            {
              d: as,
              fill: info.start.arrowhead === "arrow" ? "none" : "black",
              stroke: "none"
            }
          ),
          ae && /* @__PURE__ */ jsx(
            "path",
            {
              d: ae,
              fill: info.end.arrowhead === "arrow" ? "none" : "black",
              stroke: "none"
            }
          )
        ] }) }),
        /* @__PURE__ */ jsxs("g", { ...(includeMask ? { mask: `url(#${maskId})` } : void 0), children: [
          includeMask && /* @__PURE__ */ jsx(
            "rect",
            {
              x: bounds.minX - 100,
              y: bounds.minY - 100,
              width: bounds.width + 200,
              height: bounds.height + 200,
              opacity: 0
            }
          ),
          /* @__PURE__ */ jsx("path", { d: path })
        ] }),
        as && /* @__PURE__ */ jsx("path", { d: as }),
        ae && /* @__PURE__ */ jsx("path", { d: ae }),
        labelSize && /* @__PURE__ */ jsx(
          "rect",
          {
            x: labelSize.x,
            y: labelSize.y,
            width: labelSize.w,
            height: labelSize.h,
            rx: 4,
            ry: 4
          }
        )
      ] })
    );
  }
  get labelBoundsCache() {
    return this.editor.store.createComputedCache("labelBoundsCache", (shape) => {
      const info = this.getArrowInfo(shape);
      const bounds = this.bounds(shape);
      const { text, font, size } = shape.props;
      if (!info)
        return null;
      if (!text.trim())
        return null;
      const { w, h } = this.editor.textMeasure.measureText(text, {
        ...TEXT_PROPS,
        fontFamily: FONT_FAMILIES[font],
        fontSize: ARROW_LABEL_FONT_SIZES[size],
        width: "fit-content"
      });
      let width = w;
      let height = h;
      if (bounds.width > bounds.height) {
        width = Math.max(Math.min(w, 64), Math.min(bounds.width - 64, w));
        const { w: squishedWidth, h: squishedHeight } = this.editor.textMeasure.measureText(text, {
          ...TEXT_PROPS,
          fontFamily: FONT_FAMILIES[font],
          fontSize: ARROW_LABEL_FONT_SIZES[size],
          width: width + "px"
        });
        width = squishedWidth;
        height = squishedHeight;
      }
      if (width > 16 * ARROW_LABEL_FONT_SIZES[size]) {
        width = 16 * ARROW_LABEL_FONT_SIZES[size];
        const { w: squishedWidth, h: squishedHeight } = this.editor.textMeasure.measureText(text, {
          ...TEXT_PROPS,
          fontFamily: FONT_FAMILIES[font],
          fontSize: ARROW_LABEL_FONT_SIZES[size],
          width: width + "px"
        });
        width = squishedWidth;
        height = squishedHeight;
      }
      return new Box2d(
        info.middle.x - (width + 8) / 2,
        info.middle.y - (height + 8) / 2,
        width + 8,
        height + 8
      );
    });
  }
  getLabelBounds(shape) {
    return this.labelBoundsCache.get(shape.id) || null;
  }
  getEditingBounds = (shape) => {
    return this.getLabelBounds(shape) ?? new Box2d();
  };
  onEditEnd = (shape) => {
    const {
      id,
      type,
      props: { text }
    } = shape;
    if (text.trimEnd() !== shape.props.text) {
      this.editor.updateShapes([
        {
          id,
          type,
          props: {
            text: text.trimEnd()
          }
        }
      ]);
    }
  };
  toSvg(shape, font, colors) {
    const color = colors.fill[shape.props.color];
    const info = this.getArrowInfo(shape);
    const strokeWidth = STROKE_SIZES[shape.props.size];
    const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
    if (!info)
      return g;
    const as = info.start.arrowhead && getArrowheadPathForType(info, "start", strokeWidth);
    const ae = info.end.arrowhead && getArrowheadPathForType(info, "end", strokeWidth);
    const bounds = this.bounds(shape);
    const labelSize = this.getLabelBounds(shape);
    const maskId = (shape.id + "_clip").replace(":", "_");
    if (as || ae || labelSize) {
      const defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
      const mask = document.createElementNS("http://www.w3.org/2000/svg", "mask");
      mask.id = maskId;
      const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
      rect.setAttribute("x", bounds.minX - 100 + "");
      rect.setAttribute("y", bounds.minY - 100 + "");
      rect.setAttribute("width", bounds.width + 200 + "");
      rect.setAttribute("height", bounds.height + 200 + "");
      rect.setAttribute("fill", "white");
      mask.appendChild(rect);
      if (as)
        mask.appendChild(getArrowheadSvgMask(as, info.start.arrowhead));
      if (ae)
        mask.appendChild(getArrowheadSvgMask(ae, info.end.arrowhead));
      if (labelSize) {
        const labelMask = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        labelMask.setAttribute("x", labelSize.x + "");
        labelMask.setAttribute("y", labelSize.y + "");
        labelMask.setAttribute("width", labelSize.w + "");
        labelMask.setAttribute("height", labelSize.h + "");
        labelMask.setAttribute("fill", "black");
        mask.appendChild(labelMask);
      }
      defs.appendChild(mask);
      g.appendChild(defs);
    }
    const g2 = document.createElementNS("http://www.w3.org/2000/svg", "g");
    g2.setAttribute("mask", `url(#${maskId})`);
    g.appendChild(g2);
    const rect2 = document.createElementNS("http://www.w3.org/2000/svg", "rect");
    rect2.setAttribute("x", "-100");
    rect2.setAttribute("y", "-100");
    rect2.setAttribute("width", bounds.width + 200 + "");
    rect2.setAttribute("height", bounds.height + 200 + "");
    rect2.setAttribute("fill", "transparent");
    rect2.setAttribute("stroke", "none");
    g2.appendChild(rect2);
    const path = getArrowSvgPath(
      info.isStraight ? getSolidStraightArrowPath(info) : getSolidCurvedArrowPath(info),
      color,
      strokeWidth
    );
    const { strokeDasharray, strokeDashoffset } = getPerfectDashProps(
      info.isStraight ? info.length : Math.abs(info.bodyArc.length),
      strokeWidth,
      {
        style: shape.props.dash
      }
    );
    path.setAttribute("stroke-dasharray", strokeDasharray);
    path.setAttribute("stroke-dashoffset", strokeDashoffset);
    g2.appendChild(path);
    if (as) {
      g.appendChild(
        getArrowheadSvgPath(
          as,
          shape.props.color,
          strokeWidth,
          shape.props.arrowheadStart === "arrow" ? "none" : shape.props.fill,
          colors
        )
      );
    }
    if (ae) {
      g.appendChild(
        getArrowheadSvgPath(
          ae,
          shape.props.color,
          strokeWidth,
          shape.props.arrowheadEnd === "arrow" ? "none" : shape.props.fill,
          colors
        )
      );
    }
    if (labelSize) {
      const opts = {
        fontSize: ARROW_LABEL_FONT_SIZES[shape.props.size],
        lineHeight: TEXT_PROPS.lineHeight,
        fontFamily: font,
        padding: 0,
        textAlign: "middle",
        width: labelSize.w - 8,
        verticalTextAlign: "middle",
        height: labelSize.h,
        fontStyle: "normal",
        fontWeight: "normal",
        overflow: "wrap"
      };
      const textElm = createTextSvgElementFromSpans(
        this.editor,
        this.editor.textMeasure.measureTextSpans(shape.props.text, opts),
        opts
      );
      textElm.setAttribute("fill", colors.fill[shape.props.labelColor]);
      const children = Array.from(textElm.children);
      children.forEach((child) => {
        const x = parseFloat(child.getAttribute("x") || "0");
        const y = parseFloat(child.getAttribute("y") || "0");
        child.setAttribute("x", x + 4 + labelSize.x + "px");
        child.setAttribute("y", y + labelSize.y + "px");
      });
      const textBgEl = textElm.cloneNode(true);
      textBgEl.setAttribute("stroke-width", "2");
      textBgEl.setAttribute("fill", colors.background);
      textBgEl.setAttribute("stroke", colors.background);
      g.appendChild(textBgEl);
      g.appendChild(textElm);
    }
    return g;
  }
}
__decorateClass([
  computed
], ArrowShapeUtil.prototype, "infoCache", 1);
__decorateClass([
  computed
], ArrowShapeUtil.prototype, "labelBoundsCache", 1);
function getArrowheadSvgMask(d, arrowhead) {
  const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
  path.setAttribute("d", d);
  path.setAttribute("fill", arrowhead === "arrow" ? "none" : "black");
  path.setAttribute("stroke", "none");
  return path;
}
function getArrowSvgPath(d, color, strokeWidth) {
  const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
  path.setAttribute("d", d);
  path.setAttribute("fill", "none");
  path.setAttribute("stroke", color);
  path.setAttribute("stroke-width", strokeWidth + "");
  return path;
}
function getArrowheadSvgPath(d, color, strokeWidth, fill, colors) {
  const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
  path.setAttribute("d", d);
  path.setAttribute("fill", "none");
  path.setAttribute("stroke", colors.fill[color]);
  path.setAttribute("stroke-width", strokeWidth + "");
  const shapeFill = getShapeFillSvg({
    d,
    fill,
    color,
    colors
  });
  if (shapeFill) {
    const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
    g.appendChild(shapeFill);
    g.appendChild(path);
    return g;
  } else {
    return path;
  }
}
function isPrecise(normalizedAnchor) {
  return normalizedAnchor.x !== 0.5 || normalizedAnchor.y !== 0.5;
}
export {
  ArrowShapeUtil
};
//# sourceMappingURL=ArrowShapeUtil.mjs.map
