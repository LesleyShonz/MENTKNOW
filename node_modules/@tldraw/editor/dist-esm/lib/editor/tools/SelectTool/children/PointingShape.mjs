import { GroupShapeUtil } from "../../../shapes/group/GroupShapeUtil.mjs";
import { StateNode } from "../../StateNode.mjs";
class PointingShape extends StateNode {
  static id = "pointing_shape";
  eventTargetShape = {};
  selectingShape = {};
  didSelectOnEnter = false;
  onEnter = (info) => {
    this.eventTargetShape = info.shape;
    this.selectingShape = this.editor.getOutermostSelectableShape(info.shape);
    const util = this.editor.getShapeUtil(info.shape);
    if (util.onClick || this.selectingShape.id === this.editor.focusLayerId) {
      this.didSelectOnEnter = false;
      return;
    }
    const isSelected = this.editor.isWithinSelection(this.selectingShape.id);
    const isBehindSelectionBounds = this.editor.selectedIds.length > 1 && // only on 2+ selected shapes!
    this.editor.selectionBounds?.containsPoint(this.editor.inputs.currentPagePoint);
    this.didSelectOnEnter = !isSelected && this.selectingShape.id !== this.editor.focusLayerId && !isBehindSelectionBounds;
    if (this.didSelectOnEnter) {
      const { inputs, selectedIds } = this.editor;
      const parent = this.editor.getParentShape(info.shape);
      if (parent && this.editor.isShapeOfType(parent, GroupShapeUtil)) {
        this.editor.cancelDoubleClick();
      }
      if (inputs.shiftKey && !inputs.altKey) {
        if (!selectedIds.includes(this.selectingShape.id)) {
          this.editor.mark("shift selecting shape");
          this.editor.setSelectedIds([...selectedIds, this.selectingShape.id]);
        }
      } else {
        this.editor.mark("selecting shape");
        this.editor.setSelectedIds([this.selectingShape.id]);
      }
    }
  };
  onPointerUp = (info) => {
    const { shape } = info;
    if (shape) {
      const util = this.editor.getShapeUtil(shape);
      if (util.onClick) {
        const change = util.onClick?.(shape);
        if (change) {
          this.editor.updateShapes([change]);
          this.parent.transition("idle", info);
          return;
        }
      }
    }
    if (!this.didSelectOnEnter && this.selectingShape.id !== this.editor.focusLayerId) {
      this.editor.mark("selecting shape (pointer up)");
      const targetShape = this.editor.getOutermostSelectableShape(
        this.eventTargetShape,
        // if a group is selected, we want to stop before reaching that group
        // so we can drill down into the group
        (parent) => !this.editor.isSelected(parent.id)
      );
      if (this.editor.selectedIds.includes(targetShape.id)) {
        this.editor.setSelectedIds(
          this.editor.inputs.shiftKey ? this.editor.selectedIds.filter((id) => id !== this.selectingShape.id) : [this.selectingShape.id]
        );
      } else if (this.editor.inputs.shiftKey) {
        const ancestors = this.editor.getAncestors(targetShape);
        this.editor.setSelectedIds([
          ...this.editor.selectedIds.filter((id) => !ancestors.find((a) => a.id === id)),
          targetShape.id
        ]);
      } else {
        this.editor.setSelectedIds([targetShape.id]);
      }
    } else if (this.selectingShape.id === this.editor.focusLayerId) {
      if (this.editor.selectedIds.length > 0) {
        this.editor.setSelectedIds([]);
      } else {
        this.editor.popFocusLayer();
      }
    }
    this.parent.transition("idle", info);
  };
  onPointerMove = (info) => {
    if (this.editor.inputs.isDragging) {
      if (this.editor.isReadOnly)
        return;
      this.parent.transition("translating", info);
    }
  };
  onCancel = () => {
    this.cancel();
  };
  onComplete = () => {
    this.cancel();
  };
  onInterrupt = () => {
    this.cancel();
  };
  cancel() {
    this.parent.transition("idle", {});
  }
}
export {
  PointingShape
};
//# sourceMappingURL=PointingShape.mjs.map
