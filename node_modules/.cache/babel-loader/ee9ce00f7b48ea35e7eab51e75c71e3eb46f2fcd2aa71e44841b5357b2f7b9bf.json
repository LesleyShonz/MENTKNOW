{"ast":null,"code":"import _slicedToArray from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _createForOfIteratorHelper from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _objectSpread from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _classCallCheck from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _inherits from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _defineProperty from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport { Fragment, jsx, jsxs } from \"react/jsx-runtime\";\nimport { Box2d, getPolygonVertices, getRoundedInkyPolygonPath, getRoundedPolygonPoints, linesIntersect, PI, PI2, pointInPolygon, TAU, Vec2d } from \"@tldraw/primitives\";\nimport { SVGContainer } from \"../../../components/SVGContainer.mjs\";\nimport { BaseBoxShapeUtil } from \"../BaseBoxShapeUtil.mjs\";\nimport { FONT_FAMILIES, LABEL_FONT_SIZES, STROKE_SIZES, TEXT_PROPS } from \"../shared/default-shape-constants.mjs\";\nimport { getTextLabelSvgElement } from \"../shared/getTextLabelSvgElement.mjs\";\nimport { HyperlinkButton } from \"../shared/HyperlinkButton.mjs\";\nimport { TextLabel } from \"../shared/TextLabel.mjs\";\nimport { useForceSolid } from \"../shared/useForceSolid.mjs\";\nimport { DashStyleEllipse, DashStyleEllipseSvg } from \"./components/DashStyleEllipse.mjs\";\nimport { DashStyleOval, DashStyleOvalSvg } from \"./components/DashStyleOval.mjs\";\nimport { DashStylePolygon, DashStylePolygonSvg } from \"./components/DashStylePolygon.mjs\";\nimport { DrawStyleEllipseSvg, getEllipseIndicatorPath } from \"./components/DrawStyleEllipse.mjs\";\nimport { DrawStylePolygon, DrawStylePolygonSvg } from \"./components/DrawStylePolygon.mjs\";\nimport { SolidStyleEllipse, SolidStyleEllipseSvg } from \"./components/SolidStyleEllipse.mjs\";\nimport { getOvalIndicatorPath, SolidStyleOval, SolidStyleOvalSvg } from \"./components/SolidStyleOval.mjs\";\nimport { SolidStylePolygon, SolidStylePolygonSvg } from \"./components/SolidStylePolygon.mjs\";\nvar LABEL_PADDING = 16;\nvar MIN_SIZE_WITH_LABEL = 17 * 3;\nvar GeoShapeUtil = /*#__PURE__*/function (_BaseBoxShapeUtil) {\n  _inherits(GeoShapeUtil, _BaseBoxShapeUtil);\n  var _super = _createSuper(GeoShapeUtil);\n  function GeoShapeUtil() {\n    var _this;\n    _classCallCheck(this, GeoShapeUtil);\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    _this = _super.call.apply(_super, [this].concat(args));\n    _defineProperty(_assertThisInitialized(_this), \"canEdit\", function () {\n      return true;\n    });\n    _defineProperty(_assertThisInitialized(_this), \"onEditEnd\", function (shape) {\n      var id = shape.id,\n        type = shape.type,\n        text = shape.props.text;\n      if (text.trimEnd() !== shape.props.text) {\n        _this.editor.updateShapes([{\n          id: id,\n          type: type,\n          props: {\n            text: text.trimEnd()\n          }\n        }]);\n      }\n    });\n    _defineProperty(_assertThisInitialized(_this), \"onResize\", function (shape, _ref) {\n      var initialBounds = _ref.initialBounds,\n        handle = _ref.handle,\n        newPoint = _ref.newPoint,\n        scaleX = _ref.scaleX,\n        scaleY = _ref.scaleY;\n      var w = initialBounds.width * scaleX;\n      var h = initialBounds.height * scaleY;\n      var overShrinkX = 0;\n      var overShrinkY = 0;\n      if (shape.props.text.trim()) {\n        var newW = Math.max(Math.abs(w), MIN_SIZE_WITH_LABEL);\n        var newH = Math.max(Math.abs(h), MIN_SIZE_WITH_LABEL);\n        if (newW < MIN_SIZE_WITH_LABEL && newH === MIN_SIZE_WITH_LABEL) {\n          newW = MIN_SIZE_WITH_LABEL;\n        }\n        if (newW === MIN_SIZE_WITH_LABEL && newH < MIN_SIZE_WITH_LABEL) {\n          newH = MIN_SIZE_WITH_LABEL;\n        }\n        var labelSize = getLabelSize(_this.editor, _objectSpread(_objectSpread({}, shape), {}, {\n          props: _objectSpread(_objectSpread({}, shape.props), {}, {\n            w: newW,\n            h: newH\n          })\n        }));\n        var nextW = Math.max(Math.abs(w), labelSize.w) * Math.sign(w);\n        var nextH = Math.max(Math.abs(h), labelSize.h) * Math.sign(h);\n        overShrinkX = Math.abs(nextW) - Math.abs(w);\n        overShrinkY = Math.abs(nextH) - Math.abs(h);\n        w = nextW;\n        h = nextH;\n      }\n      var offset = new Vec2d(0, 0);\n      if (scaleX < 0) {\n        offset.x += w;\n      }\n      if (handle === \"left\" || handle === \"top_left\" || handle === \"bottom_left\") {\n        offset.x += scaleX < 0 ? overShrinkX : -overShrinkX;\n      }\n      if (scaleY < 0) {\n        offset.y += h;\n      }\n      if (handle === \"top\" || handle === \"top_left\" || handle === \"top_right\") {\n        offset.y += scaleY < 0 ? overShrinkY : -overShrinkY;\n      }\n      var _offset$rot$add = offset.rot(shape.rotation).add(newPoint),\n        x = _offset$rot$add.x,\n        y = _offset$rot$add.y;\n      return {\n        x: x,\n        y: y,\n        props: {\n          w: Math.max(Math.abs(w), 1),\n          h: Math.max(Math.abs(h), 1),\n          growY: 0\n        }\n      };\n    });\n    _defineProperty(_assertThisInitialized(_this), \"onBeforeCreate\", function (shape) {\n      if (!shape.props.text) {\n        if (shape.props.growY) {\n          return _objectSpread(_objectSpread({}, shape), {}, {\n            props: _objectSpread(_objectSpread({}, shape.props), {}, {\n              growY: 0\n            })\n          });\n        } else {\n          return;\n        }\n      }\n      var prevHeight = shape.props.h;\n      var nextHeight = getLabelSize(_this.editor, shape).h;\n      var growY = null;\n      if (nextHeight > prevHeight) {\n        growY = nextHeight - prevHeight;\n      } else {\n        if (shape.props.growY) {\n          growY = 0;\n        }\n      }\n      if (growY !== null) {\n        return _objectSpread(_objectSpread({}, shape), {}, {\n          props: _objectSpread(_objectSpread({}, shape.props), {}, {\n            growY: growY\n          })\n        });\n      }\n    });\n    _defineProperty(_assertThisInitialized(_this), \"onBeforeUpdate\", function (prev, next) {\n      var prevText = prev.props.text.trimEnd();\n      var nextText = next.props.text.trimEnd();\n      if (prevText === nextText && prev.props.font === next.props.font && prev.props.size === next.props.size) {\n        return;\n      }\n      if (prevText && !nextText) {\n        return _objectSpread(_objectSpread({}, next), {}, {\n          props: _objectSpread(_objectSpread({}, next.props), {}, {\n            growY: 0\n          })\n        });\n      }\n      var prevWidth = prev.props.w;\n      var prevHeight = prev.props.h;\n      var nextSize = getLabelSize(_this.editor, next);\n      var nextWidth = nextSize.w;\n      var nextHeight = nextSize.h;\n      if (!prevText && nextText && nextText.length === 1) {\n        var w = Math.max(prevWidth, nextWidth);\n        var h = Math.max(prevHeight, nextHeight);\n        if (prev.props.w < MIN_SIZE_WITH_LABEL && prev.props.h < MIN_SIZE_WITH_LABEL) {\n          w = Math.max(w, MIN_SIZE_WITH_LABEL);\n          h = Math.max(h, MIN_SIZE_WITH_LABEL);\n          w = Math.max(w, h);\n          h = Math.max(w, h);\n        }\n        return _objectSpread(_objectSpread({}, next), {}, {\n          props: _objectSpread(_objectSpread({}, next.props), {}, {\n            w: w,\n            h: h,\n            growY: 0\n          })\n        });\n      }\n      var growY = null;\n      if (nextHeight > prevHeight) {\n        growY = nextHeight - prevHeight;\n      } else {\n        if (prev.props.growY) {\n          growY = 0;\n        }\n      }\n      if (growY !== null) {\n        return _objectSpread(_objectSpread({}, next), {}, {\n          props: _objectSpread(_objectSpread({}, next.props), {}, {\n            growY: growY,\n            w: Math.max(next.props.w, nextWidth)\n          })\n        });\n      }\n      if (nextWidth > prev.props.w) {\n        return _objectSpread(_objectSpread({}, next), {}, {\n          props: _objectSpread(_objectSpread({}, next.props), {}, {\n            w: nextWidth\n          })\n        });\n      }\n    });\n    _defineProperty(_assertThisInitialized(_this), \"onDoubleClick\", function (shape) {\n      if (_this.editor.inputs.altKey) {\n        switch (shape.props.geo) {\n          case \"rectangle\":\n            {\n              return _objectSpread(_objectSpread({}, shape), {}, {\n                props: {\n                  geo: \"check-box\"\n                }\n              });\n            }\n          case \"check-box\":\n            {\n              return _objectSpread(_objectSpread({}, shape), {}, {\n                props: {\n                  geo: \"rectangle\"\n                }\n              });\n            }\n        }\n      }\n      return;\n    });\n    return _this;\n  }\n  _createClass(GeoShapeUtil, [{\n    key: \"defaultProps\",\n    value: function defaultProps() {\n      return {\n        w: 100,\n        h: 100,\n        geo: \"rectangle\",\n        color: \"black\",\n        labelColor: \"black\",\n        fill: \"none\",\n        dash: \"draw\",\n        size: \"m\",\n        font: \"draw\",\n        text: \"\",\n        align: \"middle\",\n        verticalAlign: \"middle\",\n        growY: 0,\n        url: \"\"\n      };\n    }\n  }, {\n    key: \"hitTestLineSegment\",\n    value: function hitTestLineSegment(shape, A, B) {\n      var outline = this.outline(shape);\n      for (var i = 0; i < outline.length; i++) {\n        var C = outline[i];\n        var D = outline[(i + 1) % outline.length];\n        if (linesIntersect(A, B, C, D)) return true;\n      }\n      var lines = getLines(shape.props, 0);\n      if (lines !== void 0) {\n        var _iterator = _createForOfIteratorHelper(lines),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var _step$value = _slicedToArray(_step.value, 2),\n              _C = _step$value[0],\n              _D = _step$value[1];\n            if (linesIntersect(A, B, _C, _D)) return true;\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      }\n      return false;\n    }\n  }, {\n    key: \"hitTestPoint\",\n    value: function hitTestPoint(shape, point) {\n      var outline = this.outline(shape);\n      if (shape.props.fill === \"none\") {\n        var zoomLevel = this.editor.zoomLevel;\n        var offsetDist = STROKE_SIZES[shape.props.size] / zoomLevel;\n        for (var i = 0; i < outline.length; i++) {\n          var C = outline[i];\n          var D = outline[(i + 1) % outline.length];\n          if (Vec2d.DistanceToLineSegment(C, D, point) < offsetDist) return true;\n        }\n        var lines = getLines(shape.props, 1);\n        if (lines !== void 0) {\n          var _iterator2 = _createForOfIteratorHelper(lines),\n            _step2;\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var _step2$value = _slicedToArray(_step2.value, 2),\n                _C2 = _step2$value[0],\n                _D2 = _step2$value[1];\n              if (Vec2d.DistanceToLineSegment(_C2, _D2, point) < offsetDist) return true;\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n        }\n        return false;\n      }\n      return pointInPolygon(point, outline);\n    }\n  }, {\n    key: \"getBounds\",\n    value: function getBounds(shape) {\n      return new Box2d(0, 0, shape.props.w, shape.props.h + shape.props.growY);\n    }\n  }, {\n    key: \"getCenter\",\n    value: function getCenter(shape) {\n      return new Vec2d(shape.props.w / 2, (shape.props.h + shape.props.growY) / 2);\n    }\n  }, {\n    key: \"getOutline\",\n    value: function getOutline(shape) {\n      var w = Math.max(1, shape.props.w);\n      var h = Math.max(1, shape.props.h + shape.props.growY);\n      var cx = w / 2;\n      var cy = h / 2;\n      switch (shape.props.geo) {\n        case \"triangle\":\n          {\n            return [new Vec2d(cx, 0), new Vec2d(w, h), new Vec2d(0, h)];\n          }\n        case \"diamond\":\n          {\n            return [new Vec2d(cx, 0), new Vec2d(w, cy), new Vec2d(cx, h), new Vec2d(0, cy)];\n          }\n        case \"pentagon\":\n          {\n            return getPolygonVertices(w, h, 5);\n          }\n        case \"hexagon\":\n          {\n            return getPolygonVertices(w, h, 6);\n          }\n        case \"octagon\":\n          {\n            return getPolygonVertices(w, h, 8);\n          }\n        case \"ellipse\":\n          {\n            var q = Math.pow(cx - cy, 2) / Math.pow(cx + cy, 2);\n            var p = PI * (cx + cy) * (1 + 3 * q / (10 + Math.sqrt(4 - 3 * q)));\n            var len = Math.max(4, Math.ceil(p / 10));\n            len = Math.ceil(len / 4) * 4;\n            var step = PI2 / len;\n            var a = Math.cos(step);\n            var b = Math.sin(step);\n            var sin = 0;\n            var cos = 1;\n            var ts = 0;\n            var tc = 1;\n            var points = Array(len);\n            for (var i = 0; i < len; i++) {\n              points[i] = new Vec2d(cx + cx * cos, cy + cy * sin);\n              ts = b * cos + a * sin;\n              tc = a * cos - b * sin;\n              sin = ts;\n              cos = tc;\n            }\n            return points;\n          }\n        case \"oval\":\n          {\n            var _len2 = 10;\n            var _points = Array(_len2 * 2);\n            if (h > w) {\n              for (var _i = 0; _i < _len2; _i++) {\n                var t1 = -PI + PI * _i / (_len2 - 2);\n                var t2 = PI * _i / (_len2 - 2);\n                _points[_i] = new Vec2d(cx + cx * Math.cos(t1), cx + cx * Math.sin(t1));\n                _points[_i + _len2] = new Vec2d(cx + cx * Math.cos(t2), h - cx + cx * Math.sin(t2));\n              }\n            } else {\n              for (var _i2 = 0; _i2 < _len2; _i2++) {\n                var _t = -TAU + PI * _i2 / (_len2 - 2);\n                var _t2 = TAU + PI * -_i2 / (_len2 - 2);\n                _points[_i2] = new Vec2d(w - cy + cy * Math.cos(_t), h - cy + cy * Math.sin(_t));\n                _points[_i2 + _len2] = new Vec2d(cy - cy * Math.cos(_t2), h - cy + cy * Math.sin(_t2));\n              }\n            }\n            return _points;\n          }\n        case \"star\":\n          {\n            var sides = 5;\n            var _step3 = PI2 / sides / 2;\n            var rightMostIndex = Math.floor(sides / 4) * 2;\n            var leftMostIndex = sides * 2 - rightMostIndex;\n            var topMostIndex = 0;\n            var bottomMostIndex = Math.floor(sides / 2) * 2;\n            var maxX = Math.cos(-TAU + rightMostIndex * _step3) * w / 2;\n            var minX = Math.cos(-TAU + leftMostIndex * _step3) * w / 2;\n            var minY = Math.sin(-TAU + topMostIndex * _step3) * h / 2;\n            var maxY = Math.sin(-TAU + bottomMostIndex * _step3) * h / 2;\n            var diffX = w - Math.abs(maxX - minX);\n            var diffY = h - Math.abs(maxY - minY);\n            var offsetX = w / 2 + minX - (w / 2 - maxX);\n            var offsetY = h / 2 + minY - (h / 2 - maxY);\n            var ratio = 1;\n            var cx2 = (w - offsetX) / 2;\n            var cy2 = (h - offsetY) / 2;\n            var ox = (w + diffX) / 2;\n            var oy = (h + diffY) / 2;\n            var ix = ox * ratio / 2;\n            var iy = oy * ratio / 2;\n            return Array.from(Array(sides * 2)).map(function (_, i) {\n              var theta = -TAU + i * _step3;\n              return new Vec2d(cx2 + (i % 2 ? ix : ox) * Math.cos(theta), cy2 + (i % 2 ? iy : oy) * Math.sin(theta));\n            });\n          }\n        case \"rhombus\":\n          {\n            var offset = Math.min(w * 0.38, h * 0.38);\n            return [new Vec2d(offset, 0), new Vec2d(w, 0), new Vec2d(w - offset, h), new Vec2d(0, h)];\n          }\n        case \"rhombus-2\":\n          {\n            var _offset = Math.min(w * 0.38, h * 0.38);\n            return [new Vec2d(0, 0), new Vec2d(w - _offset, 0), new Vec2d(w, h), new Vec2d(_offset, h)];\n          }\n        case \"trapezoid\":\n          {\n            var _offset2 = Math.min(w * 0.38, h * 0.38);\n            return [new Vec2d(_offset2, 0), new Vec2d(w - _offset2, 0), new Vec2d(w, h), new Vec2d(0, h)];\n          }\n        case \"arrow-right\":\n          {\n            var _ox = Math.min(w, h) * 0.38;\n            var _oy = h * 0.16;\n            return [new Vec2d(0, _oy), new Vec2d(w - _ox, _oy), new Vec2d(w - _ox, 0), new Vec2d(w, h / 2), new Vec2d(w - _ox, h), new Vec2d(w - _ox, h - _oy), new Vec2d(0, h - _oy)];\n          }\n        case \"arrow-left\":\n          {\n            var _ox2 = Math.min(w, h) * 0.38;\n            var _oy2 = h * 0.16;\n            return [new Vec2d(_ox2, 0), new Vec2d(_ox2, _oy2), new Vec2d(w, _oy2), new Vec2d(w, h - _oy2), new Vec2d(_ox2, h - _oy2), new Vec2d(_ox2, h), new Vec2d(0, h / 2)];\n          }\n        case \"arrow-up\":\n          {\n            var _ox3 = w * 0.16;\n            var _oy3 = Math.min(w, h) * 0.38;\n            return [new Vec2d(w / 2, 0), new Vec2d(w, _oy3), new Vec2d(w - _ox3, _oy3), new Vec2d(w - _ox3, h), new Vec2d(_ox3, h), new Vec2d(_ox3, _oy3), new Vec2d(0, _oy3)];\n          }\n        case \"arrow-down\":\n          {\n            var _ox4 = w * 0.16;\n            var _oy4 = Math.min(w, h) * 0.38;\n            return [new Vec2d(_ox4, 0), new Vec2d(w - _ox4, 0), new Vec2d(w - _ox4, h - _oy4), new Vec2d(w, h - _oy4), new Vec2d(w / 2, h), new Vec2d(0, h - _oy4), new Vec2d(_ox4, h - _oy4)];\n          }\n        case \"check-box\":\n        case \"x-box\":\n        case \"rectangle\":\n          {\n            return [new Vec2d(0, 0), new Vec2d(w, 0), new Vec2d(w, h), new Vec2d(0, h)];\n          }\n      }\n    }\n  }, {\n    key: \"component\",\n    value: function component(shape) {\n      var _this2 = this;\n      var id = shape.id,\n        type = shape.type,\n        props = shape.props;\n      var forceSolid = useForceSolid();\n      var strokeWidth = STROKE_SIZES[props.size];\n      var w = props.w,\n        color = props.color,\n        labelColor = props.labelColor,\n        fill = props.fill,\n        dash = props.dash,\n        growY = props.growY,\n        font = props.font,\n        align = props.align,\n        verticalAlign = props.verticalAlign,\n        size = props.size,\n        text = props.text;\n      var getShape = function getShape() {\n        var h = props.h + growY;\n        switch (props.geo) {\n          case \"ellipse\":\n            {\n              if (dash === \"solid\" || dash === \"draw\" && forceSolid) {\n                return /* @__PURE__ */jsx(SolidStyleEllipse, {\n                  strokeWidth: strokeWidth,\n                  w: w,\n                  h: h,\n                  color: color,\n                  fill: fill\n                });\n              } else if (dash === \"dashed\" || dash === \"dotted\") {\n                return /* @__PURE__ */jsx(DashStyleEllipse, {\n                  id: id,\n                  strokeWidth: strokeWidth,\n                  w: w,\n                  h: h,\n                  dash: dash === \"dashed\" ? dash : size === \"s\" && forceSolid ? \"dashed\" : dash,\n                  color: color,\n                  fill: fill\n                });\n              } else if (dash === \"draw\") {\n                return /* @__PURE__ */jsx(SolidStyleEllipse, {\n                  strokeWidth: strokeWidth,\n                  w: w,\n                  h: h,\n                  color: color,\n                  fill: fill\n                });\n              }\n              break;\n            }\n          case \"oval\":\n            {\n              if (dash === \"solid\" || dash === \"draw\" && forceSolid) {\n                return /* @__PURE__ */jsx(SolidStyleOval, {\n                  strokeWidth: strokeWidth,\n                  w: w,\n                  h: h,\n                  color: color,\n                  fill: fill\n                });\n              } else if (dash === \"dashed\" || dash === \"dotted\") {\n                return /* @__PURE__ */jsx(DashStyleOval, {\n                  id: id,\n                  strokeWidth: strokeWidth,\n                  w: w,\n                  h: h,\n                  dash: dash === \"dashed\" ? dash : size === \"s\" && forceSolid ? \"dashed\" : dash,\n                  color: color,\n                  fill: fill\n                });\n              } else if (dash === \"draw\") {\n                return /* @__PURE__ */jsx(SolidStyleOval, {\n                  strokeWidth: strokeWidth,\n                  w: w,\n                  h: h,\n                  color: color,\n                  fill: fill\n                });\n              }\n              break;\n            }\n          default:\n            {\n              var outline = _this2.outline(shape);\n              var lines = getLines(shape.props, strokeWidth);\n              if (dash === \"solid\" || dash === \"draw\" && forceSolid) {\n                return /* @__PURE__ */jsx(SolidStylePolygon, {\n                  fill: fill,\n                  color: color,\n                  strokeWidth: strokeWidth,\n                  outline: outline,\n                  lines: lines\n                });\n              } else if (dash === \"dashed\" || dash === \"dotted\") {\n                return /* @__PURE__ */jsx(DashStylePolygon, {\n                  dash: dash === \"dashed\" ? dash : size === \"s\" && forceSolid ? \"dashed\" : dash,\n                  fill: fill,\n                  color: color,\n                  strokeWidth: strokeWidth,\n                  outline: outline,\n                  lines: lines\n                });\n              } else if (dash === \"draw\") {\n                return /* @__PURE__ */jsx(DrawStylePolygon, {\n                  id: id,\n                  fill: fill,\n                  color: color,\n                  strokeWidth: strokeWidth,\n                  outline: outline,\n                  lines: lines\n                });\n              }\n            }\n        }\n      };\n      return /* @__PURE__ */jsxs(Fragment, {\n        children: [/* @__PURE__ */jsx(SVGContainer, {\n          id: id,\n          children: getShape()\n        }), /* @__PURE__ */jsx(TextLabel, {\n          id: id,\n          type: type,\n          font: font,\n          fill: fill,\n          size: size,\n          align: align,\n          verticalAlign: verticalAlign,\n          text: text,\n          labelColor: labelColor,\n          wrap: true\n        }), shape.props.url && /* @__PURE__ */jsx(HyperlinkButton, {\n          url: shape.props.url,\n          zoomLevel: this.editor.zoomLevel\n        })]\n      });\n    }\n  }, {\n    key: \"indicator\",\n    value: function indicator(shape) {\n      var id = shape.id,\n        props = shape.props;\n      var w = props.w,\n        h = props.h,\n        growY = props.growY,\n        size = props.size;\n      var forceSolid = useForceSolid();\n      var strokeWidth = STROKE_SIZES[size];\n      switch (props.geo) {\n        case \"ellipse\":\n          {\n            if (props.dash === \"draw\" && !forceSolid) {\n              return /* @__PURE__ */jsx(\"path\", {\n                d: getEllipseIndicatorPath(id, w, h + growY, strokeWidth)\n              });\n            }\n            return /* @__PURE__ */jsx(\"ellipse\", {\n              cx: w / 2,\n              cy: (h + growY) / 2,\n              rx: w / 2,\n              ry: (h + growY) / 2\n            });\n          }\n        case \"oval\":\n          {\n            return /* @__PURE__ */jsx(\"path\", {\n              d: getOvalIndicatorPath(w, h + growY)\n            });\n          }\n        default:\n          {\n            var outline = this.outline(shape);\n            var path;\n            if (props.dash === \"draw\" && !forceSolid) {\n              var polygonPoints = getRoundedPolygonPoints(id, outline, 0, strokeWidth * 2, 1);\n              path = getRoundedInkyPolygonPath(polygonPoints);\n            } else {\n              path = \"M\" + outline[0] + \"L\" + outline.slice(1) + \"Z\";\n            }\n            var lines = getLines(shape.props, strokeWidth);\n            if (lines) {\n              var _iterator3 = _createForOfIteratorHelper(lines),\n                _step4;\n              try {\n                for (_iterator3.s(); !(_step4 = _iterator3.n()).done;) {\n                  var _step4$value = _slicedToArray(_step4.value, 2),\n                    A = _step4$value[0],\n                    B = _step4$value[1];\n                  path += \"M\".concat(A.x, \",\").concat(A.y, \"L\").concat(B.x, \",\").concat(B.y);\n                }\n              } catch (err) {\n                _iterator3.e(err);\n              } finally {\n                _iterator3.f();\n              }\n            }\n            return /* @__PURE__ */jsx(\"path\", {\n              d: path\n            });\n          }\n      }\n    }\n  }, {\n    key: \"toSvg\",\n    value: function toSvg(shape, font, colors) {\n      var id = shape.id,\n        props = shape.props;\n      var strokeWidth = STROKE_SIZES[props.size];\n      var svgElm;\n      switch (props.geo) {\n        case \"ellipse\":\n          {\n            switch (props.dash) {\n              case \"draw\":\n                svgElm = DrawStyleEllipseSvg({\n                  id: id,\n                  w: props.w,\n                  h: props.h,\n                  color: props.color,\n                  fill: props.fill,\n                  strokeWidth: strokeWidth,\n                  colors: colors\n                });\n                break;\n              case \"solid\":\n                svgElm = SolidStyleEllipseSvg({\n                  strokeWidth: strokeWidth,\n                  w: props.w,\n                  h: props.h,\n                  color: props.color,\n                  fill: props.fill,\n                  colors: colors\n                });\n                break;\n              default:\n                svgElm = DashStyleEllipseSvg({\n                  id: id,\n                  strokeWidth: strokeWidth,\n                  w: props.w,\n                  h: props.h,\n                  dash: props.dash,\n                  color: props.color,\n                  fill: props.fill,\n                  colors: colors\n                });\n                break;\n            }\n            break;\n          }\n        case \"oval\":\n          {\n            switch (props.dash) {\n              case \"draw\":\n                svgElm = DashStyleOvalSvg({\n                  id: id,\n                  strokeWidth: strokeWidth,\n                  w: props.w,\n                  h: props.h,\n                  dash: props.dash,\n                  color: props.color,\n                  fill: props.fill,\n                  colors: colors\n                });\n                break;\n              case \"solid\":\n                svgElm = SolidStyleOvalSvg({\n                  strokeWidth: strokeWidth,\n                  w: props.w,\n                  h: props.h,\n                  color: props.color,\n                  fill: props.fill,\n                  colors: colors\n                });\n                break;\n              default:\n                svgElm = DashStyleOvalSvg({\n                  id: id,\n                  strokeWidth: strokeWidth,\n                  w: props.w,\n                  h: props.h,\n                  dash: props.dash,\n                  color: props.color,\n                  fill: props.fill,\n                  colors: colors\n                });\n            }\n            break;\n          }\n        default:\n          {\n            var outline = this.outline(shape);\n            var lines = getLines(shape.props, strokeWidth);\n            switch (props.dash) {\n              case \"draw\":\n                svgElm = DrawStylePolygonSvg({\n                  id: id,\n                  fill: props.fill,\n                  color: props.color,\n                  strokeWidth: strokeWidth,\n                  outline: outline,\n                  lines: lines,\n                  colors: colors\n                });\n                break;\n              case \"solid\":\n                svgElm = SolidStylePolygonSvg({\n                  fill: props.fill,\n                  color: props.color,\n                  strokeWidth: strokeWidth,\n                  outline: outline,\n                  lines: lines,\n                  colors: colors\n                });\n                break;\n              default:\n                svgElm = DashStylePolygonSvg({\n                  dash: props.dash,\n                  fill: props.fill,\n                  color: props.color,\n                  strokeWidth: strokeWidth,\n                  outline: outline,\n                  lines: lines,\n                  colors: colors\n                });\n                break;\n            }\n            break;\n          }\n      }\n      if (props.text) {\n        var bounds = this.bounds(shape);\n        var rootTextElm = getTextLabelSvgElement({\n          editor: this.editor,\n          shape: shape,\n          font: font,\n          bounds: bounds\n        });\n        var textElm = rootTextElm.cloneNode(true);\n        textElm.setAttribute(\"fill\", colors.fill[shape.props.labelColor]);\n        textElm.setAttribute(\"stroke\", \"none\");\n        var textBgEl = rootTextElm.cloneNode(true);\n        textBgEl.setAttribute(\"stroke-width\", \"2\");\n        textBgEl.setAttribute(\"fill\", colors.background);\n        textBgEl.setAttribute(\"stroke\", colors.background);\n        var groupEl = document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\");\n        groupEl.append(textBgEl);\n        groupEl.append(textElm);\n        if (svgElm.nodeName === \"g\") {\n          svgElm.appendChild(groupEl);\n          return svgElm;\n        } else {\n          var g = document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\");\n          g.appendChild(svgElm);\n          g.appendChild(groupEl);\n          return g;\n        }\n      }\n      return svgElm;\n    }\n  }]);\n  return GeoShapeUtil;\n}(BaseBoxShapeUtil);\n_defineProperty(GeoShapeUtil, \"type\", \"geo\");\nfunction getLabelSize(editor, shape) {\n  var text = shape.props.text.trimEnd();\n  if (!text) {\n    return {\n      w: 0,\n      h: 0\n    };\n  }\n  var minSize = editor.textMeasure.measureText(\"w\", _objectSpread(_objectSpread({}, TEXT_PROPS), {}, {\n    fontFamily: FONT_FAMILIES[shape.props.font],\n    fontSize: LABEL_FONT_SIZES[shape.props.size],\n    width: \"fit-content\",\n    maxWidth: \"100px\"\n  }));\n  var sizes = {\n    s: 2,\n    m: 3.5,\n    l: 5,\n    xl: 10\n  };\n  var size = editor.textMeasure.measureText(text, _objectSpread(_objectSpread({}, TEXT_PROPS), {}, {\n    fontFamily: FONT_FAMILIES[shape.props.font],\n    fontSize: LABEL_FONT_SIZES[shape.props.size],\n    width: \"fit-content\",\n    minWidth: minSize.w + \"px\",\n    maxWidth: Math.max(\n    // Guard because a DOM nodes can't be less 0\n    0,\n    // A 'w' width that we're setting as the min-width\n    Math.ceil(minSize.w + sizes[shape.props.size]),\n    // The actual text size\n    Math.ceil(shape.props.w - LABEL_PADDING * 2)) + \"px\"\n  }));\n  return {\n    w: size.w + LABEL_PADDING * 2,\n    h: size.h + LABEL_PADDING * 2\n  };\n}\nfunction getLines(props, sw) {\n  switch (props.geo) {\n    case \"x-box\":\n      {\n        return getXBoxLines(props.w, props.h, sw, props.dash);\n      }\n    case \"check-box\":\n      {\n        return getCheckBoxLines(props.w, props.h);\n      }\n    default:\n      {\n        return void 0;\n      }\n  }\n}\nfunction getXBoxLines(w, h, sw, dash) {\n  var inset = dash === \"draw\" ? 0.62 : 0;\n  if (dash === \"dashed\") {\n    return [[new Vec2d(0, 0), new Vec2d(w / 2, h / 2)], [new Vec2d(w, h), new Vec2d(w / 2, h / 2)], [new Vec2d(0, h), new Vec2d(w / 2, h / 2)], [new Vec2d(w, 0), new Vec2d(w / 2, h / 2)]];\n  }\n  return [[new Vec2d(sw * inset, sw * inset), new Vec2d(w - sw * inset, h - sw * inset)], [new Vec2d(sw * inset, h - sw * inset), new Vec2d(w - sw * inset, sw * inset)]];\n}\nfunction getCheckBoxLines(w, h) {\n  var size = Math.min(w, h) * 0.82;\n  var ox = (w - size) / 2;\n  var oy = (h - size) / 2;\n  return [[new Vec2d(ox + size * 0.25, oy + size * 0.52), new Vec2d(ox + size * 0.45, oy + size * 0.82)], [new Vec2d(ox + size * 0.45, oy + size * 0.82), new Vec2d(ox + size * 0.82, oy + size * 0.22)]];\n}\nexport { GeoShapeUtil };","map":{"version":3,"names":["Fragment","jsx","jsxs","Box2d","getPolygonVertices","getRoundedInkyPolygonPath","getRoundedPolygonPoints","linesIntersect","PI","PI2","pointInPolygon","TAU","Vec2d","SVGContainer","BaseBoxShapeUtil","FONT_FAMILIES","LABEL_FONT_SIZES","STROKE_SIZES","TEXT_PROPS","getTextLabelSvgElement","HyperlinkButton","TextLabel","useForceSolid","DashStyleEllipse","DashStyleEllipseSvg","DashStyleOval","DashStyleOvalSvg","DashStylePolygon","DashStylePolygonSvg","DrawStyleEllipseSvg","getEllipseIndicatorPath","DrawStylePolygon","DrawStylePolygonSvg","SolidStyleEllipse","SolidStyleEllipseSvg","getOvalIndicatorPath","SolidStyleOval","SolidStyleOvalSvg","SolidStylePolygon","SolidStylePolygonSvg","LABEL_PADDING","MIN_SIZE_WITH_LABEL","GeoShapeUtil","_BaseBoxShapeUtil","_inherits","_super","_createSuper","_this","_classCallCheck","_len","arguments","length","args","Array","_key","call","apply","concat","_defineProperty","_assertThisInitialized","shape","id","type","text","props","trimEnd","editor","updateShapes","_ref","initialBounds","handle","newPoint","scaleX","scaleY","w","width","h","height","overShrinkX","overShrinkY","trim","newW","Math","max","abs","newH","labelSize","getLabelSize","_objectSpread","nextW","sign","nextH","offset","x","y","_offset$rot$add","rot","rotation","add","growY","prevHeight","nextHeight","prev","next","prevText","nextText","font","size","prevWidth","nextSize","nextWidth","inputs","altKey","geo","_createClass","key","value","defaultProps","color","labelColor","fill","dash","align","verticalAlign","url","hitTestLineSegment","A","B","outline","i","C","D","lines","getLines","_iterator","_createForOfIteratorHelper","_step","s","n","done","_step$value","_slicedToArray","err","e","f","hitTestPoint","point","zoomLevel","offsetDist","DistanceToLineSegment","_iterator2","_step2","_step2$value","getBounds","getCenter","getOutline","cx","cy","q","pow","p","sqrt","len","ceil","step","a","cos","b","sin","ts","tc","points","t1","t2","sides","rightMostIndex","floor","leftMostIndex","topMostIndex","bottomMostIndex","maxX","minX","minY","maxY","diffX","diffY","offsetX","offsetY","ratio","cx2","cy2","ox","oy","ix","iy","from","map","_","theta","min","component","_this2","forceSolid","strokeWidth","getShape","children","wrap","indicator","d","rx","ry","path","polygonPoints","slice","_iterator3","_step4","_step4$value","toSvg","colors","svgElm","bounds","rootTextElm","textElm","cloneNode","setAttribute","textBgEl","background","groupEl","document","createElementNS","append","nodeName","appendChild","g","minSize","textMeasure","measureText","fontFamily","fontSize","maxWidth","sizes","m","l","xl","minWidth","sw","getXBoxLines","getCheckBoxLines","inset"],"sources":["/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@tldraw/editor/src/lib/editor/shapes/geo/GeoShapeUtil.tsx"],"sourcesContent":["/* eslint-disable react-hooks/rules-of-hooks */\nimport {\n\tBox2d,\n\tgetPolygonVertices,\n\tgetRoundedInkyPolygonPath,\n\tgetRoundedPolygonPoints,\n\tlinesIntersect,\n\tPI,\n\tPI2,\n\tpointInPolygon,\n\tTAU,\n\tVec2d,\n\tVecLike,\n} from '@tldraw/primitives'\nimport { TLDefaultDashStyle, TLGeoShape } from '@tldraw/tlschema'\nimport { SVGContainer } from '../../../components/SVGContainer'\nimport { Editor } from '../../Editor'\nimport { BaseBoxShapeUtil } from '../BaseBoxShapeUtil'\nimport { TLOnEditEndHandler, TLOnResizeHandler } from '../ShapeUtil'\nimport {\n\tFONT_FAMILIES,\n\tLABEL_FONT_SIZES,\n\tSTROKE_SIZES,\n\tTEXT_PROPS,\n} from '../shared/default-shape-constants'\nimport { getTextLabelSvgElement } from '../shared/getTextLabelSvgElement'\nimport { HyperlinkButton } from '../shared/HyperlinkButton'\nimport { TextLabel } from '../shared/TextLabel'\nimport { TLExportColors } from '../shared/TLExportColors'\nimport { useForceSolid } from '../shared/useForceSolid'\nimport { DashStyleEllipse, DashStyleEllipseSvg } from './components/DashStyleEllipse'\nimport { DashStyleOval, DashStyleOvalSvg } from './components/DashStyleOval'\nimport { DashStylePolygon, DashStylePolygonSvg } from './components/DashStylePolygon'\nimport { DrawStyleEllipseSvg, getEllipseIndicatorPath } from './components/DrawStyleEllipse'\nimport { DrawStylePolygon, DrawStylePolygonSvg } from './components/DrawStylePolygon'\nimport { SolidStyleEllipse, SolidStyleEllipseSvg } from './components/SolidStyleEllipse'\nimport {\n\tgetOvalIndicatorPath,\n\tSolidStyleOval,\n\tSolidStyleOvalSvg,\n} from './components/SolidStyleOval'\nimport { SolidStylePolygon, SolidStylePolygonSvg } from './components/SolidStylePolygon'\n\nconst LABEL_PADDING = 16\nconst MIN_SIZE_WITH_LABEL = 17 * 3\n\n/** @public */\nexport class GeoShapeUtil extends BaseBoxShapeUtil<TLGeoShape> {\n\tstatic override type = 'geo' as const\n\n\tcanEdit = () => true\n\n\toverride defaultProps(): TLGeoShape['props'] {\n\t\treturn {\n\t\t\tw: 100,\n\t\t\th: 100,\n\t\t\tgeo: 'rectangle',\n\t\t\tcolor: 'black',\n\t\t\tlabelColor: 'black',\n\t\t\tfill: 'none',\n\t\t\tdash: 'draw',\n\t\t\tsize: 'm',\n\t\t\tfont: 'draw',\n\t\t\ttext: '',\n\t\t\talign: 'middle',\n\t\t\tverticalAlign: 'middle',\n\t\t\tgrowY: 0,\n\t\t\turl: '',\n\t\t}\n\t}\n\n\thitTestLineSegment(shape: TLGeoShape, A: VecLike, B: VecLike): boolean {\n\t\tconst outline = this.outline(shape)\n\n\t\t// Check the outline\n\t\tfor (let i = 0; i < outline.length; i++) {\n\t\t\tconst C = outline[i]\n\t\t\tconst D = outline[(i + 1) % outline.length]\n\t\t\tif (linesIntersect(A, B, C, D)) return true\n\t\t}\n\n\t\t// Also check lines, if any\n\t\tconst lines = getLines(shape.props, 0)\n\t\tif (lines !== undefined) {\n\t\t\tfor (const [C, D] of lines) {\n\t\t\t\tif (linesIntersect(A, B, C, D)) return true\n\t\t\t}\n\t\t}\n\n\t\treturn false\n\t}\n\n\thitTestPoint(shape: TLGeoShape, point: VecLike): boolean {\n\t\tconst outline = this.outline(shape)\n\n\t\tif (shape.props.fill === 'none') {\n\t\t\tconst zoomLevel = this.editor.zoomLevel\n\t\t\tconst offsetDist = STROKE_SIZES[shape.props.size] / zoomLevel\n\t\t\t// Check the outline\n\t\t\tfor (let i = 0; i < outline.length; i++) {\n\t\t\t\tconst C = outline[i]\n\t\t\t\tconst D = outline[(i + 1) % outline.length]\n\t\t\t\tif (Vec2d.DistanceToLineSegment(C, D, point) < offsetDist) return true\n\t\t\t}\n\n\t\t\t// Also check lines, if any\n\t\t\tconst lines = getLines(shape.props, 1)\n\t\t\tif (lines !== undefined) {\n\t\t\t\tfor (const [C, D] of lines) {\n\t\t\t\t\tif (Vec2d.DistanceToLineSegment(C, D, point) < offsetDist) return true\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn false\n\t\t}\n\n\t\treturn pointInPolygon(point, outline)\n\t}\n\n\tgetBounds(shape: TLGeoShape) {\n\t\treturn new Box2d(0, 0, shape.props.w, shape.props.h + shape.props.growY)\n\t}\n\n\tgetCenter(shape: TLGeoShape) {\n\t\treturn new Vec2d(shape.props.w / 2, (shape.props.h + shape.props.growY) / 2)\n\t}\n\n\tgetOutline(shape: TLGeoShape) {\n\t\tconst w = Math.max(1, shape.props.w)\n\t\tconst h = Math.max(1, shape.props.h + shape.props.growY)\n\t\tconst cx = w / 2\n\t\tconst cy = h / 2\n\n\t\tswitch (shape.props.geo) {\n\t\t\tcase 'triangle': {\n\t\t\t\treturn [new Vec2d(cx, 0), new Vec2d(w, h), new Vec2d(0, h)]\n\t\t\t}\n\t\t\tcase 'diamond': {\n\t\t\t\treturn [new Vec2d(cx, 0), new Vec2d(w, cy), new Vec2d(cx, h), new Vec2d(0, cy)]\n\t\t\t}\n\t\t\tcase 'pentagon': {\n\t\t\t\treturn getPolygonVertices(w, h, 5)\n\t\t\t}\n\t\t\tcase 'hexagon': {\n\t\t\t\treturn getPolygonVertices(w, h, 6)\n\t\t\t}\n\t\t\tcase 'octagon': {\n\t\t\t\treturn getPolygonVertices(w, h, 8)\n\t\t\t}\n\t\t\tcase 'ellipse': {\n\t\t\t\t// Perimeter of the ellipse\n\n\t\t\t\tconst q = Math.pow(cx - cy, 2) / Math.pow(cx + cy, 2)\n\t\t\t\tconst p = PI * (cx + cy) * (1 + (3 * q) / (10 + Math.sqrt(4 - 3 * q)))\n\n\t\t\t\t// Number of points\n\t\t\t\tlet len = Math.max(4, Math.ceil(p / 10))\n\n\t\t\t\t// Round length to nearest multiple of 4\n\t\t\t\t// In some cases, this stops the outline overlapping with the indicator\n\t\t\t\t// (it doesn't prevent all cases though, eg: when the shape is on the edge of a group)\n\t\t\t\tlen = Math.ceil(len / 4) * 4\n\n\t\t\t\t// Size of step\n\t\t\t\tconst step = PI2 / len\n\n\t\t\t\tconst a = Math.cos(step)\n\t\t\t\tconst b = Math.sin(step)\n\n\t\t\t\tlet sin = 0\n\t\t\t\tlet cos = 1\n\t\t\t\tlet ts = 0\n\t\t\t\tlet tc = 1\n\n\t\t\t\tconst points: Vec2d[] = Array(len)\n\n\t\t\t\tfor (let i = 0; i < len; i++) {\n\t\t\t\t\tpoints[i] = new Vec2d(cx + cx * cos, cy + cy * sin)\n\t\t\t\t\tts = b * cos + a * sin\n\t\t\t\t\ttc = a * cos - b * sin\n\t\t\t\t\tsin = ts\n\t\t\t\t\tcos = tc\n\t\t\t\t}\n\n\t\t\t\treturn points\n\t\t\t}\n\t\t\tcase 'oval': {\n\t\t\t\tconst len = 10\n\t\t\t\tconst points: Vec2d[] = Array(len * 2)\n\n\t\t\t\tif (h > w) {\n\t\t\t\t\tfor (let i = 0; i < len; i++) {\n\t\t\t\t\t\tconst t1 = -PI + (PI * i) / (len - 2)\n\t\t\t\t\t\tconst t2 = (PI * i) / (len - 2)\n\t\t\t\t\t\tpoints[i] = new Vec2d(cx + cx * Math.cos(t1), cx + cx * Math.sin(t1))\n\t\t\t\t\t\tpoints[i + len] = new Vec2d(cx + cx * Math.cos(t2), h - cx + cx * Math.sin(t2))\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor (let i = 0; i < len; i++) {\n\t\t\t\t\t\tconst t1 = -TAU + (PI * i) / (len - 2)\n\t\t\t\t\t\tconst t2 = TAU + (PI * -i) / (len - 2)\n\t\t\t\t\t\tpoints[i] = new Vec2d(w - cy + cy * Math.cos(t1), h - cy + cy * Math.sin(t1))\n\t\t\t\t\t\tpoints[i + len] = new Vec2d(cy - cy * Math.cos(t2), h - cy + cy * Math.sin(t2))\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn points\n\t\t\t}\n\t\t\tcase 'star': {\n\t\t\t\t// Most of this code is to offset the center, a 5 point star\n\t\t\t\t// will need to be moved downward because from its center [0,0]\n\t\t\t\t// it will have a bigger minY than maxY. This is because it'll\n\t\t\t\t// have 2 points at the bottom.\n\t\t\t\tconst sides = 5\n\t\t\t\tconst step = PI2 / sides / 2\n\t\t\t\tconst rightMostIndex = Math.floor(sides / 4) * 2\n\t\t\t\tconst leftMostIndex = sides * 2 - rightMostIndex\n\t\t\t\tconst topMostIndex = 0\n\t\t\t\tconst bottomMostIndex = Math.floor(sides / 2) * 2\n\t\t\t\tconst maxX = (Math.cos(-TAU + rightMostIndex * step) * w) / 2\n\t\t\t\tconst minX = (Math.cos(-TAU + leftMostIndex * step) * w) / 2\n\n\t\t\t\tconst minY = (Math.sin(-TAU + topMostIndex * step) * h) / 2\n\t\t\t\tconst maxY = (Math.sin(-TAU + bottomMostIndex * step) * h) / 2\n\t\t\t\tconst diffX = w - Math.abs(maxX - minX)\n\t\t\t\tconst diffY = h - Math.abs(maxY - minY)\n\t\t\t\tconst offsetX = w / 2 + minX - (w / 2 - maxX)\n\t\t\t\tconst offsetY = h / 2 + minY - (h / 2 - maxY)\n\n\t\t\t\tconst ratio = 1\n\t\t\t\tconst cx = (w - offsetX) / 2\n\t\t\t\tconst cy = (h - offsetY) / 2\n\t\t\t\tconst ox = (w + diffX) / 2\n\t\t\t\tconst oy = (h + diffY) / 2\n\t\t\t\tconst ix = (ox * ratio) / 2\n\t\t\t\tconst iy = (oy * ratio) / 2\n\n\t\t\t\treturn Array.from(Array(sides * 2)).map((_, i) => {\n\t\t\t\t\tconst theta = -TAU + i * step\n\t\t\t\t\treturn new Vec2d(\n\t\t\t\t\t\tcx + (i % 2 ? ix : ox) * Math.cos(theta),\n\t\t\t\t\t\tcy + (i % 2 ? iy : oy) * Math.sin(theta)\n\t\t\t\t\t)\n\t\t\t\t})\n\t\t\t}\n\t\t\tcase 'rhombus': {\n\t\t\t\tconst offset = Math.min(w * 0.38, h * 0.38)\n\t\t\t\treturn [new Vec2d(offset, 0), new Vec2d(w, 0), new Vec2d(w - offset, h), new Vec2d(0, h)]\n\t\t\t}\n\t\t\tcase 'rhombus-2': {\n\t\t\t\tconst offset = Math.min(w * 0.38, h * 0.38)\n\t\t\t\treturn [new Vec2d(0, 0), new Vec2d(w - offset, 0), new Vec2d(w, h), new Vec2d(offset, h)]\n\t\t\t}\n\t\t\tcase 'trapezoid': {\n\t\t\t\tconst offset = Math.min(w * 0.38, h * 0.38)\n\t\t\t\treturn [new Vec2d(offset, 0), new Vec2d(w - offset, 0), new Vec2d(w, h), new Vec2d(0, h)]\n\t\t\t}\n\t\t\tcase 'arrow-right': {\n\t\t\t\tconst ox = Math.min(w, h) * 0.38\n\t\t\t\tconst oy = h * 0.16\n\t\t\t\treturn [\n\t\t\t\t\tnew Vec2d(0, oy),\n\t\t\t\t\tnew Vec2d(w - ox, oy),\n\t\t\t\t\tnew Vec2d(w - ox, 0),\n\t\t\t\t\tnew Vec2d(w, h / 2),\n\t\t\t\t\tnew Vec2d(w - ox, h),\n\t\t\t\t\tnew Vec2d(w - ox, h - oy),\n\t\t\t\t\tnew Vec2d(0, h - oy),\n\t\t\t\t]\n\t\t\t}\n\t\t\tcase 'arrow-left': {\n\t\t\t\tconst ox = Math.min(w, h) * 0.38\n\t\t\t\tconst oy = h * 0.16\n\t\t\t\treturn [\n\t\t\t\t\tnew Vec2d(ox, 0),\n\t\t\t\t\tnew Vec2d(ox, oy),\n\t\t\t\t\tnew Vec2d(w, oy),\n\t\t\t\t\tnew Vec2d(w, h - oy),\n\t\t\t\t\tnew Vec2d(ox, h - oy),\n\t\t\t\t\tnew Vec2d(ox, h),\n\t\t\t\t\tnew Vec2d(0, h / 2),\n\t\t\t\t]\n\t\t\t}\n\t\t\tcase 'arrow-up': {\n\t\t\t\tconst ox = w * 0.16\n\t\t\t\tconst oy = Math.min(w, h) * 0.38\n\t\t\t\treturn [\n\t\t\t\t\tnew Vec2d(w / 2, 0),\n\t\t\t\t\tnew Vec2d(w, oy),\n\t\t\t\t\tnew Vec2d(w - ox, oy),\n\t\t\t\t\tnew Vec2d(w - ox, h),\n\t\t\t\t\tnew Vec2d(ox, h),\n\t\t\t\t\tnew Vec2d(ox, oy),\n\t\t\t\t\tnew Vec2d(0, oy),\n\t\t\t\t]\n\t\t\t}\n\t\t\tcase 'arrow-down': {\n\t\t\t\tconst ox = w * 0.16\n\t\t\t\tconst oy = Math.min(w, h) * 0.38\n\t\t\t\treturn [\n\t\t\t\t\tnew Vec2d(ox, 0),\n\t\t\t\t\tnew Vec2d(w - ox, 0),\n\t\t\t\t\tnew Vec2d(w - ox, h - oy),\n\t\t\t\t\tnew Vec2d(w, h - oy),\n\t\t\t\t\tnew Vec2d(w / 2, h),\n\t\t\t\t\tnew Vec2d(0, h - oy),\n\t\t\t\t\tnew Vec2d(ox, h - oy),\n\t\t\t\t]\n\t\t\t}\n\t\t\tcase 'check-box':\n\t\t\tcase 'x-box':\n\t\t\tcase 'rectangle': {\n\t\t\t\treturn [new Vec2d(0, 0), new Vec2d(w, 0), new Vec2d(w, h), new Vec2d(0, h)]\n\t\t\t}\n\t\t}\n\t}\n\n\tonEditEnd: TLOnEditEndHandler<TLGeoShape> = (shape) => {\n\t\tconst {\n\t\t\tid,\n\t\t\ttype,\n\t\t\tprops: { text },\n\t\t} = shape\n\n\t\tif (text.trimEnd() !== shape.props.text) {\n\t\t\tthis.editor.updateShapes([\n\t\t\t\t{\n\t\t\t\t\tid,\n\t\t\t\t\ttype,\n\t\t\t\t\tprops: {\n\t\t\t\t\t\ttext: text.trimEnd(),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t])\n\t\t}\n\t}\n\n\tcomponent(shape: TLGeoShape) {\n\t\tconst { id, type, props } = shape\n\n\t\tconst forceSolid = useForceSolid()\n\t\tconst strokeWidth = STROKE_SIZES[props.size]\n\n\t\tconst { w, color, labelColor, fill, dash, growY, font, align, verticalAlign, size, text } =\n\t\t\tprops\n\n\t\tconst getShape = () => {\n\t\t\tconst h = props.h + growY\n\n\t\t\tswitch (props.geo) {\n\t\t\t\tcase 'ellipse': {\n\t\t\t\t\tif (dash === 'solid' || (dash === 'draw' && forceSolid)) {\n\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t<SolidStyleEllipse strokeWidth={strokeWidth} w={w} h={h} color={color} fill={fill} />\n\t\t\t\t\t\t)\n\t\t\t\t\t} else if (dash === 'dashed' || dash === 'dotted') {\n\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t<DashStyleEllipse\n\t\t\t\t\t\t\t\tid={id}\n\t\t\t\t\t\t\t\tstrokeWidth={strokeWidth}\n\t\t\t\t\t\t\t\tw={w}\n\t\t\t\t\t\t\t\th={h}\n\t\t\t\t\t\t\t\tdash={dash === 'dashed' ? dash : size === 's' && forceSolid ? 'dashed' : dash}\n\t\t\t\t\t\t\t\tcolor={color}\n\t\t\t\t\t\t\t\tfill={fill}\n\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t)\n\t\t\t\t\t} else if (dash === 'draw') {\n\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t<SolidStyleEllipse strokeWidth={strokeWidth} w={w} h={h} color={color} fill={fill} />\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tcase 'oval': {\n\t\t\t\t\tif (dash === 'solid' || (dash === 'draw' && forceSolid)) {\n\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t<SolidStyleOval strokeWidth={strokeWidth} w={w} h={h} color={color} fill={fill} />\n\t\t\t\t\t\t)\n\t\t\t\t\t} else if (dash === 'dashed' || dash === 'dotted') {\n\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t<DashStyleOval\n\t\t\t\t\t\t\t\tid={id}\n\t\t\t\t\t\t\t\tstrokeWidth={strokeWidth}\n\t\t\t\t\t\t\t\tw={w}\n\t\t\t\t\t\t\t\th={h}\n\t\t\t\t\t\t\t\tdash={dash === 'dashed' ? dash : size === 's' && forceSolid ? 'dashed' : dash}\n\t\t\t\t\t\t\t\tcolor={color}\n\t\t\t\t\t\t\t\tfill={fill}\n\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t)\n\t\t\t\t\t} else if (dash === 'draw') {\n\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t<SolidStyleOval strokeWidth={strokeWidth} w={w} h={h} color={color} fill={fill} />\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tdefault: {\n\t\t\t\t\tconst outline = this.outline(shape)\n\t\t\t\t\tconst lines = getLines(shape.props, strokeWidth)\n\n\t\t\t\t\tif (dash === 'solid' || (dash === 'draw' && forceSolid)) {\n\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t<SolidStylePolygon\n\t\t\t\t\t\t\t\tfill={fill}\n\t\t\t\t\t\t\t\tcolor={color}\n\t\t\t\t\t\t\t\tstrokeWidth={strokeWidth}\n\t\t\t\t\t\t\t\toutline={outline}\n\t\t\t\t\t\t\t\tlines={lines}\n\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t)\n\t\t\t\t\t} else if (dash === 'dashed' || dash === 'dotted') {\n\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t<DashStylePolygon\n\t\t\t\t\t\t\t\tdash={dash === 'dashed' ? dash : size === 's' && forceSolid ? 'dashed' : dash}\n\t\t\t\t\t\t\t\tfill={fill}\n\t\t\t\t\t\t\t\tcolor={color}\n\t\t\t\t\t\t\t\tstrokeWidth={strokeWidth}\n\t\t\t\t\t\t\t\toutline={outline}\n\t\t\t\t\t\t\t\tlines={lines}\n\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t)\n\t\t\t\t\t} else if (dash === 'draw') {\n\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t<DrawStylePolygon\n\t\t\t\t\t\t\t\tid={id}\n\t\t\t\t\t\t\t\tfill={fill}\n\t\t\t\t\t\t\t\tcolor={color}\n\t\t\t\t\t\t\t\tstrokeWidth={strokeWidth}\n\t\t\t\t\t\t\t\toutline={outline}\n\t\t\t\t\t\t\t\tlines={lines}\n\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn (\n\t\t\t<>\n\t\t\t\t<SVGContainer id={id}>{getShape()}</SVGContainer>\n\t\t\t\t<TextLabel\n\t\t\t\t\tid={id}\n\t\t\t\t\ttype={type}\n\t\t\t\t\tfont={font}\n\t\t\t\t\tfill={fill}\n\t\t\t\t\tsize={size}\n\t\t\t\t\talign={align}\n\t\t\t\t\tverticalAlign={verticalAlign}\n\t\t\t\t\ttext={text}\n\t\t\t\t\tlabelColor={labelColor}\n\t\t\t\t\twrap\n\t\t\t\t/>\n\t\t\t\t{shape.props.url && (\n\t\t\t\t\t<HyperlinkButton url={shape.props.url} zoomLevel={this.editor.zoomLevel} />\n\t\t\t\t)}\n\t\t\t</>\n\t\t)\n\t}\n\n\tindicator(shape: TLGeoShape) {\n\t\tconst { id, props } = shape\n\t\tconst { w, h, growY, size } = props\n\n\t\tconst forceSolid = useForceSolid()\n\t\tconst strokeWidth = STROKE_SIZES[size]\n\n\t\tswitch (props.geo) {\n\t\t\tcase 'ellipse': {\n\t\t\t\tif (props.dash === 'draw' && !forceSolid) {\n\t\t\t\t\treturn <path d={getEllipseIndicatorPath(id, w, h + growY, strokeWidth)} />\n\t\t\t\t}\n\n\t\t\t\treturn <ellipse cx={w / 2} cy={(h + growY) / 2} rx={w / 2} ry={(h + growY) / 2} />\n\t\t\t}\n\t\t\tcase 'oval': {\n\t\t\t\treturn <path d={getOvalIndicatorPath(w, h + growY)} />\n\t\t\t}\n\n\t\t\tdefault: {\n\t\t\t\tconst outline = this.outline(shape)\n\t\t\t\tlet path: string\n\n\t\t\t\tif (props.dash === 'draw' && !forceSolid) {\n\t\t\t\t\tconst polygonPoints = getRoundedPolygonPoints(id, outline, 0, strokeWidth * 2, 1)\n\t\t\t\t\tpath = getRoundedInkyPolygonPath(polygonPoints)\n\t\t\t\t} else {\n\t\t\t\t\tpath = 'M' + outline[0] + 'L' + outline.slice(1) + 'Z'\n\t\t\t\t}\n\n\t\t\t\tconst lines = getLines(shape.props, strokeWidth)\n\n\t\t\t\tif (lines) {\n\t\t\t\t\tfor (const [A, B] of lines) {\n\t\t\t\t\t\tpath += `M${A.x},${A.y}L${B.x},${B.y}`\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn <path d={path} />\n\t\t\t}\n\t\t}\n\t}\n\n\ttoSvg(shape: TLGeoShape, font: string, colors: TLExportColors) {\n\t\tconst { id, props } = shape\n\t\tconst strokeWidth = STROKE_SIZES[props.size]\n\n\t\tlet svgElm: SVGElement\n\n\t\tswitch (props.geo) {\n\t\t\tcase 'ellipse': {\n\t\t\t\tswitch (props.dash) {\n\t\t\t\t\tcase 'draw':\n\t\t\t\t\t\tsvgElm = DrawStyleEllipseSvg({\n\t\t\t\t\t\t\tid,\n\t\t\t\t\t\t\tw: props.w,\n\t\t\t\t\t\t\th: props.h,\n\t\t\t\t\t\t\tcolor: props.color,\n\t\t\t\t\t\t\tfill: props.fill,\n\t\t\t\t\t\t\tstrokeWidth,\n\t\t\t\t\t\t\tcolors,\n\t\t\t\t\t\t})\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase 'solid':\n\t\t\t\t\t\tsvgElm = SolidStyleEllipseSvg({\n\t\t\t\t\t\t\tstrokeWidth,\n\t\t\t\t\t\t\tw: props.w,\n\t\t\t\t\t\t\th: props.h,\n\t\t\t\t\t\t\tcolor: props.color,\n\t\t\t\t\t\t\tfill: props.fill,\n\t\t\t\t\t\t\tcolors,\n\t\t\t\t\t\t})\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tsvgElm = DashStyleEllipseSvg({\n\t\t\t\t\t\t\tid,\n\t\t\t\t\t\t\tstrokeWidth,\n\t\t\t\t\t\t\tw: props.w,\n\t\t\t\t\t\t\th: props.h,\n\t\t\t\t\t\t\tdash: props.dash,\n\t\t\t\t\t\t\tcolor: props.color,\n\t\t\t\t\t\t\tfill: props.fill,\n\t\t\t\t\t\t\tcolors,\n\t\t\t\t\t\t})\n\t\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tcase 'oval': {\n\t\t\t\tswitch (props.dash) {\n\t\t\t\t\tcase 'draw':\n\t\t\t\t\t\tsvgElm = DashStyleOvalSvg({\n\t\t\t\t\t\t\tid,\n\t\t\t\t\t\t\tstrokeWidth,\n\t\t\t\t\t\t\tw: props.w,\n\t\t\t\t\t\t\th: props.h,\n\t\t\t\t\t\t\tdash: props.dash,\n\t\t\t\t\t\t\tcolor: props.color,\n\t\t\t\t\t\t\tfill: props.fill,\n\t\t\t\t\t\t\tcolors,\n\t\t\t\t\t\t})\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase 'solid':\n\t\t\t\t\t\tsvgElm = SolidStyleOvalSvg({\n\t\t\t\t\t\t\tstrokeWidth,\n\t\t\t\t\t\t\tw: props.w,\n\t\t\t\t\t\t\th: props.h,\n\t\t\t\t\t\t\tcolor: props.color,\n\t\t\t\t\t\t\tfill: props.fill,\n\t\t\t\t\t\t\tcolors,\n\t\t\t\t\t\t})\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tsvgElm = DashStyleOvalSvg({\n\t\t\t\t\t\t\tid,\n\t\t\t\t\t\t\tstrokeWidth,\n\t\t\t\t\t\t\tw: props.w,\n\t\t\t\t\t\t\th: props.h,\n\t\t\t\t\t\t\tdash: props.dash,\n\t\t\t\t\t\t\tcolor: props.color,\n\t\t\t\t\t\t\tfill: props.fill,\n\t\t\t\t\t\t\tcolors,\n\t\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\tconst outline = this.outline(shape)\n\t\t\t\tconst lines = getLines(shape.props, strokeWidth)\n\n\t\t\t\tswitch (props.dash) {\n\t\t\t\t\tcase 'draw':\n\t\t\t\t\t\tsvgElm = DrawStylePolygonSvg({\n\t\t\t\t\t\t\tid,\n\t\t\t\t\t\t\tfill: props.fill,\n\t\t\t\t\t\t\tcolor: props.color,\n\t\t\t\t\t\t\tstrokeWidth,\n\t\t\t\t\t\t\toutline,\n\t\t\t\t\t\t\tlines,\n\t\t\t\t\t\t\tcolors,\n\t\t\t\t\t\t})\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase 'solid':\n\t\t\t\t\t\tsvgElm = SolidStylePolygonSvg({\n\t\t\t\t\t\t\tfill: props.fill,\n\t\t\t\t\t\t\tcolor: props.color,\n\t\t\t\t\t\t\tstrokeWidth,\n\t\t\t\t\t\t\toutline,\n\t\t\t\t\t\t\tlines,\n\t\t\t\t\t\t\tcolors,\n\t\t\t\t\t\t})\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tsvgElm = DashStylePolygonSvg({\n\t\t\t\t\t\t\tdash: props.dash,\n\t\t\t\t\t\t\tfill: props.fill,\n\t\t\t\t\t\t\tcolor: props.color,\n\t\t\t\t\t\t\tstrokeWidth,\n\t\t\t\t\t\t\toutline,\n\t\t\t\t\t\t\tlines,\n\t\t\t\t\t\t\tcolors,\n\t\t\t\t\t\t})\n\t\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tif (props.text) {\n\t\t\tconst bounds = this.bounds(shape)\n\n\t\t\tconst rootTextElm = getTextLabelSvgElement({\n\t\t\t\teditor: this.editor,\n\t\t\t\tshape,\n\t\t\t\tfont,\n\t\t\t\tbounds,\n\t\t\t})\n\n\t\t\tconst textElm = rootTextElm.cloneNode(true) as SVGTextElement\n\t\t\ttextElm.setAttribute('fill', colors.fill[shape.props.labelColor])\n\t\t\ttextElm.setAttribute('stroke', 'none')\n\n\t\t\tconst textBgEl = rootTextElm.cloneNode(true) as SVGTextElement\n\t\t\ttextBgEl.setAttribute('stroke-width', '2')\n\t\t\ttextBgEl.setAttribute('fill', colors.background)\n\t\t\ttextBgEl.setAttribute('stroke', colors.background)\n\n\t\t\tconst groupEl = document.createElementNS('http://www.w3.org/2000/svg', 'g')\n\t\t\tgroupEl.append(textBgEl)\n\t\t\tgroupEl.append(textElm)\n\n\t\t\tif (svgElm.nodeName === 'g') {\n\t\t\t\tsvgElm.appendChild(groupEl)\n\t\t\t\treturn svgElm\n\t\t\t} else {\n\t\t\t\tconst g = document.createElementNS('http://www.w3.org/2000/svg', 'g')\n\t\t\t\tg.appendChild(svgElm)\n\t\t\t\tg.appendChild(groupEl)\n\t\t\t\treturn g\n\t\t\t}\n\t\t}\n\n\t\treturn svgElm\n\t}\n\n\tonResize: TLOnResizeHandler<TLGeoShape> = (\n\t\tshape,\n\t\t{ initialBounds, handle, newPoint, scaleX, scaleY }\n\t) => {\n\t\tlet w = initialBounds.width * scaleX\n\t\tlet h = initialBounds.height * scaleY\n\t\tlet overShrinkX = 0\n\t\tlet overShrinkY = 0\n\n\t\tif (shape.props.text.trim()) {\n\t\t\tlet newW = Math.max(Math.abs(w), MIN_SIZE_WITH_LABEL)\n\t\t\tlet newH = Math.max(Math.abs(h), MIN_SIZE_WITH_LABEL)\n\n\t\t\tif (newW < MIN_SIZE_WITH_LABEL && newH === MIN_SIZE_WITH_LABEL) {\n\t\t\t\tnewW = MIN_SIZE_WITH_LABEL\n\t\t\t}\n\n\t\t\tif (newW === MIN_SIZE_WITH_LABEL && newH < MIN_SIZE_WITH_LABEL) {\n\t\t\t\tnewH = MIN_SIZE_WITH_LABEL\n\t\t\t}\n\n\t\t\tconst labelSize = getLabelSize(this.editor, {\n\t\t\t\t...shape,\n\t\t\t\tprops: {\n\t\t\t\t\t...shape.props,\n\t\t\t\t\tw: newW,\n\t\t\t\t\th: newH,\n\t\t\t\t},\n\t\t\t})\n\n\t\t\tconst nextW = Math.max(Math.abs(w), labelSize.w) * Math.sign(w)\n\t\t\tconst nextH = Math.max(Math.abs(h), labelSize.h) * Math.sign(h)\n\t\t\toverShrinkX = Math.abs(nextW) - Math.abs(w)\n\t\t\toverShrinkY = Math.abs(nextH) - Math.abs(h)\n\n\t\t\tw = nextW\n\t\t\th = nextH\n\t\t}\n\n\t\tconst offset = new Vec2d(0, 0)\n\n\t\t// x offsets\n\n\t\tif (scaleX < 0) {\n\t\t\toffset.x += w\n\t\t}\n\n\t\tif (handle === 'left' || handle === 'top_left' || handle === 'bottom_left') {\n\t\t\toffset.x += scaleX < 0 ? overShrinkX : -overShrinkX\n\t\t}\n\n\t\t// y offsets\n\n\t\tif (scaleY < 0) {\n\t\t\toffset.y += h\n\t\t}\n\n\t\tif (handle === 'top' || handle === 'top_left' || handle === 'top_right') {\n\t\t\toffset.y += scaleY < 0 ? overShrinkY : -overShrinkY\n\t\t}\n\n\t\tconst { x, y } = offset.rot(shape.rotation).add(newPoint)\n\n\t\treturn {\n\t\t\tx,\n\t\t\ty,\n\t\t\tprops: {\n\t\t\t\tw: Math.max(Math.abs(w), 1),\n\t\t\t\th: Math.max(Math.abs(h), 1),\n\t\t\t\tgrowY: 0,\n\t\t\t},\n\t\t}\n\t}\n\n\tonBeforeCreate = (shape: TLGeoShape) => {\n\t\tif (!shape.props.text) {\n\t\t\tif (shape.props.growY) {\n\t\t\t\t// No text / some growY, set growY to 0\n\t\t\t\treturn {\n\t\t\t\t\t...shape,\n\t\t\t\t\tprops: {\n\t\t\t\t\t\t...shape.props,\n\t\t\t\t\t\tgrowY: 0,\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// No text / no growY, nothing to change\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\tconst prevHeight = shape.props.h\n\t\tconst nextHeight = getLabelSize(this.editor, shape).h\n\n\t\tlet growY: number | null = null\n\n\t\tif (nextHeight > prevHeight) {\n\t\t\tgrowY = nextHeight - prevHeight\n\t\t} else {\n\t\t\tif (shape.props.growY) {\n\t\t\t\tgrowY = 0\n\t\t\t}\n\t\t}\n\n\t\tif (growY !== null) {\n\t\t\treturn {\n\t\t\t\t...shape,\n\t\t\t\tprops: {\n\t\t\t\t\t...shape.props,\n\t\t\t\t\tgrowY,\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t}\n\n\tonBeforeUpdate = (prev: TLGeoShape, next: TLGeoShape) => {\n\t\tconst prevText = prev.props.text.trimEnd()\n\t\tconst nextText = next.props.text.trimEnd()\n\n\t\tif (\n\t\t\tprevText === nextText &&\n\t\t\tprev.props.font === next.props.font &&\n\t\t\tprev.props.size === next.props.size\n\t\t) {\n\t\t\treturn\n\t\t}\n\n\t\tif (prevText && !nextText) {\n\t\t\treturn {\n\t\t\t\t...next,\n\t\t\t\tprops: {\n\t\t\t\t\t...next.props,\n\t\t\t\t\tgrowY: 0,\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\n\t\tconst prevWidth = prev.props.w\n\t\tconst prevHeight = prev.props.h\n\t\tconst nextSize = getLabelSize(this.editor, next)\n\t\tconst nextWidth = nextSize.w\n\t\tconst nextHeight = nextSize.h\n\n\t\t// When entering the first character in a label (not pasting in multiple characters...)\n\t\tif (!prevText && nextText && nextText.length === 1) {\n\t\t\tlet w = Math.max(prevWidth, nextWidth)\n\t\t\tlet h = Math.max(prevHeight, nextHeight)\n\n\t\t\t// If both the width and height were less than the minimum size, make the shape square\n\t\t\tif (prev.props.w < MIN_SIZE_WITH_LABEL && prev.props.h < MIN_SIZE_WITH_LABEL) {\n\t\t\t\tw = Math.max(w, MIN_SIZE_WITH_LABEL)\n\t\t\t\th = Math.max(h, MIN_SIZE_WITH_LABEL)\n\t\t\t\tw = Math.max(w, h)\n\t\t\t\th = Math.max(w, h)\n\t\t\t}\n\n\t\t\t// Don't set a growYat least, not until we've implemented a growX property\n\t\t\treturn {\n\t\t\t\t...next,\n\t\t\t\tprops: {\n\t\t\t\t\t...next.props,\n\t\t\t\t\tw,\n\t\t\t\t\th,\n\t\t\t\t\tgrowY: 0,\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\n\t\tlet growY: number | null = null\n\n\t\tif (nextHeight > prevHeight) {\n\t\t\tgrowY = nextHeight - prevHeight\n\t\t} else {\n\t\t\tif (prev.props.growY) {\n\t\t\t\tgrowY = 0\n\t\t\t}\n\t\t}\n\n\t\tif (growY !== null) {\n\t\t\treturn {\n\t\t\t\t...next,\n\t\t\t\tprops: {\n\t\t\t\t\t...next.props,\n\t\t\t\t\tgrowY,\n\t\t\t\t\tw: Math.max(next.props.w, nextWidth),\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\n\t\tif (nextWidth > prev.props.w) {\n\t\t\treturn {\n\t\t\t\t...next,\n\t\t\t\tprops: {\n\t\t\t\t\t...next.props,\n\t\t\t\t\tw: nextWidth,\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t}\n\n\tonDoubleClick = (shape: TLGeoShape) => {\n\t\t// Little easter egg: double-clicking a rectangle / checkbox while\n\t\t// holding alt will toggle between check-box and rectangle\n\t\tif (this.editor.inputs.altKey) {\n\t\t\tswitch (shape.props.geo) {\n\t\t\t\tcase 'rectangle': {\n\t\t\t\t\treturn {\n\t\t\t\t\t\t...shape,\n\t\t\t\t\t\tprops: {\n\t\t\t\t\t\t\tgeo: 'check-box' as const,\n\t\t\t\t\t\t},\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcase 'check-box': {\n\t\t\t\t\treturn {\n\t\t\t\t\t\t...shape,\n\t\t\t\t\t\tprops: {\n\t\t\t\t\t\t\tgeo: 'rectangle' as const,\n\t\t\t\t\t\t},\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn\n\t}\n}\n\nfunction getLabelSize(editor: Editor, shape: TLGeoShape) {\n\tconst text = shape.props.text.trimEnd()\n\n\tif (!text) {\n\t\treturn { w: 0, h: 0 }\n\t}\n\n\tconst minSize = editor.textMeasure.measureText('w', {\n\t\t...TEXT_PROPS,\n\t\tfontFamily: FONT_FAMILIES[shape.props.font],\n\t\tfontSize: LABEL_FONT_SIZES[shape.props.size],\n\t\twidth: 'fit-content',\n\t\tmaxWidth: '100px',\n\t})\n\n\t// TODO: Can I get these from somewhere?\n\tconst sizes = {\n\t\ts: 2,\n\t\tm: 3.5,\n\t\tl: 5,\n\t\txl: 10,\n\t}\n\n\tconst size = editor.textMeasure.measureText(text, {\n\t\t...TEXT_PROPS,\n\t\tfontFamily: FONT_FAMILIES[shape.props.font],\n\t\tfontSize: LABEL_FONT_SIZES[shape.props.size],\n\t\twidth: 'fit-content',\n\t\tminWidth: minSize.w + 'px',\n\t\tmaxWidth:\n\t\t\tMath.max(\n\t\t\t\t// Guard because a DOM nodes can't be less 0\n\t\t\t\t0,\n\t\t\t\t// A 'w' width that we're setting as the min-width\n\t\t\t\tMath.ceil(minSize.w + sizes[shape.props.size]),\n\t\t\t\t// The actual text size\n\t\t\t\tMath.ceil(shape.props.w - LABEL_PADDING * 2)\n\t\t\t) + 'px',\n\t})\n\n\treturn {\n\t\tw: size.w + LABEL_PADDING * 2,\n\t\th: size.h + LABEL_PADDING * 2,\n\t}\n}\n\nfunction getLines(props: TLGeoShape['props'], sw: number) {\n\tswitch (props.geo) {\n\t\tcase 'x-box': {\n\t\t\treturn getXBoxLines(props.w, props.h, sw, props.dash)\n\t\t}\n\t\tcase 'check-box': {\n\t\t\treturn getCheckBoxLines(props.w, props.h)\n\t\t}\n\t\tdefault: {\n\t\t\treturn undefined\n\t\t}\n\t}\n}\n\nfunction getXBoxLines(w: number, h: number, sw: number, dash: TLDefaultDashStyle) {\n\tconst inset = dash === 'draw' ? 0.62 : 0\n\n\tif (dash === 'dashed') {\n\t\treturn [\n\t\t\t[new Vec2d(0, 0), new Vec2d(w / 2, h / 2)],\n\t\t\t[new Vec2d(w, h), new Vec2d(w / 2, h / 2)],\n\t\t\t[new Vec2d(0, h), new Vec2d(w / 2, h / 2)],\n\t\t\t[new Vec2d(w, 0), new Vec2d(w / 2, h / 2)],\n\t\t]\n\t}\n\n\treturn [\n\t\t[new Vec2d(sw * inset, sw * inset), new Vec2d(w - sw * inset, h - sw * inset)],\n\t\t[new Vec2d(sw * inset, h - sw * inset), new Vec2d(w - sw * inset, sw * inset)],\n\t]\n}\n\nfunction getCheckBoxLines(w: number, h: number) {\n\tconst size = Math.min(w, h) * 0.82\n\tconst ox = (w - size) / 2\n\tconst oy = (h - size) / 2\n\treturn [\n\t\t[new Vec2d(ox + size * 0.25, oy + size * 0.52), new Vec2d(ox + size * 0.45, oy + size * 0.82)],\n\t\t[new Vec2d(ox + size * 0.45, oy + size * 0.82), new Vec2d(ox + size * 0.82, oy + size * 0.22)],\n\t]\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}