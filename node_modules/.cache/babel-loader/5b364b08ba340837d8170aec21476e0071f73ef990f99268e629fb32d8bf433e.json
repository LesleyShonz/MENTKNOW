{"ast":null,"code":"import _objectSpread from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _createForOfIteratorHelper from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _defineProperty from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport { Box2d } from \"./Box2d.mjs\";\nimport { Vec2d } from \"./Vec2d.mjs\";\nvar BaseSegment2d = /*#__PURE__*/function () {\n  function BaseSegment2d(values) {\n    _classCallCheck(this, BaseSegment2d);\n    /**\n     * The segment's values. Do not modify these directly. Instead, use the `values` setter or\n     * `update` method.\n     *\n     * @internal\n     */\n    _defineProperty(this, \"_values\", void 0);\n    /**\n     * A private set of cached values, used for lookups and computations. Changing any of the\n     * segment's values will clear this object.\n     *\n     * @internal\n     */\n    _defineProperty(this, \"_computed\", {});\n    this._values = values;\n  }\n  _createClass(BaseSegment2d, [{\n    key: \"values\",\n    get:\n    /**\n     * The values for the curve segment.\n     *\n     * @public\n     */\n    function get() {\n      return this._values;\n    },\n    set: function set(values) {\n      this._values = values;\n      this._computed = {};\n    }\n    /**\n     * The length of the curve segment.\n     *\n     * @public\n     */\n  }, {\n    key: \"length\",\n    get: function get() {\n      if (this._computed.length !== void 0) {\n        return this._computed.length;\n      }\n      var lut = this.lut;\n      var prev = lut[0];\n      var result = 0;\n      for (var i = 1; i < lut.length; i++) {\n        var curr = lut[i];\n        result += prev.dist(curr);\n        prev = curr;\n      }\n      this._computed.length = result;\n      return result;\n    }\n    /**\n     * The bounding box containing the curve segment.\n     *\n     * @public\n     */\n  }, {\n    key: \"bounds\",\n    get: function get() {\n      if (this._computed.bounds !== void 0) {\n        return this._computed.bounds;\n      }\n      var minX = Infinity;\n      var minY = Infinity;\n      var maxX = -Infinity;\n      var maxY = -Infinity;\n      var lut = this.lut;\n      var _iterator = _createForOfIteratorHelper(lut),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var pt = _step.value;\n          minX = Math.min(pt.x, minX);\n          minY = Math.min(pt.y, minY);\n          maxX = Math.max(pt.x, maxX);\n          maxY = Math.max(pt.y, maxY);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      var result = new Box2d(minX, minY, maxX - minX, maxY - minY);\n      this._computed.bounds = result;\n      return result;\n    }\n    /**\n     * A lookup table consisting of values.p points along the segment. Used to compute lengths,\n     * closest points, etc. This should only be _computed once (when first requested) per set of\n     * values.\n     *\n     * @public\n     */\n  }, {\n    key: \"lut\",\n    get: function get() {\n      if (this._computed.lut) {\n        return this._computed.lut;\n      }\n      var p = this.values.p;\n      var result = [];\n      for (var i = 0; i < p + 1; i++) {\n        result.push(this.getPoint(i / p));\n      }\n      this._computed.lut = result;\n      return result;\n    }\n    /**\n     * A point half-way along the length of the segment.\n     *\n     * @public\n     */\n  }, {\n    key: \"midPoint\",\n    get: function get() {\n      if (this._computed.midPoint) {\n        return this._computed.midPoint;\n      }\n      var result = this.getPoint(0.5);\n      this._computed.midPoint = result;\n      return result;\n    }\n    /**\n     * An SVG path for the segment.\n     *\n     * @public\n     */\n  }, {\n    key: \"path\",\n    get: function get() {\n      if (this._computed.path) {\n        return this._computed.path;\n      }\n      var result = this.getPath();\n      this._computed.path = result;\n      return result;\n    }\n    /**\n     * Evaluate a point at a length along the curve segment.\n     *\n     * @param length - The length to find the point value.\n     * @public\n     */\n  }, {\n    key: \"getPointAtLength\",\n    value: function getPointAtLength(length) {\n      var t = Math.max(0, Math.min(1, length / this.length));\n      return this.getPoint(t);\n    }\n    /**\n     * Get the normal at distance t along the curve segment.\n     *\n     * @param t - The distance (0-1) to find the normal.\n     * @public\n     */\n  }, {\n    key: \"getNormal\",\n    value: function getNormal(t) {\n      return this.getPoint(t - 25e-4).tan(this.getPoint(t + 25e-4)).per().uni().toFixed();\n    }\n    /**\n     * Get the normal at a length along the curve segment.\n     *\n     * @param length - The length to find the normal.\n     * @public\n     */\n  }, {\n    key: \"getNormalAtLength\",\n    value: function getNormalAtLength(length) {\n      return this.getNormal(length / this.length);\n    }\n    /**\n     * Get the closest point on the segment to an arbitrary point.\n     *\n     * @param point - The arbitrary point.\n     * @public\n     */\n  }, {\n    key: \"getClosestPointTo\",\n    value: function getClosestPointTo(point) {\n      var lut = this.lut;\n      var closestT = 0;\n      var closestPoint = lut[0];\n      var closestDistance = lut[0].dist(point);\n      for (var i = 1; i < lut.length; i++) {\n        var distance = Vec2d.Dist(lut[i], point);\n        if (distance < closestDistance) {\n          closestDistance = distance;\n          closestPoint = lut[i];\n          closestT = i / lut.length;\n        }\n      }\n      var step = 1 / this.values.p;\n      for (var t = Math.max(0, closestT - step / 2); t < Math.min(1, closestT + step / 2); t += step / 10) {\n        var pt = this.getPoint(t);\n        var _distance = Vec2d.Dist(pt, point);\n        if (_distance < closestDistance) {\n          closestDistance = _distance;\n          closestPoint = pt;\n        }\n      }\n      return {\n        point: closestPoint,\n        distance: closestDistance\n      };\n    }\n    /**\n     * Set one or more values. Updating the segment will clear cached values.\n     *\n     * @param values - A partial of the segment's values object.\n     * @public\n     */\n  }, {\n    key: \"update\",\n    value: function update(values) {\n      this._computed = {};\n      this.values = _objectSpread(_objectSpread({}, this.values), values);\n    }\n  }]);\n  return BaseSegment2d;\n}();\nexport { BaseSegment2d };","map":{"version":3,"names":["Box2d","Vec2d","BaseSegment2d","values","_classCallCheck","_defineProperty","_values","_createClass","key","get","set","_computed","length","lut","prev","result","i","curr","dist","bounds","minX","Infinity","minY","maxX","maxY","_iterator","_createForOfIteratorHelper","_step","s","n","done","pt","value","Math","min","x","y","max","err","e","f","p","push","getPoint","midPoint","path","getPath","getPointAtLength","t","getNormal","tan","per","uni","toFixed","getNormalAtLength","getClosestPointTo","point","closestT","closestPoint","closestDistance","distance","Dist","step","update","_objectSpread"],"sources":["/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@tldraw/primitives/src/lib/BaseSegment2d.ts"],"sourcesContent":["import { Box2d } from './Box2d'\nimport { Vec2d, VecLike } from './Vec2d'\n\n/**\n * A base segment used for cubic and quadradic curves.\n *\n * @public\n */\nexport abstract class BaseSegment2d<T extends { p: number }> {\n\tconstructor(values: T) {\n\t\tthis._values = values\n\t}\n\n\t/**\n\t * The segment's values. Do not modify these directly. Instead, use the `values` setter or\n\t * `update` method.\n\t *\n\t * @internal\n\t */\n\tprotected _values: T\n\n\t/**\n\t * A private set of cached values, used for lookups and computations. Changing any of the\n\t * segment's values will clear this object.\n\t *\n\t * @internal\n\t */\n\tprotected _computed: {\n\t\tlength?: number\n\t\tbounds?: Box2d\n\t\tpath?: string\n\t\tlut?: Vec2d[]\n\t\tmidPoint?: Vec2d\n\t} = {}\n\n\t/**\n\t * The values for the curve segment.\n\t *\n\t * @public\n\t */\n\tget values() {\n\t\treturn this._values\n\t}\n\n\tset values(values: T) {\n\t\tthis._values = values\n\t\tthis._computed = {}\n\t}\n\n\t/**\n\t * The length of the curve segment.\n\t *\n\t * @public\n\t */\n\tget length(): number {\n\t\tif (this._computed.length !== undefined) {\n\t\t\treturn this._computed.length\n\t\t}\n\n\t\tconst { lut } = this\n\n\t\tlet prev = lut[0]\n\t\tlet result = 0\n\n\t\tfor (let i = 1; i < lut.length; i++) {\n\t\t\tconst curr = lut[i]\n\t\t\tresult += prev.dist(curr)\n\t\t\tprev = curr\n\t\t}\n\n\t\tthis._computed.length = result\n\n\t\treturn result\n\t}\n\n\t/**\n\t * The bounding box containing the curve segment.\n\t *\n\t * @public\n\t */\n\tget bounds(): Box2d {\n\t\tif (this._computed.bounds !== undefined) {\n\t\t\treturn this._computed.bounds\n\t\t}\n\n\t\tlet minX = Infinity\n\t\tlet minY = Infinity\n\t\tlet maxX = -Infinity\n\t\tlet maxY = -Infinity\n\n\t\tconst { lut } = this\n\n\t\tfor (const pt of lut) {\n\t\t\tminX = Math.min(pt.x, minX)\n\t\t\tminY = Math.min(pt.y, minY)\n\t\t\tmaxX = Math.max(pt.x, maxX)\n\t\t\tmaxY = Math.max(pt.y, maxY)\n\t\t}\n\n\t\tconst result = new Box2d(minX, minY, maxX - minX, maxY - minY)\n\n\t\tthis._computed.bounds = result\n\n\t\treturn result\n\t}\n\n\t/**\n\t * A lookup table consisting of values.p points along the segment. Used to compute lengths,\n\t * closest points, etc. This should only be _computed once (when first requested) per set of\n\t * values.\n\t *\n\t * @public\n\t */\n\tget lut() {\n\t\tif (this._computed.lut) {\n\t\t\treturn this._computed.lut\n\t\t}\n\n\t\tconst { p } = this.values\n\n\t\tconst result: Vec2d[] = []\n\n\t\tfor (let i = 0; i < p + 1; i++) {\n\t\t\tresult.push(this.getPoint(i / p))\n\t\t}\n\n\t\tthis._computed.lut = result\n\n\t\treturn result\n\t}\n\n\t/**\n\t * A point half-way along the length of the segment.\n\t *\n\t * @public\n\t */\n\tget midPoint() {\n\t\tif (this._computed.midPoint) {\n\t\t\treturn this._computed.midPoint\n\t\t}\n\n\t\tconst result = this.getPoint(0.5)\n\n\t\tthis._computed.midPoint = result\n\n\t\treturn result\n\t}\n\n\t/**\n\t * An SVG path for the segment.\n\t *\n\t * @public\n\t */\n\tget path() {\n\t\tif (this._computed.path) {\n\t\t\treturn this._computed.path\n\t\t}\n\n\t\tconst result = this.getPath()\n\n\t\tthis._computed.path = result\n\n\t\treturn result\n\t}\n\n\t/**\n\t * Evaluate a point at a length along the curve segment.\n\t *\n\t * @param length - The length to find the point value.\n\t * @public\n\t */\n\tgetPointAtLength(length: number) {\n\t\tconst t = Math.max(0, Math.min(1, length / this.length))\n\n\t\treturn this.getPoint(t)\n\t}\n\n\t/**\n\t * Get the normal at distance t along the curve segment.\n\t *\n\t * @param t - The distance (0-1) to find the normal.\n\t * @public\n\t */\n\tgetNormal(t: number) {\n\t\treturn this.getPoint(t - 0.0025)\n\t\t\t.tan(this.getPoint(t + 0.0025))\n\t\t\t.per()\n\t\t\t.uni()\n\t\t\t.toFixed()\n\t}\n\n\t/**\n\t * Get the normal at a length along the curve segment.\n\t *\n\t * @param length - The length to find the normal.\n\t * @public\n\t */\n\tgetNormalAtLength(length: number) {\n\t\treturn this.getNormal(length / this.length)\n\t}\n\n\t/**\n\t * Get the closest point on the segment to an arbitrary point.\n\t *\n\t * @param point - The arbitrary point.\n\t * @public\n\t */\n\tgetClosestPointTo(point: VecLike) {\n\t\tconst { lut } = this\n\n\t\tlet closestT = 0\n\t\tlet closestPoint = lut[0]\n\t\tlet closestDistance = lut[0].dist(point)\n\n\t\t// Find the closest\n\t\tfor (let i = 1; i < lut.length; i++) {\n\t\t\tconst distance = Vec2d.Dist(lut[i], point)\n\t\t\tif (distance < closestDistance) {\n\t\t\t\tclosestDistance = distance\n\t\t\t\tclosestPoint = lut[i]\n\t\t\t\tclosestT = i / lut.length\n\t\t\t}\n\t\t}\n\n\t\t// Solve again for the closest point on the segment\n\t\tconst step = 1 / this.values.p\n\n\t\tfor (\n\t\t\tlet t = Math.max(0, closestT - step / 2);\n\t\t\tt < Math.min(1, closestT + step / 2);\n\t\t\tt += step / 10\n\t\t) {\n\t\t\tconst pt = this.getPoint(t)\n\t\t\tconst distance = Vec2d.Dist(pt, point)\n\t\t\tif (distance < closestDistance) {\n\t\t\t\tclosestDistance = distance\n\t\t\t\tclosestPoint = pt\n\t\t\t}\n\t\t}\n\n\t\treturn { point: closestPoint, distance: closestDistance }\n\t}\n\n\t/**\n\t * Set one or more values. Updating the segment will clear cached values.\n\t *\n\t * @param values - A partial of the segment's values object.\n\t * @public\n\t */\n\tupdate(values: Partial<T>) {\n\t\tthis._computed = {}\n\t\tthis.values = { ...this.values, ...values }\n\t}\n\n\t/**\n\t * Get the SVG path data for the segment.\n\t *\n\t * @public\n\t */\n\tabstract getPath(head?: boolean): string\n\n\t/**\n\t * Evaluate a point at distance t along the curve segment.\n\t *\n\t * @param t - The distance (0-1) to find the point.\n\t * @public\n\t */\n\tabstract getPoint(t: number): Vec2d\n\n\t/**\n\t * Evaluate a x value at distance t along the curve segment.\n\t *\n\t * @param t - The distance (0-1) to find the x value.\n\t * @public\n\t */\n\tabstract getX(t: number): number\n\n\t/**\n\t * Evaluate a y value at distance t along the curve segment.\n\t *\n\t * @param t - The distance (0-1) to find the y value.\n\t * @public\n\t */\n\tabstract getY(t: number): number\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}