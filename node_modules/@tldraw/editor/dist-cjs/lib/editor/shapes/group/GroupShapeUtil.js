"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var GroupShapeUtil_exports = {};
__export(GroupShapeUtil_exports, {
  GroupShapeUtil: () => GroupShapeUtil
});
module.exports = __toCommonJS(GroupShapeUtil_exports);
var import_jsx_runtime = require("react/jsx-runtime");
var import_primitives = require("@tldraw/primitives");
var import_SVGContainer = require("../../../components/SVGContainer");
var import_ShapeUtil = require("../ShapeUtil");
var import_DashedOutlineBox = require("../shared/DashedOutlineBox");
class GroupShapeUtil extends import_ShapeUtil.ShapeUtil {
  static type = "group";
  type = "group";
  hideSelectionBoundsBg = () => false;
  hideSelectionBoundsFg = () => true;
  canBind = () => false;
  defaultProps() {
    return {};
  }
  getBounds(shape) {
    const children = this.editor.getSortedChildIds(shape.id);
    if (children.length === 0) {
      return new import_primitives.Box2d();
    }
    const allChildPoints = children.flatMap((childId) => {
      const shape2 = this.editor.getShapeById(childId);
      return this.editor.getOutlineById(childId).map((point) => import_primitives.Matrix2d.applyToPoint(this.editor.getTransform(shape2), point));
    });
    return import_primitives.Box2d.FromPoints(allChildPoints);
  }
  getCenter(shape) {
    return this.bounds(shape).center;
  }
  getOutline(shape) {
    return this.bounds(shape).corners;
  }
  component(shape) {
    const {
      erasingIdsSet,
      pageState: { hintingIds, focusLayerId },
      zoomLevel
    } = this.editor;
    const isErasing = erasingIdsSet.has(shape.id);
    const isHintingOtherGroup = hintingIds.length > 0 && hintingIds.some(
      (id) => id !== shape.id && this.editor.isShapeOfType(this.editor.getShapeById(id), GroupShapeUtil)
    );
    if (
      // always show the outline while we're erasing the group
      !isErasing && // show the outline while the group is focused unless something outside of the group is being hinted
      // this happens dropping shapes from a group onto some outside group
      (shape.id !== focusLayerId || isHintingOtherGroup)
    ) {
      return null;
    }
    const bounds = this.bounds(shape);
    return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_SVGContainer.SVGContainer, { id: shape.id, children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_DashedOutlineBox.DashedOutlineBox, { className: "tl-group", bounds, zoomLevel }) });
  }
  indicator(shape) {
    const {
      camera: { z: zoomLevel }
    } = this.editor;
    const bounds = this.bounds(shape);
    return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_DashedOutlineBox.DashedOutlineBox, { className: "", bounds, zoomLevel });
  }
  onChildrenChange = (group) => {
    const children = this.editor.getSortedChildIds(group.id);
    if (children.length === 0) {
      if (this.editor.pageState.focusLayerId === group.id) {
        this.editor.popFocusLayer();
      }
      this.editor.deleteShapes([group.id]);
      return;
    } else if (children.length === 1) {
      if (this.editor.pageState.focusLayerId === group.id) {
        this.editor.popFocusLayer();
      }
      this.editor.reparentShapesById(children, group.parentId);
      this.editor.deleteShapes([group.id]);
      return;
    }
  };
}
//# sourceMappingURL=GroupShapeUtil.js.map
