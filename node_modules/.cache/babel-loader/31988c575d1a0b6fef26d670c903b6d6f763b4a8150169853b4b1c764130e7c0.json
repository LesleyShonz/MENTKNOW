{"ast":null,"code":"import _defineProperty from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _objectSpread from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _classCallCheck from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _get from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\n/**\n * @module awareness-protocol\n */\n\nimport * as encoding from 'lib0/encoding';\nimport * as decoding from 'lib0/decoding';\nimport * as time from 'lib0/time';\nimport * as math from 'lib0/math';\nimport { Observable } from 'lib0/observable';\nimport * as f from 'lib0/function';\nimport * as Y from 'yjs'; // eslint-disable-line\n\nexport var outdatedTimeout = 30000;\n\n/**\n * @typedef {Object} MetaClientState\n * @property {number} MetaClientState.clock\n * @property {number} MetaClientState.lastUpdated unix timestamp\n */\n\n/**\n * The Awareness class implements a simple shared state protocol that can be used for non-persistent data like awareness information\n * (cursor, username, status, ..). Each client can update its own local state and listen to state changes of\n * remote clients. Every client may set a state of a remote peer to `null` to mark the client as offline.\n *\n * Each client is identified by a unique client id (something we borrow from `doc.clientID`). A client can override\n * its own state by propagating a message with an increasing timestamp (`clock`). If such a message is received, it is\n * applied if the known state of that client is older than the new state (`clock < newClock`). If a client thinks that\n * a remote client is offline, it may propagate a message with\n * `{ clock: currentClientClock, state: null, client: remoteClient }`. If such a\n * message is received, and the known clock of that client equals the received clock, it will override the state with `null`.\n *\n * Before a client disconnects, it should propagate a `null` state with an updated clock.\n *\n * Awareness states must be updated every 30 seconds. Otherwise the Awareness instance will delete the client state.\n *\n * @extends {Observable<string>}\n */\nexport var Awareness = /*#__PURE__*/function (_Observable) {\n  _inherits(Awareness, _Observable);\n  var _super = _createSuper(Awareness);\n  /**\n   * @param {Y.Doc} doc\n   */\n  function Awareness(doc) {\n    var _this;\n    _classCallCheck(this, Awareness);\n    _this = _super.call(this);\n    _this.doc = doc;\n    /**\n     * @type {number}\n     */\n    _this.clientID = doc.clientID;\n    /**\n     * Maps from client id to client state\n     * @type {Map<number, Object<string, any>>}\n     */\n    _this.states = new Map();\n    /**\n     * @type {Map<number, MetaClientState>}\n     */\n    _this.meta = new Map();\n    _this._checkInterval = /** @type {any} */setInterval(function () {\n      var now = time.getUnixTime();\n      if (_this.getLocalState() !== null && outdatedTimeout / 2 <= now - /** @type {{lastUpdated:number}} */_this.meta.get(_this.clientID).lastUpdated) {\n        // renew local clock\n        _this.setLocalState(_this.getLocalState());\n      }\n      /**\n       * @type {Array<number>}\n       */\n      var remove = [];\n      _this.meta.forEach(function (meta, clientid) {\n        if (clientid !== _this.clientID && outdatedTimeout <= now - meta.lastUpdated && _this.states.has(clientid)) {\n          remove.push(clientid);\n        }\n      });\n      if (remove.length > 0) {\n        removeAwarenessStates(_assertThisInitialized(_this), remove, 'timeout');\n      }\n    }, math.floor(outdatedTimeout / 10));\n    doc.on('destroy', function () {\n      _this.destroy();\n    });\n    _this.setLocalState({});\n    return _this;\n  }\n  _createClass(Awareness, [{\n    key: \"destroy\",\n    value: function destroy() {\n      this.emit('destroy', [this]);\n      this.setLocalState(null);\n      _get(_getPrototypeOf(Awareness.prototype), \"destroy\", this).call(this);\n      clearInterval(this._checkInterval);\n    }\n\n    /**\n     * @return {Object<string,any>|null}\n     */\n  }, {\n    key: \"getLocalState\",\n    value: function getLocalState() {\n      return this.states.get(this.clientID) || null;\n    }\n\n    /**\n     * @param {Object<string,any>|null} state\n     */\n  }, {\n    key: \"setLocalState\",\n    value: function setLocalState(state) {\n      var clientID = this.clientID;\n      var currLocalMeta = this.meta.get(clientID);\n      var clock = currLocalMeta === undefined ? 0 : currLocalMeta.clock + 1;\n      var prevState = this.states.get(clientID);\n      if (state === null) {\n        this.states.delete(clientID);\n      } else {\n        this.states.set(clientID, state);\n      }\n      this.meta.set(clientID, {\n        clock: clock,\n        lastUpdated: time.getUnixTime()\n      });\n      var added = [];\n      var updated = [];\n      var filteredUpdated = [];\n      var removed = [];\n      if (state === null) {\n        removed.push(clientID);\n      } else if (prevState == null) {\n        if (state != null) {\n          added.push(clientID);\n        }\n      } else {\n        updated.push(clientID);\n        if (!f.equalityDeep(prevState, state)) {\n          filteredUpdated.push(clientID);\n        }\n      }\n      if (added.length > 0 || filteredUpdated.length > 0 || removed.length > 0) {\n        this.emit('change', [{\n          added: added,\n          updated: filteredUpdated,\n          removed: removed\n        }, 'local']);\n      }\n      this.emit('update', [{\n        added: added,\n        updated: updated,\n        removed: removed\n      }, 'local']);\n    }\n\n    /**\n     * @param {string} field\n     * @param {any} value\n     */\n  }, {\n    key: \"setLocalStateField\",\n    value: function setLocalStateField(field, value) {\n      var state = this.getLocalState();\n      if (state !== null) {\n        this.setLocalState(_objectSpread(_objectSpread({}, state), {}, _defineProperty({}, field, value)));\n      }\n    }\n\n    /**\n     * @return {Map<number,Object<string,any>>}\n     */\n  }, {\n    key: \"getStates\",\n    value: function getStates() {\n      return this.states;\n    }\n  }]);\n  return Awareness;\n}(Observable);\n\n/**\n * Mark (remote) clients as inactive and remove them from the list of active peers.\n * This change will be propagated to remote clients.\n *\n * @param {Awareness} awareness\n * @param {Array<number>} clients\n * @param {any} origin\n */\nexport var removeAwarenessStates = function removeAwarenessStates(awareness, clients, origin) {\n  var removed = [];\n  for (var i = 0; i < clients.length; i++) {\n    var clientID = clients[i];\n    if (awareness.states.has(clientID)) {\n      awareness.states.delete(clientID);\n      if (clientID === awareness.clientID) {\n        var curMeta = /** @type {MetaClientState} */awareness.meta.get(clientID);\n        awareness.meta.set(clientID, {\n          clock: curMeta.clock + 1,\n          lastUpdated: time.getUnixTime()\n        });\n      }\n      removed.push(clientID);\n    }\n  }\n  if (removed.length > 0) {\n    awareness.emit('change', [{\n      added: [],\n      updated: [],\n      removed: removed\n    }, origin]);\n    awareness.emit('update', [{\n      added: [],\n      updated: [],\n      removed: removed\n    }, origin]);\n  }\n};\n\n/**\n * @param {Awareness} awareness\n * @param {Array<number>} clients\n * @return {Uint8Array}\n */\nexport var encodeAwarenessUpdate = function encodeAwarenessUpdate(awareness, clients) {\n  var states = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : awareness.states;\n  var len = clients.length;\n  var encoder = encoding.createEncoder();\n  encoding.writeVarUint(encoder, len);\n  for (var i = 0; i < len; i++) {\n    var clientID = clients[i];\n    var state = states.get(clientID) || null;\n    var clock = /** @type {MetaClientState} */awareness.meta.get(clientID).clock;\n    encoding.writeVarUint(encoder, clientID);\n    encoding.writeVarUint(encoder, clock);\n    encoding.writeVarString(encoder, JSON.stringify(state));\n  }\n  return encoding.toUint8Array(encoder);\n};\n\n/**\n * Modify the content of an awareness update before re-encoding it to an awareness update.\n *\n * This might be useful when you have a central server that wants to ensure that clients\n * cant hijack somebody elses identity.\n *\n * @param {Uint8Array} update\n * @param {function(any):any} modify\n * @return {Uint8Array}\n */\nexport var modifyAwarenessUpdate = function modifyAwarenessUpdate(update, modify) {\n  var decoder = decoding.createDecoder(update);\n  var encoder = encoding.createEncoder();\n  var len = decoding.readVarUint(decoder);\n  encoding.writeVarUint(encoder, len);\n  for (var i = 0; i < len; i++) {\n    var clientID = decoding.readVarUint(decoder);\n    var clock = decoding.readVarUint(decoder);\n    var state = JSON.parse(decoding.readVarString(decoder));\n    var modifiedState = modify(state);\n    encoding.writeVarUint(encoder, clientID);\n    encoding.writeVarUint(encoder, clock);\n    encoding.writeVarString(encoder, JSON.stringify(modifiedState));\n  }\n  return encoding.toUint8Array(encoder);\n};\n\n/**\n * @param {Awareness} awareness\n * @param {Uint8Array} update\n * @param {any} origin This will be added to the emitted change event\n */\nexport var applyAwarenessUpdate = function applyAwarenessUpdate(awareness, update, origin) {\n  var decoder = decoding.createDecoder(update);\n  var timestamp = time.getUnixTime();\n  var added = [];\n  var updated = [];\n  var filteredUpdated = [];\n  var removed = [];\n  var len = decoding.readVarUint(decoder);\n  for (var i = 0; i < len; i++) {\n    var clientID = decoding.readVarUint(decoder);\n    var clock = decoding.readVarUint(decoder);\n    var state = JSON.parse(decoding.readVarString(decoder));\n    var clientMeta = awareness.meta.get(clientID);\n    var prevState = awareness.states.get(clientID);\n    var currClock = clientMeta === undefined ? 0 : clientMeta.clock;\n    if (currClock < clock || currClock === clock && state === null && awareness.states.has(clientID)) {\n      if (state === null) {\n        // never let a remote client remove this local state\n        if (clientID === awareness.clientID && awareness.getLocalState() != null) {\n          // remote client removed the local state. Do not remote state. Broadcast a message indicating\n          // that this client still exists by increasing the clock\n          clock++;\n        } else {\n          awareness.states.delete(clientID);\n        }\n      } else {\n        awareness.states.set(clientID, state);\n      }\n      awareness.meta.set(clientID, {\n        clock: clock,\n        lastUpdated: timestamp\n      });\n      if (clientMeta === undefined && state !== null) {\n        added.push(clientID);\n      } else if (clientMeta !== undefined && state === null) {\n        removed.push(clientID);\n      } else if (state !== null) {\n        if (!f.equalityDeep(state, prevState)) {\n          filteredUpdated.push(clientID);\n        }\n        updated.push(clientID);\n      }\n    }\n  }\n  if (added.length > 0 || filteredUpdated.length > 0 || removed.length > 0) {\n    awareness.emit('change', [{\n      added: added,\n      updated: filteredUpdated,\n      removed: removed\n    }, origin]);\n  }\n  if (added.length > 0 || updated.length > 0 || removed.length > 0) {\n    awareness.emit('update', [{\n      added: added,\n      updated: updated,\n      removed: removed\n    }, origin]);\n  }\n};","map":{"version":3,"names":["encoding","decoding","time","math","Observable","f","Y","outdatedTimeout","Awareness","_Observable","_inherits","_super","_createSuper","doc","_this","_classCallCheck","call","clientID","states","Map","meta","_checkInterval","setInterval","now","getUnixTime","getLocalState","get","lastUpdated","setLocalState","remove","forEach","clientid","has","push","length","removeAwarenessStates","_assertThisInitialized","floor","on","destroy","_createClass","key","value","emit","_get","_getPrototypeOf","prototype","clearInterval","state","currLocalMeta","clock","undefined","prevState","delete","set","added","updated","filteredUpdated","removed","equalityDeep","setLocalStateField","field","_objectSpread","_defineProperty","getStates","awareness","clients","origin","i","curMeta","encodeAwarenessUpdate","arguments","len","encoder","createEncoder","writeVarUint","writeVarString","JSON","stringify","toUint8Array","modifyAwarenessUpdate","update","modify","decoder","createDecoder","readVarUint","parse","readVarString","modifiedState","applyAwarenessUpdate","timestamp","clientMeta","currClock"],"sources":["/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/y-protocols/awareness.js"],"sourcesContent":["/**\n * @module awareness-protocol\n */\n\nimport * as encoding from 'lib0/encoding'\nimport * as decoding from 'lib0/decoding'\nimport * as time from 'lib0/time'\nimport * as math from 'lib0/math'\nimport { Observable } from 'lib0/observable'\nimport * as f from 'lib0/function'\nimport * as Y from 'yjs' // eslint-disable-line\n\nexport const outdatedTimeout = 30000\n\n/**\n * @typedef {Object} MetaClientState\n * @property {number} MetaClientState.clock\n * @property {number} MetaClientState.lastUpdated unix timestamp\n */\n\n/**\n * The Awareness class implements a simple shared state protocol that can be used for non-persistent data like awareness information\n * (cursor, username, status, ..). Each client can update its own local state and listen to state changes of\n * remote clients. Every client may set a state of a remote peer to `null` to mark the client as offline.\n *\n * Each client is identified by a unique client id (something we borrow from `doc.clientID`). A client can override\n * its own state by propagating a message with an increasing timestamp (`clock`). If such a message is received, it is\n * applied if the known state of that client is older than the new state (`clock < newClock`). If a client thinks that\n * a remote client is offline, it may propagate a message with\n * `{ clock: currentClientClock, state: null, client: remoteClient }`. If such a\n * message is received, and the known clock of that client equals the received clock, it will override the state with `null`.\n *\n * Before a client disconnects, it should propagate a `null` state with an updated clock.\n *\n * Awareness states must be updated every 30 seconds. Otherwise the Awareness instance will delete the client state.\n *\n * @extends {Observable<string>}\n */\nexport class Awareness extends Observable {\n  /**\n   * @param {Y.Doc} doc\n   */\n  constructor (doc) {\n    super()\n    this.doc = doc\n    /**\n     * @type {number}\n     */\n    this.clientID = doc.clientID\n    /**\n     * Maps from client id to client state\n     * @type {Map<number, Object<string, any>>}\n     */\n    this.states = new Map()\n    /**\n     * @type {Map<number, MetaClientState>}\n     */\n    this.meta = new Map()\n    this._checkInterval = /** @type {any} */ (setInterval(() => {\n      const now = time.getUnixTime()\n      if (this.getLocalState() !== null && (outdatedTimeout / 2 <= now - /** @type {{lastUpdated:number}} */ (this.meta.get(this.clientID)).lastUpdated)) {\n        // renew local clock\n        this.setLocalState(this.getLocalState())\n      }\n      /**\n       * @type {Array<number>}\n       */\n      const remove = []\n      this.meta.forEach((meta, clientid) => {\n        if (clientid !== this.clientID && outdatedTimeout <= now - meta.lastUpdated && this.states.has(clientid)) {\n          remove.push(clientid)\n        }\n      })\n      if (remove.length > 0) {\n        removeAwarenessStates(this, remove, 'timeout')\n      }\n    }, math.floor(outdatedTimeout / 10)))\n    doc.on('destroy', () => {\n      this.destroy()\n    })\n    this.setLocalState({})\n  }\n\n  destroy () {\n    this.emit('destroy', [this])\n    this.setLocalState(null)\n    super.destroy()\n    clearInterval(this._checkInterval)\n  }\n\n  /**\n   * @return {Object<string,any>|null}\n   */\n  getLocalState () {\n    return this.states.get(this.clientID) || null\n  }\n\n  /**\n   * @param {Object<string,any>|null} state\n   */\n  setLocalState (state) {\n    const clientID = this.clientID\n    const currLocalMeta = this.meta.get(clientID)\n    const clock = currLocalMeta === undefined ? 0 : currLocalMeta.clock + 1\n    const prevState = this.states.get(clientID)\n    if (state === null) {\n      this.states.delete(clientID)\n    } else {\n      this.states.set(clientID, state)\n    }\n    this.meta.set(clientID, {\n      clock,\n      lastUpdated: time.getUnixTime()\n    })\n    const added = []\n    const updated = []\n    const filteredUpdated = []\n    const removed = []\n    if (state === null) {\n      removed.push(clientID)\n    } else if (prevState == null) {\n      if (state != null) {\n        added.push(clientID)\n      }\n    } else {\n      updated.push(clientID)\n      if (!f.equalityDeep(prevState, state)) {\n        filteredUpdated.push(clientID)\n      }\n    }\n    if (added.length > 0 || filteredUpdated.length > 0 || removed.length > 0) {\n      this.emit('change', [{ added, updated: filteredUpdated, removed }, 'local'])\n    }\n    this.emit('update', [{ added, updated, removed }, 'local'])\n  }\n\n  /**\n   * @param {string} field\n   * @param {any} value\n   */\n  setLocalStateField (field, value) {\n    const state = this.getLocalState()\n    if (state !== null) {\n      this.setLocalState({\n        ...state,\n        [field]: value\n      })\n    }\n  }\n\n  /**\n   * @return {Map<number,Object<string,any>>}\n   */\n  getStates () {\n    return this.states\n  }\n}\n\n/**\n * Mark (remote) clients as inactive and remove them from the list of active peers.\n * This change will be propagated to remote clients.\n *\n * @param {Awareness} awareness\n * @param {Array<number>} clients\n * @param {any} origin\n */\nexport const removeAwarenessStates = (awareness, clients, origin) => {\n  const removed = []\n  for (let i = 0; i < clients.length; i++) {\n    const clientID = clients[i]\n    if (awareness.states.has(clientID)) {\n      awareness.states.delete(clientID)\n      if (clientID === awareness.clientID) {\n        const curMeta = /** @type {MetaClientState} */ (awareness.meta.get(clientID))\n        awareness.meta.set(clientID, {\n          clock: curMeta.clock + 1,\n          lastUpdated: time.getUnixTime()\n        })\n      }\n      removed.push(clientID)\n    }\n  }\n  if (removed.length > 0) {\n    awareness.emit('change', [{ added: [], updated: [], removed }, origin])\n    awareness.emit('update', [{ added: [], updated: [], removed }, origin])\n  }\n}\n\n/**\n * @param {Awareness} awareness\n * @param {Array<number>} clients\n * @return {Uint8Array}\n */\nexport const encodeAwarenessUpdate = (awareness, clients, states = awareness.states) => {\n  const len = clients.length\n  const encoder = encoding.createEncoder()\n  encoding.writeVarUint(encoder, len)\n  for (let i = 0; i < len; i++) {\n    const clientID = clients[i]\n    const state = states.get(clientID) || null\n    const clock = /** @type {MetaClientState} */ (awareness.meta.get(clientID)).clock\n    encoding.writeVarUint(encoder, clientID)\n    encoding.writeVarUint(encoder, clock)\n    encoding.writeVarString(encoder, JSON.stringify(state))\n  }\n  return encoding.toUint8Array(encoder)\n}\n\n/**\n * Modify the content of an awareness update before re-encoding it to an awareness update.\n *\n * This might be useful when you have a central server that wants to ensure that clients\n * cant hijack somebody elses identity.\n *\n * @param {Uint8Array} update\n * @param {function(any):any} modify\n * @return {Uint8Array}\n */\nexport const modifyAwarenessUpdate = (update, modify) => {\n  const decoder = decoding.createDecoder(update)\n  const encoder = encoding.createEncoder()\n  const len = decoding.readVarUint(decoder)\n  encoding.writeVarUint(encoder, len)\n  for (let i = 0; i < len; i++) {\n    const clientID = decoding.readVarUint(decoder)\n    const clock = decoding.readVarUint(decoder)\n    const state = JSON.parse(decoding.readVarString(decoder))\n    const modifiedState = modify(state)\n    encoding.writeVarUint(encoder, clientID)\n    encoding.writeVarUint(encoder, clock)\n    encoding.writeVarString(encoder, JSON.stringify(modifiedState))\n  }\n  return encoding.toUint8Array(encoder)\n}\n\n/**\n * @param {Awareness} awareness\n * @param {Uint8Array} update\n * @param {any} origin This will be added to the emitted change event\n */\nexport const applyAwarenessUpdate = (awareness, update, origin) => {\n  const decoder = decoding.createDecoder(update)\n  const timestamp = time.getUnixTime()\n  const added = []\n  const updated = []\n  const filteredUpdated = []\n  const removed = []\n  const len = decoding.readVarUint(decoder)\n  for (let i = 0; i < len; i++) {\n    const clientID = decoding.readVarUint(decoder)\n    let clock = decoding.readVarUint(decoder)\n    const state = JSON.parse(decoding.readVarString(decoder))\n    const clientMeta = awareness.meta.get(clientID)\n    const prevState = awareness.states.get(clientID)\n    const currClock = clientMeta === undefined ? 0 : clientMeta.clock\n    if (currClock < clock || (currClock === clock && state === null && awareness.states.has(clientID))) {\n      if (state === null) {\n        // never let a remote client remove this local state\n        if (clientID === awareness.clientID && awareness.getLocalState() != null) {\n          // remote client removed the local state. Do not remote state. Broadcast a message indicating\n          // that this client still exists by increasing the clock\n          clock++\n        } else {\n          awareness.states.delete(clientID)\n        }\n      } else {\n        awareness.states.set(clientID, state)\n      }\n      awareness.meta.set(clientID, {\n        clock,\n        lastUpdated: timestamp\n      })\n      if (clientMeta === undefined && state !== null) {\n        added.push(clientID)\n      } else if (clientMeta !== undefined && state === null) {\n        removed.push(clientID)\n      } else if (state !== null) {\n        if (!f.equalityDeep(state, prevState)) {\n          filteredUpdated.push(clientID)\n        }\n        updated.push(clientID)\n      }\n    }\n  }\n  if (added.length > 0 || filteredUpdated.length > 0 || removed.length > 0) {\n    awareness.emit('change', [{\n      added, updated: filteredUpdated, removed\n    }, origin])\n  }\n  if (added.length > 0 || updated.length > 0 || removed.length > 0) {\n    awareness.emit('update', [{\n      added, updated, removed\n    }, origin])\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}