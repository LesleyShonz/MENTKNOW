{"ast":null,"code":"import _regeneratorRuntime from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _toArray from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/toArray.js\";\nimport _toConsumableArray from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _slicedToArray from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _objectSpread from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _createForOfIteratorHelper from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _inherits from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _defineProperty from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __decorateClass = function __decorateClass(decorators, target, key, kind) {\n  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;\n  for (var i = decorators.length - 1, decorator; i >= 0; i--) if (decorator = decorators[i]) result = (kind ? decorator(target, key, result) : decorator(result)) || result;\n  if (kind && result) __defProp(target, key, result);\n  return result;\n};\nimport { getIndexAbove, getIndexBetween, getIndices, getIndicesAbove, getIndicesBetween, sortByIndex } from \"@tldraw/indices\";\nimport { Box2d, EASINGS, Matrix2d, PI2, Vec2d, approximately, areAnglesCompatible, clamp, intersectPolygonPolygon, pointInPolygon } from \"@tldraw/primitives\";\nimport { CameraRecordType, DefaultColorStyle, DefaultFontStyle, InstancePageStateRecordType, PageRecordType, TLDOCUMENT_ID, TLINSTANCE_ID, TLPOINTER_ID, createShapeId, getShapePropKeysByStyle, isPageId, isShape, isShapeId } from \"@tldraw/tlschema\";\nimport { annotateError as _annotateError, assert, compact, dedupe, deepCopy, getOwnProperty, hasOwnProperty, objectMapFromEntries, partition, sortById, structuredClone } from \"@tldraw/utils\";\nimport { EventEmitter } from \"eventemitter3\";\nimport { nanoid } from \"nanoid\";\nimport { EMPTY_ARRAY, atom, computed, transact } from \"signia\";\nimport { createTLUser } from \"../config/createTLUser.mjs\";\nimport { checkShapesAndAddCore } from \"../config/defaultShapes.mjs\";\nimport { ANIMATION_MEDIUM_MS, CAMERA_MAX_RENDERING_INTERVAL, CAMERA_MOVING_TIMEOUT, COARSE_DRAG_DISTANCE, COLLABORATOR_TIMEOUT, DEFAULT_ANIMATION_OPTIONS, DRAG_DISTANCE, FOLLOW_CHASE_PAN_SNAP, FOLLOW_CHASE_PAN_UNSNAP, FOLLOW_CHASE_PROPORTION, FOLLOW_CHASE_ZOOM_SNAP, FOLLOW_CHASE_ZOOM_UNSNAP, GRID_INCREMENT, HAND_TOOL_FRICTION, INTERNAL_POINTER_IDS, MAJOR_NUDGE_FACTOR, MAX_PAGES, MAX_SHAPES_PER_PAGE, MAX_ZOOM, MINOR_NUDGE_FACTOR, MIN_ZOOM, SVG_PADDING, ZOOMS } from \"../constants.mjs\";\nimport { exportPatternSvgDefs } from \"../hooks/usePattern.mjs\";\nimport { SharedStyleMap } from \"../utils/SharedStylesMap.mjs\";\nimport { WeakMapCache } from \"../utils/WeakMapCache.mjs\";\nimport { dataUrlToFile } from \"../utils/assets.mjs\";\nimport { getIncrementedName, uniqueId } from \"../utils/data.mjs\";\nimport { applyRotationToSnapshotShapes, getRotationSnapshot } from \"../utils/rotation.mjs\";\nimport { arrowBindingsIndex } from \"./derivations/arrowBindingsIndex.mjs\";\nimport { parentsToChildrenWithIndexes } from \"./derivations/parentsToChildrenWithIndexes.mjs\";\nimport { deriveShapeIdsInCurrentPage } from \"./derivations/shapeIdsInCurrentPage.mjs\";\nimport { ActiveAreaManager, getActiveAreaScreenSpace } from \"./managers/ActiveAreaManager.mjs\";\nimport { ClickManager } from \"./managers/ClickManager.mjs\";\nimport { DprManager } from \"./managers/DprManager.mjs\";\nimport { ExternalContentManager } from \"./managers/ExternalContentManager.mjs\";\nimport { HistoryManager } from \"./managers/HistoryManager.mjs\";\nimport { SnapManager } from \"./managers/SnapManager.mjs\";\nimport { TextManager } from \"./managers/TextManager.mjs\";\nimport { TickManager } from \"./managers/TickManager.mjs\";\nimport { UserPreferencesManager } from \"./managers/UserPreferencesManager.mjs\";\nimport { ShapeUtil } from \"./shapes/ShapeUtil.mjs\";\nimport { ArrowShapeUtil } from \"./shapes/arrow/ArrowShapeUtil.mjs\";\nimport { getCurvedArrowInfo } from \"./shapes/arrow/arrow/curved-arrow.mjs\";\nimport { getArrowTerminalsInArrowSpace, getIsArrowStraight } from \"./shapes/arrow/arrow/shared.mjs\";\nimport { getStraightArrowInfo } from \"./shapes/arrow/arrow/straight-arrow.mjs\";\nimport { FrameShapeUtil } from \"./shapes/frame/FrameShapeUtil.mjs\";\nimport { GroupShapeUtil } from \"./shapes/group/GroupShapeUtil.mjs\";\nimport { TextShapeUtil } from \"./shapes/text/TextShapeUtil.mjs\";\nimport { RootState } from \"./tools/RootState.mjs\";\nvar Editor = /*#__PURE__*/function (_EventEmitter) {\n  _inherits(Editor, _EventEmitter);\n  var _super = _createSuper(Editor);\n  function Editor(_ref) {\n    var _this;\n    var store = _ref.store,\n      user = _ref.user,\n      shapes = _ref.shapes,\n      tools = _ref.tools,\n      getContainer = _ref.getContainer;\n    _classCallCheck(this, Editor);\n    _this = _super.call(this);\n    /**\n     * The editor's store\n     *\n     * @public\n     */\n    _defineProperty(_assertThisInitialized(_this), \"store\", void 0);\n    /**\n     * The root state of the statechart.\n     *\n     * @public\n     */\n    _defineProperty(_assertThisInitialized(_this), \"root\", void 0);\n    /**\n     * A set of functions to call when the app is disposed.\n     *\n     * @public\n     */\n    _defineProperty(_assertThisInitialized(_this), \"disposables\", /* @__PURE__ */new Set());\n    /** @internal */\n    _defineProperty(_assertThisInitialized(_this), \"_dprManager\", new DprManager(_assertThisInitialized(_this)));\n    /** @internal */\n    _defineProperty(_assertThisInitialized(_this), \"_activeAreaManager\", new ActiveAreaManager(_assertThisInitialized(_this)));\n    /** @internal */\n    _defineProperty(_assertThisInitialized(_this), \"_tickManager\", new TickManager(_assertThisInitialized(_this)));\n    /** @internal */\n    _defineProperty(_assertThisInitialized(_this), \"_updateDepth\", 0);\n    /** @public */\n    _defineProperty(_assertThisInitialized(_this), \"externalContentManager\", new ExternalContentManager(_assertThisInitialized(_this)));\n    /**\n     * A manager for the app's snapping feature.\n     *\n     * @public\n     */\n    _defineProperty(_assertThisInitialized(_this), \"snaps\", new SnapManager(_assertThisInitialized(_this)));\n    /**\n     * A manager for the user and their preferences.\n     *\n     * @public\n     */\n    _defineProperty(_assertThisInitialized(_this), \"user\", void 0);\n    /**\n     * Whether the editor is running in Safari.\n     *\n     * @public\n     */\n    _defineProperty(_assertThisInitialized(_this), \"isSafari\", void 0);\n    /**\n     * Whether the editor is running on iOS.\n     *\n     * @public\n     */\n    _defineProperty(_assertThisInitialized(_this), \"isIos\", void 0);\n    /**\n     * Whether the editor is running on iOS.\n     *\n     * @public\n     */\n    _defineProperty(_assertThisInitialized(_this), \"isChromeForIos\", void 0);\n    /**\n     * The current HTML element containing the editor.\n     *\n     * @example\n     * ```ts\n     * const container = editor.getContainer()\n     * ```\n     *\n     * @public\n     */\n    _defineProperty(_assertThisInitialized(_this), \"getContainer\", void 0);\n    /**\n     * A manager for the app's history.\n     *\n     * @readonly\n     */\n    _defineProperty(_assertThisInitialized(_this), \"history\", new HistoryManager(_assertThisInitialized(_this), function () {\n      return _this._complete();\n    }, function (error) {\n      _this.annotateError(error, {\n        origin: \"history.batch\",\n        willCrashApp: true\n      });\n      _this.crash(error);\n    }));\n    /**\n     * A map of shape utility classes (TLShapeUtils) by shape type.\n     *\n     * @public\n     */\n    _defineProperty(_assertThisInitialized(_this), \"shapeUtils\", void 0);\n    /**\n     * A derived map containing all current styles among the user's selected shapes.\n     *\n     * @internal\n     */\n    _defineProperty(_assertThisInitialized(_this), \"_selectionSharedStyles\", computed(\"_selectionSharedStyles\", function () {\n      var _assertThisInitialize = _assertThisInitialized(_this),\n        selectedShapes = _assertThisInitialize.selectedShapes;\n      var sharedStyles = new SharedStyleMap();\n      var _iterator = _createForOfIteratorHelper(selectedShapes),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var selectedShape = _step.value;\n          _this._extractSharedStyles(selectedShape, sharedStyles);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return sharedStyles;\n    }));\n    /**\n     * _invalidParents is used to trigger the 'onChildrenChange' callback that shapes can have.\n     *\n     * @internal\n     */\n    _defineProperty(_assertThisInitialized(_this), \"_invalidParents\", /* @__PURE__ */new Set());\n    /** @internal */\n    _defineProperty(_assertThisInitialized(_this), \"_crashingError\", null);\n    /* ----------------- Internal State ----------------- */\n    _defineProperty(_assertThisInitialized(_this), \"_canMoveCamera\", atom(\"can move camera\", true));\n    _defineProperty(_assertThisInitialized(_this), \"_isFocused\", atom(\"_isFocused\", false));\n    // Coarse Pointer\n    /** @internal */\n    _defineProperty(_assertThisInitialized(_this), \"_isCoarsePointer\", atom(\"isCoarsePointer\", false));\n    // Menus\n    _defineProperty(_assertThisInitialized(_this), \"_openMenus\", atom(\"open-menus\", []));\n    // Changing style\n    /** @internal */\n    _defineProperty(_assertThisInitialized(_this), \"_isChangingStyle\", atom(\"isChangingStyle\", false));\n    /** @internal */\n    _defineProperty(_assertThisInitialized(_this), \"_isChangingStyleTimeout\", -1);\n    // Pen Mode\n    /** @internal */\n    _defineProperty(_assertThisInitialized(_this), \"_isPenMode\", atom(\"isPenMode\", false));\n    /** @internal */\n    _defineProperty(_assertThisInitialized(_this), \"_touchEventsRemainingBeforeExitingPenMode\", 0);\n    // Read only\n    _defineProperty(_assertThisInitialized(_this), \"_isReadOnly\", atom(\"isReadOnly\", false));\n    /**\n     * A cache of shape ids in the current page.\n     *\n     * @internal\n     */\n    _defineProperty(_assertThisInitialized(_this), \"_currentPageShapeIds\", void 0);\n    /** @internal */\n    _defineProperty(_assertThisInitialized(_this), \"_setSelectedIds\", _this.history.createCommand(\"setSelectedIds\", function (ids) {\n      var squashing = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var prevSelectedIds = _this.pageState.selectedIds;\n      var prevSet = new Set(_this.pageState.selectedIds);\n      if (ids.length === prevSet.size && ids.every(function (id) {\n        return prevSet.has(id);\n      })) return null;\n      return {\n        data: {\n          ids: ids,\n          prevSelectedIds: prevSelectedIds\n        },\n        squashing: squashing,\n        preservesRedoStack: true\n      };\n    }, {\n      do: function _do(_ref2) {\n        var ids = _ref2.ids;\n        _this.store.update(_this.pageState.id, function (state) {\n          return _objectSpread(_objectSpread({}, state), {}, {\n            selectedIds: ids\n          });\n        });\n      },\n      undo: function undo(_ref3) {\n        var prevSelectedIds = _ref3.prevSelectedIds;\n        _this.store.update(_this.pageState.id, function () {\n          return _objectSpread(_objectSpread({}, _this.pageState), {}, {\n            selectedIds: prevSelectedIds\n          });\n        });\n      },\n      squash: function squash(prev, next) {\n        return {\n          ids: next.ids,\n          prevSelectedIds: prev.prevSelectedIds\n        };\n      }\n    }));\n    /** @internal */\n    _defineProperty(_assertThisInitialized(_this), \"_setFocusLayer\", _this.history.createCommand(\"setFocusLayer\", function (next) {\n      if (next === null && !_this.canUndo) {\n        return;\n      }\n      var prev = _this.pageState.focusLayerId;\n      return {\n        data: {\n          prev: prev,\n          next: next\n        },\n        preservesRedoStack: true,\n        squashing: true\n      };\n    }, {\n      do: function _do(_ref4) {\n        var next = _ref4.next;\n        _this.store.update(_this.pageState.id, function (s) {\n          return _objectSpread(_objectSpread({}, s), {}, {\n            focusLayerId: next\n          });\n        });\n      },\n      undo: function undo(_ref5) {\n        var prev = _ref5.prev;\n        _this.store.update(_this.pageState.id, function (s) {\n          return _objectSpread(_objectSpread({}, s), {}, {\n            focusLayerId: prev\n          });\n        });\n      },\n      squash: function squash(_ref6, _ref7) {\n        var prev = _ref6.prev;\n        var next = _ref7.next;\n        return {\n          prev: prev,\n          next: next\n        };\n      }\n    }));\n    /* -------- Rendering Shapes / rendering Bounds ------- */\n    _defineProperty(_assertThisInitialized(_this), \"_cameraState\", atom(\"camera state\", \"idle\"));\n    // Camera state does two things: first, it allows us to subscribe to whether\n    // the camera is moving or not; and second, it allows us to update the rendering\n    // shapes on the canvas. Changing the rendering shapes may cause shapes to\n    // unmount / remount in the DOM, which is expensive; and computing visibility is\n    // also expensive in large projects. For this reason, we use a second bounding\n    // box just for rendering, and we only update after the camera stops moving.\n    _defineProperty(_assertThisInitialized(_this), \"_cameraStateTimeoutRemaining\", 0);\n    _defineProperty(_assertThisInitialized(_this), \"_lastUpdateRenderingBoundsTimestamp\", Date.now());\n    _defineProperty(_assertThisInitialized(_this), \"_decayCameraStateTimeout\", function (elapsed) {\n      _this._cameraStateTimeoutRemaining -= elapsed;\n      if (_this._cameraStateTimeoutRemaining <= 0) {\n        _this.off(\"tick\", _this._decayCameraStateTimeout);\n        _this._cameraState.set(\"idle\");\n        _this.updateRenderingBounds();\n      }\n    });\n    _defineProperty(_assertThisInitialized(_this), \"_tickCameraState\", function () {\n      _this._cameraStateTimeoutRemaining = CAMERA_MOVING_TIMEOUT;\n      var now = Date.now();\n      if (_this._cameraState.__unsafe__getWithoutCapture() === \"idle\") {\n        _this._lastUpdateRenderingBoundsTimestamp = now;\n        _this._cameraState.set(\"moving\");\n        _this.on(\"tick\", _this._decayCameraStateTimeout);\n      } else {\n        if (now - _this._lastUpdateRenderingBoundsTimestamp > CAMERA_MAX_RENDERING_INTERVAL) {\n          _this.updateRenderingBounds();\n        }\n      }\n    });\n    /** @internal */\n    _defineProperty(_assertThisInitialized(_this), \"_renderingBounds\", atom(\"rendering viewport\", new Box2d()));\n    /** @internal */\n    _defineProperty(_assertThisInitialized(_this), \"_renderingBoundsExpanded\", atom(\"rendering viewport expanded\", new Box2d()));\n    /* --------------------- Inputs --------------------- */\n    /**\n     * The app's current input state.\n     *\n     * @public\n     */\n    _defineProperty(_assertThisInitialized(_this), \"inputs\", {\n      /** The most recent pointer down's position in page space. */\n      originPagePoint: new Vec2d(),\n      /** The most recent pointer down's position in screen space. */\n      originScreenPoint: new Vec2d(),\n      /** The previous pointer position in page space. */\n      previousPagePoint: new Vec2d(),\n      /** The previous pointer position in screen space. */\n      previousScreenPoint: new Vec2d(),\n      /** The most recent pointer position in page space. */\n      currentPagePoint: new Vec2d(),\n      /** The most recent pointer position in screen space. */\n      currentScreenPoint: new Vec2d(),\n      /** A set containing the currently pressed keys. */\n      keys: /* @__PURE__ */new Set(),\n      /** A set containing the currently pressed buttons. */\n      buttons: /* @__PURE__ */new Set(),\n      /** Whether the input is from a pe. */\n      isPen: false,\n      /** Whether the shift key is currently pressed. */\n      shiftKey: false,\n      /** Whether the control or command key is currently pressed. */\n      ctrlKey: false,\n      /** Whether the alt or option key is currently pressed. */\n      altKey: false,\n      /** Whether the user is dragging. */\n      isDragging: false,\n      /** Whether the user is pointing. */\n      isPointing: false,\n      /** Whether the user is pinching. */\n      isPinching: false,\n      /** Whether the user is editing. */\n      isEditing: false,\n      /** Whether the user is panning. */\n      isPanning: false,\n      /** Velocity of mouse pointer, in pixels per millisecond */\n      pointerVelocity: new Vec2d()\n    });\n    /* --------------------- Events --------------------- */\n    /**\n     * A manager for recording multiple click events.\n     *\n     * @internal\n     */\n    _defineProperty(_assertThisInitialized(_this), \"_clickManager\", new ClickManager(_assertThisInitialized(_this)));\n    /**\n     * The previous cursor. Used for restoring the cursor after pan events.\n     *\n     * @internal\n     */\n    _defineProperty(_assertThisInitialized(_this), \"_prevCursor\", \"default\");\n    /** @internal */\n    _defineProperty(_assertThisInitialized(_this), \"_shiftKeyTimeout\", -1);\n    /** @internal */\n    _defineProperty(_assertThisInitialized(_this), \"_setShiftKeyTimeout\", function () {\n      _this.inputs.shiftKey = false;\n      _this.dispatch({\n        type: \"keyboard\",\n        name: \"key_up\",\n        key: \"Shift\",\n        shiftKey: _this.inputs.shiftKey,\n        ctrlKey: _this.inputs.ctrlKey,\n        altKey: _this.inputs.altKey,\n        code: \"ShiftLeft\"\n      });\n    });\n    /** @internal */\n    _defineProperty(_assertThisInitialized(_this), \"_altKeyTimeout\", -1);\n    /** @internal */\n    _defineProperty(_assertThisInitialized(_this), \"_setAltKeyTimeout\", function () {\n      _this.inputs.altKey = false;\n      _this.dispatch({\n        type: \"keyboard\",\n        name: \"key_up\",\n        key: \"Alt\",\n        shiftKey: _this.inputs.shiftKey,\n        ctrlKey: _this.inputs.ctrlKey,\n        altKey: _this.inputs.altKey,\n        code: \"AltLeft\"\n      });\n    });\n    /** @internal */\n    _defineProperty(_assertThisInitialized(_this), \"_ctrlKeyTimeout\", -1);\n    /** @internal */\n    _defineProperty(_assertThisInitialized(_this), \"_setCtrlKeyTimeout\", function () {\n      _this.inputs.ctrlKey = false;\n      _this.dispatch({\n        type: \"keyboard\",\n        name: \"key_up\",\n        key: \"Ctrl\",\n        shiftKey: _this.inputs.shiftKey,\n        ctrlKey: _this.inputs.ctrlKey,\n        altKey: _this.inputs.altKey,\n        code: \"ControlLeft\"\n      });\n    });\n    /** @internal */\n    _defineProperty(_assertThisInitialized(_this), \"_restoreToolId\", \"select\");\n    /** @internal */\n    _defineProperty(_assertThisInitialized(_this), \"_pinchStart\", 1);\n    /** @internal */\n    _defineProperty(_assertThisInitialized(_this), \"_didPinch\", false);\n    /** @internal */\n    _defineProperty(_assertThisInitialized(_this), \"_selectedIdsAtPointerDown\", []);\n    /** @internal */\n    _defineProperty(_assertThisInitialized(_this), \"capturedPointerId\", null);\n    /** @internal */\n    _defineProperty(_assertThisInitialized(_this), \"_createShapes\", _this.history.createCommand(\"createShapes\", function (partials) {\n      var select = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      if (_this.isReadOnly) return null;\n      if (partials.length <= 0) return null;\n      var _assertThisInitialize2 = _assertThisInitialized(_this),\n        shapeIds = _assertThisInitialize2.currentPageShapeIds,\n        selectedIds = _assertThisInitialize2.selectedIds;\n      var prevSelectedIds = select ? selectedIds : void 0;\n      var maxShapesReached = partials.length + shapeIds.size > MAX_SHAPES_PER_PAGE;\n      if (maxShapesReached) {\n        alertMaxShapes(_assertThisInitialized(_this));\n      }\n      var partialsToCreate = maxShapesReached ? partials.slice(0, MAX_SHAPES_PER_PAGE - shapeIds.size) : partials;\n      if (partialsToCreate.length === 0) return null;\n      return {\n        data: {\n          currentPageId: _this.currentPageId,\n          createdIds: partials.map(function (p) {\n            return p.id;\n          }),\n          prevSelectedIds: prevSelectedIds,\n          partials: partialsToCreate,\n          select: select\n        }\n      };\n    }, {\n      do: function _do(_ref8) {\n        var createdIds = _ref8.createdIds,\n          partials = _ref8.partials,\n          select = _ref8.select;\n        var _assertThisInitialize3 = _assertThisInitialized(_this),\n          focusLayerId = _assertThisInitialize3.focusLayerId;\n        partials = partials.map(function (partial) {\n          if (\n          // No parentId provided\n          !partial.parentId ||\n          // A parentId is proved but the parent is neither a) in the store\n          // or b) among the other creating shape partials\n          !_this.store.get(partial.parentId) && !partials.find(function (p) {\n            return p.id === partial.parentId;\n          })) {\n            var _partial$x, _partial$y;\n            partial = _objectSpread({}, partial);\n            var parentId = _this.getParentIdForNewShapeAtPoint({\n              x: (_partial$x = partial.x) !== null && _partial$x !== void 0 ? _partial$x : 0,\n              y: (_partial$y = partial.y) !== null && _partial$y !== void 0 ? _partial$y : 0\n            }, partial.type);\n            partial.parentId = parentId;\n            if (isShapeId(parentId)) {\n              var _partial$x2, _partial$y2, _partial$rotation;\n              var point = _this.getPointInShapeSpace(_this.getShapeById(parentId), {\n                x: (_partial$x2 = partial.x) !== null && _partial$x2 !== void 0 ? _partial$x2 : 0,\n                y: (_partial$y2 = partial.y) !== null && _partial$y2 !== void 0 ? _partial$y2 : 0\n              });\n              partial.x = point.x;\n              partial.y = point.y;\n              partial.rotation = -_this.getPageRotationById(parentId) + ((_partial$rotation = partial.rotation) !== null && _partial$rotation !== void 0 ? _partial$rotation : 0);\n            }\n            if (partial.parentId === partial.id) {\n              partial.parentId = focusLayerId;\n            }\n            return partial;\n          }\n          return partial;\n        });\n        var parentIndices = /* @__PURE__ */new Map();\n        var shapeRecordsToCreate = [];\n        var _iterator2 = _createForOfIteratorHelper(partials),\n          _step2;\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var _partial$opacity, _partial$parentId2, _this$getShapeUtil$on, _this$getShapeUtil;\n            var partial = _step2.value;\n            var util = _this.getShapeUtil(partial);\n            var index = partial.index;\n            if (!index) {\n              var _partial$parentId;\n              var parentId = (_partial$parentId = partial.parentId) !== null && _partial$parentId !== void 0 ? _partial$parentId : focusLayerId;\n              if (!parentIndices.has(parentId)) {\n                parentIndices.set(parentId, _this.getHighestIndexForParent(parentId));\n              }\n              index = parentIndices.get(parentId);\n              parentIndices.set(parentId, getIndexAbove(index));\n            }\n            var initialProps = util.defaultProps();\n            var _iterator3 = _createForOfIteratorHelper(util.styleProps),\n              _step3;\n            try {\n              for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                var _step3$value = _slicedToArray(_step3.value, 2),\n                  style = _step3$value[0],\n                  propKey = _step3$value[1];\n                ;\n                initialProps[propKey] = _this.getStyleForNextShape(style);\n              }\n            } catch (err) {\n              _iterator3.e(err);\n            } finally {\n              _iterator3.f();\n            }\n            var shapeRecordToCreate = _this.store.schema.types.shape.create(_objectSpread(_objectSpread({}, partial), {}, {\n              index: index,\n              opacity: (_partial$opacity = partial.opacity) !== null && _partial$opacity !== void 0 ? _partial$opacity : _this.instanceState.opacityForNextShape,\n              parentId: (_partial$parentId2 = partial.parentId) !== null && _partial$parentId2 !== void 0 ? _partial$parentId2 : focusLayerId,\n              props: \"props\" in partial ? _objectSpread(_objectSpread({}, initialProps), partial.props) : initialProps\n            }));\n            if (shapeRecordToCreate.index === void 0) {\n              throw Error(\"no index!\");\n            }\n            var next = (_this$getShapeUtil$on = (_this$getShapeUtil = _this.getShapeUtil(shapeRecordToCreate)).onBeforeCreate) === null || _this$getShapeUtil$on === void 0 ? void 0 : _this$getShapeUtil$on.call(_this$getShapeUtil, shapeRecordToCreate);\n            if (next) {\n              shapeRecordToCreate = next;\n            }\n            shapeRecordsToCreate.push(shapeRecordToCreate);\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n        _this.store.put(shapeRecordsToCreate);\n        if (select) {\n          _this.store.update(_this.pageState.id, function (state) {\n            return _objectSpread(_objectSpread({}, state), {}, {\n              selectedIds: createdIds\n            });\n          });\n        }\n      },\n      undo: function undo(_ref9) {\n        var createdIds = _ref9.createdIds,\n          prevSelectedIds = _ref9.prevSelectedIds;\n        _this.store.remove(createdIds);\n        if (prevSelectedIds) {\n          _this.store.update(_this.pageState.id, function (state) {\n            return _objectSpread(_objectSpread({}, state), {}, {\n              selectedIds: prevSelectedIds\n            });\n          });\n        }\n      }\n    }));\n    _defineProperty(_assertThisInitialized(_this), \"animatingShapes\", /* @__PURE__ */new Map());\n    /** @internal */\n    _defineProperty(_assertThisInitialized(_this), \"_updateShapes\", _this.history.createCommand(\"updateShapes\", function (_partials) {\n      var squashing = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      if (_this.isReadOnly) return null;\n      var partials = compact(_partials);\n      var snapshots = Object.fromEntries(compact(partials.map(function (_ref10) {\n        var id = _ref10.id;\n        return _this.getShapeById(id);\n      })).map(function (shape) {\n        return [shape.id, shape];\n      }));\n      if (partials.length <= 0) return null;\n      var updated = compact(partials.map(function (partial) {\n        var _newRecord;\n        var prev = snapshots[partial.id];\n        if (!prev) return null;\n        var newRecord = null;\n        for (var _i = 0, _Object$entries = Object.entries(partial); _i < _Object$entries.length; _i++) {\n          var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),\n            k = _Object$entries$_i[0],\n            v = _Object$entries$_i[1];\n          if (v === void 0) continue;\n          switch (k) {\n            case \"id\":\n            case \"type\":\n            case \"typeName\":\n              {\n                continue;\n              }\n            default:\n              {\n                if (v !== prev[k]) {\n                  if (!newRecord) {\n                    newRecord = _objectSpread({}, prev);\n                  }\n                  if (k === \"props\") {\n                    var nextProps = _objectSpread({}, prev.props);\n                    for (var _i2 = 0, _Object$entries2 = Object.entries(v); _i2 < _Object$entries2.length; _i2++) {\n                      var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i2], 2),\n                        propKey = _Object$entries2$_i[0],\n                        propValue = _Object$entries2$_i[1];\n                      if (propValue === void 0) continue;\n                      nextProps[propKey] = propValue;\n                    }\n                    newRecord.props = nextProps;\n                  } else {\n                    ;\n                    newRecord[k] = v;\n                  }\n                }\n              }\n          }\n        }\n        return (_newRecord = newRecord) !== null && _newRecord !== void 0 ? _newRecord : prev;\n      }));\n      var updates = Object.fromEntries(updated.map(function (shape) {\n        return [shape.id, shape];\n      }));\n      return {\n        data: {\n          snapshots: snapshots,\n          updates: updates\n        },\n        squashing: squashing\n      };\n    }, {\n      do: function _do(_ref11) {\n        var updates = _ref11.updates;\n        var result = Object.values(updates);\n        for (var i = 0; i < result.length; i++) {\n          var _this$getShapeUtil$on2, _this$getShapeUtil2;\n          var shape = result[i];\n          var current = _this.store.get(shape.id);\n          if (!current) continue;\n          var next = (_this$getShapeUtil$on2 = (_this$getShapeUtil2 = _this.getShapeUtil(shape)).onBeforeUpdate) === null || _this$getShapeUtil$on2 === void 0 ? void 0 : _this$getShapeUtil$on2.call(_this$getShapeUtil2, current, shape);\n          if (next) {\n            result[i] = next;\n          }\n        }\n        _this.store.put(result);\n      },\n      undo: function undo(_ref12) {\n        var snapshots = _ref12.snapshots;\n        _this.store.put(Object.values(snapshots));\n      },\n      squash: function squash(prevData, nextData) {\n        return {\n          // keep the oldest snapshots\n          snapshots: _objectSpread(_objectSpread({}, nextData.snapshots), prevData.snapshots),\n          // keep the newest updates\n          updates: _objectSpread(_objectSpread({}, prevData.updates), nextData.updates)\n        };\n      }\n    }));\n    /** @internal */\n    _defineProperty(_assertThisInitialized(_this), \"_deleteShapes\", _this.history.createCommand(\"delete_shapes\", function (ids) {\n      if (_this.isReadOnly) return null;\n      if (ids.length === 0) return null;\n      var prevSelectedIds = _toConsumableArray(_this.pageState.selectedIds);\n      var allIds = new Set(ids);\n      var _iterator4 = _createForOfIteratorHelper(ids),\n        _step4;\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var id = _step4.value;\n          _this.visitDescendants(id, function (childId) {\n            allIds.add(childId);\n          });\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n      var deletedIds = _toConsumableArray(allIds);\n      var arrowBindings = _this._arrowBindingsIndex.value;\n      var snapshots = compact(deletedIds.flatMap(function (id) {\n        var shape = _this.getShapeById(id);\n        var bindings = arrowBindings[id];\n        if (bindings && bindings.length > 0) {\n          return bindings.map(function (_ref13) {\n            var arrowId = _ref13.arrowId;\n            return _this.getShapeById(arrowId);\n          }).concat(shape);\n        }\n        return shape;\n      }));\n      var postSelectedIds = prevSelectedIds.filter(function (id) {\n        return !allIds.has(id);\n      });\n      return {\n        data: {\n          deletedIds: deletedIds,\n          snapshots: snapshots,\n          prevSelectedIds: prevSelectedIds,\n          postSelectedIds: postSelectedIds\n        }\n      };\n    }, {\n      do: function _do(_ref14) {\n        var deletedIds = _ref14.deletedIds,\n          postSelectedIds = _ref14.postSelectedIds;\n        _this.store.remove(deletedIds);\n        _this.store.update(_this.pageState.id, function (state) {\n          return _objectSpread(_objectSpread({}, state), {}, {\n            selectedIds: postSelectedIds\n          });\n        });\n      },\n      undo: function undo(_ref15) {\n        var snapshots = _ref15.snapshots,\n          prevSelectedIds = _ref15.prevSelectedIds;\n        _this.store.put(snapshots);\n        _this.store.update(_this.pageState.id, function (state) {\n          return _objectSpread(_objectSpread({}, state), {}, {\n            selectedIds: prevSelectedIds\n          });\n        });\n      }\n    }));\n    /** @internal */\n    _defineProperty(_assertThisInitialized(_this), \"_updatePage\", _this.history.createCommand(\"updatePage\", function (partial) {\n      var squashing = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      if (_this.isReadOnly) return null;\n      var prev = _this.getPageById(partial.id);\n      if (!prev) return null;\n      return {\n        data: {\n          prev: prev,\n          partial: partial\n        },\n        squashing: squashing\n      };\n    }, {\n      do: function _do(_ref16) {\n        var partial = _ref16.partial;\n        _this.store.update(partial.id, function (page) {\n          return _objectSpread(_objectSpread({}, page), partial);\n        });\n      },\n      undo: function undo(_ref17) {\n        var prev = _ref17.prev,\n          partial = _ref17.partial;\n        _this.store.update(partial.id, function () {\n          return prev;\n        });\n      },\n      squash: function squash(prevData, nextData) {\n        return {\n          prev: _objectSpread(_objectSpread({}, prevData.prev), nextData.prev),\n          partial: nextData.partial\n        };\n      }\n    }));\n    /** @internal */\n    _defineProperty(_assertThisInitialized(_this), \"_createPage\", _this.history.createCommand(\"createPage\", function (title) {\n      var _ref18, _pageInfo, _pageInfo2;\n      var id = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : PageRecordType.createId();\n      var belowPageIndex = arguments.length > 2 ? arguments[2] : undefined;\n      if (_this.isReadOnly) return null;\n      if (_this.pages.length >= MAX_PAGES) return null;\n      var pageInfo = _this.pages;\n      var topIndex = (_ref18 = belowPageIndex !== null && belowPageIndex !== void 0 ? belowPageIndex : (_pageInfo = pageInfo[pageInfo.length - 1]) === null || _pageInfo === void 0 ? void 0 : _pageInfo.index) !== null && _ref18 !== void 0 ? _ref18 : \"a1\";\n      var bottomIndex = (_pageInfo2 = pageInfo[pageInfo.findIndex(function (p) {\n        return p.index === topIndex;\n      }) + 1]) === null || _pageInfo2 === void 0 ? void 0 : _pageInfo2.index;\n      title = getIncrementedName(title, pageInfo.map(function (p) {\n        return p.name;\n      }));\n      var newPage = PageRecordType.create({\n        id: id,\n        name: title,\n        index: bottomIndex && topIndex !== bottomIndex ? getIndexBetween(topIndex, bottomIndex) : getIndexAbove(topIndex)\n      });\n      var newCamera = CameraRecordType.create({\n        id: CameraRecordType.createId(newPage.id)\n      });\n      var newTabPageState = InstancePageStateRecordType.create({\n        id: InstancePageStateRecordType.createId(newPage.id),\n        pageId: newPage.id\n      });\n      return {\n        data: {\n          prevSelectedPageId: _this.currentPageId,\n          newPage: newPage,\n          newTabPageState: newTabPageState,\n          newCamera: newCamera\n        }\n      };\n    }, {\n      do: function _do(_ref19) {\n        var newPage = _ref19.newPage,\n          newTabPageState = _ref19.newTabPageState,\n          newCamera = _ref19.newCamera;\n        _this.store.put([newPage, newCamera, newTabPageState, _objectSpread(_objectSpread({}, _this.instanceState), {}, {\n          currentPageId: newPage.id\n        })]);\n        _this.updateRenderingBounds();\n      },\n      undo: function undo(_ref20) {\n        var newPage = _ref20.newPage,\n          prevSelectedPageId = _ref20.prevSelectedPageId,\n          newTabPageState = _ref20.newTabPageState,\n          newCamera = _ref20.newCamera;\n        if (_this.pages.length === 1) return;\n        _this.store.remove([newTabPageState.id, newPage.id, newCamera.id]);\n        if (_this.store.has(prevSelectedPageId) && _this.currentPageId !== prevSelectedPageId) {\n          _this.store.put([_objectSpread(_objectSpread({}, _this.instanceState), {}, {\n            currentPageId: prevSelectedPageId\n          })]);\n        }\n        _this.updateRenderingBounds();\n      }\n    }));\n    /** @internal */\n    _defineProperty(_assertThisInitialized(_this), \"_deletePage\", _this.history.createCommand(\"delete_page\", function (id) {\n      if (_this.isReadOnly) return null;\n      var _assertThisInitialize4 = _assertThisInitialized(_this),\n        pages = _assertThisInitialize4.pages;\n      if (pages.length === 1) return null;\n      var deletedPage = _this.getPageById(id);\n      var deletedPageStates = _this._pageStates.value.filter(function (s) {\n        return s.pageId === id;\n      });\n      if (!deletedPage) return null;\n      if (id === _this.currentPageId) {\n        var _pages;\n        var index = pages.findIndex(function (page) {\n          return page.id === id;\n        });\n        var next = (_pages = pages[index - 1]) !== null && _pages !== void 0 ? _pages : pages[index + 1];\n        _this.setCurrentPageId(next.id);\n      }\n      return {\n        data: {\n          id: id,\n          deletedPage: deletedPage,\n          deletedPageStates: deletedPageStates\n        }\n      };\n    }, {\n      do: function _do(_ref21) {\n        var deletedPage = _ref21.deletedPage,\n          deletedPageStates = _ref21.deletedPageStates;\n        var _assertThisInitialize5 = _assertThisInitialized(_this),\n          pages = _assertThisInitialize5.pages;\n        if (pages.length === 1) return;\n        if (deletedPage.id === _this.currentPageId) {\n          var _pages2;\n          var index = pages.findIndex(function (page) {\n            return page.id === deletedPage.id;\n          });\n          var next = (_pages2 = pages[index - 1]) !== null && _pages2 !== void 0 ? _pages2 : pages[index + 1];\n          _this.setCurrentPageId(next.id);\n        }\n        _this.store.remove(deletedPageStates.map(function (s) {\n          return s.id;\n        }));\n        _this.store.remove([deletedPage.id]);\n        _this.updateRenderingBounds();\n      },\n      undo: function undo(_ref22) {\n        var deletedPage = _ref22.deletedPage,\n          deletedPageStates = _ref22.deletedPageStates;\n        _this.store.put([deletedPage]);\n        _this.store.put(deletedPageStates);\n        _this.updateRenderingBounds();\n      }\n    }));\n    /** @internal */\n    _defineProperty(_assertThisInitialized(_this), \"_setInstancePageState\", _this.history.createCommand(\"setInstancePageState\", function (partial) {\n      var _partial$id;\n      var ephemeral = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var prev = _this.store.get((_partial$id = partial.id) !== null && _partial$id !== void 0 ? _partial$id : _this.pageState.id);\n      return {\n        data: {\n          prev: prev,\n          partial: partial\n        },\n        ephemeral: ephemeral\n      };\n    }, {\n      do: function _do(_ref23) {\n        var prev = _ref23.prev,\n          partial = _ref23.partial;\n        _this.store.update(prev.id, function (state) {\n          return _objectSpread(_objectSpread({}, state), partial);\n        });\n      },\n      undo: function undo(_ref24) {\n        var prev = _ref24.prev;\n        _this.store.update(prev.id, function () {\n          return prev;\n        });\n      }\n    }));\n    /** @internal */\n    _defineProperty(_assertThisInitialized(_this), \"_createAssets\", _this.history.createCommand(\"createAssets\", function (assets) {\n      if (_this.isReadOnly) return null;\n      if (assets.length <= 0) return null;\n      return {\n        data: {\n          assets: assets\n        }\n      };\n    }, {\n      do: function _do(_ref25) {\n        var assets = _ref25.assets;\n        _this.store.put(assets);\n      },\n      undo: function undo(_ref26) {\n        var assets = _ref26.assets;\n        _this.store.remove(assets.map(function (a) {\n          return a.id;\n        }));\n      }\n    }));\n    /** @internal */\n    _defineProperty(_assertThisInitialized(_this), \"_deleteAssets\", _this.history.createCommand(\"deleteAssets\", function (ids) {\n      if (_this.isReadOnly) return;\n      if (ids.length <= 0) return;\n      var prev = compact(ids.map(function (id) {\n        return _this.store.get(id);\n      }));\n      return {\n        data: {\n          ids: ids,\n          prev: prev\n        }\n      };\n    }, {\n      do: function _do(_ref27) {\n        var ids = _ref27.ids;\n        _this.store.remove(ids);\n      },\n      undo: function undo(_ref28) {\n        var prev = _ref28.prev;\n        _this.store.put(prev);\n      }\n    }));\n    /** @internal */\n    _defineProperty(_assertThisInitialized(_this), \"_updateAssets\", _this.history.createCommand(\"updateAssets\", function (assets) {\n      if (_this.isReadOnly) return;\n      if (assets.length <= 0) return;\n      var snapshots = {};\n      return {\n        data: {\n          snapshots: snapshots,\n          assets: assets\n        }\n      };\n    }, {\n      do: function _do(_ref29) {\n        var assets = _ref29.assets,\n          snapshots = _ref29.snapshots;\n        _this.store.put(assets.map(function (a) {\n          var asset = _this.store.get(a.id);\n          snapshots[a.id] = asset;\n          return _objectSpread(_objectSpread({}, asset), a);\n        }));\n      },\n      undo: function undo(_ref30) {\n        var snapshots = _ref30.snapshots;\n        _this.store.put(Object.values(snapshots));\n      }\n    }));\n    // Parents and children\n    /**\n     * A cache of parents to children.\n     *\n     * @internal\n     */\n    _defineProperty(_assertThisInitialized(_this), \"_parentIdsToChildIds\", void 0);\n    /**\n     * A cache of children for each parent.\n     *\n     * @internal\n     */\n    _defineProperty(_assertThisInitialized(_this), \"_childIdsCache\", new WeakMapCache());\n    /** @internal */\n    _defineProperty(_assertThisInitialized(_this), \"_setCurrentPageId\", _this.history.createCommand(\"setCurrentPage\", function (pageId) {\n      var _ref31 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        _ref31$stopFollowing = _ref31.stopFollowing,\n        stopFollowing = _ref31$stopFollowing === void 0 ? true : _ref31$stopFollowing;\n      if (!_this.store.has(pageId)) {\n        console.error(\"Tried to set the current page id to a page that doesn't exist.\");\n        return;\n      }\n      if (stopFollowing && _this.instanceState.followingUserId) {\n        _this.stopFollowingUser();\n      }\n      return {\n        data: {\n          toId: pageId,\n          fromId: _this.currentPageId\n        },\n        squashing: true,\n        preservesRedoStack: true\n      };\n    }, {\n      do: function _do(_ref32) {\n        var toId = _ref32.toId;\n        if (!_this.store.has(toId)) {\n          return;\n        }\n        if (!_this.getPageStateByPageId(toId)) {\n          var camera = CameraRecordType.create({\n            id: CameraRecordType.createId(toId)\n          });\n          _this.store.put([camera, InstancePageStateRecordType.create({\n            id: InstancePageStateRecordType.createId(toId),\n            pageId: toId\n          })]);\n        }\n        _this.store.put([_objectSpread(_objectSpread({}, _this.instanceState), {}, {\n          currentPageId: toId\n        })]);\n        _this.updateRenderingBounds();\n      },\n      undo: function undo(_ref33) {\n        var fromId = _ref33.fromId;\n        if (!_this.store.has(fromId)) {\n          return;\n        }\n        _this.store.put([_objectSpread(_objectSpread({}, _this.instanceState), {}, {\n          currentPageId: fromId\n        })]);\n        _this.updateRenderingBounds();\n      },\n      squash: function squash(_ref34, _ref35) {\n        var fromId = _ref34.fromId;\n        var toId = _ref35.toId;\n        return {\n          toId: toId,\n          fromId: fromId\n        };\n      }\n    }));\n    /** @internal */\n    _defineProperty(_assertThisInitialized(_this), \"_updateInstanceState\", _this.history.createCommand(\"updateTabState\", function (partial) {\n      var ephemeral = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var squashing = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var prev = _this.instanceState;\n      var next = _objectSpread(_objectSpread({}, prev), partial);\n      return {\n        data: {\n          prev: prev,\n          next: next\n        },\n        squashing: squashing,\n        ephemeral: ephemeral\n      };\n    }, {\n      do: function _do(_ref36) {\n        var next = _ref36.next;\n        _this.store.put([next]);\n      },\n      undo: function undo(_ref37) {\n        var prev = _ref37.prev;\n        _this.store.put([prev]);\n      },\n      squash: function squash(_ref38, _ref39) {\n        var prev = _ref38.prev;\n        var next = _ref39.next;\n        return {\n          prev: prev,\n          next: next\n        };\n      }\n    }));\n    /** @internal */\n    _defineProperty(_assertThisInitialized(_this), \"_willSetInitialBounds\", true);\n    /** @internal */\n    _defineProperty(_assertThisInitialized(_this), \"_viewportAnimation\", null);\n    /* ---------------- Text Measurement ---------------- */\n    /**\n     * A helper for measuring text.\n     *\n     * @public\n     */\n    _defineProperty(_assertThisInitialized(_this), \"textMeasure\", void 0);\n    _this.store = store;\n    _this.user = new UserPreferencesManager(user !== null && user !== void 0 ? user : createTLUser());\n    _this.getContainer = getContainer !== null && getContainer !== void 0 ? getContainer : function () {\n      return document.body;\n    };\n    _this.textMeasure = new TextManager(_assertThisInitialized(_this));\n    _this.root = new RootState(_assertThisInitialized(_this));\n    var allShapes = checkShapesAndAddCore(shapes);\n    var shapeTypesInSchema = new Set(Object.keys(store.schema.types.shape.migrations.subTypeMigrations));\n    var _iterator5 = _createForOfIteratorHelper(allShapes),\n      _step5;\n    try {\n      for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n        var shape = _step5.value;\n        if (!shapeTypesInSchema.has(shape.type)) {\n          throw Error(\"Editor and store have different shapes: \\\"\".concat(shape.type, \"\\\" was passed into the editor but not the schema\"));\n        }\n        shapeTypesInSchema.delete(shape.type);\n      }\n    } catch (err) {\n      _iterator5.e(err);\n    } finally {\n      _iterator5.f();\n    }\n    if (shapeTypesInSchema.size > 0) {\n      throw Error(\"Editor and store have different shapes: \\\"\".concat(_toConsumableArray(shapeTypesInSchema)[0], \"\\\" is present in the store schema but not provided to the editor\"));\n    }\n    var shapeUtils = {};\n    var allStylesById = /* @__PURE__ */new Map();\n    var _iterator6 = _createForOfIteratorHelper(allShapes),\n      _step6;\n    try {\n      for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n        var _step6$value = _step6.value,\n          Util = _step6$value.util,\n          props = _step6$value.props;\n        var propKeysByStyle = getShapePropKeysByStyle(props !== null && props !== void 0 ? props : {});\n        shapeUtils[Util.type] = new Util(_assertThisInitialized(_this), Util.type, propKeysByStyle);\n        var _iterator9 = _createForOfIteratorHelper(propKeysByStyle.keys()),\n          _step9;\n        try {\n          for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n            var style = _step9.value;\n            if (!allStylesById.has(style.id)) {\n              allStylesById.set(style.id, style);\n            } else if (allStylesById.get(style.id) !== style) {\n              throw Error(\"Multiple style props with id \\\"\".concat(style.id, \"\\\" in use. Style prop IDs must be unique.\"));\n            }\n          }\n        } catch (err) {\n          _iterator9.e(err);\n        } finally {\n          _iterator9.f();\n        }\n      }\n    } catch (err) {\n      _iterator6.e(err);\n    } finally {\n      _iterator6.f();\n    }\n    _this.shapeUtils = shapeUtils;\n    var _iterator7 = _createForOfIteratorHelper(allShapes),\n      _step7;\n    try {\n      for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n        var Tool = _step7.value.tool;\n        if (Tool) {\n          if (hasOwnProperty(_this.root.children, Tool.id)) {\n            throw Error(\"Can't override tool with id \\\"\".concat(Tool.id, \"\\\"\"));\n          }\n          _this.root.children[Tool.id] = new Tool(_assertThisInitialized(_this));\n        }\n      }\n    } catch (err) {\n      _iterator7.e(err);\n    } finally {\n      _iterator7.f();\n    }\n    var _iterator8 = _createForOfIteratorHelper(tools),\n      _step8;\n    try {\n      for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n        var _Tool = _step8.value;\n        if (hasOwnProperty(_this.root.children, _Tool.id)) {\n          throw Error(\"Can't override tool with id \\\"\".concat(_Tool.id, \"\\\"\"));\n        }\n        _this.root.children[_Tool.id] = new _Tool(_assertThisInitialized(_this));\n      }\n    } catch (err) {\n      _iterator8.e(err);\n    } finally {\n      _iterator8.f();\n    }\n    if (typeof window !== \"undefined\" && \"navigator\" in window) {\n      _this.isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\n      _this.isIos = !!navigator.userAgent.match(/iPad/i) || !!navigator.userAgent.match(/iPhone/i);\n      _this.isChromeForIos = /crios.*safari/i.test(navigator.userAgent);\n    } else {\n      _this.isSafari = false;\n      _this.isIos = false;\n      _this.isChromeForIos = false;\n    }\n    _this.store.onBeforeDelete = function (record) {\n      if (record.typeName === \"shape\") {\n        _this._shapeWillBeDeleted(record);\n      } else if (record.typeName === \"page\") {\n        _this._pageWillBeDeleted(record);\n      }\n    };\n    _this.store.onAfterChange = function (prev, next) {\n      _this._updateDepth++;\n      if (_this._updateDepth > 1e3) {\n        console.error(\"[onAfterChange] Maximum update depth exceeded, bailing out.\");\n      }\n      if (prev.typeName === \"shape\" && next.typeName === \"shape\") {\n        _this._shapeDidChange(prev, next);\n      } else if (prev.typeName === \"instance_page_state\" && next.typeName === \"instance_page_state\") {\n        _this._pageStateDidChange(prev, next);\n      }\n      _this._updateDepth--;\n    };\n    _this.store.onAfterCreate = function (record) {\n      if (record.typeName === \"shape\" && _this.isShapeOfType(record, ArrowShapeUtil)) {\n        _this._arrowDidUpdate(record);\n      }\n      if (record.typeName === \"page\") {\n        var cameraId = CameraRecordType.createId(record.id);\n        var pageStateId = InstancePageStateRecordType.createId(record.id);\n        if (!_this.store.has(cameraId)) {\n          _this.store.put([CameraRecordType.create({\n            id: cameraId\n          })]);\n        }\n        if (!_this.store.has(pageStateId)) {\n          _this.store.put([InstancePageStateRecordType.create({\n            id: pageStateId,\n            pageId: record.id\n          })]);\n        }\n      }\n    };\n    _this._currentPageShapeIds = deriveShapeIdsInCurrentPage(_this.store, function () {\n      return _this.currentPageId;\n    });\n    _this._parentIdsToChildIds = parentsToChildrenWithIndexes(_this.store);\n    _this.disposables.add(_this.store.listen(function (changes) {\n      _this.emit(\"change\", changes);\n    }));\n    var container = _this.getContainer();\n    var focusin = function focusin() {\n      _this._isFocused.set(true);\n    };\n    var focusout = function focusout() {\n      _this._isFocused.set(false);\n    };\n    container.addEventListener(\"focusin\", focusin);\n    container.addEventListener(\"focus\", focusin);\n    container.addEventListener(\"focusout\", focusout);\n    container.addEventListener(\"blur\", focusout);\n    _this.disposables.add(function () {\n      container.removeEventListener(\"focusin\", focusin);\n      container.removeEventListener(\"focus\", focusin);\n      container.removeEventListener(\"focusout\", focusout);\n      container.removeEventListener(\"blur\", focusout);\n    });\n    _this.store.ensureStoreIsUsable();\n    _this.setInstancePageState({\n      editingId: null,\n      hoveredId: null,\n      erasingIds: []\n    }, true);\n    _this.root.enter(void 0, \"initial\");\n    if (_this.instanceState.followingUserId) {\n      _this.stopFollowingUser();\n    }\n    _this.updateRenderingBounds();\n    requestAnimationFrame(function () {\n      _this._tickManager.start();\n    });\n    return _this;\n  }\n  _createClass(Editor, [{\n    key: \"_pageTransformCache\",\n    get: function get() {\n      var _this2 = this;\n      return this.store.createComputedCache(\"pageTransformCache\", function (shape) {\n        var _this2$_pageTransform;\n        if (isPageId(shape.parentId)) {\n          return _this2.getTransform(shape);\n        }\n        var parent = (_this2$_pageTransform = _this2._pageTransformCache.get(shape.parentId)) !== null && _this2$_pageTransform !== void 0 ? _this2$_pageTransform : Matrix2d.Identity();\n        return Matrix2d.Compose(parent, _this2.getTransform(shape));\n      });\n    }\n  }, {\n    key: \"_pageBoundsCache\",\n    get: function get() {\n      var _this3 = this;\n      return this.store.createComputedCache(\"pageBoundsCache\", function (shape) {\n        var pageTransform = _this3._pageTransformCache.get(shape.id);\n        if (!pageTransform) return new Box2d();\n        var result = Box2d.FromPoints(Matrix2d.applyToPoints(pageTransform, _this3.getShapeUtil(shape).outline(shape)));\n        return result;\n      });\n    }\n    /**\n     * Dispose the editor.\n     *\n     * @public\n     */\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      this.disposables.forEach(function (dispose) {\n        return dispose();\n      });\n      this.disposables.clear();\n    }\n  }, {\n    key: \"undo\",\n    value:\n    /**\n     * Undo to the last mark.\n     *\n     * @example\n     * ```ts\n     * editor.undo()\n     * ```\n     *\n     * @public\n     */\n    function undo() {\n      return this.history.undo();\n    }\n  }, {\n    key: \"canUndo\",\n    get: function get() {\n      return this.history.numUndos > 0;\n    }\n    /**\n     * Redo to the next mark.\n     *\n     * @example\n     * ```ts\n     * editor.redo()\n     * ```\n     *\n     * @public\n     */\n  }, {\n    key: \"redo\",\n    value: function redo() {\n      this.history.redo();\n      return this;\n    }\n  }, {\n    key: \"canRedo\",\n    get: function get() {\n      return this.history.numRedos > 0;\n    }\n    /**\n     * Create a new \"mark\", or stopping point, in the undo redo history. Creating a mark will clear\n     * any redos.\n     *\n     * @example\n     * ```ts\n     * editor.mark()\n     * editor.mark('flip shapes')\n     * ```\n     *\n     * @param reason - The reason for the mark.\n     * @param onUndo - Whether to stop at the mark when undoing.\n     * @param onRedo - Whether to stop at the mark when redoing.\n     *\n     * @public\n     */\n  }, {\n    key: \"mark\",\n    value: function mark(reason, onUndo, onRedo) {\n      return this.history.mark(reason, onUndo, onRedo);\n    }\n    /**\n     * Clear all marks in the undo stack back to the next mark.\n     *\n     * @example\n     * ```ts\n     * editor.bail()\n     * ```\n     *\n     * @public\n     */\n  }, {\n    key: \"bail\",\n    value: function bail() {\n      this.history.bail();\n      return this;\n    }\n    /**\n     * Clear all marks in the undo stack back to the mark with the provided mark id.\n     *\n     * @example\n     * ```ts\n     * editor.bailToMark('creating')\n     * ```\n     *\n     * @public\n     */\n  }, {\n    key: \"bailToMark\",\n    value: function bailToMark(id) {\n      this.history.bailToMark(id);\n      return this;\n    }\n    /**\n     * Run a function in a batch, which will be undone/redone as a single action.\n     *\n     * @example\n     * ```ts\n     * editor.batch(() => {\n     * \teditor.selectAll()\n     * \teditor.deleteShapes()\n     * \teditor.createShapes(myShapes)\n     * \teditor.selectNone()\n     * })\n     *\n     * editor.undo() // will undo all of the above\n     * ```\n     *\n     * @public\n     */\n  }, {\n    key: \"batch\",\n    value: function batch(fn) {\n      this.history.batch(fn);\n      return this;\n    }\n  }, {\n    key: \"getShapeUtil\",\n    value: function getShapeUtil(shapeUtilConstructor) {\n      var shapeUtil = getOwnProperty(this.shapeUtils, shapeUtilConstructor.type);\n      assert(shapeUtil, \"No shape util found for type \\\"\".concat(shapeUtilConstructor.type, \"\\\"\"));\n      if (\"prototype\" in shapeUtilConstructor && shapeUtilConstructor.prototype instanceof ShapeUtil) {\n        assert(shapeUtil instanceof shapeUtilConstructor, \"Shape util found for type \\\"\".concat(shapeUtilConstructor.type, \"\\\" is not an instance of the provided constructor\"));\n      }\n      return shapeUtil;\n    }\n    /* ---------------------- Props --------------------- */\n    /**\n     * Get all the current styles among the users selected shapes\n     *\n     * @internal\n     */\n  }, {\n    key: \"_extractSharedStyles\",\n    value: function _extractSharedStyles(shape, sharedStyleMap) {\n      if (this.isShapeOfType(shape, GroupShapeUtil)) {\n        var childIds = this._parentIdsToChildIds.value[shape.id];\n        if (!childIds) return;\n        for (var i = 0, n = childIds.length; i < n; i++) {\n          this._extractSharedStyles(this.getShapeById(childIds[i][0]), sharedStyleMap);\n        }\n      } else {\n        var util = this.getShapeUtil(shape);\n        var _iterator10 = _createForOfIteratorHelper(util.iterateStyles(shape)),\n          _step10;\n        try {\n          for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n            var _step10$value = _slicedToArray(_step10.value, 2),\n              style = _step10$value[0],\n              value = _step10$value[1];\n            sharedStyleMap.applyValue(style, value);\n          }\n        } catch (err) {\n          _iterator10.e(err);\n        } finally {\n          _iterator10.f();\n        }\n      }\n    }\n  }, {\n    key: \"_stylesForNextShape\",\n    get: function get() {\n      return this.instanceState.stylesForNextShape;\n    }\n    /** @internal */\n  }, {\n    key: \"getStyleForNextShape\",\n    value: function getStyleForNextShape(style) {\n      var value = this._stylesForNextShape[style.id];\n      return value === void 0 ? style.defaultValue : value;\n    }\n  }, {\n    key: \"sharedStyles\",\n    get: function get() {\n      if (this.isIn(\"select\") && this.selectedIds.length > 0) {\n        return this._selectionSharedStyles.value;\n      }\n      var currentTool = this.root.current.value;\n      var styles = new SharedStyleMap();\n      if (currentTool.shapeType) {\n        var _iterator11 = _createForOfIteratorHelper(this.getShapeUtil(currentTool.shapeType).styleProps.keys()),\n          _step11;\n        try {\n          for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n            var style = _step11.value;\n            styles.applyValue(style, this.getStyleForNextShape(style));\n          }\n        } catch (err) {\n          _iterator11.e(err);\n        } finally {\n          _iterator11.f();\n        }\n      }\n      return styles;\n    }\n  }, {\n    key: \"sharedOpacity\",\n    get: function get() {\n      var _this4 = this;\n      if (this.isIn(\"select\") && this.selectedIds.length > 0) {\n        var shapesToCheck = [];\n        var addShape = function addShape(shapeId) {\n          var shape = _this4.getShapeById(shapeId);\n          if (!shape) return;\n          if (_this4.isShapeOfType(shape, GroupShapeUtil)) {\n            var _iterator12 = _createForOfIteratorHelper(_this4.getSortedChildIds(shape.id)),\n              _step12;\n            try {\n              for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n                var childId = _step12.value;\n                addShape(childId);\n              }\n            } catch (err) {\n              _iterator12.e(err);\n            } finally {\n              _iterator12.f();\n            }\n          } else {\n            shapesToCheck.push(shape);\n          }\n        };\n        var _iterator13 = _createForOfIteratorHelper(this.selectedIds),\n          _step13;\n        try {\n          for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n            var shapeId = _step13.value;\n            addShape(shapeId);\n          }\n        } catch (err) {\n          _iterator13.e(err);\n        } finally {\n          _iterator13.f();\n        }\n        var opacity = null;\n        for (var _i3 = 0, _shapesToCheck = shapesToCheck; _i3 < _shapesToCheck.length; _i3++) {\n          var shape = _shapesToCheck[_i3];\n          if (opacity === null) {\n            opacity = shape.opacity;\n          } else if (opacity !== shape.opacity) {\n            return {\n              type: \"mixed\"\n            };\n          }\n        }\n        if (opacity !== null) return {\n          type: \"shared\",\n          value: opacity\n        };\n      }\n      return {\n        type: \"shared\",\n        value: this.instanceState.opacityForNextShape\n      };\n    }\n  }, {\n    key: \"_arrowBindingsIndex\",\n    get: function get() {\n      return arrowBindingsIndex(this);\n    }\n    /**\n     * Get all arrows bound to a shape.\n     *\n     * @param shapeId - The id of the shape.\n     *\n     * @public\n     */\n  }, {\n    key: \"getArrowsBoundTo\",\n    value: function getArrowsBoundTo(shapeId) {\n      return this._arrowBindingsIndex.value[shapeId] || EMPTY_ARRAY;\n    }\n    /** @internal */\n  }, {\n    key: \"_reparentArrow\",\n    value: function _reparentArrow(arrowId) {\n      var _this5 = this;\n      var arrow = this.getShapeById(arrowId);\n      if (!arrow) return;\n      var _arrow$props = arrow.props,\n        start = _arrow$props.start,\n        end = _arrow$props.end;\n      var startShape = start.type === \"binding\" ? this.getShapeById(start.boundShapeId) : void 0;\n      var endShape = end.type === \"binding\" ? this.getShapeById(end.boundShapeId) : void 0;\n      var parentPageId = this.getAncestorPageId(arrow);\n      if (!parentPageId) return;\n      var nextParentId;\n      if (startShape && endShape) {\n        var _this$findCommonAnces;\n        nextParentId = (_this$findCommonAnces = this.findCommonAncestor([startShape, endShape])) !== null && _this$findCommonAnces !== void 0 ? _this$findCommonAnces : parentPageId;\n      } else if (startShape || endShape) {\n        nextParentId = parentPageId;\n      } else {\n        return;\n      }\n      if (nextParentId && nextParentId !== arrow.parentId) {\n        this.reparentShapesById([arrowId], nextParentId);\n      }\n      var reparentedArrow = this.getShapeById(arrowId);\n      if (!reparentedArrow) throw Error(\"no reparented arrow\");\n      var startSibling = this.getShapeNearestSibling(reparentedArrow, startShape);\n      var endSibling = this.getShapeNearestSibling(reparentedArrow, endShape);\n      var highestSibling;\n      if (startSibling && endSibling) {\n        highestSibling = startSibling.index > endSibling.index ? startSibling : endSibling;\n      } else if (startSibling && !endSibling) {\n        highestSibling = startSibling;\n      } else if (endSibling && !startSibling) {\n        highestSibling = endSibling;\n      } else {\n        return;\n      }\n      var finalIndex;\n      var higherSiblings = this.getSortedChildIds(highestSibling.parentId).map(function (id) {\n        return _this5.getShapeById(id);\n      }).filter(function (sibling) {\n        return sibling.index > highestSibling.index;\n      });\n      if (higherSiblings.length) {\n        var nextHighestNonArrowSibling = higherSiblings.find(function (sibling) {\n          return sibling.type !== \"arrow\";\n        });\n        if (\n        // ...then, if we're above the last shape we want to be above...\n        reparentedArrow.index > highestSibling.index && (\n        // ...but below the next non-arrow sibling...\n        !nextHighestNonArrowSibling || reparentedArrow.index < nextHighestNonArrowSibling.index)) {\n          return;\n        }\n        finalIndex = getIndexBetween(highestSibling.index, higherSiblings[0].index);\n      } else {\n        finalIndex = getIndexAbove(highestSibling.index);\n      }\n      if (finalIndex !== reparentedArrow.index) {\n        this.updateShapes([{\n          id: arrowId,\n          type: \"arrow\",\n          index: finalIndex\n        }]);\n      }\n    }\n    /** @internal */\n  }, {\n    key: \"_unbindArrowTerminal\",\n    value: function _unbindArrowTerminal(arrow, handleId) {\n      var _getArrowTerminalsInA = getArrowTerminalsInArrowSpace(this, arrow)[handleId],\n        x = _getArrowTerminalsInA.x,\n        y = _getArrowTerminalsInA.y;\n      this.store.put([_objectSpread(_objectSpread({}, arrow), {}, {\n        props: _objectSpread(_objectSpread({}, arrow.props), {}, _defineProperty({}, handleId, {\n          type: \"point\",\n          x: x,\n          y: y\n        }))\n      })]);\n    }\n  }, {\n    key: \"_allPageStates\",\n    get: function get() {\n      return this.store.query.records(\"instance_page_state\");\n    }\n    /** @internal */\n  }, {\n    key: \"_shapeWillBeDeleted\",\n    value: function _shapeWillBeDeleted(deletedShape) {\n      var _this6 = this;\n      if (deletedShape.parentId && isShapeId(deletedShape.parentId)) {\n        this._invalidParents.add(deletedShape.parentId);\n      }\n      var bindings = this._arrowBindingsIndex.value[deletedShape.id];\n      if (bindings !== null && bindings !== void 0 && bindings.length) {\n        var _iterator14 = _createForOfIteratorHelper(bindings),\n          _step14;\n        try {\n          for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {\n            var _step14$value = _step14.value,\n              arrowId = _step14$value.arrowId,\n              handleId = _step14$value.handleId;\n            var arrow = this.getShapeById(arrowId);\n            if (!arrow) continue;\n            this._unbindArrowTerminal(arrow, handleId);\n          }\n        } catch (err) {\n          _iterator14.e(err);\n        } finally {\n          _iterator14.f();\n        }\n      }\n      var pageStates = this._allPageStates.value;\n      var deletedIds = /* @__PURE__ */new Set([deletedShape.id]);\n      var updates = compact(pageStates.map(function (pageState) {\n        return _this6._cleanupInstancePageState(pageState, deletedIds);\n      }));\n      if (updates.length) {\n        this.store.put(updates);\n      }\n    }\n    /** @internal */\n  }, {\n    key: \"_arrowDidUpdate\",\n    value: function _arrowDidUpdate(arrow) {\n      for (var _i4 = 0, _arr = [\"start\", \"end\"]; _i4 < _arr.length; _i4++) {\n        var handle = _arr[_i4];\n        var terminal = arrow.props[handle];\n        if (terminal.type !== \"binding\") continue;\n        var boundShape = this.getShapeById(terminal.boundShapeId);\n        var isShapeInSamePageAsArrow = this.getAncestorPageId(arrow) === this.getAncestorPageId(boundShape);\n        if (!boundShape || !isShapeInSamePageAsArrow) {\n          this._unbindArrowTerminal(arrow, handle);\n        }\n      }\n      this._reparentArrow(arrow.id);\n    }\n  }, {\n    key: \"_complete\",\n    value: /** @internal */\n    function _complete() {\n      var _iterator15 = _createForOfIteratorHelper(this._invalidParents),\n        _step15;\n      try {\n        for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {\n          var _util$onChildrenChang;\n          var parentId = _step15.value;\n          this._invalidParents.delete(parentId);\n          var parent = this.getShapeById(parentId);\n          if (!parent) continue;\n          var util = this.getShapeUtil(parent);\n          var changes = (_util$onChildrenChang = util.onChildrenChange) === null || _util$onChildrenChang === void 0 ? void 0 : _util$onChildrenChang.call(util, parent);\n          if (changes !== null && changes !== void 0 && changes.length) {\n            this.updateShapes(changes, true);\n          }\n        }\n      } catch (err) {\n        _iterator15.e(err);\n      } finally {\n        _iterator15.f();\n      }\n      this.emit(\"update\");\n    }\n    /** @internal */\n  }, {\n    key: \"_cleanupInstancePageState\",\n    value: function _cleanupInstancePageState(prevPageState, shapesNoLongerInPage) {\n      var nextPageState = null;\n      var selectedIds = prevPageState.selectedIds.filter(function (id) {\n        return !shapesNoLongerInPage.has(id);\n      });\n      if (selectedIds.length !== prevPageState.selectedIds.length) {\n        if (!nextPageState) nextPageState = _objectSpread({}, prevPageState);\n        nextPageState.selectedIds = selectedIds;\n      }\n      var erasingIds = prevPageState.erasingIds.filter(function (id) {\n        return !shapesNoLongerInPage.has(id);\n      });\n      if (erasingIds.length !== prevPageState.erasingIds.length) {\n        if (!nextPageState) nextPageState = _objectSpread({}, prevPageState);\n        nextPageState.erasingIds = erasingIds;\n      }\n      if (prevPageState.hoveredId && shapesNoLongerInPage.has(prevPageState.hoveredId)) {\n        if (!nextPageState) nextPageState = _objectSpread({}, prevPageState);\n        nextPageState.hoveredId = null;\n      }\n      if (prevPageState.editingId && shapesNoLongerInPage.has(prevPageState.editingId)) {\n        if (!nextPageState) nextPageState = _objectSpread({}, prevPageState);\n        nextPageState.editingId = null;\n      }\n      var hintingIds = prevPageState.hintingIds.filter(function (id) {\n        return !shapesNoLongerInPage.has(id);\n      });\n      if (hintingIds.length !== prevPageState.hintingIds.length) {\n        if (!nextPageState) nextPageState = _objectSpread({}, prevPageState);\n        nextPageState.hintingIds = hintingIds;\n      }\n      if (prevPageState.focusLayerId && shapesNoLongerInPage.has(prevPageState.focusLayerId)) {\n        if (!nextPageState) nextPageState = _objectSpread({}, prevPageState);\n        nextPageState.focusLayerId = null;\n      }\n      return nextPageState;\n    }\n    /** @internal */\n  }, {\n    key: \"_shapeDidChange\",\n    value: function _shapeDidChange(prev, next) {\n      var _this7 = this;\n      if (this.isShapeOfType(next, ArrowShapeUtil)) {\n        this._arrowDidUpdate(next);\n      }\n      if (prev.parentId !== next.parentId) {\n        var reparentBoundArrows = function reparentBoundArrows(id) {\n          var boundArrows = _this7._arrowBindingsIndex.value[id];\n          if (boundArrows !== null && boundArrows !== void 0 && boundArrows.length) {\n            var _iterator16 = _createForOfIteratorHelper(boundArrows),\n              _step16;\n            try {\n              for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {\n                var arrow = _step16.value;\n                _this7._reparentArrow(arrow.arrowId);\n              }\n            } catch (err) {\n              _iterator16.e(err);\n            } finally {\n              _iterator16.f();\n            }\n          }\n        };\n        reparentBoundArrows(next.id);\n        this.visitDescendants(next.id, reparentBoundArrows);\n      }\n      if (prev.parentId !== next.parentId && isPageId(next.parentId)) {\n        var allMovingIds = /* @__PURE__ */new Set([prev.id]);\n        this.visitDescendants(prev.id, function (id) {\n          allMovingIds.add(id);\n        });\n        var _iterator17 = _createForOfIteratorHelper(this._allPageStates.value),\n          _step17;\n        try {\n          for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {\n            var instancePageState = _step17.value;\n            if (instancePageState.pageId === next.parentId) continue;\n            var nextPageState = this._cleanupInstancePageState(instancePageState, allMovingIds);\n            if (nextPageState) {\n              this.store.put([nextPageState]);\n            }\n          }\n        } catch (err) {\n          _iterator17.e(err);\n        } finally {\n          _iterator17.f();\n        }\n      }\n      if (prev.parentId && isShapeId(prev.parentId)) {\n        this._invalidParents.add(prev.parentId);\n      }\n      if (next.parentId !== prev.parentId && isShapeId(next.parentId)) {\n        this._invalidParents.add(next.parentId);\n      }\n    }\n    /** @internal */\n  }, {\n    key: \"_pageStateDidChange\",\n    value: function _pageStateDidChange(prev, next) {\n      var _this8 = this;\n      if ((prev === null || prev === void 0 ? void 0 : prev.selectedIds) !== (next === null || next === void 0 ? void 0 : next.selectedIds)) {\n        var filtered = next.selectedIds.filter(function (id) {\n          var _this8$getShapeById;\n          var parentId = (_this8$getShapeById = _this8.getShapeById(id)) === null || _this8$getShapeById === void 0 ? void 0 : _this8$getShapeById.parentId;\n          while (isShapeId(parentId)) {\n            var _this8$getShapeById2;\n            if (next.selectedIds.includes(parentId)) {\n              return false;\n            }\n            parentId = (_this8$getShapeById2 = _this8.getShapeById(parentId)) === null || _this8$getShapeById2 === void 0 ? void 0 : _this8$getShapeById2.parentId;\n          }\n          return true;\n        });\n        var nextFocusLayerId = filtered.length === 0 ? next === null || next === void 0 ? void 0 : next.focusLayerId : this.findCommonAncestor(compact(filtered.map(function (id) {\n          return _this8.getShapeById(id);\n        })), function (shape) {\n          return _this8.isShapeOfType(shape, GroupShapeUtil);\n        });\n        if (filtered.length !== next.selectedIds.length || nextFocusLayerId != next.focusLayerId) {\n          this.store.put([_objectSpread(_objectSpread({}, next), {}, {\n            selectedIds: filtered,\n            focusLayerId: nextFocusLayerId !== null && nextFocusLayerId !== void 0 ? nextFocusLayerId : null\n          })]);\n        }\n      }\n    }\n    /** @internal */\n  }, {\n    key: \"_pageWillBeDeleted\",\n    value: function _pageWillBeDeleted(page) {\n      var _this$pages$find;\n      if (this.instanceState.currentPageId !== page.id) return;\n      var backupPageId = (_this$pages$find = this.pages.find(function (p) {\n        return p.id !== page.id;\n      })) === null || _this$pages$find === void 0 ? void 0 : _this$pages$find.id;\n      if (!backupPageId) return;\n      this.store.put([_objectSpread(_objectSpread({}, this.instanceState), {}, {\n        currentPageId: backupPageId\n      })]);\n      var cameraId = CameraRecordType.createId(page.id);\n      var instancePageStateId = InstancePageStateRecordType.createId(page.id);\n      this.store.remove([cameraId, instancePageStateId]);\n    }\n    /* --------------------- Errors --------------------- */\n    /** @internal */\n  }, {\n    key: \"annotateError\",\n    value: function annotateError(error, _ref40) {\n      var origin = _ref40.origin,\n        willCrashApp = _ref40.willCrashApp,\n        tags = _ref40.tags,\n        extras = _ref40.extras;\n      var defaultAnnotations = this.createErrorAnnotations(origin, willCrashApp);\n      _annotateError(error, {\n        tags: _objectSpread(_objectSpread({}, defaultAnnotations.tags), tags),\n        extras: _objectSpread(_objectSpread({}, defaultAnnotations.extras), extras)\n      });\n      if (willCrashApp) {\n        this.store.markAsPossiblyCorrupted();\n      }\n    }\n    /** @internal */\n  }, {\n    key: \"createErrorAnnotations\",\n    value: function createErrorAnnotations(origin, willCrashApp) {\n      try {\n        return {\n          tags: {\n            origin: origin,\n            willCrashApp: willCrashApp\n          },\n          extras: {\n            activeStateNode: this.root.path.value,\n            selectedShapes: this.selectedShapes,\n            editingShape: this.editingId ? this.getShapeById(this.editingId) : void 0,\n            inputs: this.inputs\n          }\n        };\n      } catch (_unused) {\n        return {\n          tags: {\n            origin: origin,\n            willCrashApp: willCrashApp\n          },\n          extras: {}\n        };\n      }\n    }\n  }, {\n    key: \"crashingError\",\n    get:\n    /**\n     * We can't use an `atom` here because there's a chance that when `crashAndReportError` is called,\n     * we're in a transaction that's about to be rolled back due to the same error we're currently\n     * reporting.\n     *\n     * Instead, to listen to changes to this value, you need to listen to app's `crash` event.\n     *\n     * @internal\n     */\n    function get() {\n      return this._crashingError;\n    }\n    /** @internal */\n  }, {\n    key: \"crash\",\n    value: function crash(error) {\n      this._crashingError = error;\n      this.store.markAsPossiblyCorrupted();\n      this.emit(\"crash\", {\n        error: error\n      });\n    }\n  }, {\n    key: \"canMoveCamera\",\n    get:\n    /**\n     * Whether the editor's camera can move.\n     *\n     * @example\n     * ```ts\n     * editor.canMoveCamera = false\n     * ```\n     *\n     * @param canMove - Whether the camera can move.\n     *\n     * @public\n     */\n    function get() {\n      return this._canMoveCamera.value;\n    },\n    set: function set(canMove) {\n      this._canMoveCamera.set(canMove);\n    }\n  }, {\n    key: \"isFocused\",\n    get:\n    /**\n     * Whether or not the editor is focused.\n     *\n     * @public\n     */\n    function get() {\n      return this._isFocused.value;\n    }\n    /**\n     * The window's device pixel ratio.\n     *\n     * @public\n     */\n  }, {\n    key: \"devicePixelRatio\",\n    get: function get() {\n      return this._dprManager.dpr.value;\n    }\n  }, {\n    key: \"isCoarsePointer\",\n    get:\n    /**\n     * Whether the user is using a \"coarse\" pointer, such as on a touch screen. This is automatically set by the canvas.\n     *\n     * @public\n     **/\n    function get() {\n      return this._isCoarsePointer.value;\n    },\n    set: function set(v) {\n      this._isCoarsePointer.set(v);\n    }\n  }, {\n    key: \"openMenus\",\n    get: function get() {\n      return this._openMenus.value;\n    }\n    /**\n     * Add an open menu.\n     *\n     * @example\n     * ```ts\n     * editor.addOpenMenu('menu-id')\n     * ```\n     *\n     * @public\n     */\n  }, {\n    key: \"addOpenMenu\",\n    value: function addOpenMenu(id) {\n      var menus = new Set(this.openMenus);\n      if (!menus.has(id)) {\n        menus.add(id);\n        this._openMenus.set(_toConsumableArray(menus));\n      }\n      return this;\n    }\n    /**\n     * Delete an open menu.\n     *\n     * @example\n     * ```ts\n     * editor.deleteOpenMenu('menu-id')\n     * ```\n     *\n     * @public\n     */\n  }, {\n    key: \"deleteOpenMenu\",\n    value: function deleteOpenMenu(id) {\n      var menus = new Set(this.openMenus);\n      if (menus.has(id)) {\n        menus.delete(id);\n        this._openMenus.set(_toConsumableArray(menus));\n      }\n      return this;\n    }\n  }, {\n    key: \"isMenuOpen\",\n    get: function get() {\n      return this.openMenus.length > 0;\n    }\n  }, {\n    key: \"isChangingStyle\",\n    get:\n    /**\n     * Whether the user is currently changing the style of a shape. This may cause the UI to change.\n     *\n     * @example\n     * ```ts\n     * editor.isChangingStyle = true\n     * ```\n     *\n     * @public\n     */\n    function get() {\n      return this._isChangingStyle.value;\n    },\n    set: function set(v) {\n      var _this9 = this;\n      this._isChangingStyle.set(v);\n      clearTimeout(this._isChangingStyleTimeout);\n      if (v) {\n        this._isChangingStyleTimeout = setTimeout(function () {\n          return _this9.isChangingStyle = false;\n        }, 2e3);\n      }\n    }\n  }, {\n    key: \"isPenMode\",\n    get:\n    /**\n     * Whether the editor is in pen mode or not.\n     *\n     * @public\n     **/\n    function get() {\n      return this._isPenMode.value;\n    }\n    /**\n     * Set whether the editor is in pen mode or not.\n     *\n     * @public\n     **/\n  }, {\n    key: \"setPenMode\",\n    value: function setPenMode(isPenMode) {\n      if (isPenMode) this._touchEventsRemainingBeforeExitingPenMode = 3;\n      if (isPenMode !== this.isPenMode) {\n        this._isPenMode.set(isPenMode);\n      }\n      return this;\n    }\n  }, {\n    key: \"setReadOnly\",\n    value:\n    /**\n     * Set whether the editor is in read-only mode or not.\n     *\n     * @public\n     **/\n    function setReadOnly(isReadOnly) {\n      this._isReadOnly.set(isReadOnly);\n      if (isReadOnly) {\n        this.setSelectedTool(\"hand\");\n      }\n      return this;\n    }\n    /**\n     * Whether the editor is in read-only mode or not.\n     *\n     * @public\n     **/\n  }, {\n    key: \"isReadOnly\",\n    get: function get() {\n      return this._isReadOnly.value;\n    }\n  }, {\n    key: \"documentSettings\",\n    get: function get() {\n      return this.store.get(TLDOCUMENT_ID);\n    }\n    /**\n     * Update the global document settings that apply to all users.\n     *\n     * @public\n     **/\n  }, {\n    key: \"updateDocumentSettings\",\n    value: function updateDocumentSettings(settings) {\n      this.store.put([_objectSpread(_objectSpread({}, this.documentSettings), settings)]);\n    }\n    /**\n     * The document's grid size.\n     *\n     * @public\n     **/\n  }, {\n    key: \"gridSize\",\n    get: function get() {\n      return this.documentSettings.gridSize;\n    }\n    /** @internal */\n  }, {\n    key: \"projectName\",\n    get: function get() {\n      return this.documentSettings.name;\n    }\n    /** @internal */\n  }, {\n    key: \"setProjectName\",\n    value: function setProjectName(name) {\n      this.updateDocumentSettings({\n        name: name\n      });\n    }\n    /* ---------------------- User ---------------------- */\n    /**\n     * Whether the user has \"always snap\" mode enabled.\n     *\n     * @public\n     **/\n  }, {\n    key: \"isSnapMode\",\n    get: function get() {\n      return this.user.isSnapMode;\n    }\n    /**\n     * Set whether the user has \"always snap\" mode enabled.\n     *\n     * @public\n     **/\n  }, {\n    key: \"setSnapMode\",\n    value: function setSnapMode(isSnapMode) {\n      if (isSnapMode !== this.isSnapMode) {\n        this.user.updateUserPreferences({\n          isSnapMode: isSnapMode\n        });\n      }\n      return this;\n    }\n    /**\n     * Whether the user has dark mode enabled.\n     *\n     * @public\n     **/\n  }, {\n    key: \"isDarkMode\",\n    get: function get() {\n      return this.user.isDarkMode;\n    }\n    /**\n     * Set whether the user has dark mode enabled.\n     *\n     * @public\n     **/\n  }, {\n    key: \"setDarkMode\",\n    value: function setDarkMode(isDarkMode) {\n      if (isDarkMode !== this.isDarkMode) {\n        this.user.updateUserPreferences({\n          isDarkMode: isDarkMode\n        });\n      }\n      return this;\n    }\n    /**\n     * The user's chosen animation speed.\n     *\n     * @public\n     */\n  }, {\n    key: \"animationSpeed\",\n    get: function get() {\n      return this.user.animationSpeed;\n    }\n    /**\n     * Set the user's chosen animation speed.\n     * Set to 0.0 to disable animations.\n     * Set to 1.0 for full speed.\n     *\n     * @public\n     */\n  }, {\n    key: \"setAnimationSpeed\",\n    value: function setAnimationSpeed(animationSpeed) {\n      if (animationSpeed !== this.animationSpeed) {\n        this.user.updateUserPreferences({\n          animationSpeed: animationSpeed\n        });\n      }\n      return this;\n    }\n    /* ----------------- Instance State ----------------- */\n    /**\n     * The current instance's state.\n     *\n     * @public\n     */\n  }, {\n    key: \"instanceState\",\n    get: function get() {\n      return this.store.get(TLINSTANCE_ID);\n    }\n    /**\n     * The instance's cursor state.\n     *\n     * @public\n     **/\n  }, {\n    key: \"cursor\",\n    get: function get() {\n      return this.instanceState.cursor;\n    }\n    /**\n     * The instance's brush state.\n     *\n     * @public\n     **/\n  }, {\n    key: \"brush\",\n    get: function get() {\n      return this.instanceState.brush;\n    }\n    /**\n     * The instance's zoom brush state.\n     *\n     * @public\n     **/\n  }, {\n    key: \"zoomBrush\",\n    get: function get() {\n      return this.instanceState.zoomBrush;\n    }\n    /**\n     * The instance's scribble state.\n     *\n     * @public\n     **/\n  }, {\n    key: \"scribble\",\n    get: function get() {\n      return this.instanceState.scribble;\n    }\n    // Focus Mode\n    /**\n     * Whether the instance is in focus mode or not.\n     *\n     * @public\n     **/\n  }, {\n    key: \"isFocusMode\",\n    get: function get() {\n      return this.instanceState.isFocusMode;\n    }\n    /**\n     * Set whether the instance is in focus mode or not.\n     *\n     * @public\n     **/\n  }, {\n    key: \"setFocusMode\",\n    value: function setFocusMode(isFocusMode) {\n      if (isFocusMode !== this.isFocusMode) {\n        this.updateInstanceState({\n          isFocusMode: isFocusMode\n        }, true);\n      }\n      return this;\n    }\n    // Tool Locked\n    /**\n     * Whether the instance has \"tool lock\" mode enabled.\n     *\n     * @public\n     **/\n  }, {\n    key: \"isToolLocked\",\n    get: function get() {\n      return this.instanceState.isToolLocked;\n    }\n    /**\n     * Set whether the instance has \"tool lock\" mode enabled.\n     *\n     * @public\n     **/\n  }, {\n    key: \"setToolLocked\",\n    value: function setToolLocked(isToolLocked) {\n      if (isToolLocked !== this.isToolLocked) {\n        this.updateInstanceState({\n          isToolLocked: isToolLocked\n        }, true);\n      }\n      return this;\n    }\n    // Grid Mode\n    /**\n     * Whether the instance's grid is enabled.\n     *\n     * @public\n     **/\n  }, {\n    key: \"isGridMode\",\n    get: function get() {\n      return this.instanceState.isGridMode;\n    }\n    /**\n     * Set whether the instance's grid is enabled.\n     *\n     * @public\n     **/\n  }, {\n    key: \"setGridMode\",\n    value: function setGridMode(isGridMode) {\n      if (isGridMode !== this.isGridMode) {\n        this.updateInstanceState({\n          isGridMode: isGridMode\n        }, true);\n      }\n      return this;\n    }\n  }, {\n    key: \"_pages\",\n    get: function get() {\n      return this.store.query.records(\"page\");\n    }\n  }, {\n    key: \"pages\",\n    get: function get() {\n      return this._pages.value.sort(sortByIndex);\n    }\n    /**\n     * The current page.\n     *\n     * @public\n     */\n  }, {\n    key: \"currentPage\",\n    get: function get() {\n      var page = this.getPageById(this.currentPageId);\n      if (!page) throw Error(\"No current page (id \".concat(this.currentPageId, \", \").concat(this.pages.length, \" pages))\"));\n      return page;\n    }\n    /**\n     * The current page id.\n     *\n     * @public\n     */\n  }, {\n    key: \"currentPageId\",\n    get: function get() {\n      return this.instanceState.currentPageId;\n    }\n    /**\n     * Get a page by its ID.\n     *\n     * @example\n     * ```ts\n     * editor.getPageById(myPage.id)\n     * ```\n     *\n     * @public\n     */\n  }, {\n    key: \"getPageById\",\n    value: function getPageById(id) {\n      return this.store.get(id);\n    }\n    /**\n     * Get a page by its ID.\n     *\n     * @example\n     * ```ts\n     * editor.getPageById(myPage.id)\n     * ```\n     *\n     * @public\n     */\n  }, {\n    key: \"getPageInfoById\",\n    value: function getPageInfoById(id) {\n      return this.store.get(id);\n    }\n  }, {\n    key: \"currentPageShapeIds\",\n    get:\n    /**\n     * An array of all of the shapes on the current page.\n     *\n     * @public\n     */\n    function get() {\n      return this._currentPageShapeIds.value;\n    }\n    /**\n     * Get the ids of shapes on a page.\n     *\n     * @example\n     * ```ts\n     * const idsOnPage1 = editor.getShapeIdsInPage('page1')\n     * const idsOnPage2 = editor.getShapeIdsInPage('page2')\n     * ```\n     *\n     * @param pageId - The id of the page.\n     *\n     * @public\n     **/\n  }, {\n    key: \"getShapeIdsInPage\",\n    value: function getShapeIdsInPage(pageId) {\n      var result = this.store.query.exec(\"shape\", {\n        parentId: {\n          eq: pageId\n        }\n      });\n      return this.getShapeAndDescendantIds(result.map(function (s) {\n        return s.id;\n      }));\n    }\n  }, {\n    key: \"_pageStates\",\n    get: function get() {\n      return this.store.query.records(\"instance_page_state\");\n    }\n    /**\n     * Get a page state by its id.\n     *\n     * @example\n     * ```ts\n     * editor.getPageStateByPageId('page1')\n     * ```\n     *\n     * @public\n     */\n  }, {\n    key: \"getPageStateByPageId\",\n    value: function getPageStateByPageId(id) {\n      return this._pageStates.value.find(function (p) {\n        return p.pageId === id;\n      });\n    }\n  }, {\n    key: \"pageStateId\",\n    get: function get() {\n      return InstancePageStateRecordType.createId(this.currentPageId);\n    }\n  }, {\n    key: \"pageState\",\n    get: function get() {\n      return this.store.get(this.pageStateId);\n    }\n    /**\n     * Update a page state.\n     *\n     * @example\n     * ```ts\n     * editor.setInstancePageState({ id: 'page1', editingId: 'shape:123' })\n     * editor.setInstancePageState({ id: 'page1', editingId: 'shape:123' }, true)\n     * ```\n     *\n     * @param partial - The partial of the page state object containing the changes.\n     * @param ephemeral - Whether the command is ephemeral.\n     *\n     * @public\n     */\n  }, {\n    key: \"setInstancePageState\",\n    value: function setInstancePageState(partial) {\n      var ephemeral = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      this._setInstancePageState(partial, ephemeral);\n    }\n  }, {\n    key: \"selectedIds\",\n    get: function get() {\n      return this.pageState.selectedIds;\n    }\n  }, {\n    key: \"selectedIdsSet\",\n    get: function get() {\n      return new Set(this.selectedIds);\n    }\n    /**\n     * Select one or more shapes.\n     *\n     * @example\n     * ```ts\n     * editor.setSelectedIds(['id1'])\n     * editor.setSelectedIds(['id1', 'id2'])\n     * ```\n     *\n     * @param ids - The ids to select.\n     * @param squashing - Whether the change should create a new history entry or combine with the\n     *   previous (if the previous is the same type).\n     *\n     * @public\n     */\n  }, {\n    key: \"setSelectedIds\",\n    value: function setSelectedIds(ids) {\n      var squashing = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      this._setSelectedIds(ids, squashing);\n      return this;\n    }\n  }, {\n    key: \"isSelected\",\n    value:\n    /**\n     * Determine whether or not a shape is selected\n     *\n     * @example\n     * ```ts\n     * editor.isSelected('id1')\n     * ```\n     *\n     * @param id - The id of the shape to check.\n     *\n     * @public\n     */\n    function isSelected(id) {\n      return this.selectedIdsSet.has(id);\n    }\n    /**\n     * Determine whether a not a shape is within the current selection. A shape is within the\n     * selection if it or any of its parents is selected.\n     *\n     * @param id - The id of the shape to check.\n     *\n     * @public\n     */\n  }, {\n    key: \"isWithinSelection\",\n    value: function isWithinSelection(id) {\n      var _this10 = this;\n      var shape = this.getShapeById(id);\n      if (!shape) return false;\n      if (this.isSelected(id)) return true;\n      return !!this.findAncestor(shape, function (parent) {\n        return _this10.isSelected(parent.id);\n      });\n    }\n    /**\n     * Select one or more shapes.\n     *\n     * @example\n     * ```ts\n     * editor.select('id1')\n     * editor.select('id1', 'id2')\n     * ```\n     *\n     * @param ids - The ids to select.\n     *\n     * @public\n     */\n  }, {\n    key: \"select\",\n    value: function select() {\n      for (var _len = arguments.length, ids = new Array(_len), _key = 0; _key < _len; _key++) {\n        ids[_key] = arguments[_key];\n      }\n      this.setSelectedIds(ids);\n      return this;\n    }\n    /**\n     * Remove a shape from the existing set of selected shapes.\n     *\n     * @example\n     * ```ts\n     * editor.deselect(shape.id)\n     * ```\n     *\n     * @public\n     */\n  }, {\n    key: \"deselect\",\n    value: function deselect() {\n      for (var _len2 = arguments.length, ids = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        ids[_key2] = arguments[_key2];\n      }\n      var selectedIds = this.selectedIds;\n      if (selectedIds.length > 0 && ids.length > 0) {\n        this.setSelectedIds(selectedIds.filter(function (id) {\n          return !ids.includes(id);\n        }));\n      }\n      return this;\n    }\n    /**\n     * Select all direct children of the current page.\n     *\n     * @example\n     * ```ts\n     * editor.selectAll()\n     * ```\n     *\n     * @public\n     */\n  }, {\n    key: \"selectAll\",\n    value: function selectAll() {\n      var ids = this.getSortedChildIds(this.currentPageId);\n      if (ids.length <= 0) return this;\n      this.setSelectedIds(this._getUnlockedShapeIds(ids));\n      return this;\n    }\n    /**\n     * Clear the selection.\n     *\n     * @example\n     * ```ts\n     * editor.selectNone()\n     * ```\n     *\n     * @public\n     */\n  }, {\n    key: \"selectNone\",\n    value: function selectNone() {\n      if (this.selectedIds.length > 0) {\n        this.setSelectedIds([]);\n      }\n      return this;\n    }\n    // Focus Layer Id\n    /**\n     * The shape id of the current focus layer.\n     *\n     * @public\n     */\n  }, {\n    key: \"focusLayerId\",\n    get: function get() {\n      var _this$pageState$focus;\n      return (_this$pageState$focus = this.pageState.focusLayerId) !== null && _this$pageState$focus !== void 0 ? _this$pageState$focus : this.currentPageId;\n    }\n    /**\n     * The shape of the current focus layer.\n     *\n     * @public\n     */\n  }, {\n    key: \"focusLayerShape\",\n    get: function get() {\n      var id = this.pageState.focusLayerId;\n      if (!id) {\n        return;\n      }\n      return this.getShapeById(id);\n    }\n    /**\n     * Exit the current focus layer, moving up to the next group if there is one.\n     *\n     * @public\n     */\n  }, {\n    key: \"popFocusLayer\",\n    value: function popFocusLayer() {\n      var _this11 = this;\n      var current = this.pageState.focusLayerId;\n      var focusedShape = current && this.getShapeById(current);\n      if (focusedShape) {\n        var _match$id;\n        var match = this.findAncestor(focusedShape, function (shape) {\n          return _this11.isShapeOfType(shape, GroupShapeUtil);\n        });\n        this.setFocusLayer((_match$id = match === null || match === void 0 ? void 0 : match.id) !== null && _match$id !== void 0 ? _match$id : null);\n        this.select(focusedShape.id);\n      } else {\n        this.setFocusLayer(null);\n        this.selectNone();\n      }\n      return this;\n    }\n    /**\n     * Set the focus layer to the given shape id.\n     *\n     * @param next - The next focus layer id or null to reset the focus layer to the page\n     *\n     * @public\n     */\n  }, {\n    key: \"setFocusLayer\",\n    value: function setFocusLayer(next) {\n      this._setFocusLayer(next);\n      return this;\n    }\n  }, {\n    key: \"editingId\",\n    get:\n    // Editing Id\n    /**\n     * The current editing shape's id.\n     *\n     * @public\n     */\n    function get() {\n      return this.pageState.editingId;\n    }\n    /**\n     * Set the current editing id.\n     *\n     * @param id - The id of the shape to edit or null to clear the editing id.\n     *\n     * @public\n     */\n  }, {\n    key: \"setEditingId\",\n    value: function setEditingId(id) {\n      if (!id) {\n        this.setInstancePageState({\n          editingId: null\n        });\n      } else {\n        if (id !== this.editingId) {\n          var shape = this.getShapeById(id);\n          var util = this.getShapeUtil(shape);\n          if (shape && util.canEdit(shape)) {\n            this.setInstancePageState({\n              editingId: id,\n              hoveredId: null\n            }, false);\n            var viewportPageBounds = this.viewportPageBounds;\n            var localEditingBounds = util.getEditingBounds(shape);\n            var pageTransform = this.getPageTransformById(id);\n            var pageEditingBounds = Box2d.FromPoints(Matrix2d.applyToPoints(pageTransform, localEditingBounds.corners));\n            if (!viewportPageBounds.contains(pageEditingBounds)) {\n              if (pageEditingBounds.width > viewportPageBounds.width || pageEditingBounds.height > viewportPageBounds.height) {\n                this.zoomToBounds(pageEditingBounds.minX, pageEditingBounds.minY, pageEditingBounds.width, pageEditingBounds.height);\n              } else {\n                this.centerOnPoint(pageEditingBounds.midX, pageEditingBounds.midY);\n              }\n            }\n          }\n        }\n      }\n      return this;\n    }\n  }, {\n    key: \"editingShape\",\n    get: function get() {\n      var _this$getShapeById;\n      if (!this.editingId) return null;\n      return (_this$getShapeById = this.getShapeById(this.editingId)) !== null && _this$getShapeById !== void 0 ? _this$getShapeById : null;\n    }\n  }, {\n    key: \"hoveredId\",\n    get: function get() {\n      return this.pageState.hoveredId;\n    }\n    /**\n     * Set the current hovered shape.\n     *\n     * @example\n     * ```ts\n     * editor.setHoveredId('box1')\n     * editor.setHoveredId() // Clears the hovered shape.\n     * ```\n     *\n     * @param id - The id of the page to set as the current page\n     *\n     * @public\n     */\n  }, {\n    key: \"setHoveredId\",\n    value: function setHoveredId() {\n      var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      if (id === this.pageState.hoveredId) return this;\n      this.setInstancePageState({\n        hoveredId: id\n      }, true);\n      return this;\n    }\n  }, {\n    key: \"hoveredShape\",\n    get: function get() {\n      var _this$getShapeById2;\n      if (!this.hoveredId) return null;\n      return (_this$getShapeById2 = this.getShapeById(this.hoveredId)) !== null && _this$getShapeById2 !== void 0 ? _this$getShapeById2 : null;\n    }\n  }, {\n    key: \"hintingIds\",\n    get: function get() {\n      return this.pageState.hintingIds;\n    }\n    /**\n     * Set the hinted shape ids.\n     *\n     * @param ids - The ids to set as hinted.\n     *\n     * @public\n     */\n  }, {\n    key: \"setHintingIds\",\n    value: function setHintingIds(ids) {\n      this.store.update(this.pageState.id, function (s) {\n        return _objectSpread(_objectSpread({}, s), {}, {\n          hintingIds: dedupe(ids)\n        });\n      });\n      return this;\n    }\n  }, {\n    key: \"erasingIds\",\n    get: function get() {\n      return this.pageState.erasingIds;\n    }\n  }, {\n    key: \"erasingIdsSet\",\n    get: function get() {\n      return new Set(this.erasingIds);\n    }\n    /**\n     * Set the current erasing shapes.\n     *\n     * @example\n     * ```ts\n     * editor.setErasingIds(['box1', 'box2'])\n     * editor.setErasingIds() // Clears the erasing set\n     * ```\n     *\n     * @param ids - The ids of shapes to set as erasing.\n     *\n     * @public\n     */\n  }, {\n    key: \"setErasingIds\",\n    value: function setErasingIds() {\n      var ids = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      var erasingIds = this.erasingIdsSet;\n      if (ids.length === erasingIds.size && ids.every(function (id) {\n        return erasingIds.has(id);\n      })) return this;\n      this.setInstancePageState({\n        erasingIds: ids\n      }, true);\n      return this;\n    }\n    // Cropping Id\n    /**\n     * The current cropping shape's id.\n     *\n     * @public\n     */\n  }, {\n    key: \"croppingId\",\n    get: function get() {\n      return this.pageState.croppingId;\n    }\n    /**\n     * Set the current cropping shape's id.\n     *\n     * @param id - The id of the shape to crop or null to clear the cropping id.\n     *\n     * @public\n     */\n  }, {\n    key: \"setCroppingId\",\n    value: function setCroppingId(id) {\n      if (id !== this.croppingId) {\n        if (!id) {\n          this.setInstancePageState({\n            croppingId: null\n          });\n          if (this.isInAny(\"select.crop\", \"select.pointing_crop_handle\", \"select.cropping\")) {\n            this.setSelectedTool(\"select.idle\");\n          }\n        } else {\n          var shape = this.getShapeById(id);\n          var util = this.getShapeUtil(shape);\n          if (shape && util.canCrop(shape)) {\n            this.setInstancePageState({\n              croppingId: id,\n              hoveredId: null\n            });\n          }\n        }\n      }\n      return this;\n    }\n  }, {\n    key: \"cameraId\",\n    get: function get() {\n      return CameraRecordType.createId(this.currentPageId);\n    }\n  }, {\n    key: \"camera\",\n    get: function get() {\n      return this.store.get(this.cameraId);\n    }\n  }, {\n    key: \"zoomLevel\",\n    get: function get() {\n      return this.camera.z;\n    }\n    /* -------------------- Viewport -------------------- */\n    /**\n     * Update the viewport. The viewport will measure the size and screen position of its container\n     * element. This should be done whenever the container's position on the screen changes.\n     *\n     * @example\n     * ```ts\n     * editor.updateViewportScreenBounds()\n     * editor.updateViewportScreenBounds(true)\n     * ```\n     *\n     * @param center - (optional) Whether to preserve the viewport page center as the viewport changes.\n     *\n     * @public\n     */\n  }, {\n    key: \"updateViewportScreenBounds\",\n    value: function updateViewportScreenBounds() {\n      var center = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var container = this.getContainer();\n      if (!container) return this;\n      var rect = container.getBoundingClientRect();\n      var screenBounds = new Box2d(0, 0, Math.max(rect.width, 1), Math.max(rect.height, 1));\n      var boundsAreEqual = screenBounds.equals(this.viewportScreenBounds);\n      var _willSetInitialBounds = this._willSetInitialBounds;\n      if (boundsAreEqual) {\n        this._willSetInitialBounds = false;\n      } else {\n        if (_willSetInitialBounds) {\n          this._willSetInitialBounds = false;\n          this.updateInstanceState({\n            screenBounds: screenBounds.toJson()\n          }, true, true);\n        } else {\n          var zoomLevel = this.zoomLevel;\n          if (center) {\n            var before = this.viewportPageCenter;\n            this.updateInstanceState({\n              screenBounds: screenBounds.toJson()\n            }, true, true);\n            var after = this.viewportPageCenter;\n            if (!this.instanceState.followingUserId) {\n              this.pan((after.x - before.x) * zoomLevel, (after.y - before.y) * zoomLevel);\n            }\n          } else {\n            var _before = this.screenToPage(0, 0);\n            this.updateInstanceState({\n              screenBounds: screenBounds.toJson()\n            }, true, true);\n            var _after = this.screenToPage(0, 0);\n            if (!this.instanceState.followingUserId) {\n              this.pan((_after.x - _before.x) * zoomLevel, (_after.y - _before.y) * zoomLevel);\n            }\n          }\n        }\n      }\n      this._tickCameraState();\n      this.updateRenderingBounds();\n      var editingId = this.editingId;\n      if (editingId) {\n        this.panZoomIntoView([editingId]);\n      }\n      return this;\n    }\n  }, {\n    key: \"viewportScreenBounds\",\n    get: function get() {\n      var _this$instanceState$s = this.instanceState.screenBounds,\n        x = _this$instanceState$s.x,\n        y = _this$instanceState$s.y,\n        w = _this$instanceState$s.w,\n        h = _this$instanceState$s.h;\n      return new Box2d(x, y, w, h);\n    }\n  }, {\n    key: \"viewportScreenCenter\",\n    get: function get() {\n      return this.viewportScreenBounds.center;\n    }\n  }, {\n    key: \"viewportPageBounds\",\n    get: function get() {\n      var _this$viewportScreenB = this.viewportScreenBounds,\n        x = _this$viewportScreenB.x,\n        y = _this$viewportScreenB.y,\n        w = _this$viewportScreenB.w,\n        h = _this$viewportScreenB.h;\n      var tl = this.screenToPage(x, y);\n      var br = this.screenToPage(x + w, y + h);\n      return new Box2d(tl.x, tl.y, br.x - tl.x, br.y - tl.y);\n    }\n  }, {\n    key: \"viewportPageCenter\",\n    get: function get() {\n      return this.viewportPageBounds.center;\n    }\n    /**\n     * Convert a point in screen space to a point in page space.\n     *\n     * @example\n     * ```ts\n     * editor.screenToPage(100, 100)\n     * ```\n     *\n     * @param x - The x coordinate of the point in screen space.\n     * @param y - The y coordinate of the point in screen space.\n     * @param camera - The camera to use. Defaults to the current camera.\n     *\n     * @public\n     */\n  }, {\n    key: \"screenToPage\",\n    value: function screenToPage(x, y) {\n      var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.5;\n      var camera = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : this.camera;\n      var _this$store$unsafeGet = this.store.unsafeGetWithoutCapture(TLINSTANCE_ID),\n        screenBounds = _this$store$unsafeGet.screenBounds;\n      var cx = camera.x,\n        cy = camera.y,\n        _camera$z = camera.z,\n        cz = _camera$z === void 0 ? 1 : _camera$z;\n      return {\n        x: (x - screenBounds.x) / cz - cx,\n        y: (y - screenBounds.y) / cz - cy,\n        z: z\n      };\n    }\n    /**\n     * Convert a point in page space to a point in screen space.\n     *\n     * @example\n     * ```ts\n     * editor.pageToScreen(100, 100)\n     * ```\n     *\n     * @param x - The x coordinate of the point in screen space.\n     * @param y - The y coordinate of the point in screen space.\n     * @param camera - The camera to use. Defaults to the current camera.\n     *\n     * @public\n     */\n  }, {\n    key: \"pageToScreen\",\n    value: function pageToScreen(x, y) {\n      var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.5;\n      var camera = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : this.camera;\n      var cx = camera.x,\n        cy = camera.y,\n        _camera$z2 = camera.z,\n        cz = _camera$z2 === void 0 ? 1 : _camera$z2;\n      return {\n        x: x + cx * cz,\n        y: y + cy * cz,\n        z: z\n      };\n    }\n  }, {\n    key: \"cameraState\",\n    get: function get() {\n      return this._cameraState.value;\n    }\n  }, {\n    key: \"computeUnorderedRenderingShapes\",\n    value: function computeUnorderedRenderingShapes(ids) {\n      var _this12 = this;\n      var _ref41 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        renderingBounds = _ref41.renderingBounds,\n        renderingBoundsExpanded = _ref41.renderingBoundsExpanded,\n        erasingIdsSet = _ref41.erasingIdsSet,\n        editingId = _ref41.editingId;\n      var renderingShapes = [];\n      var nextIndex = MAX_SHAPES_PER_PAGE;\n      var nextBackgroundIndex = 0;\n      var addShapeById = function addShapeById(id, parentOpacity, isAncestorErasing) {\n        var _renderingBounds$incl, _ref42;\n        if (PageRecordType.isId(id)) {\n          var _iterator18 = _createForOfIteratorHelper(_this12.getSortedChildIds(id)),\n            _step18;\n          try {\n            for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {\n              var childId = _step18.value;\n              addShapeById(childId, parentOpacity, isAncestorErasing);\n            }\n          } catch (err) {\n            _iterator18.e(err);\n          } finally {\n            _iterator18.f();\n          }\n          return;\n        }\n        var shape = _this12.getShapeById(id);\n        if (!shape) return;\n        var opacity = shape.opacity * parentOpacity;\n        var isShapeErasing = false;\n        if (!isAncestorErasing && erasingIdsSet !== null && erasingIdsSet !== void 0 && erasingIdsSet.has(id)) {\n          isShapeErasing = true;\n          opacity *= 0.32;\n        }\n        var maskedPageBounds = _this12.getMaskedPageBoundsById(id);\n        var isInViewport = maskedPageBounds ? (_renderingBounds$incl = renderingBounds === null || renderingBounds === void 0 ? void 0 : renderingBounds.includes(maskedPageBounds)) !== null && _renderingBounds$incl !== void 0 ? _renderingBounds$incl : true : false;\n        var isCulled = maskedPageBounds ? (_ref42 = editingId !== id && !(renderingBoundsExpanded !== null && renderingBoundsExpanded !== void 0 && renderingBoundsExpanded.includes(maskedPageBounds))) !== null && _ref42 !== void 0 ? _ref42 : true : true;\n        renderingShapes.push({\n          id: id,\n          index: nextIndex,\n          backgroundIndex: nextBackgroundIndex,\n          opacity: opacity,\n          isCulled: isCulled,\n          isInViewport: isInViewport,\n          maskedPageBounds: maskedPageBounds\n        });\n        nextIndex += 1;\n        nextBackgroundIndex += 1;\n        var childIds = _this12.getSortedChildIds(id);\n        if (!childIds.length) return;\n        var backgroundIndexToRestore = null;\n        if (_this12.getShapeUtil(shape).providesBackgroundForChildren(shape)) {\n          backgroundIndexToRestore = nextBackgroundIndex;\n          nextBackgroundIndex = nextIndex;\n          nextIndex += MAX_SHAPES_PER_PAGE;\n        }\n        var _iterator19 = _createForOfIteratorHelper(childIds),\n          _step19;\n        try {\n          for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {\n            var _childId = _step19.value;\n            addShapeById(_childId, opacity, isAncestorErasing || isShapeErasing);\n          }\n        } catch (err) {\n          _iterator19.e(err);\n        } finally {\n          _iterator19.f();\n        }\n        if (backgroundIndexToRestore !== null) {\n          nextBackgroundIndex = backgroundIndexToRestore;\n        }\n      };\n      var _iterator20 = _createForOfIteratorHelper(ids),\n        _step20;\n      try {\n        for (_iterator20.s(); !(_step20 = _iterator20.n()).done;) {\n          var id = _step20.value;\n          addShapeById(id, 1, false);\n        }\n      } catch (err) {\n        _iterator20.e(err);\n      } finally {\n        _iterator20.f();\n      }\n      return renderingShapes;\n    }\n  }, {\n    key: \"renderingShapes\",\n    get: function get() {\n      var renderingShapes = this.computeUnorderedRenderingShapes([this.currentPageId], {\n        renderingBounds: this.renderingBounds,\n        renderingBoundsExpanded: this.renderingBoundsExpanded,\n        erasingIdsSet: this.erasingIdsSet,\n        editingId: this.editingId\n      });\n      return renderingShapes.sort(sortById);\n    }\n  }, {\n    key: \"renderingBounds\",\n    get: function get() {\n      return this._renderingBounds.value;\n    }\n  }, {\n    key: \"renderingBoundsExpanded\",\n    get: function get() {\n      return this._renderingBoundsExpanded.value;\n    }\n  }, {\n    key: \"updateRenderingBounds\",\n    value:\n    /**\n     * Update the rendering bounds. This should be called when the viewport has stopped changing, such\n     * as at the end of a pan, zoom, or animation.\n     *\n     * @example\n     * ```ts\n     * editor.updateRenderingBounds()\n     * ```\n     *\n     *\n     * @internal\n     */\n    function updateRenderingBounds() {\n      var viewportPageBounds = this.viewportPageBounds;\n      if (viewportPageBounds.equals(this._renderingBounds.__unsafe__getWithoutCapture())) return this;\n      this._renderingBounds.set(viewportPageBounds.clone());\n      this._renderingBoundsExpanded.set(viewportPageBounds.clone().expandBy(100 / this.zoomLevel));\n      return this;\n    }\n    /* --------------------- Shapes --------------------- */\n    /**\n     * Get the local transform for a shape as a matrix model. This transform reflects both its\n     * translation (x, y) from from either its parent's top left corner, if the shape's parent is\n     * another shape, or else from the 0,0 of the page, if the shape's parent is the page; and the\n     * shape's rotation.\n     *\n     * @example\n     * ```ts\n     * editor.getTransform(myShape)\n     * ```\n     *\n     * @param shape - The shape to get the local transform for.\n     *\n     * @public\n     */\n  }, {\n    key: \"getTransform\",\n    value: function getTransform(shape) {\n      return Matrix2d.Compose(Matrix2d.Translate(shape.x, shape.y), Matrix2d.Rotate(shape.rotation));\n    }\n    /**\n     * Get the local transform of a shape's parent as a matrix model.\n     *\n     * @example\n     * ```ts\n     * editor.getParentTransform(myShape)\n     * ```\n     *\n     * @param shape - The shape to get the parent transform for.\n     *\n     * @public\n     */\n  }, {\n    key: \"getParentTransform\",\n    value: function getParentTransform(shape) {\n      var _this$_pageTransformC;\n      if (isPageId(shape.parentId)) {\n        return Matrix2d.Identity();\n      }\n      return (_this$_pageTransformC = this._pageTransformCache.get(shape.parentId)) !== null && _this$_pageTransformC !== void 0 ? _this$_pageTransformC : Matrix2d.Identity();\n    }\n    /**\n     * Get the page transform (or absolute transform) of a shape.\n     *\n     * @example\n     * ```ts\n     * editor.getPageTransform(myShape)\n     * ```\n     *\n     * @param shape - The shape to get the page transform for.\n     *\n     * @public\n     */\n  }, {\n    key: \"getPageTransform\",\n    value: function getPageTransform(shape) {\n      return this.getPageTransformById(shape.id);\n    }\n    /**\n     * Get the page transform (or absolute transform) of a shape by its id.\n     *\n     * @example\n     * ```ts\n     * editor.getPageTransformById(myShape)\n     * ```\n     *\n     * @param id - The if of the shape to get the page transform for.\n     *\n     * @public\n     */\n  }, {\n    key: \"getPageTransformById\",\n    value: function getPageTransformById(id) {\n      return this._pageTransformCache.get(id);\n    }\n    /**\n     * Get the page point (or absolute point) of a shape.\n     *\n     * @example\n     * ```ts\n     * editor.getPagePoint(myShape)\n     * ```\n     *\n     * @param shape - The shape to get the page point for.\n     *\n     * @public\n     */\n  }, {\n    key: \"getPagePointById\",\n    value: function getPagePointById(id) {\n      var pageTransform = this.getPageTransformById(id);\n      if (!pageTransform) return;\n      return Matrix2d.applyToPoint(pageTransform, new Vec2d());\n    }\n    /**\n     * Get the page point (or absolute point) of a shape.\n     *\n     * @example\n     * ```ts\n     * editor.getPagePoint(myShape)\n     * ```\n     *\n     * @param shape - The shape to get the page point for.\n     *\n     * @public\n     */\n  }, {\n    key: \"getPageCenter\",\n    value: function getPageCenter(shape) {\n      var pageTransform = this.getPageTransformById(shape.id);\n      if (!pageTransform) return null;\n      var util = this.getShapeUtil(shape);\n      var center = util.center(shape);\n      return Matrix2d.applyToPoint(pageTransform, center);\n    }\n    /**\n     * Get the page point (or absolute point) of a shape by its id.\n     *\n     * @example\n     * ```ts\n     * editor.getPagePoint(myShape)\n     * ```\n     *\n     * @param id - The shape id to get the page point for.\n     *\n     * @public\n     */\n  }, {\n    key: \"getPageCenterById\",\n    value: function getPageCenterById(id) {\n      var shape = this.getShapeById(id);\n      return this.getPageCenter(shape);\n    }\n    /**\n     * Get the page rotation (or absolute rotation) of a shape.\n     *\n     * @example\n     * ```ts\n     * editor.getPageRotation(myShape)\n     * ```\n     *\n     * @param shape - The shape to get the page rotation for.\n     *\n     * @public\n     */\n  }, {\n    key: \"getPageRotation\",\n    value: function getPageRotation(shape) {\n      return this.getPageRotationById(shape.id);\n    }\n    /**\n     * Get the page rotation (or absolute rotation) of a shape by its id.\n     *\n     * @example\n     * ```ts\n     * editor.getPageRotationById(myShapeId)\n     * ```\n     *\n     * @param id - The id of the shape to get the page rotation for.\n     */\n  }, {\n    key: \"getPageRotationById\",\n    value: function getPageRotationById(id) {\n      var pageTransform = this.getPageTransformById(id);\n      if (pageTransform) {\n        return Matrix2d.Decompose(pageTransform).rotation;\n      }\n      return 0;\n    }\n    /**\n     * Get the local bounds of a shape.\n     *\n     * @example\n     * ```ts\n     * editor.getBounds(myShape)\n     * ```\n     *\n     * @param shape - The shape to get the bounds for.\n     *\n     * @public\n     */\n  }, {\n    key: \"getBounds\",\n    value: function getBounds(shape) {\n      return this.getShapeUtil(shape).bounds(shape);\n    }\n    /**\n     * Get the local bounds of a shape by its id.\n     *\n     * @example\n     * ```ts\n     * editor.getBoundsById(myShape)\n     * ```\n     *\n     * @param id - The id of the shape to get the bounds for.\n     *\n     * @public\n     */\n  }, {\n    key: \"getBoundsById\",\n    value: function getBoundsById(id) {\n      var shape = this.getShapeById(id);\n      if (!shape) return void 0;\n      return this.getBounds(shape);\n    }\n    /**\n     * Get the page (or absolute) bounds of a shape.\n     *\n     * @example\n     * ```ts\n     * editor.getPageBounds(myShape)\n     * ```\n     *\n     * @param shape - The shape to get the bounds for.\n     *\n     * @public\n     */\n  }, {\n    key: \"getPageBounds\",\n    value: function getPageBounds(shape) {\n      return this.getPageBoundsById(shape.id);\n    }\n    /**\n     * Get the page (or absolute) bounds of a shape by its id.\n     *\n     * @example\n     * ```ts\n     * editor.getPageBoundsById(myShape)\n     * ```\n     *\n     * @param id - The id of the shape to get the page bounds for.\n     *\n     * @public\n     */\n  }, {\n    key: \"getPageBoundsById\",\n    value: function getPageBoundsById(id) {\n      return this._pageBoundsCache.get(id);\n    }\n  }, {\n    key: \"_clipPathCache\",\n    get: function get() {\n      var _this13 = this;\n      return this.store.createComputedCache(\"clipPathCache\", function (shape) {\n        var pageMask = _this13._pageMaskCache.get(shape.id);\n        if (!pageMask) return void 0;\n        var pageTransform = _this13._pageTransformCache.get(shape.id);\n        if (!pageTransform) return void 0;\n        if (pageMask.length === 0) {\n          return \"polygon(0px 0px, 0px 0px, 0px 0px)\";\n        }\n        var localMask = Matrix2d.applyToPoints(Matrix2d.Inverse(pageTransform), pageMask);\n        return \"polygon(\".concat(localMask.map(function (p) {\n          return \"\".concat(p.x, \"px \").concat(p.y, \"px\");\n        }).join(\",\"), \")\");\n      });\n    }\n    /**\n     * Get the clip path for a shape.\n     *\n     * @example\n     * ```ts\n     * const clipPath = editor.getClipPathById(shape.id)\n     * ```\n     *\n     * @param id - The shape id.\n     *\n     * @returns The clip path or undefined.\n     *\n     * @public\n     */\n  }, {\n    key: \"getClipPathById\",\n    value: function getClipPathById(id) {\n      return this._clipPathCache.get(id);\n    }\n  }, {\n    key: \"_pageMaskCache\",\n    get: function get() {\n      var _this14 = this;\n      return this.store.createComputedCache(\"pageMaskCache\", function (shape) {\n        if (isPageId(shape.parentId)) {\n          return void 0;\n        }\n        var frameAncestors = _this14.getAncestorsById(shape.id).filter(function (shape2) {\n          return _this14.isShapeOfType(shape2, FrameShapeUtil);\n        });\n        if (frameAncestors.length === 0) return void 0;\n        var pageMask = frameAncestors.map(function (s) {\n          return (\n            // Apply the frame transform to the frame outline to get the frame outline in page space\n            Matrix2d.applyToPoints(_this14._pageTransformCache.get(s.id), _this14.getOutline(s))\n          );\n        }).reduce(function (acc, b) {\n          var _intersectPolygonPoly;\n          return b && acc ? (_intersectPolygonPoly = intersectPolygonPolygon(acc, b)) !== null && _intersectPolygonPoly !== void 0 ? _intersectPolygonPoly : void 0 : void 0;\n        });\n        return pageMask;\n      });\n    }\n    /**\n     * Get the page mask for a shape.\n     *\n     * @example\n     * ```ts\n     * const pageMask = editor.getPageMaskById(shape.id)\n     * ```\n     *\n     * @param id - The id of the shape to get the page mask for.\n     *\n     * @returns The page mask for the shape.\n     *\n     * @public\n     */\n  }, {\n    key: \"getPageMaskById\",\n    value: function getPageMaskById(id) {\n      return this._pageMaskCache.get(id);\n    }\n    /**\n     * Get the page (or absolute) bounds of a shape, incorporating any masks. For example, if the\n     * shape were the child of a frame and was half way out of the frame, the bounds would be the half\n     * of the shape that was in the frame.\n     *\n     * @example\n     * ```ts\n     * editor.getMaskedPageBounds(myShape)\n     * ```\n     *\n     * @param shape - The shape to get the masked bounds for.\n     *\n     * @public\n     */\n  }, {\n    key: \"getMaskedPageBounds\",\n    value: function getMaskedPageBounds(shape) {\n      return this.getMaskedPageBoundsById(shape.id);\n    }\n    /**\n     * Get the page (or absolute) bounds of a shape by its id, incorporating any masks. For example,\n     * if the shape were the child of a frame and was half way out of the frame, the bounds would be\n     * the half of the shape that was in the frame.\n     *\n     * @example\n     * ```ts\n     * editor.getMaskedPageBoundsById(myShape)\n     * ```\n     *\n     * @param id - The id of the shape to get the masked page bounds for.\n     *\n     * @public\n     */\n  }, {\n    key: \"getMaskedPageBoundsById\",\n    value: function getMaskedPageBoundsById(id) {\n      var pageBounds = this._pageBoundsCache.get(id);\n      if (!pageBounds) return;\n      var pageMask = this._pageMaskCache.get(id);\n      if (pageMask) {\n        var intersection = intersectPolygonPolygon(pageMask, pageBounds.corners);\n        if (!intersection) return;\n        return Box2d.FromPoints(intersection);\n      }\n      return pageBounds;\n    }\n    /**\n     * Get the local outline of a shape.\n     *\n     * @example\n     * ```ts\n     * editor.getOutline(myShape)\n     * ```\n     *\n     * @param shape - The shape to get the outline for.\n     *\n     * @public\n     */\n  }, {\n    key: \"getOutline\",\n    value: function getOutline(shape) {\n      return this.getShapeUtil(shape).outline(shape);\n    }\n    /**\n     * Get the local outline of a shape.\n     *\n     * @example\n     * ```ts\n     * editor.getOutlineById(myShape)\n     * ```\n     *\n     * @param id - The shape id to get the outline for.\n     *\n     * @public\n     */\n  }, {\n    key: \"getOutlineById\",\n    value: function getOutlineById(id) {\n      return this.getOutline(this.getShapeById(id));\n    }\n    /**\n     * Get the ancestors of a shape.\n     *\n     * @example\n     * ```ts\n     * const ancestors = editor.getAncestors(myShape)\n     * ```\n     *\n     * @param shape - The shape to get the ancestors for.\n     *\n     * @public\n     */\n  }, {\n    key: \"getAncestors\",\n    value: function getAncestors(shape) {\n      var acc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n      var parentId = shape.parentId;\n      if (isPageId(parentId)) {\n        acc.reverse();\n        return acc;\n      }\n      var parent = this.store.get(parentId);\n      if (!parent) return acc;\n      acc.push(parent);\n      return this.getAncestors(parent, acc);\n    }\n    /**\n     * Get the ancestors of a shape by its id.\n     *\n     * @example\n     * ```ts\n     * const ancestors = editor.getAncestorsById(myShape)\n     * ```\n     *\n     * @param id - The id of the shape to get the ancestors for.\n     *\n     * @public\n     */\n  }, {\n    key: \"getAncestorsById\",\n    value: function getAncestorsById(id) {\n      var acc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n      var shape = this.getShapeById(id);\n      if (!shape) return acc;\n      return this.getAncestors(shape, acc);\n    }\n    /**\n     * Find the first ancestor matching the given predicate\n     *\n     * @example\n     * ```ts\n     * const ancestor = editor.findAncestor(myShape)\n     * ```\n     *\n     * @param shape - The shape to check the ancestors for.\n     *\n     * @public\n     */\n  }, {\n    key: \"findAncestor\",\n    value: function findAncestor(shape, predicate) {\n      var parentId = shape.parentId;\n      if (isPageId(parentId)) {\n        return void 0;\n      }\n      var parent = this.getShapeById(parentId);\n      if (parent) {\n        if (predicate(parent)) {\n          return parent;\n        }\n        return this.findAncestor(parent, predicate);\n      }\n      return void 0;\n    }\n    /**\n     * Returns true if the the given shape has the given ancestor.\n     *\n     * @param shape - The shape.\n     * @param ancestorId - The id of the ancestor.\n     *\n     * @public\n     */\n  }, {\n    key: \"hasAncestor\",\n    value: function hasAncestor(shape, ancestorId) {\n      if (!shape) return false;\n      if (shape.parentId === ancestorId) return true;\n      return this.hasAncestor(this.getParentShape(shape), ancestorId);\n    }\n    /**\n     * Get the common ancestor of two or more shapes that matches a predicate.\n     *\n     * @param shapes - The shapes to check.\n     * @param predicate - The predicate to match.\n     */\n  }, {\n    key: \"findCommonAncestor\",\n    value: function findCommonAncestor(shapes, predicate) {\n      var _this15 = this;\n      if (shapes.length === 0) {\n        return;\n      }\n      if (shapes.length === 1) {\n        var _this$findAncestor;\n        var parentId = shapes[0].parentId;\n        if (isPageId(parentId)) {\n          return;\n        }\n        return predicate ? (_this$findAncestor = this.findAncestor(shapes[0], predicate)) === null || _this$findAncestor === void 0 ? void 0 : _this$findAncestor.id : parentId;\n      }\n      var _shapes = _toArray(shapes),\n        nodeA = _shapes[0],\n        others = _shapes.slice(1);\n      var ancestor = this.getParentShape(nodeA);\n      while (ancestor) {\n        if (predicate && !predicate(ancestor)) {\n          ancestor = this.getParentShape(ancestor);\n          continue;\n        }\n        if (others.every(function (shape) {\n          return _this15.hasAncestor(shape, ancestor.id);\n        })) {\n          return ancestor.id;\n        }\n        ancestor = this.getParentShape(ancestor);\n      }\n      return void 0;\n    }\n    /**\n     * Check whether a shape or its parent is locked.\n     *\n     * @param id - The id of the shape to check.\n     *\n     * @public\n     */\n  }, {\n    key: \"isShapeOrAncestorLocked\",\n    value: function isShapeOrAncestorLocked(shape) {\n      if (shape === void 0) return false;\n      if (shape.isLocked) return true;\n      return this.isShapeOrAncestorLocked(this.getParentShape(shape));\n    }\n  }, {\n    key: \"allShapesCommonBounds\",\n    get: function get() {\n      var _this16 = this;\n      var commonBounds = null;\n      this.currentPageShapeIds.forEach(function (shapeId) {\n        var bounds = _this16.getMaskedPageBoundsById(shapeId);\n        if (bounds) {\n          if (commonBounds) {\n            commonBounds.expand(bounds);\n          } else {\n            commonBounds = bounds.clone();\n          }\n        }\n      });\n      return commonBounds;\n    }\n    /**\n     * Get the corners of a shape in page space.\n     *\n     * @example\n     * ```ts\n     * const corners = editor.getPageCorners(myShape)\n     * ```\n     *\n     * @param shape - The shape to get the corners for.\n     *\n     * @public\n     */\n  }, {\n    key: \"getPageCorners\",\n    value: function getPageCorners(shape) {\n      var ancestors = this.getAncestors(shape);\n      var corners = this.getBounds(shape).corners;\n      var transform = Matrix2d.Compose.apply(Matrix2d, _toConsumableArray(ancestors.flatMap(function (s) {\n        return [Matrix2d.Translate(s.x, s.y), Matrix2d.Rotate(s.rotation)];\n      })).concat([Matrix2d.Translate(shape.x, shape.y), Matrix2d.Rotate(shape.rotation, 0, 0)]));\n      return Matrix2d.applyToPoints(transform, corners);\n    }\n    /**\n     * Test whether a point (in page space) will will a shape. This method takes into account masks,\n     * such as when a shape is the child of a frame and is partially clipped by the frame.\n     *\n     * @example\n     * ```ts\n     * editor.isPointInShape({ x: 100, y: 100 }, myShape)\n     * ```\n     *\n     * @param point - The page point to test.\n     * @param shape - The shape to test against.\n     *\n     * @public\n     */\n  }, {\n    key: \"isPointInShape\",\n    value: function isPointInShape(point, shape) {\n      var util = this.getShapeUtil(shape);\n      var pageMask = this._pageMaskCache.get(shape.id);\n      if (pageMask) {\n        var hit = pointInPolygon(point, pageMask);\n        if (!hit) return false;\n      }\n      return util.hitTestPoint(shape, this.getPointInShapeSpace(shape, point));\n    }\n    /**\n     * Get the shapes, if any, at a given page point.\n     *\n     * @example\n     * ```ts\n     * editor.getShapesAtPoint({ x: 100, y: 100 })\n     * ```\n     *\n     * @param point - The page point to test.\n     *\n     * @public\n     */\n  }, {\n    key: \"getShapesAtPoint\",\n    value: function getShapesAtPoint(point) {\n      var _this17 = this;\n      return this.shapesArray.filter(function (shape) {\n        var pageMask = _this17._pageMaskCache.get(shape.id);\n        if (pageMask) {\n          return pointInPolygon(point, pageMask);\n        }\n        return _this17.getShapeUtil(shape).hitTestPoint(shape, _this17.getPointInShapeSpace(shape, point));\n      });\n    }\n    /**\n     * Convert a point in page space to a point in the local space of a shape. For example, if a\n     * shape's page point were `{ x: 100, y: 100 }`, a page point at `{ x: 110, y: 110 }` would be at\n     * `{ x: 10, y: 10 }` in the shape's local space.\n     *\n     * @example\n     * ```ts\n     * editor.getPointInShapeSpace(myShape, { x: 100, y: 100 })\n     * ```\n     *\n     * @param shape - The shape to get the point in the local space of.\n     * @param point - The page point to get in the local space of the shape.\n     *\n     * @public\n     */\n  }, {\n    key: \"getPointInShapeSpace\",\n    value: function getPointInShapeSpace(shape, point) {\n      return Matrix2d.applyToPoint(Matrix2d.Inverse(this.getPageTransform(shape)), point);\n    }\n    /**\n     * Convert a delta in page space to a point in the local space of a shape. For example, if a\n     * shape's page point were `{ x: 100, y: 100 }`, a page point at `{ x: 110, y: 110 }` would be at\n     * `{ x: 10, y: 10 }` in the shape's local space.\n     *\n     * @example\n     * ```ts\n     * editor.getPointInShapeSpace(myShape.id, { x: 100, y: 100 })\n     * ```\n     *\n     * @param shape - The shape to get the point in the local space of.\n     * @param point - The page point to get in the local space of the shape.\n     *\n     * @public\n     */\n  }, {\n    key: \"getPointInParentSpace\",\n    value: function getPointInParentSpace(shapeId, point) {\n      var shape = this.getShapeById(shapeId);\n      if (!shape) {\n        return new Vec2d(0, 0);\n      }\n      if (isPageId(shape.parentId)) return Vec2d.From(point);\n      var parentTransform = this.getPageTransformById(shape.parentId);\n      if (!parentTransform) return Vec2d.From(point);\n      return Matrix2d.applyToPoint(Matrix2d.Inverse(parentTransform), point);\n    }\n    /**\n     * Convert a delta in page space to a delta in the local space of a shape.\n     *\n     * @example\n     * ```ts\n     * editor.getDeltaInShapeSpace(myShape, { x: 100, y: 100 })\n     * ```\n     *\n     * @param shape - The shape to get the delta in the local space of.\n     * @param delta - The page delta to convert.\n     *\n     * @public\n     */\n  }, {\n    key: \"getDeltaInShapeSpace\",\n    value: function getDeltaInShapeSpace(shape, delta) {\n      var pageTransform = this.getPageTransform(shape);\n      if (!pageTransform) return Vec2d.From(delta);\n      return Vec2d.Rot(delta, -Matrix2d.Decompose(pageTransform).rotation);\n    }\n    /**\n     * Convert a delta in page space to a delta in the parent space of a shape.\n     *\n     * @example\n     * ```ts\n     * editor.getDeltaInParentSpace(myShape, { x: 100, y: 100 })\n     * ```\n     *\n     * @param shape - The shape to get the delta in the parent space of.\n     * @param delta - The page delta to convert.\n     *\n     * @public\n     */\n  }, {\n    key: \"getDeltaInParentSpace\",\n    value: function getDeltaInParentSpace(shape, delta) {\n      if (isPageId(shape.parentId)) return Vec2d.From(delta);\n      var parent = this.getShapeById(shape.parentId);\n      if (!parent) return Vec2d.From(delta);\n      return this.getDeltaInShapeSpace(parent, delta);\n    }\n    /**\n     * For a given set of ids, get a map containing the ids of their parents and the children of those\n     * parents.\n     *\n     * @example\n     * ```ts\n     * editor.getParentsMappedToChildren(['id1', 'id2', 'id3'])\n     * ```\n     *\n     * @param ids - The ids to get the parents and children of.\n     *\n     * @public\n     */\n  }, {\n    key: \"getParentsMappedToChildren\",\n    value: function getParentsMappedToChildren(ids) {\n      var _this18 = this;\n      var shapes = ids.map(function (id) {\n        return _this18.store.get(id);\n      });\n      var parents = /* @__PURE__ */new Map();\n      shapes.forEach(function (shape) {\n        var _parents$get;\n        if (!parents.has(shape.parentId)) {\n          parents.set(shape.parentId, /* @__PURE__ */new Set());\n        }\n        (_parents$get = parents.get(shape.parentId)) === null || _parents$get === void 0 || _parents$get.add(shape);\n      });\n      return parents;\n    }\n  }, {\n    key: \"selectedPageBounds\",\n    get: function get() {\n      var _this19 = this;\n      var selectedIds = this.pageState.selectedIds;\n      if (selectedIds.length === 0) return null;\n      return Box2d.Common(compact(selectedIds.map(function (id) {\n        return _this19.getPageBoundsById(id);\n      })));\n    }\n  }, {\n    key: \"selectionRotation\",\n    get: function get() {\n      var _this20 = this;\n      var selectedIds = this.selectedIds;\n      if (selectedIds.length === 0) {\n        return 0;\n      }\n      if (selectedIds.length === 1) {\n        return this.getPageRotationById(this.selectedIds[0]);\n      }\n      var allRotations = selectedIds.map(function (id) {\n        return _this20.getPageRotationById(id) % (Math.PI / 2);\n      });\n      if (allRotations.every(function (rotation) {\n        return Math.abs(rotation - allRotations[0]) < Math.PI / 180;\n      })) {\n        return this.getPageRotationById(selectedIds[0]);\n      }\n      return 0;\n    }\n  }, {\n    key: \"selectionBounds\",\n    get: function get() {\n      var _this21 = this;\n      var selectedIds = this.selectedIds;\n      if (selectedIds.length === 0) {\n        return void 0;\n      }\n      var selectionRotation = this.selectionRotation;\n      if (selectionRotation === 0) {\n        return this.selectedPageBounds;\n      }\n      if (selectedIds.length === 1) {\n        var bounds = this.getBounds(this.getShapeById(selectedIds[0])).clone();\n        bounds.point = Matrix2d.applyToPoint(this.getPageTransformById(selectedIds[0]), bounds.point);\n        return bounds;\n      }\n      var allPoints = this.selectedIds.flatMap(function (id) {\n        var pageTransform = _this21.getPageTransformById(id);\n        if (!pageTransform) return [];\n        return _this21.getOutlineById(id).map(function (point) {\n          return Matrix2d.applyToPoint(pageTransform, point);\n        });\n      }).map(function (p) {\n        return Vec2d.Rot(p, -selectionRotation);\n      });\n      var box = Box2d.FromPoints(allPoints);\n      box.point = box.point.rot(selectionRotation);\n      return box;\n    }\n  }, {\n    key: \"selectionPageCenter\",\n    get: function get() {\n      var selectionBounds = this.selectionBounds,\n        selectionRotation = this.selectionRotation;\n      if (!selectionBounds) return null;\n      return Vec2d.RotWith(selectionBounds.center, selectionBounds.point, selectionRotation);\n    }\n    /* ------------------- Statechart ------------------- */\n    /**\n     * The id of the current selected tool.\n     *\n     * @public\n     */\n  }, {\n    key: \"currentToolId\",\n    get: function get() {\n      var _activeToolId;\n      var activeTool = this.root.current.value;\n      var activeToolId = activeTool === null || activeTool === void 0 ? void 0 : activeTool.id;\n      if (activeToolId === \"select\" || activeToolId === \"zoom\") {\n        var _currentChildState$in, _currentChildState$in2;\n        var currentChildState = activeTool === null || activeTool === void 0 ? void 0 : activeTool.current.value;\n        activeToolId = (_currentChildState$in = currentChildState === null || currentChildState === void 0 || (_currentChildState$in2 = currentChildState.info) === null || _currentChildState$in2 === void 0 ? void 0 : _currentChildState$in2.onInteractionEnd) !== null && _currentChildState$in !== void 0 ? _currentChildState$in : \"select\";\n      }\n      return (_activeToolId = activeToolId) !== null && _activeToolId !== void 0 ? _activeToolId : \"select\";\n    }\n    /**\n     * Set the selected tool.\n     *\n     * @example\n     * ```ts\n     * editor.setSelectedTool('hand')\n     * editor.setSelectedTool('hand', { date: Date.now() })\n     * ```\n     *\n     * @param id - The id of the tool to select.\n     * @param info - Arbitrary data to pass along into the transition.\n     *\n     * @public\n     */\n  }, {\n    key: \"setSelectedTool\",\n    value: function setSelectedTool(id) {\n      var info = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      this.root.transition(id, info);\n      return this;\n    }\n    /**\n     * Get a descendant by its path.\n     *\n     * @example\n     * ```ts\n     * state.getStateDescendant('select')\n     * state.getStateDescendant('select.brushing')\n     * ```\n     *\n     * @param path - The descendant's path of state ids, separated by periods.\n     *\n     * @public\n     */\n  }, {\n    key: \"getStateDescendant\",\n    value: function getStateDescendant(path) {\n      var ids = path.split(\".\").reverse();\n      var state = this.root;\n      while (ids.length > 0) {\n        var _state$children;\n        var id = ids.pop();\n        if (!id) return state;\n        var childState = (_state$children = state.children) === null || _state$children === void 0 ? void 0 : _state$children[id];\n        if (!childState) return void 0;\n        state = childState;\n      }\n      return state;\n    }\n    /**\n     * Get whether a certain tool (or other state node) is currently active.\n     *\n     * @example\n     * ```ts\n     * editor.isIn('select')\n     * editor.isIn('select.brushing')\n     * ```\n     *\n     * @param path - The path of active states, separated by periods.\n     *\n     * @public\n     */\n  }, {\n    key: \"isIn\",\n    value: function isIn(path) {\n      var ids = path.split(\".\").reverse();\n      var state = this.root;\n      while (ids.length > 0) {\n        var id = ids.pop();\n        if (!id) return true;\n        var current = state.current.value;\n        if ((current === null || current === void 0 ? void 0 : current.id) === id) {\n          if (ids.length === 0) return true;\n          state = current;\n          continue;\n        } else return false;\n      }\n      return false;\n    }\n    /**\n     * Get whether the state node is in any of the given active paths.\n     *\n     * @example\n     * ```ts\n     * state.isInAny('select', 'erase')\n     * state.isInAny('select.brushing', 'erase.idle')\n     * ```\n     *\n     * @public\n     */\n  }, {\n    key: \"isInAny\",\n    value: function isInAny() {\n      var _this22 = this;\n      for (var _len3 = arguments.length, paths = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        paths[_key3] = arguments[_key3];\n      }\n      return paths.some(function (path) {\n        return _this22.isIn(path);\n      });\n    }\n  }, {\n    key: \"_updateInputsFromEvent\",\n    value:\n    /**\n     * Update the input points from a pointer or pinch event.\n     *\n     * @param info - The event info.\n     */\n    function _updateInputsFromEvent(info) {\n      var _this$store$get$lastA, _this$store$get;\n      var _this$inputs = this.inputs,\n        previousScreenPoint = _this$inputs.previousScreenPoint,\n        previousPagePoint = _this$inputs.previousPagePoint,\n        currentScreenPoint = _this$inputs.currentScreenPoint,\n        currentPagePoint = _this$inputs.currentPagePoint;\n      var _this$store$unsafeGet2 = this.store.unsafeGetWithoutCapture(TLINSTANCE_ID),\n        screenBounds = _this$store$unsafeGet2.screenBounds;\n      var _info$point = info.point,\n        sx = _info$point.x,\n        sy = _info$point.y,\n        sz = _info$point.z;\n      var _this$camera = this.camera,\n        cx = _this$camera.x,\n        cy = _this$camera.y,\n        cz = _this$camera.z;\n      previousScreenPoint.setTo(currentScreenPoint);\n      previousPagePoint.setTo(currentPagePoint);\n      currentScreenPoint.set(sx, sy);\n      currentPagePoint.set((sx - screenBounds.x) / cz - cx, (sy - screenBounds.y) / cz - cy, sz !== null && sz !== void 0 ? sz : 0.5);\n      this.inputs.isPen = info.type === \"pointer\" && info.isPen;\n      if (info.name === \"pointer_down\") {\n        this.inputs.pointerVelocity.set(0, 0);\n      }\n      this.store.put([{\n        id: TLPOINTER_ID,\n        typeName: \"pointer\",\n        x: currentPagePoint.x,\n        y: currentPagePoint.y,\n        lastActivityTimestamp:\n        // If our pointer moved only because we're following some other user, then don't\n        // update our last activity timestamp; otherwise, update it to the current timestamp.\n        info.type === \"pointer\" && info.pointerId === INTERNAL_POINTER_IDS.CAMERA_MOVE ? (_this$store$get$lastA = (_this$store$get = this.store.get(TLPOINTER_ID)) === null || _this$store$get === void 0 ? void 0 : _this$store$get.lastActivityTimestamp) !== null && _this$store$get$lastA !== void 0 ? _this$store$get$lastA : Date.now() : Date.now()\n      }]);\n    }\n  }, {\n    key: \"cancelDoubleClick\",\n    value:\n    /**\n     * Prevent a double click event from firing the next time the user clicks\n     *\n     * @public\n     */\n    function cancelDoubleClick() {\n      this._clickManager.cancelDoubleClickTimeout();\n    }\n  }, {\n    key: \"dispatch\",\n    value:\n    /**\n     * Dispatch an event to the editor.\n     *\n     * @example\n     * ```ts\n     * editor.dispatch(myPointerEvent)\n     * ```\n     *\n     * @param info - The event info.\n     *\n     * @public\n     */\n    function dispatch(info) {\n      var _this23 = this;\n      if (this.crashingError) return this;\n      var inputs = this.inputs;\n      var type = info.type;\n      this.batch(function () {\n        if (info.type === \"misc\") {\n          if (info.name === \"cancel\" || info.name === \"complete\") {\n            _this23.inputs.isDragging = false;\n            if (_this23.inputs.isPanning) {\n              _this23.inputs.isPanning = false;\n              _this23.setCursor({\n                type: _this23._prevCursor\n              });\n            }\n          }\n          _this23.root.handleEvent(info);\n          return;\n        }\n        if (info.shiftKey) {\n          clearInterval(_this23._shiftKeyTimeout);\n          _this23._shiftKeyTimeout = -1;\n          inputs.shiftKey = true;\n        } else if (!info.shiftKey && inputs.shiftKey && _this23._shiftKeyTimeout === -1) {\n          _this23._shiftKeyTimeout = setTimeout(_this23._setShiftKeyTimeout, 150);\n        }\n        if (info.altKey) {\n          clearInterval(_this23._altKeyTimeout);\n          _this23._altKeyTimeout = -1;\n          inputs.altKey = true;\n        } else if (!info.altKey && inputs.altKey && _this23._altKeyTimeout === -1) {\n          _this23._altKeyTimeout = setTimeout(_this23._setAltKeyTimeout, 150);\n        }\n        if (info.ctrlKey) {\n          clearInterval(_this23._ctrlKeyTimeout);\n          _this23._ctrlKeyTimeout = -1;\n          inputs.ctrlKey = true;\n        } else if (!info.ctrlKey && inputs.ctrlKey && _this23._ctrlKeyTimeout === -1) {\n          _this23._ctrlKeyTimeout = setTimeout(_this23._setCtrlKeyTimeout, 150);\n        }\n        var originPagePoint = inputs.originPagePoint,\n          originScreenPoint = inputs.originScreenPoint,\n          currentPagePoint = inputs.currentPagePoint,\n          currentScreenPoint = inputs.currentScreenPoint;\n        if (!inputs.isPointing) {\n          inputs.isDragging = false;\n        }\n        switch (type) {\n          case \"pinch\":\n            {\n              if (!_this23.canMoveCamera) return;\n              _this23._updateInputsFromEvent(info);\n              switch (info.name) {\n                case \"pinch_start\":\n                  {\n                    if (inputs.isPinching) return;\n                    if (!inputs.isEditing) {\n                      _this23._pinchStart = _this23.camera.z;\n                      if (!_this23._selectedIdsAtPointerDown.length) {\n                        _this23._selectedIdsAtPointerDown = _this23.selectedIds.slice();\n                      }\n                      _this23._didPinch = true;\n                      inputs.isPinching = true;\n                      _this23.interrupt();\n                    }\n                    return;\n                  }\n                case \"pinch\":\n                  {\n                    if (!inputs.isPinching) return;\n                    var _info$point2 = info.point,\n                      x = _info$point2.x,\n                      y = _info$point2.y,\n                      _info$point2$z = _info$point2.z,\n                      z = _info$point2$z === void 0 ? 1 : _info$point2$z,\n                      _info$delta = info.delta,\n                      dx = _info$delta.x,\n                      dy = _info$delta.y;\n                    var _this23$camera = _this23.camera,\n                      cx = _this23$camera.x,\n                      cy = _this23$camera.y,\n                      cz = _this23$camera.z;\n                    var zoom = Math.min(MAX_ZOOM, Math.max(MIN_ZOOM, z));\n                    _this23.setCamera(cx + dx / cz - x / cz + x / zoom, cy + dy / cz - y / cz + y / zoom, zoom);\n                    return;\n                  }\n                case \"pinch_end\":\n                  {\n                    if (!inputs.isPinching) return _this23;\n                    inputs.isPinching = false;\n                    var _selectedIdsAtPointerDown = _this23._selectedIdsAtPointerDown;\n                    _this23.setSelectedIds(_this23._selectedIdsAtPointerDown, true);\n                    _this23._selectedIdsAtPointerDown = [];\n                    var _this23$camera2 = _this23.camera,\n                      _cx = _this23$camera2.x,\n                      _cy = _this23$camera2.y,\n                      _cz = _this23$camera2.z;\n                    var _zoom;\n                    if (_cz > 0.9 && _cz < 1.05) {\n                      _zoom = 1;\n                    } else if (_cz > 0.49 && _cz < 0.505) {\n                      _zoom = 0.5;\n                    }\n                    if (_cz > _this23._pinchStart - 0.1 && _cz < _this23._pinchStart + 0.05) {\n                      _zoom = _this23._pinchStart;\n                    }\n                    if (_zoom !== void 0) {\n                      var _this23$viewportScree = _this23.viewportScreenCenter,\n                        _x = _this23$viewportScree.x,\n                        _y = _this23$viewportScree.y;\n                      _this23.animateCamera(_cx + (_x / _zoom - _x) - (_x / _cz - _x), _cy + (_y / _zoom - _y) - (_y / _cz - _y), _zoom, {\n                        duration: 100\n                      });\n                    }\n                    if (_this23._didPinch) {\n                      _this23._didPinch = false;\n                      requestAnimationFrame(function () {\n                        if (!_this23._didPinch) {\n                          _this23.setSelectedIds(_selectedIdsAtPointerDown, true);\n                        }\n                      });\n                    }\n                    return;\n                  }\n              }\n            }\n          case \"wheel\":\n            {\n              if (!_this23.canMoveCamera) return;\n              if (_this23.isMenuOpen) {} else {\n                if (inputs.ctrlKey) {\n                  var _info$delta$z;\n                  var _this23$inputs$curren = _this23.inputs.currentScreenPoint,\n                    _x2 = _this23$inputs$curren.x,\n                    _y2 = _this23$inputs$curren.y;\n                  var _this23$camera3 = _this23.camera,\n                    _cx2 = _this23$camera3.x,\n                    _cy2 = _this23$camera3.y,\n                    _cz2 = _this23$camera3.z;\n                  var _zoom2 = Math.min(MAX_ZOOM, Math.max(MIN_ZOOM, _cz2 + ((_info$delta$z = info.delta.z) !== null && _info$delta$z !== void 0 ? _info$delta$z : 0) * _cz2));\n                  _this23.setCamera(_cx2 + (_x2 / _zoom2 - _x2) - (_x2 / _cz2 - _x2), _cy2 + (_y2 / _zoom2 - _y2) - (_y2 / _cz2 - _y2), _zoom2);\n                  return;\n                }\n                _this23.pan(info.delta.x, info.delta.y);\n                if (!inputs.isDragging && inputs.isPointing && originPagePoint.dist(currentPagePoint) > (_this23.isCoarsePointer ? COARSE_DRAG_DISTANCE : DRAG_DISTANCE) / _this23.zoomLevel) {\n                  inputs.isDragging = true;\n                }\n              }\n              break;\n            }\n          case \"pointer\":\n            {\n              if (inputs.isPinching) return;\n              _this23._updateInputsFromEvent(info);\n              var isPen = info.isPen;\n              switch (info.name) {\n                case \"pointer_down\":\n                  {\n                    _this23._selectedIdsAtPointerDown = _this23.selectedIds.slice();\n                    if (info.button === 0) {\n                      _this23.capturedPointerId = info.pointerId;\n                    }\n                    inputs.buttons.add(info.button);\n                    inputs.isPointing = true;\n                    inputs.isDragging = false;\n                    if (_this23.isPenMode) {\n                      if (!isPen) {\n                        _this23._touchEventsRemainingBeforeExitingPenMode--;\n                        if (_this23._touchEventsRemainingBeforeExitingPenMode === 0) {\n                          _this23.setPenMode(false);\n                        } else {\n                          return;\n                        }\n                      } else {\n                        _this23._touchEventsRemainingBeforeExitingPenMode = 3;\n                      }\n                    } else {\n                      if (isPen) {\n                        _this23.setPenMode(true);\n                      }\n                    }\n                    if (info.button === 5) {\n                      _this23._restoreToolId = _this23.currentToolId;\n                      _this23.complete();\n                      _this23.setSelectedTool(\"eraser\");\n                    } else if (info.button === 1) {\n                      if (!_this23.inputs.isPanning) {\n                        _this23._prevCursor = _this23.instanceState.cursor.type;\n                      }\n                      _this23.inputs.isPanning = true;\n                    }\n                    if (_this23.inputs.isPanning) {\n                      _this23.stopCameraAnimation();\n                      _this23.setCursor({\n                        type: \"grabbing\"\n                      });\n                      return _this23;\n                    }\n                    originScreenPoint.setTo(currentScreenPoint);\n                    originPagePoint.setTo(currentPagePoint);\n                    break;\n                  }\n                case \"pointer_move\":\n                  {\n                    if (!isPen && _this23.isPenMode) {\n                      return;\n                    }\n                    if (_this23.inputs.isPanning && _this23.inputs.isPointing) {\n                      var _this23$inputs = _this23.inputs,\n                        currentScreenPoint2 = _this23$inputs.currentScreenPoint,\n                        previousScreenPoint = _this23$inputs.previousScreenPoint;\n                      var delta = Vec2d.Sub(currentScreenPoint2, previousScreenPoint);\n                      _this23.pan(delta.x, delta.y);\n                      return;\n                    }\n                    if (!inputs.isDragging && inputs.isPointing && originPagePoint.dist(currentPagePoint) > (_this23.isCoarsePointer ? COARSE_DRAG_DISTANCE : DRAG_DISTANCE) / _this23.zoomLevel) {\n                      inputs.isDragging = true;\n                    }\n                    break;\n                  }\n                case \"pointer_up\":\n                  {\n                    inputs.buttons.delete(info.button);\n                    inputs.isPointing = false;\n                    inputs.isDragging = false;\n                    if (_this23.isMenuOpen) {\n                      return;\n                    }\n                    if (!isPen && _this23.isPenMode) {\n                      return;\n                    }\n                    if (_this23.capturedPointerId === info.pointerId) {\n                      _this23.capturedPointerId = null;\n                      info.button = 0;\n                    }\n                    if (inputs.isPanning) {\n                      if (info.button === 1) {\n                        if (!_this23.inputs.keys.has(\" \")) {\n                          inputs.isPanning = false;\n                          _this23.slideCamera({\n                            speed: Math.min(2, _this23.inputs.pointerVelocity.len()),\n                            direction: _this23.inputs.pointerVelocity,\n                            friction: HAND_TOOL_FRICTION\n                          });\n                          _this23.setCursor({\n                            type: _this23._prevCursor\n                          });\n                        } else {\n                          _this23.slideCamera({\n                            speed: Math.min(2, _this23.inputs.pointerVelocity.len()),\n                            direction: _this23.inputs.pointerVelocity,\n                            friction: HAND_TOOL_FRICTION\n                          });\n                          _this23.setCursor({\n                            type: \"grab\"\n                          });\n                        }\n                      } else if (info.button === 0) {\n                        _this23.slideCamera({\n                          speed: Math.min(2, _this23.inputs.pointerVelocity.len()),\n                          direction: _this23.inputs.pointerVelocity,\n                          friction: HAND_TOOL_FRICTION\n                        });\n                        _this23.setCursor({\n                          type: \"grab\"\n                        });\n                      }\n                    } else {\n                      if (info.button === 5) {\n                        _this23.complete();\n                        _this23.setSelectedTool(_this23._restoreToolId);\n                      }\n                    }\n                    break;\n                  }\n              }\n              break;\n            }\n          case \"keyboard\":\n            {\n              if (info.key === \"ShiftRight\") info.key = \"ShiftLeft\";\n              if (info.key === \"AltRight\") info.key = \"AltLeft\";\n              if (info.code === \"ControlRight\") info.code = \"ControlLeft\";\n              switch (info.name) {\n                case \"key_down\":\n                  {\n                    inputs.keys.add(info.code);\n                    if (!info.ctrlKey && info.code === \"Space\") {\n                      if (!_this23.inputs.isPanning) {\n                        _this23._prevCursor = _this23.instanceState.cursor.type;\n                      }\n                      _this23.inputs.isPanning = true;\n                      _this23.setCursor({\n                        type: _this23.inputs.isPointing ? \"grabbing\" : \"grab\"\n                      });\n                    }\n                    break;\n                  }\n                case \"key_up\":\n                  {\n                    inputs.keys.delete(info.code);\n                    if (info.code === \"Space\" && !_this23.inputs.buttons.has(1)) {\n                      _this23.inputs.isPanning = false;\n                      _this23.setCursor({\n                        type: _this23._prevCursor\n                      });\n                    }\n                    break;\n                  }\n                case \"key_repeat\":\n                  {\n                    break;\n                  }\n              }\n              break;\n            }\n        }\n        if (info.type === \"pointer\") {\n          if (info.button === 1) {\n            info.name = \"middle_click\";\n          } else if (info.button === 2) {\n            info.name = \"right_click\";\n          }\n          if (info.isPen === _this23.isPenMode) {\n            switch (info.name) {\n              case \"pointer_down\":\n                {\n                  var otherEvent = _this23._clickManager.transformPointerDownEvent(info);\n                  if (info.name !== otherEvent.name) {\n                    _this23.root.handleEvent(info);\n                    _this23.emit(\"event\", info);\n                    _this23.root.handleEvent(otherEvent);\n                    _this23.emit(\"event\", otherEvent);\n                    return;\n                  }\n                  break;\n                }\n              case \"pointer_up\":\n                {\n                  var _otherEvent = _this23._clickManager.transformPointerUpEvent(info);\n                  if (info.name !== _otherEvent.name) {\n                    _this23.root.handleEvent(info);\n                    _this23.emit(\"event\", info);\n                    _this23.root.handleEvent(_otherEvent);\n                    _this23.emit(\"event\", _otherEvent);\n                    return;\n                  }\n                  break;\n                }\n              case \"pointer_move\":\n                {\n                  _this23._clickManager.handleMove();\n                  break;\n                }\n            }\n          }\n        }\n        _this23.root.handleEvent(info);\n        _this23.emit(\"event\", info);\n      });\n      return this;\n    }\n    /**\n     * Replace the store's contents with the given records.\n     *\n     * @param records - The records to replace the store's contents with.\n     */\n  }, {\n    key: \"replaceStoreContentsWithRecordsForOtherDocument\",\n    value: function replaceStoreContentsWithRecordsForOtherDocument(records) {\n      var _this24 = this;\n      transact(function () {\n        _this24.store.clear();\n        var _partition = partition(records, function (record) {\n            return record.typeName === \"shape\";\n          }),\n          _partition2 = _slicedToArray(_partition, 2),\n          shapes = _partition2[0],\n          nonShapes = _partition2[1];\n        _this24.store.put(nonShapes, \"initialize\");\n        _this24.store.ensureStoreIsUsable();\n        _this24.store.put(shapes, \"initialize\");\n        _this24.history.clear();\n        _this24.updateViewportScreenBounds();\n        _this24.updateRenderingBounds();\n        var bounds = _this24.allShapesCommonBounds;\n        if (bounds) {\n          _this24.zoomToBounds(bounds.minX, bounds.minY, bounds.width, bounds.height, 1);\n        }\n      });\n    }\n    /**\n     * Get content that can be exported for the given shape ids.\n     *\n     * @param ids - The ids of the shapes to get content for. Defaults to the selected shape ids.\n     *\n     * @returns The exported content.\n     *\n     * @public\n     */\n  }, {\n    key: \"getContent\",\n    value: function getContent() {\n      var _this25 = this;\n      var ids = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.selectedIds;\n      if (!ids) return;\n      if (ids.length === 0) return;\n      var pageTransforms = {};\n      var shapes = dedupe(ids.map(function (id) {\n        return _this25.getShapeById(id);\n      }).sort(sortByIndex).flatMap(function (shape) {\n        var allShapes = [shape];\n        _this25.visitDescendants(shape.id, function (descendant) {\n          allShapes.push(_this25.getShapeById(descendant));\n        });\n        return allShapes;\n      }));\n      shapes = shapes.map(function (shape) {\n        pageTransforms[shape.id] = _this25.getPageTransformById(shape.id);\n        shape = structuredClone(shape);\n        if (_this25.isShapeOfType(shape, ArrowShapeUtil)) {\n          var startBindingId = shape.props.start.type === \"binding\" ? shape.props.start.boundShapeId : void 0;\n          var endBindingId = shape.props.end.type === \"binding\" ? shape.props.end.boundShapeId : void 0;\n          var info = _this25.getShapeUtil(ArrowShapeUtil).getArrowInfo(shape);\n          if (shape.props.start.type === \"binding\") {\n            if (!shapes.some(function (s) {\n              return s.id === startBindingId;\n            })) {\n              if (info !== null && info !== void 0 && info.isValid) {\n                var _info$start$point = info.start.point,\n                  x = _info$start$point.x,\n                  y = _info$start$point.y;\n                shape.props.start = {\n                  type: \"point\",\n                  x: x,\n                  y: y\n                };\n              } else {\n                var _getArrowTerminalsInA2 = getArrowTerminalsInArrowSpace(_this25, shape),\n                  start = _getArrowTerminalsInA2.start;\n                shape.props.start = {\n                  type: \"point\",\n                  x: start.x,\n                  y: start.y\n                };\n              }\n            }\n          }\n          if (shape.props.end.type === \"binding\") {\n            if (!shapes.some(function (s) {\n              return s.id === endBindingId;\n            })) {\n              if (info !== null && info !== void 0 && info.isValid) {\n                var _info$end$point = info.end.point,\n                  _x3 = _info$end$point.x,\n                  _y3 = _info$end$point.y;\n                shape.props.end = {\n                  type: \"point\",\n                  x: _x3,\n                  y: _y3\n                };\n              } else {\n                var _getArrowTerminalsInA3 = getArrowTerminalsInArrowSpace(_this25, shape),\n                  end = _getArrowTerminalsInA3.end;\n                shape.props.end = {\n                  type: \"point\",\n                  x: end.x,\n                  y: end.y\n                };\n              }\n            }\n          }\n          var infoAfter = getIsArrowStraight(shape) ? getStraightArrowInfo(_this25, shape) : getCurvedArrowInfo(_this25, shape);\n          if (info !== null && info !== void 0 && info.isValid && infoAfter !== null && infoAfter !== void 0 && infoAfter.isValid && !getIsArrowStraight(shape)) {\n            var mpA = Vec2d.Med(info.start.handle, info.end.handle);\n            var distA = Vec2d.Dist(info.middle, mpA);\n            var distB = Vec2d.Dist(infoAfter.middle, mpA);\n            if (shape.props.bend < 0) {\n              shape.props.bend += distB - distA;\n            } else {\n              shape.props.bend -= distB - distA;\n            }\n          }\n          return shape;\n        }\n        return shape;\n      });\n      var rootShapeIds = [];\n      shapes.forEach(function (shape) {\n        if (shapes.find(function (s) {\n          return s.id === shape.parentId;\n        }) === void 0) {\n          var pagePoint = _this25.getPagePointById(shape.id);\n          var pageRotation = _this25.getPageRotationById(shape.id);\n          shape.x = pagePoint.x;\n          shape.y = pagePoint.y;\n          shape.rotation = pageRotation;\n          shape.parentId = _this25.currentPageId;\n          rootShapeIds.push(shape.id);\n        }\n      });\n      var assetsSet = /* @__PURE__ */new Set();\n      shapes.forEach(function (shape) {\n        if (\"assetId\" in shape.props) {\n          if (shape.props.assetId !== null) {\n            assetsSet.add(shape.props.assetId);\n          }\n        }\n      });\n      return {\n        shapes: shapes,\n        rootShapeIds: rootShapeIds,\n        schema: this.store.schema.serialize(),\n        assets: compact(Array.from(assetsSet).map(function (id) {\n          return _this25.getAssetById(id);\n        }))\n      };\n    }\n    /* --------------------- Commands --------------------- */\n    /**\n     * Place content into the editor.\n     *\n     * @param content - The content.\n     * @param options - Options for placing the content.\n     *\n     * @public\n     */\n  }, {\n    key: \"putContent\",\n    value: function putContent(content) {\n      var _this26 = this;\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      if (this.isReadOnly) return this;\n      if (!content.schema) {\n        throw Error(\"Could not put content: content is missing a schema.\");\n      }\n      var _options$select = options.select,\n        select = _options$select === void 0 ? false : _options$select,\n        _options$preserveIds = options.preserveIds,\n        preserveIds = _options$preserveIds === void 0 ? false : _options$preserveIds,\n        _options$preservePosi = options.preservePosition,\n        preservePosition = _options$preservePosi === void 0 ? false : _options$preservePosi;\n      var _options$point = options.point,\n        point = _options$point === void 0 ? void 0 : _options$point;\n      var currentPageId = this.currentPageId;\n      var assets = content.assets,\n        shapes = content.shapes,\n        rootShapeIds = content.rootShapeIds;\n      var idMap = new Map(shapes.map(function (shape) {\n        return [shape.id, createShapeId()];\n      }));\n      var pasteParentId = this.currentPageId;\n      var lowestDepth = Infinity;\n      var lowestAncestors = [];\n      var _iterator21 = _createForOfIteratorHelper(this.selectedShapes),\n        _step21;\n      try {\n        for (_iterator21.s(); !(_step21 = _iterator21.n()).done;) {\n          var _shape2 = _step21.value;\n          if (lowestDepth === 0) break;\n          var isFrame = this.isShapeOfType(_shape2, FrameShapeUtil);\n          var ancestors = this.getAncestors(_shape2);\n          if (isFrame) ancestors.push(_shape2);\n          var depth = isFrame ? ancestors.length + 1 : ancestors.length;\n          if (depth < lowestDepth) {\n            lowestDepth = depth;\n            lowestAncestors = ancestors;\n            pasteParentId = isFrame ? _shape2.id : _shape2.parentId;\n          } else if (depth === lowestDepth) {\n            if (lowestAncestors.length !== ancestors.length) {\n              throw Error(\"Ancestors: \".concat(lowestAncestors.length, \" !== \").concat(ancestors.length));\n            }\n            if (lowestAncestors.length === 0) {\n              pasteParentId = currentPageId;\n              break;\n            } else {\n              pasteParentId = currentPageId;\n              for (var _i6 = 0; _i6 < lowestAncestors.length; _i6++) {\n                if (ancestors[_i6] !== lowestAncestors[_i6]) break;\n                pasteParentId = ancestors[_i6].id;\n              }\n            }\n          }\n        }\n      } catch (err) {\n        _iterator21.e(err);\n      } finally {\n        _iterator21.f();\n      }\n      var isDuplicating = false;\n      if (!isPageId(pasteParentId)) {\n        var parent = this.getShapeById(pasteParentId);\n        if (parent) {\n          if (!this.viewportPageBounds.includes(this.getPageBounds(parent))) {\n            pasteParentId = currentPageId;\n          } else {\n            if (rootShapeIds.length === 1) {\n              var rootShape = shapes.find(function (s) {\n                return s.id === rootShapeIds[0];\n              });\n              if (this.isShapeOfType(parent, FrameShapeUtil) && this.isShapeOfType(rootShape, FrameShapeUtil) && rootShape.props.w === (parent === null || parent === void 0 ? void 0 : parent.props.w) && rootShape.props.h === (parent === null || parent === void 0 ? void 0 : parent.props.h)) {\n                isDuplicating = true;\n              }\n            }\n          }\n        } else {\n          pasteParentId = currentPageId;\n        }\n      }\n      if (!isDuplicating) {\n        isDuplicating = idMap.has(pasteParentId);\n      }\n      if (isDuplicating) {\n        pasteParentId = this.getShapeById(pasteParentId).parentId;\n      }\n      var index = this.getHighestIndexForParent(pasteParentId);\n      var rootShapes = [];\n      var newShapes = shapes.map(function (shape) {\n        var newShape;\n        if (preserveIds) {\n          newShape = deepCopy(shape);\n          idMap.set(shape.id, shape.id);\n        } else {\n          var id = idMap.get(shape.id);\n          newShape = deepCopy(_objectSpread(_objectSpread({}, shape), {}, {\n            id: id\n          }));\n        }\n        if (rootShapeIds.includes(shape.id)) {\n          newShape.parentId = currentPageId;\n          rootShapes.push(newShape);\n        }\n        if (idMap.has(newShape.parentId)) {\n          newShape.parentId = idMap.get(shape.parentId);\n        } else {\n          rootShapeIds.push(newShape.id);\n          newShape.index = index;\n          index = getIndexAbove(index);\n        }\n        if (_this26.isShapeOfType(newShape, ArrowShapeUtil)) {\n          if (newShape.props.start.type === \"binding\") {\n            var mappedId = idMap.get(newShape.props.start.boundShapeId);\n            newShape.props.start = mappedId ? _objectSpread(_objectSpread({}, newShape.props.start), {}, {\n              boundShapeId: mappedId\n            }) :\n            // this shouldn't happen, if you copy an arrow but not it's bound shape it should\n            // convert the binding to a point at the time of copying\n            {\n              type: \"point\",\n              x: 0,\n              y: 0\n            };\n          }\n          if (newShape.props.end.type === \"binding\") {\n            var _mappedId = idMap.get(newShape.props.end.boundShapeId);\n            newShape.props.end = _mappedId ? _objectSpread(_objectSpread({}, newShape.props.end), {}, {\n              boundShapeId: _mappedId\n            }) :\n            // this shouldn't happen, if you copy an arrow but not it's bound shape it should\n            // convert the binding to a point at the time of copying\n            {\n              type: \"point\",\n              x: 0,\n              y: 0\n            };\n          }\n        }\n        return newShape;\n      });\n      if (newShapes.length + this.currentPageShapeIds.size > MAX_SHAPES_PER_PAGE) {\n        alertMaxShapes(this);\n        return this;\n      }\n      var assetsToCreate = [];\n      if (assets) {\n        for (var i = 0; i < assets.length; i++) {\n          var asset = assets[i];\n          var result = this.store.schema.migratePersistedRecord(asset, content.schema);\n          if (result.type === \"success\") {\n            assets[i] = result.value;\n          } else {\n            throw Error(\"Could not put content: could not migrate content for asset:\\n\".concat(JSON.stringify(asset, null, 2)));\n          }\n        }\n        var assetsToUpdate = [];\n        assetsToCreate = assets.filter(function (asset) {\n          return !_this26.store.has(asset.id);\n        }).map(function (asset) {\n          if (asset.type === \"image\" || asset.type === \"video\") {\n            var _asset$props$src;\n            if (asset.props.src && (_asset$props$src = asset.props.src) !== null && _asset$props$src !== void 0 && _asset$props$src.startsWith(\"data:image\")) {\n              assetsToUpdate.push(structuredClone(asset));\n              asset.props.src = null;\n            } else {\n              assetsToUpdate.push(structuredClone(asset));\n            }\n          }\n          return asset;\n        });\n        Promise.allSettled(assetsToUpdate.map( /*#__PURE__*/function () {\n          var _ref43 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(asset) {\n            var _asset$props$mimeType;\n            var file, newAsset;\n            return _regeneratorRuntime().wrap(function _callee$(_context) {\n              while (1) switch (_context.prev = _context.next) {\n                case 0:\n                  _context.next = 2;\n                  return dataUrlToFile(asset.props.src, asset.props.name, (_asset$props$mimeType = asset.props.mimeType) !== null && _asset$props$mimeType !== void 0 ? _asset$props$mimeType : \"image/png\");\n                case 2:\n                  file = _context.sent;\n                  _context.next = 5;\n                  return _this26.externalContentManager.createAssetFromFile(_this26, file);\n                case 5:\n                  newAsset = _context.sent;\n                  return _context.abrupt(\"return\", [asset, newAsset]);\n                case 7:\n                case \"end\":\n                  return _context.stop();\n              }\n            }, _callee);\n          }));\n          return function (_x4) {\n            return _ref43.apply(this, arguments);\n          };\n        }())).then(function (assets2) {\n          _this26.updateAssets(compact(assets2.map(function (result) {\n            return result.status === \"fulfilled\" ? _objectSpread(_objectSpread({}, result.value[1]), {}, {\n              id: result.value[0].id\n            }) : void 0;\n          })));\n        });\n      }\n      for (var _i5 = 0; _i5 < newShapes.length; _i5++) {\n        var shape = newShapes[_i5];\n        var _result = this.store.schema.migratePersistedRecord(shape, content.schema);\n        if (_result.type === \"success\") {\n          newShapes[_i5] = _result.value;\n        } else {\n          throw Error(\"Could not put content: could not migrate content for shape:\\n\".concat(JSON.stringify(shape, null, 2)));\n        }\n      }\n      this.batch(function () {\n        if (assetsToCreate.length > 0) {\n          _this26.createAssets(assetsToCreate);\n        }\n        _this26.createShapes(newShapes, select);\n        if (pasteParentId !== currentPageId) {\n          _this26.reparentShapesById(rootShapes.map(function (s) {\n            return s.id;\n          }), pasteParentId);\n        }\n        var newCreatedShapes = newShapes.map(function (s) {\n          return _this26.getShapeById(s.id);\n        });\n        var bounds = Box2d.Common(newCreatedShapes.map(function (s) {\n          return _this26.getPageBounds(s);\n        }));\n        if (point === void 0) {\n          if (!isPageId(pasteParentId)) {\n            var _shape = _this26.getShapeById(pasteParentId);\n            var util = _this26.getShapeUtil(_shape);\n            point = util.center(_shape);\n          } else {\n            var viewportPageBounds = _this26.viewportPageBounds;\n            if (preservePosition || viewportPageBounds.includes(Box2d.From(bounds))) {\n              point = bounds.center;\n            } else {\n              point = viewportPageBounds.center;\n            }\n          }\n        }\n        if (rootShapes.length === 1) {\n          var onlyRoot = rootShapes[0];\n          if (_this26.isShapeOfType(onlyRoot, FrameShapeUtil)) {\n            while (_this26.getShapesAtPoint(point).some(function (shape) {\n              return _this26.isShapeOfType(shape, FrameShapeUtil) && shape.props.w === onlyRoot.props.w && shape.props.h === onlyRoot.props.h;\n            })) {\n              point.x += bounds.w + 16;\n            }\n          }\n        }\n        _this26.updateShapes(rootShapes.map(function (s) {\n          var _s$x, _s$y;\n          var delta = {\n            x: ((_s$x = s.x) !== null && _s$x !== void 0 ? _s$x : 0) - (bounds.x + bounds.w / 2),\n            y: ((_s$y = s.y) !== null && _s$y !== void 0 ? _s$y : 0) - (bounds.y + bounds.h / 2)\n          };\n          return {\n            id: s.id,\n            type: s.type,\n            x: point.x + delta.x,\n            y: point.y + delta.y\n          };\n        }));\n      });\n      return this;\n    }\n    /**\n     * Create shapes.\n     *\n     * @example\n     * ```ts\n     * editor.createShapes([{ id: 'box1', type: 'text', props: { text: \"ok\" } }])\n     * ```\n     *\n     * @param partials - The shape partials to create.\n     * @param select - Whether to select the created shapes. Defaults to false.\n     *\n     * @public\n     */\n  }, {\n    key: \"createShapes\",\n    value: function createShapes(partials) {\n      var select = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      this._createShapes(partials, select);\n      return this;\n    }\n  }, {\n    key: \"animateShapes\",\n    value:\n    /**\n     * Animate shapes.\n     *\n     * @example\n     * ```ts\n     * editor.animateShapes([{ id: 'box1', type: 'box', x: 100, y: 100 }])\n     * ```\n     *\n     * @param partials - The shape partials to update.\n     *\n     * @public\n     */\n    function animateShapes(partials) {\n      var _this27 = this;\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var _options$duration = options.duration,\n        duration = _options$duration === void 0 ? 500 : _options$duration,\n        _options$ease = options.ease,\n        ease = _options$ease === void 0 ? EASINGS.linear : _options$ease;\n      var animationId = uniqueId();\n      var remaining = duration;\n      var t;\n      var animations = [];\n      partials.forEach(function (partial) {\n        if (!partial) return;\n        var result = {\n          partial: partial,\n          values: []\n        };\n        var shape = _this27.getShapeById(partial.id);\n        if (!shape) return;\n        for (var _i7 = 0, _arr2 = [\"x\", \"y\", \"rotation\"]; _i7 < _arr2.length; _i7++) {\n          var key = _arr2[_i7];\n          if (partial[key] !== void 0 && shape[key] !== partial[key]) {\n            result.values.push({\n              prop: key,\n              from: shape[key],\n              to: partial[key]\n            });\n          }\n        }\n        animations.push(result);\n        _this27.animatingShapes.set(shape.id, animationId);\n      });\n      var value;\n      var handleTick = function handleTick(elapsed) {\n        remaining -= elapsed;\n        if (remaining < 0) {\n          var animatingShapes2 = _this27.animatingShapes;\n          var partialsToUpdate = partials.filter(function (p) {\n            return p && animatingShapes2.get(p.id) === animationId;\n          });\n          if (partialsToUpdate.length) {\n            _this27.updateShapes(partialsToUpdate, false);\n          }\n          _this27.removeListener(\"tick\", handleTick);\n          return;\n        }\n        t = ease(1 - remaining / duration);\n        var animatingShapes = _this27.animatingShapes;\n        try {\n          var tPartials = [];\n          for (var i = 0; i < animations.length; i++) {\n            value = animations[i];\n            if (animatingShapes.get(value.partial.id) === animationId) {\n              tPartials.push(_objectSpread({\n                id: value.partial.id,\n                type: value.partial.type\n              }, value.values.reduce(function (acc, _ref44) {\n                var prop = _ref44.prop,\n                  from = _ref44.from,\n                  to = _ref44.to;\n                acc[prop] = from + (to - from) * t;\n                return acc;\n              }, {})));\n            }\n          }\n          _this27._updateShapes(tPartials, true);\n        } catch (e) {}\n      };\n      this.addListener(\"tick\", handleTick);\n      return this;\n    }\n    /**\n     * Update shapes using partials of each shape.\n     *\n     * @example\n     * ```ts\n     * editor.updateShapes([{ id: 'box1', type: 'geo', props: { w: 100, h: 100 } }])\n     * ```\n     *\n     * @param partials - The shape partials to update.\n     * @param squashing - Whether the change is ephemeral.\n     *\n     * @public\n     */\n  }, {\n    key: \"updateShapes\",\n    value: function updateShapes(partials) {\n      var _this28 = this;\n      var squashing = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var compactedPartials = compact(partials);\n      if (this.animatingShapes.size > 0) {\n        compactedPartials.forEach(function (p) {\n          return _this28.animatingShapes.delete(p.id);\n        });\n      }\n      compactedPartials = compactedPartials.filter(function (p) {\n        var shape = _this28.getShapeById(p.id);\n        if (!shape) return false;\n        if (_this28.isShapeOrAncestorLocked(shape) && !Object.hasOwn(p, \"isLocked\")) return false;\n        return true;\n      });\n      this._updateShapes(compactedPartials, squashing);\n      return this;\n    }\n  }, {\n    key: \"_getUnlockedShapeIds\",\n    value: /** @internal */\n    function _getUnlockedShapeIds(ids) {\n      var _this29 = this;\n      return ids.filter(function (id) {\n        var _this29$getShapeById;\n        return !((_this29$getShapeById = _this29.getShapeById(id)) !== null && _this29$getShapeById !== void 0 && _this29$getShapeById.isLocked);\n      });\n    }\n    /**\n     * Delete shapes.\n     *\n     * @example\n     * ```ts\n     * editor.deleteShapes()\n     * editor.deleteShapes(['box1', 'box2'])\n     * ```\n     *\n     * @param ids - The ids of the shapes to delete. Defaults to the selected shapes.\n     *\n     * @public\n     */\n  }, {\n    key: \"deleteShapes\",\n    value: function deleteShapes() {\n      var ids = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.selectedIds;\n      this._deleteShapes(this._getUnlockedShapeIds(ids));\n      return this;\n    }\n  }, {\n    key: \"locale\",\n    get:\n    /**\n     * Get the user's locale.\n     *\n     * @public\n     */\n    function get() {\n      return this.user.locale;\n    }\n    /**\n     * Update the user's locale. This affects which translations are used when rendering UI elements.\n     *\n     * @example\n     * ```ts\n     * editor.setLocale('fr')\n     * ```\n     *\n     * @public\n     */\n  }, {\n    key: \"setLocale\",\n    value: function setLocale(locale) {\n      this.user.updateUserPreferences({\n        locale: locale\n      });\n    }\n    /**\n     * Update a page.\n     *\n     * @example\n     * ```ts\n     * editor.updatePage({ id: 'page2', name: 'Page 2' })\n     * ```\n     *\n     * @param partial - The partial of the shape to update.\n     *\n     * @public\n     */\n  }, {\n    key: \"updatePage\",\n    value: function updatePage(partial) {\n      var squashing = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      this._updatePage(partial, squashing);\n      return this;\n    }\n  }, {\n    key: \"createPage\",\n    value:\n    /**\n     * Create a page.\n     *\n     * @example\n     * ```ts\n     * editor.createPage('New Page')\n     * editor.createPage('New Page', 'page1')\n     * ```\n     *\n     * @param id - The new page's id.\n     * @param title - The new page's title.\n     *\n     * @public\n     */\n    function createPage(title) {\n      var id = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : PageRecordType.createId();\n      var belowPageIndex = arguments.length > 2 ? arguments[2] : undefined;\n      this._createPage(title, id, belowPageIndex);\n      return this;\n    }\n  }, {\n    key: \"duplicatePage\",\n    value:\n    /**\n     * Duplicate a page.\n     *\n     * @param id - The id of the page to duplicate. Defaults to the current page.\n     * @param createId - The id of the new page. Defaults to a new id.\n     *\n     * @public\n     */\n    function duplicatePage() {\n      var _this30 = this;\n      var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.currentPageId;\n      var createId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : PageRecordType.createId();\n      if (this.pages.length >= MAX_PAGES) return this;\n      var page = this.getPageById(id);\n      if (!page) return this;\n      var camera = _objectSpread({}, this.camera);\n      var content = this.getContent(this.getSortedChildIds(page.id));\n      this.batch(function () {\n        _this30.createPage(page.name + \" Copy\", createId, page.index);\n        _this30.setCurrentPageId(createId);\n        _this30.setCamera(camera.x, camera.y, camera.z);\n        if (content) {\n          return _this30.putContent(content);\n        }\n      });\n      return this;\n    }\n    /**\n     * Delete a page.\n     *\n     * @example\n     * ```ts\n     * editor.deletePage('page1')\n     * ```\n     *\n     * @param id - The id of the page to delete.\n     *\n     * @public\n     */\n  }, {\n    key: \"deletePage\",\n    value: function deletePage(id) {\n      this._deletePage(id);\n    }\n  }, {\n    key: \"_assets\",\n    get: function get() {\n      return this.store.query.records(\"asset\");\n    }\n    /**\n     * Get all assets in the editor.\n     *\n     * @public\n     */\n  }, {\n    key: \"assets\",\n    get: function get() {\n      return this._assets.value;\n    }\n    /**\n     * Create one or more assets.\n     *\n     * @example\n     * ```ts\n     * editor.createAssets([...myAssets])\n     * ```\n     *\n     * @param assets - The assets to create.\n     *\n     * @public\n     */\n  }, {\n    key: \"createAssets\",\n    value: function createAssets(assets) {\n      this._createAssets(assets);\n      return this;\n    }\n  }, {\n    key: \"deleteAssets\",\n    value:\n    /**\n     * Delete one or more assets.\n     *\n     * @example\n     * ```ts\n     * editor.deleteAssets(['asset1', 'asset2'])\n     * ```\n     *\n     * @param ids - The assets to delete.\n     *\n     * @public\n     */\n    function deleteAssets(ids) {\n      this._deleteAssets(ids);\n      return this;\n    }\n  }, {\n    key: \"updateAssets\",\n    value:\n    /**\n     * Update one or more assets.\n     *\n     * @example\n     * ```ts\n     * editor.updateAssets([{ id: 'asset1', name: 'New name' }])\n     * ```\n     *\n     * @param assets - The assets to update.\n     *\n     * @public\n     */\n    function updateAssets(assets) {\n      this._updateAssets(assets);\n      return this;\n    }\n  }, {\n    key: \"getAssetBySrc\",\n    value:\n    /**\n     * Get an asset by its src property.\n     *\n     * @example\n     * ```ts\n     * editor.getAssetBySource('https://example.com/image.png')\n     * ```\n     *\n     * @param src - The source value of the asset.\n     *\n     * @public\n     */\n    function getAssetBySrc(src) {\n      return this.assets.find(function (a) {\n        return a.props.src === src;\n      });\n    }\n    /**\n     * Get an asset by its id.\n     *\n     * @example\n     * ```ts\n     * editor.getAssetById('asset1')\n     * ```\n     *\n     * @param id - The id of the asset.\n     *\n     * @public\n     */\n  }, {\n    key: \"getAssetById\",\n    value: function getAssetById(id) {\n      return this.store.get(id);\n    }\n    /**\n     * Rename a page.\n     *\n     * @example\n     * ```ts\n     * editor.renamePage('page1', 'My Page')\n     * ```\n     *\n     * @param id - The id of the page to rename.\n     * @param name - The new name.\n     *\n     * @public\n     */\n  }, {\n    key: \"renamePage\",\n    value: function renamePage(id, name) {\n      var squashing = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      if (this.isReadOnly) return this;\n      this.updatePage({\n        id: id,\n        name: name\n      }, squashing);\n      return this;\n    }\n    /**\n     * Move shapes to page.\n     *\n     * @example\n     * ```ts\n     * editor.moveShapesToPage(['box1', 'box2'], 'page1')\n     * ```\n     *\n     * @param ids - The ids of the shapes to move.\n     * @param pageId - The id of the page where the shapes will be moved.\n     *\n     * @public\n     */\n  }, {\n    key: \"moveShapesToPage\",\n    value: function moveShapesToPage(ids, pageId) {\n      var _this31 = this;\n      if (ids.length === 0) return this;\n      if (this.isReadOnly) return this;\n      var currentPageId = this.currentPageId;\n      if (pageId === currentPageId) return this;\n      if (!this.store.has(pageId)) return this;\n      var content = this.getContent(ids);\n      if (!content) return this;\n      if (this.getShapeIdsInPage(pageId).size + content.shapes.length > MAX_SHAPES_PER_PAGE) {\n        alertMaxShapes(this, pageId);\n        return this;\n      }\n      var fromPageZ = this.camera.z;\n      this.history.batch(function () {\n        _this31.deleteShapes(ids);\n        _this31.setCurrentPageId(pageId);\n        _this31.setFocusLayer(null);\n        _this31.selectNone();\n        _this31.putContent(content, {\n          select: true,\n          preserveIds: true,\n          preservePosition: true\n        });\n        var _this31$selectionBoun = _this31.selectionBounds.center,\n          x = _this31$selectionBoun.x,\n          y = _this31$selectionBoun.y;\n        _this31.setCamera(_this31.camera.x, _this31.camera.y, fromPageZ);\n        _this31.centerOnPoint(x, y);\n      });\n      return this;\n    }\n    /**\n     * Toggle the lock state of one or more shapes. If there is a mix of locked and unlocked shapes, all shapes will be locked.\n     *\n     * @param ids - The ids of the shapes to toggle. Defaults to selected shapes.\n     *\n     * @public\n     */\n  }, {\n    key: \"toggleLock\",\n    value: function toggleLock() {\n      var ids = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.selectedIds;\n      if (this.isReadOnly || ids.length === 0) return this;\n      var allLocked = true,\n        allUnlocked = true;\n      var shapes = [];\n      var _iterator22 = _createForOfIteratorHelper(ids),\n        _step22;\n      try {\n        for (_iterator22.s(); !(_step22 = _iterator22.n()).done;) {\n          var id = _step22.value;\n          var shape = this.getShapeById(id);\n          if (shape) {\n            shapes.push(shape);\n            if (shape.isLocked) {\n              allUnlocked = false;\n            } else {\n              allLocked = false;\n            }\n          }\n        }\n      } catch (err) {\n        _iterator22.e(err);\n      } finally {\n        _iterator22.f();\n      }\n      if (allUnlocked) {\n        this.updateShapes(shapes.map(function (shape) {\n          return {\n            id: shape.id,\n            type: shape.type,\n            isLocked: true\n          };\n        }));\n        this.setSelectedIds([]);\n      } else if (allLocked) {\n        this.updateShapes(shapes.map(function (shape) {\n          return {\n            id: shape.id,\n            type: shape.type,\n            isLocked: false\n          };\n        }));\n      } else {\n        this.updateShapes(shapes.map(function (shape) {\n          return {\n            id: shape.id,\n            type: shape.type,\n            isLocked: true\n          };\n        }));\n      }\n      return this;\n    }\n    /**\n     * Reorder shapes.\n     *\n     * @param operation - The operation to perform.\n     * @param ids - The ids to reorder.\n     *\n     * @public\n     */\n  }, {\n    key: \"reorderShapes\",\n    value: function reorderShapes(operation, ids) {\n      var _this32 = this;\n      if (this.isReadOnly) return this;\n      if (ids.length === 0) return this;\n      var parents = this.getParentsMappedToChildren(ids);\n      var changes = [];\n      switch (operation) {\n        case \"toBack\":\n          {\n            parents.forEach(function (movingSet, parentId) {\n              var siblings = compact(_this32.getSortedChildIds(parentId).map(function (id) {\n                return _this32.getShapeById(id);\n              }));\n              if (movingSet.size === siblings.length) return;\n              var below;\n              var above;\n              var _iterator23 = _createForOfIteratorHelper(siblings),\n                _step23;\n              try {\n                for (_iterator23.s(); !(_step23 = _iterator23.n()).done;) {\n                  var shape = _step23.value;\n                  if (!movingSet.has(shape)) {\n                    above = shape.index;\n                    break;\n                  }\n                  movingSet.delete(shape);\n                  below = shape.index;\n                }\n              } catch (err) {\n                _iterator23.e(err);\n              } finally {\n                _iterator23.f();\n              }\n              if (movingSet.size === 0) return;\n              var indices = getIndicesBetween(below, above, movingSet.size);\n              Array.from(movingSet.values()).sort(sortByIndex).forEach(function (node, i) {\n                return changes.push({\n                  id: node.id,\n                  type: node.type,\n                  index: indices[i]\n                });\n              });\n            });\n            break;\n          }\n        case \"toFront\":\n          {\n            parents.forEach(function (movingSet, parentId) {\n              var siblings = compact(_this32.getSortedChildIds(parentId).map(function (id) {\n                return _this32.getShapeById(id);\n              }));\n              var len = siblings.length;\n              if (movingSet.size === len) return;\n              var below;\n              var above;\n              for (var i = len - 1; i > -1; i--) {\n                var shape = siblings[i];\n                if (!movingSet.has(shape)) {\n                  below = shape.index;\n                  break;\n                }\n                movingSet.delete(shape);\n                above = shape.index;\n              }\n              if (movingSet.size === 0) return;\n              var indices = getIndicesBetween(below, above, movingSet.size);\n              Array.from(movingSet.values()).sort(sortByIndex).forEach(function (node, i) {\n                return changes.push({\n                  id: node.id,\n                  type: node.type,\n                  index: indices[i]\n                });\n              });\n            });\n            break;\n          }\n        case \"forward\":\n          {\n            parents.forEach(function (movingSet, parentId) {\n              var siblings = compact(_this32.getSortedChildIds(parentId).map(function (id) {\n                return _this32.getShapeById(id);\n              }));\n              var len = siblings.length;\n              if (movingSet.size === len) return;\n              var movingIndices = new Set(Array.from(movingSet).map(function (n) {\n                return siblings.indexOf(n);\n              }));\n              var selectIndex = -1;\n              var isSelecting = false;\n              var below;\n              var above;\n              var count;\n              for (var i = 0; i < len; i++) {\n                var isMoving = movingIndices.has(i);\n                if (!isSelecting && isMoving) {\n                  isSelecting = true;\n                  selectIndex = i;\n                  above = void 0;\n                } else if (isSelecting && !isMoving) {\n                  var _siblings;\n                  isSelecting = false;\n                  count = i - selectIndex;\n                  below = siblings[i].index;\n                  above = (_siblings = siblings[i + 1]) === null || _siblings === void 0 ? void 0 : _siblings.index;\n                  var indices = getIndicesBetween(below, above, count);\n                  for (var k = 0; k < count; k++) {\n                    var node = siblings[selectIndex + k];\n                    changes.push({\n                      id: node.id,\n                      type: node.type,\n                      index: indices[k]\n                    });\n                  }\n                }\n              }\n            });\n            break;\n          }\n        case \"backward\":\n          {\n            parents.forEach(function (movingSet, parentId) {\n              var siblings = compact(_this32.getSortedChildIds(parentId).map(function (id) {\n                return _this32.getShapeById(id);\n              }));\n              var len = siblings.length;\n              if (movingSet.size === len) return;\n              var movingIndices = new Set(Array.from(movingSet).map(function (n) {\n                return siblings.indexOf(n);\n              }));\n              var selectIndex = -1;\n              var isSelecting = false;\n              var count;\n              for (var i = len - 1; i > -1; i--) {\n                var isMoving = movingIndices.has(i);\n                if (!isSelecting && isMoving) {\n                  isSelecting = true;\n                  selectIndex = i;\n                } else if (isSelecting && !isMoving) {\n                  var _siblings2;\n                  isSelecting = false;\n                  count = selectIndex - i;\n                  var indices = getIndicesBetween((_siblings2 = siblings[i - 1]) === null || _siblings2 === void 0 ? void 0 : _siblings2.index, siblings[i].index, count);\n                  for (var k = 0; k < count; k++) {\n                    var node = siblings[i + k + 1];\n                    changes.push({\n                      id: node.id,\n                      type: node.type,\n                      index: indices[k]\n                    });\n                  }\n                }\n              }\n            });\n            break;\n          }\n      }\n      this.updateShapes(changes);\n      return this;\n    }\n    /**\n     * Send shapes to the back of the page's object list.\n     *\n     * @example\n     * ```ts\n     * editor.sendToBack()\n     * editor.sendToBack(['id1', 'id2'])\n     * ```\n     *\n     * @param ids - The ids of the shapes to move. Defaults to the ids of the selected shapes.\n     *\n     * @public\n     */\n  }, {\n    key: \"sendToBack\",\n    value: function sendToBack() {\n      var ids = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.pageState.selectedIds;\n      this.reorderShapes(\"toBack\", ids);\n      return this;\n    }\n    /**\n     * Send shapes backward in the page's object list.\n     *\n     * @example\n     * ```ts\n     * editor.sendBackward()\n     * editor.sendBackward(['id1', 'id2'])\n     * ```\n     *\n     * @param ids - The ids of the shapes to move. Defaults to the ids of the selected shapes.\n     *\n     * @public\n     */\n  }, {\n    key: \"sendBackward\",\n    value: function sendBackward() {\n      var ids = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.pageState.selectedIds;\n      this.reorderShapes(\"backward\", ids);\n      return this;\n    }\n    /**\n     * Bring shapes forward in the page's object list.\n     *\n     * @example\n     * ```ts\n     * editor.bringForward()\n     * editor.bringForward(['id1', 'id2'])\n     * ```\n     *\n     * @param ids - The ids of the shapes to move. Defaults to the ids of the selected shapes.\n     *\n     * @public\n     */\n  }, {\n    key: \"bringForward\",\n    value: function bringForward() {\n      var ids = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.pageState.selectedIds;\n      this.reorderShapes(\"forward\", ids);\n      return this;\n    }\n    /**\n     * Bring shapes to the front of the page's object list.\n     *\n     * @example\n     * ```ts\n     * editor.bringToFront()\n     * editor.bringToFront(['id1', 'id2'])\n     * ```\n     *\n     * @param ids - The ids of the shapes to move. Defaults to the ids of the selected shapes.\n     *\n     * @public\n     */\n  }, {\n    key: \"bringToFront\",\n    value: function bringToFront() {\n      var ids = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.pageState.selectedIds;\n      this.reorderShapes(\"toFront\", ids);\n      return this;\n    }\n    /**\n     * Flip shape positions.\n     *\n     * @example\n     * ```ts\n     * editor.flipShapes('horizontal')\n     * editor.flipShapes('horizontal', ['box1', 'box2'])\n     * ```\n     *\n     * @param operation - Whether to flip horizontally or vertically.\n     * @param ids - The ids of the shapes to flip. Defaults to selected shapes.\n     *\n     * @public\n     */\n  }, {\n    key: \"flipShapes\",\n    value: function flipShapes(operation) {\n      var _this33 = this;\n      var ids = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.selectedIds;\n      if (this.isReadOnly) return this;\n      var shapes = compact(ids.map(function (id) {\n        return _this33.getShapeById(id);\n      }));\n      if (!shapes.length) return this;\n      shapes = compact(shapes.map(function (shape) {\n        if (_this33.isShapeOfType(shape, GroupShapeUtil)) {\n          return _this33.getSortedChildIds(shape.id).map(function (id) {\n            return _this33.getShapeById(id);\n          });\n        }\n        return shape;\n      }).flat());\n      var scaleOriginPage = Box2d.Common(compact(shapes.map(function (id) {\n        return _this33.getPageBounds(id);\n      }))).center;\n      this.batch(function () {\n        var _iterator24 = _createForOfIteratorHelper(shapes),\n          _step24;\n        try {\n          for (_iterator24.s(); !(_step24 = _iterator24.n()).done;) {\n            var shape = _step24.value;\n            var util = _this33.getShapeUtil(shape);\n            var bounds = util.bounds(shape);\n            var initialPageTransform = _this33.getPageTransformById(shape.id);\n            if (!initialPageTransform) continue;\n            _this33.resizeShape(shape.id, {\n              x: operation === \"horizontal\" ? -1 : 1,\n              y: operation === \"vertical\" ? -1 : 1\n            }, {\n              initialBounds: bounds,\n              initialPageTransform: initialPageTransform,\n              initialShape: shape,\n              mode: \"scale_shape\",\n              scaleOrigin: scaleOriginPage,\n              scaleAxisRotation: 0\n            });\n          }\n        } catch (err) {\n          _iterator24.e(err);\n        } finally {\n          _iterator24.f();\n        }\n      });\n      return this;\n    }\n    /**\n     * Stack shape.\n     *\n     * @example\n     * ```ts\n     * editor.stackShapes('horizontal')\n     * editor.stackShapes('horizontal', ['box1', 'box2'])\n     * editor.stackShapes('horizontal', ['box1', 'box2'], 20)\n     * ```\n     *\n     * @param operation - Whether to stack horizontally or vertically.\n     * @param ids - The ids of the shapes to stack. Defaults to selected shapes.\n     * @param gap - A specific gap to use when stacking.\n     *\n     * @public\n     */\n  }, {\n    key: \"stackShapes\",\n    value: function stackShapes(operation) {\n      var _this34 = this;\n      var ids = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.pageState.selectedIds;\n      var gap = arguments.length > 2 ? arguments[2] : undefined;\n      if (this.isReadOnly) return this;\n      var shapes = compact(ids.map(function (id) {\n        return _this34.getShapeById(id);\n      })).filter(function (shape) {\n        if (!shape) return false;\n        if (_this34.isShapeOfType(shape, ArrowShapeUtil)) {\n          if (shape.props.start.type === \"binding\" || shape.props.end.type === \"binding\") {\n            return false;\n          }\n        }\n        return true;\n      });\n      var len = shapes.length;\n      if (gap === void 0 && len < 3 || len < 2) return this;\n      var pageBounds = Object.fromEntries(shapes.map(function (shape) {\n        return [shape.id, _this34.getPageBounds(shape)];\n      }));\n      var val;\n      var min;\n      var max;\n      var dim;\n      if (operation === \"horizontal\") {\n        val = \"x\";\n        min = \"minX\";\n        max = \"maxX\";\n        dim = \"width\";\n      } else {\n        val = \"y\";\n        min = \"minY\";\n        max = \"maxY\";\n        dim = \"height\";\n      }\n      var shapeGap;\n      if (gap === void 0) {\n        var gaps = [];\n        shapes.sort(function (a, b) {\n          return pageBounds[a.id][min] - pageBounds[b.id][min];\n        });\n        var _loop = function _loop() {\n          var shape = shapes[i];\n          var nextShape = shapes[i + 1];\n          var bounds = pageBounds[shape.id];\n          var nextBounds = pageBounds[nextShape.id];\n          var gap2 = nextBounds[min] - bounds[max];\n          var current = gaps.find(function (g) {\n            return g.gap === gap2;\n          });\n          if (current) {\n            current.count++;\n          } else {\n            gaps.push({\n              gap: gap2,\n              count: 1\n            });\n          }\n        };\n        for (var i = 0; i < len - 1; i++) {\n          _loop();\n        }\n        var maxCount = 0;\n        gaps.forEach(function (g) {\n          if (g.count > maxCount) {\n            maxCount = g.count;\n            shapeGap = g.gap;\n          }\n        });\n        if (maxCount === 1) {\n          shapeGap = Math.max(0, gaps.reduce(function (a, c) {\n            return a + c.gap * c.count;\n          }, 0) / (len - 1));\n        }\n      } else {\n        shapeGap = gap;\n      }\n      var changes = [];\n      var v = pageBounds[shapes[0].id][max];\n      shapes.forEach(function (shape, i) {\n        var _this34$getShapeUtil$, _this34$getShapeUtil;\n        if (i === 0) return;\n        var delta = {\n          x: 0,\n          y: 0\n        };\n        delta[val] = v + shapeGap - pageBounds[shape.id][val];\n        var parent = _this34.getParentShape(shape);\n        var localDelta = parent ? Vec2d.Rot(delta, -_this34.getPageRotation(parent)) : delta;\n        var translateStartChanges = (_this34$getShapeUtil$ = (_this34$getShapeUtil = _this34.getShapeUtil(shape)).onTranslateStart) === null || _this34$getShapeUtil$ === void 0 ? void 0 : _this34$getShapeUtil$.call(_this34$getShapeUtil, shape);\n        changes.push(translateStartChanges ? _objectSpread(_objectSpread({}, translateStartChanges), {}, _defineProperty({}, val, shape[val] + localDelta[val])) : _defineProperty({\n          id: shape.id,\n          type: shape.type\n        }, val, shape[val] + localDelta[val]));\n        v += pageBounds[shape.id][dim] + shapeGap;\n      });\n      this.updateShapes(changes);\n      return this;\n    }\n    /**\n     * Pack shapes into a grid centered on their current position. Based on potpack\n     * (https://github.com/mapbox/potpack)\n     * @param ids - The ids of the shapes to pack. Defaults to selected shapes.\n     * @param padding - The padding to apply to the packed shapes.\n     */\n  }, {\n    key: \"packShapes\",\n    value: function packShapes() {\n      var _this35 = this;\n      var ids = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.pageState.selectedIds;\n      var padding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 16;\n      if (this.isReadOnly) return this;\n      if (ids.length < 2) return this;\n      var shapes = compact(ids.map(function (id) {\n        return _this35.getShapeById(id);\n      }).filter(function (shape2) {\n        if (!shape2) return false;\n        if (_this35.isShapeOfType(shape2, ArrowShapeUtil)) {\n          if (shape2.props.start.type === \"binding\" || shape2.props.end.type === \"binding\") {\n            return false;\n          }\n        }\n        return true;\n      }));\n      var shapePageBounds = {};\n      var nextShapePageBounds = {};\n      var shape,\n        bounds,\n        area = 0;\n      for (var i = 0; i < shapes.length; i++) {\n        shape = shapes[i];\n        bounds = this.getPageBounds(shape);\n        shapePageBounds[shape.id] = bounds;\n        nextShapePageBounds[shape.id] = bounds.clone();\n        area += bounds.width * bounds.height;\n      }\n      var commonBounds = Box2d.Common(compact(Object.values(shapePageBounds)));\n      var maxWidth = commonBounds.width;\n      shapes.sort(function (a, b) {\n        return shapePageBounds[b.id].height - shapePageBounds[a.id].height;\n      });\n      var startWidth = Math.max(Math.ceil(Math.sqrt(area / 0.95)), maxWidth);\n      var spaces = [new Box2d(commonBounds.x, commonBounds.y, startWidth, Infinity)];\n      var width = 0;\n      var height = 0;\n      var space;\n      var last;\n      for (var _i8 = 0; _i8 < shapes.length; _i8++) {\n        shape = shapes[_i8];\n        bounds = nextShapePageBounds[shape.id];\n        for (var i2 = spaces.length - 1; i2 >= 0; i2--) {\n          space = spaces[i2];\n          if (bounds.width > space.width || bounds.height > space.height) continue;\n          bounds.x = space.x;\n          bounds.y = space.y;\n          height = Math.max(height, bounds.maxY);\n          width = Math.max(width, bounds.maxX);\n          if (bounds.width === space.width && bounds.height === space.height) {\n            last = spaces.pop();\n            if (i2 < spaces.length) spaces[i2] = last;\n          } else if (bounds.height === space.height) {\n            space.x += bounds.width + padding;\n            space.width -= bounds.width + padding;\n          } else if (bounds.width === space.width) {\n            space.y += bounds.height + padding;\n            space.height -= bounds.height + padding;\n          } else {\n            spaces.push(new Box2d(space.x + (bounds.width + padding), space.y, space.width - (bounds.width + padding), bounds.height));\n            space.y += bounds.height + padding;\n            space.height -= bounds.height + padding;\n          }\n          break;\n        }\n      }\n      var commonAfter = Box2d.Common(Object.values(nextShapePageBounds));\n      var centerDelta = Vec2d.Sub(commonBounds.center, commonAfter.center);\n      var nextBounds;\n      var changes = [];\n      for (var _i9 = 0; _i9 < shapes.length; _i9++) {\n        var _this$getShapeUtil$on3, _this$getShapeUtil3;\n        shape = shapes[_i9];\n        bounds = shapePageBounds[shape.id];\n        nextBounds = nextShapePageBounds[shape.id];\n        var delta = this.getDeltaInParentSpace(shape, Vec2d.Sub(nextBounds.point, bounds.point).add(centerDelta));\n        var change = {\n          id: shape.id,\n          type: shape.type,\n          x: shape.x + delta.x,\n          y: shape.y + delta.y\n        };\n        var translateStartChange = (_this$getShapeUtil$on3 = (_this$getShapeUtil3 = this.getShapeUtil(shape)).onTranslateStart) === null || _this$getShapeUtil$on3 === void 0 ? void 0 : _this$getShapeUtil$on3.call(_this$getShapeUtil3, _objectSpread(_objectSpread({}, shape), change));\n        if (translateStartChange) {\n          changes.push(_objectSpread(_objectSpread({}, change), translateStartChange));\n        } else {\n          changes.push(change);\n        }\n      }\n      if (changes.length) {\n        this.updateShapes(changes);\n      }\n      return this;\n    }\n    /**\n     * Align shape positions.\n     *\n     * @example\n     * ```ts\n     * editor.alignShapes('left')\n     * editor.alignShapes('left', ['box1', 'box2'])\n     * ```\n     *\n     * @param operation - The align operation to apply.\n     * @param ids - The ids of the shapes to align. Defaults to selected shapes.\n     *\n     * @public\n     */\n  }, {\n    key: \"alignShapes\",\n    value: function alignShapes(operation) {\n      var _this36 = this;\n      var ids = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.pageState.selectedIds;\n      if (this.isReadOnly) return this;\n      if (ids.length < 2) return this;\n      var shapes = compact(ids.map(function (id) {\n        return _this36.getShapeById(id);\n      }));\n      var shapePageBounds = Object.fromEntries(shapes.map(function (shape) {\n        return [shape.id, _this36.getPageBounds(shape)];\n      }));\n      var commonBounds = Box2d.Common(compact(Object.values(shapePageBounds)));\n      var changes = [];\n      shapes.forEach(function (shape) {\n        var _this36$getShapeUtil$, _this36$getShapeUtil;\n        var pageBounds = shapePageBounds[shape.id];\n        if (!pageBounds) return;\n        var delta = {\n          x: 0,\n          y: 0\n        };\n        switch (operation) {\n          case \"top\":\n            {\n              delta.y = commonBounds.minY - pageBounds.minY;\n              break;\n            }\n          case \"center-vertical\":\n            {\n              delta.y = commonBounds.midY - pageBounds.minY - pageBounds.height / 2;\n              break;\n            }\n          case \"bottom\":\n            {\n              delta.y = commonBounds.maxY - pageBounds.minY - pageBounds.height;\n              break;\n            }\n          case \"left\":\n            {\n              delta.x = commonBounds.minX - pageBounds.minX;\n              break;\n            }\n          case \"center-horizontal\":\n            {\n              delta.x = commonBounds.midX - pageBounds.minX - pageBounds.width / 2;\n              break;\n            }\n          case \"right\":\n            {\n              delta.x = commonBounds.maxX - pageBounds.minX - pageBounds.width;\n              break;\n            }\n        }\n        var parent = _this36.getParentShape(shape);\n        var localDelta = parent ? Vec2d.Rot(delta, -_this36.getPageRotation(parent)) : delta;\n        var translateChanges = (_this36$getShapeUtil$ = (_this36$getShapeUtil = _this36.getShapeUtil(shape)).onTranslateStart) === null || _this36$getShapeUtil$ === void 0 ? void 0 : _this36$getShapeUtil$.call(_this36$getShapeUtil, shape);\n        changes.push(translateChanges ? _objectSpread(_objectSpread({}, translateChanges), {}, {\n          x: shape.x + localDelta.x,\n          y: shape.y + localDelta.y\n        }) : {\n          id: shape.id,\n          type: shape.type,\n          x: shape.x + localDelta.x,\n          y: shape.y + localDelta.y\n        });\n      });\n      this.updateShapes(changes);\n      return this;\n    }\n    /**\n     * Distribute shape positions.\n     *\n     * @example\n     * ```ts\n     * editor.distributeShapes('left')\n     * editor.distributeShapes('left', ['box1', 'box2'])\n     * ```\n     *\n     * @param operation - Whether to distribute shapes horizontally or vertically.\n     * @param ids - The ids of the shapes to distribute. Defaults to selected shapes.\n     *\n     * @public\n     */\n  }, {\n    key: \"distributeShapes\",\n    value: function distributeShapes(operation) {\n      var _this37 = this;\n      var ids = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.pageState.selectedIds;\n      if (this.isReadOnly) return this;\n      if (ids.length < 3) return this;\n      var len = ids.length;\n      var shapes = compact(ids.map(function (id) {\n        return _this37.getShapeById(id);\n      }));\n      var pageBounds = Object.fromEntries(shapes.map(function (shape) {\n        return [shape.id, _this37.getPageBounds(shape)];\n      }));\n      var val;\n      var min;\n      var max;\n      var mid;\n      var dim;\n      if (operation === \"horizontal\") {\n        val = \"x\";\n        min = \"minX\";\n        max = \"maxX\";\n        mid = \"midX\";\n        dim = \"width\";\n      } else {\n        val = \"y\";\n        min = \"minY\";\n        max = \"maxY\";\n        mid = \"midY\";\n        dim = \"height\";\n      }\n      var changes = [];\n      var first = shapes.sort(function (a, b) {\n        return pageBounds[a.id][min] - pageBounds[b.id][min];\n      })[0];\n      var last = shapes.sort(function (a, b) {\n        return pageBounds[b.id][max] - pageBounds[a.id][max];\n      })[0];\n      var midFirst = pageBounds[first.id][mid];\n      var step = (pageBounds[last.id][mid] - midFirst) / (len - 1);\n      var v = midFirst + step;\n      shapes.filter(function (shape) {\n        return shape !== first && shape !== last;\n      }).sort(function (a, b) {\n        return pageBounds[a.id][mid] - pageBounds[b.id][mid];\n      }).forEach(function (shape, i) {\n        var _this37$getShapeUtil$, _this37$getShapeUtil;\n        var delta = {\n          x: 0,\n          y: 0\n        };\n        delta[val] = v + step * i - pageBounds[shape.id][dim] / 2 - pageBounds[shape.id][val];\n        var parent = _this37.getParentShape(shape);\n        var localDelta = parent ? Vec2d.Rot(delta, -_this37.getPageRotation(parent)) : delta;\n        var translateStartChanges = (_this37$getShapeUtil$ = (_this37$getShapeUtil = _this37.getShapeUtil(shape)).onTranslateStart) === null || _this37$getShapeUtil$ === void 0 ? void 0 : _this37$getShapeUtil$.call(_this37$getShapeUtil, shape);\n        changes.push(translateStartChanges ? _objectSpread(_objectSpread({}, translateStartChanges), {}, _defineProperty({}, val, shape[val] + localDelta[val])) : _defineProperty({\n          id: shape.id,\n          type: shape.type\n        }, val, shape[val] + localDelta[val]));\n      });\n      this.updateShapes(changes);\n      return this;\n    }\n    /** @internal */\n  }, {\n    key: \"_resizeUnalignedShape\",\n    value: function _resizeUnalignedShape(id, scale, options) {\n      var type = options.initialShape.type;\n      var shapeScale = new Vec2d(scale.x, scale.y);\n      if (Math.abs(scale.x) > Math.abs(scale.y)) {\n        shapeScale.x = Math.sign(scale.x) * Math.abs(scale.y);\n      } else {\n        shapeScale.y = Math.sign(scale.y) * Math.abs(scale.x);\n      }\n      this.resizeShape(id, shapeScale, {\n        initialShape: options.initialShape,\n        initialBounds: options.initialBounds\n      });\n      if (Math.sign(scale.x) * Math.sign(scale.y) < 0) {\n        var _Matrix2d$Decompose = Matrix2d.Decompose(options.initialPageTransform),\n          rotation = _Matrix2d$Decompose.rotation;\n        rotation -= 2 * rotation;\n        this.updateShapes([{\n          id: id,\n          type: type,\n          rotation: rotation\n        }], true);\n      }\n      var preScaleShapePageCenter = Matrix2d.applyToPoint(options.initialPageTransform, options.initialBounds.center);\n      var postScaleShapePageCenter = this._scalePagePoint(preScaleShapePageCenter, options.scaleOrigin, scale, options.scaleAxisRotation);\n      var currentPageCenter = this.getPageCenterById(id);\n      var currentPagePoint = this.getPagePointById(id);\n      if (!currentPageCenter || !currentPagePoint) return this;\n      var pageDelta = Vec2d.Sub(postScaleShapePageCenter, currentPageCenter);\n      var postScaleShapePagePoint = Vec2d.Add(currentPagePoint, pageDelta);\n      var _this$getPointInParen = this.getPointInParentSpace(id, postScaleShapePagePoint),\n        x = _this$getPointInParen.x,\n        y = _this$getPointInParen.y;\n      this.updateShapes([{\n        id: id,\n        type: type,\n        x: x,\n        y: y\n      }], true);\n      return this;\n    }\n    /** @internal */\n  }, {\n    key: \"_scalePagePoint\",\n    value: function _scalePagePoint(point, scaleOrigin, scale, scaleAxisRotation) {\n      var relativePoint = Vec2d.RotWith(point, scaleOrigin, -scaleAxisRotation).sub(scaleOrigin);\n      var newRelativePagePoint = Vec2d.MulV(relativePoint, scale);\n      var destination = Vec2d.Add(newRelativePagePoint, scaleOrigin).rotWith(scaleOrigin, scaleAxisRotation);\n      return destination;\n    }\n    /**\n     * Resize a shape.\n     *\n     * @param id - The id of the shape to resize.\n     * @param scale - The scale factor to apply to the shape.\n     * @param options - Additional options.\n     *\n     * @public\n     */\n  }, {\n    key: \"resizeShape\",\n    value: function resizeShape(id, scale) {\n      var _options$initialShape, _options$scaleOrigin, _this$getPageBoundsBy, _options$scaleAxisRot, _options$initialPageT, _options$initialBound;\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      if (this.isReadOnly) return this;\n      if (!Number.isFinite(scale.x)) scale = new Vec2d(1, scale.y);\n      if (!Number.isFinite(scale.y)) scale = new Vec2d(scale.x, 1);\n      var initialShape = (_options$initialShape = options.initialShape) !== null && _options$initialShape !== void 0 ? _options$initialShape : this.getShapeById(id);\n      if (!initialShape) return this;\n      var scaleOrigin = (_options$scaleOrigin = options.scaleOrigin) !== null && _options$scaleOrigin !== void 0 ? _options$scaleOrigin : (_this$getPageBoundsBy = this.getPageBoundsById(id)) === null || _this$getPageBoundsBy === void 0 ? void 0 : _this$getPageBoundsBy.center;\n      if (!scaleOrigin) return this;\n      var pageRotation = this.getPageRotationById(id);\n      if (pageRotation == null) return this;\n      var scaleAxisRotation = (_options$scaleAxisRot = options.scaleAxisRotation) !== null && _options$scaleAxisRot !== void 0 ? _options$scaleAxisRot : pageRotation;\n      var pageTransform = (_options$initialPageT = options.initialPageTransform) !== null && _options$initialPageT !== void 0 ? _options$initialPageT : this.getPageTransformById(id);\n      if (!pageTransform) return this;\n      var initialBounds = (_options$initialBound = options.initialBounds) !== null && _options$initialBound !== void 0 ? _options$initialBound : this.getBoundsById(id);\n      if (!initialBounds) return this;\n      if (!areAnglesCompatible(pageRotation, scaleAxisRotation)) {\n        return this._resizeUnalignedShape(id, scale, _objectSpread(_objectSpread({}, options), {}, {\n          initialBounds: initialBounds,\n          scaleOrigin: scaleOrigin,\n          scaleAxisRotation: scaleAxisRotation,\n          initialPageTransform: pageTransform,\n          initialShape: initialShape\n        }));\n      }\n      var util = this.getShapeUtil(initialShape);\n      if (util.isAspectRatioLocked(initialShape)) {\n        if (Math.abs(scale.x) > Math.abs(scale.y)) {\n          scale = new Vec2d(scale.x, Math.sign(scale.y) * Math.abs(scale.x));\n        } else {\n          scale = new Vec2d(Math.sign(scale.x) * Math.abs(scale.y), scale.y);\n        }\n      }\n      if (util.onResize && util.canResize(initialShape)) {\n        var _options$dragHandle, _options$mode;\n        var newPagePoint = this._scalePagePoint(Matrix2d.applyToPoint(pageTransform, new Vec2d(0, 0)), scaleOrigin, scale, scaleAxisRotation);\n        var newLocalPoint = this.getPointInParentSpace(initialShape.id, newPagePoint);\n        var myScale = new Vec2d(scale.x, scale.y);\n        var areWidthAndHeightAlignedWithCorrectAxis = approximately((pageRotation - scaleAxisRotation) % Math.PI, 0);\n        myScale.x = areWidthAndHeightAlignedWithCorrectAxis ? scale.x : scale.y;\n        myScale.y = areWidthAndHeightAlignedWithCorrectAxis ? scale.y : scale.x;\n        var initialPagePoint = Matrix2d.applyToPoint(pageTransform, new Vec2d());\n        var _this$getPointInParen2 = this.getPointInParentSpace(initialShape.id, initialPagePoint),\n          x = _this$getPointInParen2.x,\n          y = _this$getPointInParen2.y;\n        this.updateShapes([_objectSpread({\n          id: id,\n          type: initialShape.type,\n          x: newLocalPoint.x,\n          y: newLocalPoint.y\n        }, util.onResize(_objectSpread(_objectSpread({}, initialShape), {}, {\n          x: x,\n          y: y\n        }), {\n          newPoint: newLocalPoint,\n          handle: (_options$dragHandle = options.dragHandle) !== null && _options$dragHandle !== void 0 ? _options$dragHandle : \"bottom_right\",\n          // don't set isSingle to true for children\n          mode: (_options$mode = options.mode) !== null && _options$mode !== void 0 ? _options$mode : \"scale_shape\",\n          scaleX: myScale.x,\n          scaleY: myScale.y,\n          initialBounds: initialBounds,\n          initialShape: initialShape\n        }))], true);\n      } else {\n        var initialPageCenter = Matrix2d.applyToPoint(pageTransform, initialBounds.center);\n        var newPageCenter = this._scalePagePoint(initialPageCenter, scaleOrigin, scale, scaleAxisRotation);\n        var initialPageCenterInParentSpace = this.getPointInParentSpace(initialShape.id, initialPageCenter);\n        var newPageCenterInParentSpace = this.getPointInParentSpace(initialShape.id, newPageCenter);\n        var delta = Vec2d.Sub(newPageCenterInParentSpace, initialPageCenterInParentSpace);\n        this.updateShapes([{\n          id: id,\n          type: initialShape.type,\n          x: initialShape.x + delta.x,\n          y: initialShape.y + delta.y\n        }], true);\n      }\n      return this;\n    }\n    /**\n     * Stretch shape sizes and positions to fill their common bounding box.\n     *\n     * @example\n     * ```ts\n     * editor.stretchShapes('horizontal')\n     * editor.stretchShapes('horizontal', ['box1', 'box2'])\n     * ```\n     *\n     * @param operation - Whether to stretch shapes horizontally or vertically.\n     * @param ids - The ids of the shapes to stretch. Defaults to selected shapes.\n     *\n     * @public\n     */\n  }, {\n    key: \"stretchShapes\",\n    value: function stretchShapes(operation) {\n      var _this38 = this;\n      var ids = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.pageState.selectedIds;\n      if (this.isReadOnly) return this;\n      if (ids.length < 2) return this;\n      var shapes = compact(ids.map(function (id) {\n        return _this38.getShapeById(id);\n      }));\n      var shapeBounds = Object.fromEntries(shapes.map(function (shape) {\n        return [shape.id, _this38.getBounds(shape)];\n      }));\n      var shapePageBounds = Object.fromEntries(shapes.map(function (shape) {\n        return [shape.id, _this38.getPageBounds(shape)];\n      }));\n      var commonBounds = Box2d.Common(compact(Object.values(shapePageBounds)));\n      var changes = [];\n      switch (operation) {\n        case \"vertical\":\n          {\n            this.batch(function () {\n              var _iterator25 = _createForOfIteratorHelper(shapes),\n                _step25;\n              try {\n                for (_iterator25.s(); !(_step25 = _iterator25.n()).done;) {\n                  var shape = _step25.value;\n                  var pageRotation = _this38.getPageRotation(shape);\n                  if (pageRotation % PI2) continue;\n                  var bounds = shapeBounds[shape.id];\n                  var pageBounds = shapePageBounds[shape.id];\n                  var localOffset = _this38.getDeltaInParentSpace(shape, new Vec2d(0, commonBounds.minY - pageBounds.minY));\n                  var _Vec2d$Add = Vec2d.Add(localOffset, shape),\n                    x = _Vec2d$Add.x,\n                    y = _Vec2d$Add.y;\n                  _this38.updateShapes([{\n                    id: shape.id,\n                    type: shape.type,\n                    x: x,\n                    y: y\n                  }], true);\n                  var scale = new Vec2d(1, commonBounds.height / pageBounds.height);\n                  _this38.resizeShape(shape.id, scale, {\n                    initialBounds: bounds,\n                    scaleOrigin: new Vec2d(pageBounds.center.x, commonBounds.minY),\n                    scaleAxisRotation: 0\n                  });\n                }\n              } catch (err) {\n                _iterator25.e(err);\n              } finally {\n                _iterator25.f();\n              }\n            });\n            break;\n          }\n        case \"horizontal\":\n          {\n            this.batch(function () {\n              var _iterator26 = _createForOfIteratorHelper(shapes),\n                _step26;\n              try {\n                for (_iterator26.s(); !(_step26 = _iterator26.n()).done;) {\n                  var shape = _step26.value;\n                  var bounds = shapeBounds[shape.id];\n                  var pageBounds = shapePageBounds[shape.id];\n                  var pageRotation = _this38.getPageRotation(shape);\n                  if (pageRotation % PI2) continue;\n                  var localOffset = _this38.getDeltaInParentSpace(shape, new Vec2d(commonBounds.minX - pageBounds.minX, 0));\n                  var _Vec2d$Add2 = Vec2d.Add(localOffset, shape),\n                    x = _Vec2d$Add2.x,\n                    y = _Vec2d$Add2.y;\n                  _this38.updateShapes([{\n                    id: shape.id,\n                    type: shape.type,\n                    x: x,\n                    y: y\n                  }], true);\n                  var scale = new Vec2d(commonBounds.width / pageBounds.width, 1);\n                  _this38.resizeShape(shape.id, scale, {\n                    initialBounds: bounds,\n                    scaleOrigin: new Vec2d(commonBounds.minX, pageBounds.center.y),\n                    scaleAxisRotation: 0\n                  });\n                }\n              } catch (err) {\n                _iterator26.e(err);\n              } finally {\n                _iterator26.f();\n              }\n            });\n            break;\n          }\n      }\n      this.updateShapes(changes);\n      return this;\n    }\n  }, {\n    key: \"shapesArray\",\n    get: function get() {\n      var _this39 = this;\n      return Array.from(this.currentPageShapeIds, function (id) {\n        return _this39.store.get(id);\n      });\n    }\n  }, {\n    key: \"sortedShapesArray\",\n    get: function get() {\n      var _this40 = this;\n      var shapes = new Set(this.shapesArray.sort(sortByIndex));\n      var results = [];\n      function pushShapeWithDescendants(shape) {\n        results.push(shape);\n        shapes.delete(shape);\n        shapes.forEach(function (otherShape) {\n          if (otherShape.parentId === shape.id) {\n            pushShapeWithDescendants(otherShape);\n          }\n        });\n      }\n      shapes.forEach(function (shape) {\n        var parent = _this40.getShapeById(shape.parentId);\n        if (!isShape(parent)) {\n          pushShapeWithDescendants(shape);\n        }\n      });\n      return results;\n    }\n  }, {\n    key: \"selectedShapes\",\n    get: function get() {\n      var _this41 = this;\n      var selectedIds = this.pageState.selectedIds;\n      return compact(selectedIds.map(function (id) {\n        return _this41.store.get(id);\n      }));\n    }\n  }, {\n    key: \"onlySelectedShape\",\n    get: function get() {\n      var selectedShapes = this.selectedShapes;\n      return selectedShapes.length === 1 ? selectedShapes[0] : null;\n    }\n    /**\n     * Get whether a shape matches the type of a TLShapeUtil.\n     *\n     * @example\n     * ```ts\n     * const isArrowShape = isShapeOfType(someShape, ArrowShapeUtil)\n     * ```\n     *\n     * @param util - the TLShapeUtil constructor to test against\n     * @param shape - the shape to test\n     *\n     * @public\n     */\n  }, {\n    key: \"isShapeOfType\",\n    value: function isShapeOfType(shape, util) {\n      return shape.type === util.type;\n    }\n    /**\n     * Get a shape by its id.\n     *\n     * @example\n     * ```ts\n     * editor.getShapeById('box1')\n     * ```\n     *\n     * @param id - The id of the shape to get.\n     *\n     * @public\n     */\n  }, {\n    key: \"getShapeById\",\n    value: function getShapeById(id) {\n      if (!isShapeId(id)) return void 0;\n      return this.store.get(id);\n    }\n    /**\n     * Get the parent shape for a given shape. Returns undefined if the shape is the direct child of\n     * the page.\n     *\n     * @example\n     * ```ts\n     * editor.getParentShape(myShape)\n     * ```\n     *\n     * @public\n     */\n  }, {\n    key: \"getParentShape\",\n    value: function getParentShape(shape) {\n      if (shape === void 0 || !isShapeId(shape.parentId)) return void 0;\n      return this.store.get(shape.parentId);\n    }\n    /**\n     * If siblingShape and targetShape are siblings, this returns targetShape. If targetShape has an\n     * ancestor who is a sibling of siblingShape, this returns that ancestor. Otherwise, this returns\n     * undefined.\n     *\n     * @internal\n     */\n  }, {\n    key: \"getShapeNearestSibling\",\n    value: function getShapeNearestSibling(siblingShape, targetShape) {\n      if (!targetShape) {\n        return void 0;\n      }\n      if (targetShape.parentId === siblingShape.parentId) {\n        return targetShape;\n      }\n      var ancestor = this.findAncestor(targetShape, function (ancestor2) {\n        return ancestor2.parentId === siblingShape.parentId;\n      });\n      return ancestor;\n    }\n    /**\n     * Get whether the given shape is the descendant of the given page.\n     *\n     * @example\n     * ```ts\n     * editor.isShapeInPage(myShape)\n     * editor.isShapeInPage(myShape, 'page1')\n     * ```\n     *\n     * @param shape - The shape to check.\n     * @param pageId - The id of the page to check against. Defaults to the current page.\n     *\n     * @public\n     */\n  }, {\n    key: \"isShapeInPage\",\n    value: function isShapeInPage(shape) {\n      var pageId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.currentPageId;\n      var shapeIsInPage = false;\n      if (shape.parentId === pageId) {\n        shapeIsInPage = true;\n      } else {\n        var parent = this.getShapeById(shape.parentId);\n        isInPageSearch: while (parent) {\n          if (parent.parentId === pageId) {\n            shapeIsInPage = true;\n            break isInPageSearch;\n          }\n          parent = this.getShapeById(parent.parentId);\n        }\n      }\n      return shapeIsInPage;\n    }\n    /**\n     * Get the id of the containing page for a given shape.\n     *\n     * @param shape - The shape to get the page id for.\n     *\n     * @returns The id of the page that contains the shape, or undefined if the shape is undefined.\n     *\n     * @public\n     */\n  }, {\n    key: \"getAncestorPageId\",\n    value: function getAncestorPageId(shape) {\n      if (shape === void 0) return void 0;\n      if (isPageId(shape.parentId)) {\n        return shape.parentId;\n      } else {\n        return this.getAncestorPageId(this.getShapeById(shape.parentId));\n      }\n    }\n  }, {\n    key: \"reparentShapesById\",\n    value:\n    /**\n     * Reparent shapes to a new parent. This operation preserves the shape's current page positions /\n     * rotations.\n     *\n     * @example\n     * ```ts\n     * editor.reparentShapesById(['box1', 'box2'], 'frame1')\n     * ```\n     *\n     * @param ids - The ids of the shapes to reparent.\n     * @param parentId - The id of the new parent shape.\n     * @param insertIndex - The index to insert the children.\n     *\n     * @public\n     */\n    function reparentShapesById(ids, parentId, insertIndex) {\n      var _this42 = this;\n      var changes = [];\n      var parentTransform = isPageId(parentId) ? Matrix2d.Identity() : this.getPageTransformById(parentId);\n      var parentPageRotation = parentTransform.decompose().rotation;\n      var indices = [];\n      var sibs = compact(this.getSortedChildIds(parentId).map(function (id2) {\n        return _this42.getShapeById(id2);\n      }));\n      if (insertIndex) {\n        var sibWithInsertIndex = sibs.find(function (s) {\n          return s.index === insertIndex;\n        });\n        if (sibWithInsertIndex) {\n          var sibAbove = sibs[sibs.indexOf(sibWithInsertIndex) + 1];\n          if (sibAbove) {\n            indices = getIndicesBetween(insertIndex, sibAbove.index, ids.length);\n          } else {\n            indices = getIndicesAbove(insertIndex, ids.length);\n          }\n        } else {\n          var _sibAbove = sibs.sort(sortByIndex).find(function (s) {\n            return s.index > insertIndex;\n          });\n          if (_sibAbove) {\n            indices = getIndicesBetween(insertIndex, _sibAbove.index, ids.length);\n          } else {\n            indices = getIndicesAbove(insertIndex, ids.length);\n          }\n        }\n      } else {\n        var sib = sibs.length && sibs[sibs.length - 1];\n        indices = sib ? getIndicesAbove(sib.index, ids.length) : getIndices(ids.length);\n      }\n      var id;\n      for (var i = 0; i < ids.length; i++) {\n        id = ids[i];\n        var shape = this.getShapeById(id);\n        var pagePoint = this.getPagePointById(id);\n        if (!shape || !pagePoint) continue;\n        var newPoint = Matrix2d.applyToPoint(Matrix2d.Inverse(parentTransform), pagePoint);\n        var newRotation = this.getPageRotation(shape) - parentPageRotation;\n        changes.push({\n          id: shape.id,\n          type: shape.type,\n          parentId: parentId,\n          x: newPoint.x,\n          y: newPoint.y,\n          rotation: newRotation,\n          index: indices[i]\n        });\n      }\n      this.updateShapes(changes);\n      return this;\n    }\n    /**\n     * Get the index above the highest child of a given parent.\n     *\n     * @param parentId - The id of the parent.\n     *\n     * @returns The index.\n     *\n     * @public\n     */\n  }, {\n    key: \"getHighestIndexForParent\",\n    value: function getHighestIndexForParent(parentId) {\n      var children = this._parentIdsToChildIds.value[parentId];\n      if (!children || children.length === 0) {\n        return \"a1\";\n      }\n      return getIndexAbove(children[children.length - 1][1]);\n    }\n  }, {\n    key: \"getSortedChildIds\",\n    value:\n    /**\n     * Get an array of all the children of a shape.\n     *\n     * @example\n     * ```ts\n     * editor.getSortedChildIds('frame1')\n     * ```\n     *\n     * @param parentId - The id of the parent shape.\n     *\n     * @public\n     */\n    function getSortedChildIds(parentId) {\n      var withIndices = this._parentIdsToChildIds.value[parentId];\n      if (!withIndices) return EMPTY_ARRAY;\n      return this._childIdsCache.get(withIndices, function () {\n        return withIndices.map(function (_ref47) {\n          var _ref48 = _slicedToArray(_ref47, 1),\n            id = _ref48[0];\n          return id;\n        });\n      });\n    }\n    /**\n     * Run a visitor function for all descendants of a shape.\n     *\n     * @example\n     * ```ts\n     * editor.visitDescendants('frame1', myCallback)\n     * ```\n     *\n     * @param parentId - The id of the parent shape.\n     * @param visitor - The visitor function.\n     *\n     * @public\n     */\n  }, {\n    key: \"visitDescendants\",\n    value: function visitDescendants(parentId, visitor) {\n      var children = this.getSortedChildIds(parentId);\n      var _iterator27 = _createForOfIteratorHelper(children),\n        _step27;\n      try {\n        for (_iterator27.s(); !(_step27 = _iterator27.n()).done;) {\n          var id = _step27.value;\n          if (visitor(id) === false) continue;\n          this.visitDescendants(id, visitor);\n        }\n      } catch (err) {\n        _iterator27.e(err);\n      } finally {\n        _iterator27.f();\n      }\n    }\n    /**\n     * Get the shape ids of all descendants of the given shapes (including the shapes themselves).\n     *\n     * @param ids - The ids of the shapes to get descendants of.\n     *\n     * @returns The decscendant ids.\n     *\n     * @public\n     */\n  }, {\n    key: \"getShapeAndDescendantIds\",\n    value: function getShapeAndDescendantIds(ids) {\n      var idsToInclude = /* @__PURE__ */new Set();\n      var idsToCheck = _toConsumableArray(ids);\n      while (idsToCheck.length > 0) {\n        var id = idsToCheck.pop();\n        if (!id) break;\n        if (idsToInclude.has(id)) continue;\n        idsToInclude.add(id);\n        this.getSortedChildIds(id).forEach(function (id2) {\n          idsToCheck.push(id2);\n        });\n      }\n      return idsToInclude;\n    }\n    /**\n     * Get the id of what should be the parent of a new shape at a given point. The parent can be a page or shape.\n     *\n     * @param point - The point to find the parent for.\n     * @param shapeType - The type of shape that will be created.\n     *\n     * @returns The id of the parent.\n     *\n     * @public\n     */\n  }, {\n    key: \"getParentIdForNewShapeAtPoint\",\n    value: function getParentIdForNewShapeAtPoint(point, shapeType) {\n      var shapes = this.sortedShapesArray;\n      for (var i = shapes.length - 1; i >= 0; i--) {\n        var shape = shapes[i];\n        var util = this.getShapeUtil(shape);\n        if (!util.canReceiveNewChildrenOfType(shape, shapeType)) continue;\n        var maskedPageBounds = this.getMaskedPageBoundsById(shape.id);\n        if (maskedPageBounds && maskedPageBounds.containsPoint(point) && util.hitTestPoint(shape, this.getPointInShapeSpace(shape, point))) {\n          return shape.id;\n        }\n      }\n      return this.focusLayerId;\n    }\n    /**\n     * Get the shape that some shapes should be dropped on at a given point.\n     *\n     * @param point - The point to find the parent for.\n     * @param droppingShapes - The shapes that are being dropped.\n     *\n     * @returns The shape to drop on.\n     *\n     * @public\n     */\n  }, {\n    key: \"getDroppingShape\",\n    value: function getDroppingShape(point) {\n      var _this43 = this;\n      var droppingShapes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n      var shapes = this.sortedShapesArray;\n      var _loop2 = function _loop2() {\n          var shape = shapes[i];\n          if (droppingShapes.find(function (s) {\n            return s.id === shape.id || _this43.hasAncestor(shape, s.id);\n          })) return 0; // continue\n          var util = _this43.getShapeUtil(shape);\n          if (!util.canDropShapes(shape, droppingShapes)) return 0; // continue\n          var maskedPageBounds = _this43.getMaskedPageBoundsById(shape.id);\n          if (maskedPageBounds && maskedPageBounds.containsPoint(point) && util.hitTestPoint(shape, _this43.getPointInShapeSpace(shape, point))) {\n            return {\n              v: shape\n            };\n          }\n        },\n        _ret;\n      for (var i = shapes.length - 1; i >= 0; i--) {\n        _ret = _loop2();\n        if (_ret === 0) continue;\n        if (_ret) return _ret.v;\n      }\n      return void 0;\n    }\n    /**\n     * Get the shape that should be selected when you click on a given shape, assuming there is\n     * nothing already selected. It will not return anything higher than or including the current\n     * focus layer.\n     *\n     * @param shape - The shape to get the outermost selectable shape for.\n     * @param filter - A function to filter the selectable shapes.\n     *\n     * @returns The outermost selectable shape.\n     *\n     * @public\n     */\n  }, {\n    key: \"getOutermostSelectableShape\",\n    value: function getOutermostSelectableShape(shape, filter) {\n      var match = shape;\n      var node = shape;\n      while (node) {\n        var _filter;\n        if (this.isShapeOfType(node, GroupShapeUtil) && this.focusLayerId !== node.id && !this.hasAncestor(this.focusLayerShape, node.id) && ((_filter = filter === null || filter === void 0 ? void 0 : filter(node)) !== null && _filter !== void 0 ? _filter : true)) {\n          match = node;\n        } else if (this.focusLayerId === node.id) {\n          break;\n        }\n        node = this.getParentShape(node);\n      }\n      return match;\n    }\n    /* -------------------- Commands -------------------- */\n    /**\n     * Set the current page.\n     *\n     * @example\n     * ```ts\n     * editor.setCurrentPageId('page1')\n     * ```\n     *\n     * @param pageId - The id of the page to set as the current page.\n     * @param options - Options for setting the current page.\n     *\n     * @public\n     */\n  }, {\n    key: \"setCurrentPageId\",\n    value: function setCurrentPageId(pageId) {\n      var _ref49 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        _ref49$stopFollowing = _ref49.stopFollowing,\n        stopFollowing = _ref49$stopFollowing === void 0 ? true : _ref49$stopFollowing;\n      this._setCurrentPageId(pageId, {\n        stopFollowing: stopFollowing\n      });\n      return this;\n    }\n  }, {\n    key: \"updateInstanceState\",\n    value:\n    /**\n     * Update the instance's state.\n     *\n     * @param partial - A partial object to update the instance state with.\n     * @param ephemeral - Whether the change is ephemeral. Ephemeral changes don't get added to the undo/redo stack. Defaults to false.\n     * @param squashing - Whether the change will be squashed into the existing history entry rather than creating a new one. Defaults to false.\n     *\n     * @public\n     */\n    function updateInstanceState(partial) {\n      var ephemeral = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var squashing = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      this._updateInstanceState(partial, ephemeral, squashing);\n      return this;\n    }\n  }, {\n    key: \"setCursor\",\n    value:\n    /**\n     * Set the current cursor.\n     *\n     * @example\n     * ```ts\n     * editor.setCursor({ type: 'default' })\n     * editor.setCursor({ type: 'default', rotation: Math.PI / 2, color: 'red' })\n     * ```\n     *\n     * @param cursor - A partial of the cursor object.\n     *\n     * @public\n     */\n    function setCursor(cursor) {\n      var current = this.cursor;\n      var next = _objectSpread(_objectSpread({}, current), {}, {\n        rotation: 0\n      }, cursor);\n      if (!(current.type === next.type && current.rotation === next.rotation && current.color === next.color)) {\n        this.updateInstanceState({\n          cursor: next\n        }, true);\n      }\n      return this;\n    }\n    /**\n     * Set the current scribble.\n     *\n     * @example\n     * ```ts\n     * editor.setScribble(nextScribble)\n     * editor.setScribble() // clears the scribble\n     * ```\n     *\n     * @param scribble - The new scribble object.\n     *\n     * @public\n     */\n  }, {\n    key: \"setScribble\",\n    value: function setScribble() {\n      var scribble = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      this.updateInstanceState({\n        scribble: scribble\n      }, true);\n      return this;\n    }\n    /**\n     * Set the current brush.\n     *\n     * @example\n     * ```ts\n     * editor.setBrush({ x: 0, y: 0, w: 100, h: 100 })\n     * editor.setBrush() // Clears the brush\n     * ```\n     *\n     * @param brush - The brush box model to set, or null for no brush model.\n     *\n     * @public\n     */\n  }, {\n    key: \"setBrush\",\n    value: function setBrush() {\n      var brush = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      if (!brush && !this.brush) return this;\n      this.updateInstanceState({\n        brush: brush\n      }, true);\n      return this;\n    }\n    /**\n     * Set the current zoom brush.\n     *\n     * @example\n     * ```ts\n     * editor.setZoomBrush({ x: 0, y: 0, w: 100, h: 100 })\n     * editor.setZoomBrush() // Clears the zoom\n     * ```\n     *\n     * @param zoomBrush - The zoom box model to set, or null for no zoom model.\n     *\n     * @public\n     */\n  }, {\n    key: \"setZoomBrush\",\n    value: function setZoomBrush() {\n      var zoomBrush = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      if (!zoomBrush && !this.zoomBrush) return this;\n      this.updateInstanceState({\n        zoomBrush: zoomBrush\n      }, true);\n      return this;\n    }\n    /**\n     * Rotate shapes by a delta in radians.\n     *\n     * @example\n     * ```ts\n     * editor.rotateShapesBy(['box1', 'box2'], Math.PI)\n     * editor.rotateShapesBy(['box1', 'box2'], Math.PI / 2)\n     * ```\n     *\n     * @param ids - The ids of the shapes to move.\n     * @param delta - The delta in radians to apply to the selection rotation.\n     */\n  }, {\n    key: \"rotateShapesBy\",\n    value: function rotateShapesBy(ids, delta) {\n      if (ids.length <= 0) return this;\n      var snapshot = getRotationSnapshot({\n        editor: this\n      });\n      applyRotationToSnapshotShapes({\n        delta: delta,\n        snapshot: snapshot,\n        editor: this,\n        stage: \"one-off\"\n      });\n      return this;\n    }\n    /**\n     * Move shapes by a delta.\n     *\n     * @example\n     * ```ts\n     * editor.nudgeShapes(['box1', 'box2'], { x: 0, y: 1 })\n     * editor.nudgeShapes(['box1', 'box2'], { x: 0, y: 1 }, true)\n     * ```\n     *\n     * @param ids - The ids of the shapes to move.\n     * @param direction - The direction in which to move the shapes.\n     * @param major - Whether this is a major nudge, e.g. a shift + arrow nudge.\n     */\n  }, {\n    key: \"nudgeShapes\",\n    value: function nudgeShapes(ids, direction) {\n      var major = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var ephemeral = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n      if (ids.length <= 0) return this;\n      var step = this.isGridMode ? major ? this.gridSize * GRID_INCREMENT : this.gridSize : major ? MAJOR_NUDGE_FACTOR : MINOR_NUDGE_FACTOR;\n      var steppedDelta = Vec2d.Mul(direction, step);\n      var changes = [];\n      var _iterator28 = _createForOfIteratorHelper(ids),\n        _step28;\n      try {\n        for (_iterator28.s(); !(_step28 = _iterator28.n()).done;) {\n          var _this$getShapeUtil$on4, _this$getShapeUtil4;\n          var id = _step28.value;\n          var shape = this.getShapeById(id);\n          if (!shape) {\n            throw Error(\"Could not find a shape with the id \".concat(id, \".\"));\n          }\n          var localDelta = this.getDeltaInParentSpace(shape, steppedDelta);\n          var translateStartChanges = (_this$getShapeUtil$on4 = (_this$getShapeUtil4 = this.getShapeUtil(shape)).onTranslateStart) === null || _this$getShapeUtil$on4 === void 0 ? void 0 : _this$getShapeUtil$on4.call(_this$getShapeUtil4, shape);\n          changes.push(translateStartChanges ? _objectSpread(_objectSpread({}, translateStartChanges), {}, {\n            x: shape.x + localDelta.x,\n            y: shape.y + localDelta.y\n          }) : {\n            id: id,\n            x: shape.x + localDelta.x,\n            y: shape.y + localDelta.y,\n            type: shape.type\n          });\n        }\n      } catch (err) {\n        _iterator28.e(err);\n      } finally {\n        _iterator28.f();\n      }\n      this.updateShapes(changes, ephemeral);\n      return this;\n    }\n    /**\n     * Duplicate shapes.\n     *\n     * @example\n     * ```ts\n     * editor.duplicateShapes()\n     * editor.duplicateShapes(['id1', 'id2'])\n     * editor.duplicateShapes(['id1', 'id2'], { x: 8, y: 8 })\n     * ```\n     *\n     * @param ids - The ids of the shapes to duplicate. Defaults to the ids of the selected shapes.\n     * @param offset - The offset (in pixels) to apply to the duplicated shapes.\n     *\n     * @public\n     */\n  }, {\n    key: \"duplicateShapes\",\n    value: function duplicateShapes() {\n      var _this44 = this;\n      var ids = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.selectedIds;\n      var offset = arguments.length > 1 ? arguments[1] : undefined;\n      if (ids.length <= 0) return this;\n      var initialIds = new Set(ids);\n      var idsToCreate = [];\n      var idsToCheck = _toConsumableArray(ids);\n      while (idsToCheck.length > 0) {\n        var id = idsToCheck.pop();\n        if (!id) break;\n        idsToCreate.push(id);\n        this.getSortedChildIds(id).forEach(function (childId) {\n          return idsToCheck.push(childId);\n        });\n      }\n      idsToCreate.reverse();\n      var idsMap = new Map(idsToCreate.map(function (id) {\n        return [id, createShapeId()];\n      }));\n      var shapesToCreate = compact(idsToCreate.map(function (id) {\n        var _shape$parentId;\n        var shape = _this44.getShapeById(id);\n        if (!shape) {\n          return null;\n        }\n        var createId = idsMap.get(id);\n        var ox = 0;\n        var oy = 0;\n        if (offset && initialIds.has(id)) {\n          var parentTransform = _this44.getParentTransform(shape);\n          var vec = new Vec2d(offset.x, offset.y).rot(-Matrix2d.Decompose(parentTransform).rotation);\n          ox = vec.x;\n          oy = vec.y;\n        }\n        var parentId = (_shape$parentId = shape.parentId) !== null && _shape$parentId !== void 0 ? _shape$parentId : _this44.currentPageId;\n        var siblings = _this44.getSortedChildIds(parentId);\n        var currentIndex = siblings.indexOf(shape.id);\n        var siblingAboveId = siblings[currentIndex + 1];\n        var siblingAbove = siblingAboveId ? _this44.getShapeById(siblingAboveId) : null;\n        var index = siblingAbove ? getIndexBetween(shape.index, siblingAbove.index) : getIndexAbove(shape.index);\n        var newShape = deepCopy(shape);\n        if (_this44.isShapeOfType(shape, ArrowShapeUtil) && _this44.isShapeOfType(newShape, ArrowShapeUtil)) {\n          var info = _this44.getShapeUtil(ArrowShapeUtil).getArrowInfo(shape);\n          var newStartShapeId = void 0;\n          var newEndShapeId = void 0;\n          if (shape.props.start.type === \"binding\") {\n            newStartShapeId = idsMap.get(shape.props.start.boundShapeId);\n            if (!newStartShapeId) {\n              if (info !== null && info !== void 0 && info.isValid) {\n                var _info$start$point2 = info.start.point,\n                  x = _info$start$point2.x,\n                  y = _info$start$point2.y;\n                newShape.props.start = {\n                  type: \"point\",\n                  x: x,\n                  y: y\n                };\n              } else {\n                var _getArrowTerminalsInA4 = getArrowTerminalsInArrowSpace(_this44, shape),\n                  start = _getArrowTerminalsInA4.start;\n                newShape.props.start = {\n                  type: \"point\",\n                  x: start.x,\n                  y: start.y\n                };\n              }\n            }\n          }\n          if (shape.props.end.type === \"binding\") {\n            newEndShapeId = idsMap.get(shape.props.end.boundShapeId);\n            if (!newEndShapeId) {\n              if (info !== null && info !== void 0 && info.isValid) {\n                var _info$end$point2 = info.end.point,\n                  _x5 = _info$end$point2.x,\n                  _y4 = _info$end$point2.y;\n                newShape.props.end = {\n                  type: \"point\",\n                  x: _x5,\n                  y: _y4\n                };\n              } else {\n                var _getArrowTerminalsInA5 = getArrowTerminalsInArrowSpace(_this44, shape),\n                  end = _getArrowTerminalsInA5.end;\n                newShape.props.start = {\n                  type: \"point\",\n                  x: end.x,\n                  y: end.y\n                };\n              }\n            }\n          }\n          var infoAfter = getIsArrowStraight(newShape) ? getStraightArrowInfo(_this44, newShape) : getCurvedArrowInfo(_this44, newShape);\n          if (info !== null && info !== void 0 && info.isValid && infoAfter !== null && infoAfter !== void 0 && infoAfter.isValid && !getIsArrowStraight(shape)) {\n            var mpA = Vec2d.Med(info.start.handle, info.end.handle);\n            var distA = Vec2d.Dist(info.middle, mpA);\n            var distB = Vec2d.Dist(infoAfter.middle, mpA);\n            if (newShape.props.bend < 0) {\n              newShape.props.bend += distB - distA;\n            } else {\n              newShape.props.bend -= distB - distA;\n            }\n          }\n          if (newShape.props.start.type === \"binding\" && newStartShapeId) {\n            newShape.props.start.boundShapeId = newStartShapeId;\n          }\n          if (newShape.props.end.type === \"binding\" && newEndShapeId) {\n            newShape.props.end.boundShapeId = newEndShapeId;\n          }\n        }\n        newShape = _objectSpread(_objectSpread({}, newShape), {}, {\n          id: createId,\n          x: shape.x + ox,\n          y: shape.y + oy,\n          index: index\n        });\n        return newShape;\n      }));\n      shapesToCreate.forEach(function (shape) {\n        if (isShapeId(shape.parentId)) {\n          if (idsMap.has(shape.parentId)) {\n            shape.parentId = idsMap.get(shape.parentId);\n          }\n        }\n      });\n      this.history.batch(function () {\n        var maxShapesReached = shapesToCreate.length + _this44.currentPageShapeIds.size > MAX_SHAPES_PER_PAGE;\n        if (maxShapesReached) {\n          alertMaxShapes(_this44);\n        }\n        var newShapes = maxShapesReached ? shapesToCreate.slice(0, MAX_SHAPES_PER_PAGE - _this44.currentPageShapeIds.size) : shapesToCreate;\n        var ids2 = newShapes.map(function (s) {\n          return s.id;\n        });\n        _this44.createShapes(newShapes);\n        _this44.setSelectedIds(ids2);\n        if (offset !== void 0) {\n          var viewportPageBounds = _this44.viewportPageBounds,\n            selectedPageBounds = _this44.selectedPageBounds;\n          if (selectedPageBounds && !viewportPageBounds.contains(selectedPageBounds)) {\n            _this44.centerOnPoint(selectedPageBounds.center.x, selectedPageBounds.center.y, {\n              duration: ANIMATION_MEDIUM_MS\n            });\n          }\n        }\n      });\n      return this;\n    }\n    /**\n     * Set the current opacity. This will effect any selected shapes, or the\n     * next-created shape.\n     *\n     * @example\n     * ```ts\n     * editor.setOpacity(0.5)\n     * editor.setOpacity(0.5, true)\n     * ```\n     *\n     * @param opacity - The opacity to set. Must be a number between 0 and 1 inclusive.\n     * @param ephemeral - Whether the opacity change is ephemeral. Ephemeral changes don't get added to the undo/redo stack. Defaults to false.\n     * @param squashing - Whether the opacity change will be squashed into the existing history entry rather than creating a new one. Defaults to false.\n     */\n  }, {\n    key: \"setOpacity\",\n    value: function setOpacity(opacity) {\n      var _this45 = this;\n      var ephemeral = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var squashing = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      this.history.batch(function () {\n        if (_this45.isIn(\"select\")) {\n          var selectedIds = _this45.pageState.selectedIds;\n          var shapesToUpdate = [];\n          var addShapeById = function addShapeById(id) {\n            var shape = _this45.getShapeById(id);\n            if (!shape) return;\n            if (_this45.isShapeOfType(shape, GroupShapeUtil)) {\n              var childIds = _this45.getSortedChildIds(id);\n              var _iterator29 = _createForOfIteratorHelper(childIds),\n                _step29;\n              try {\n                for (_iterator29.s(); !(_step29 = _iterator29.n()).done;) {\n                  var childId = _step29.value;\n                  addShapeById(childId);\n                }\n              } catch (err) {\n                _iterator29.e(err);\n              } finally {\n                _iterator29.f();\n              }\n            } else {\n              shapesToUpdate.push(shape);\n            }\n          };\n          if (selectedIds.length > 0) {\n            var _iterator30 = _createForOfIteratorHelper(selectedIds),\n              _step30;\n            try {\n              for (_iterator30.s(); !(_step30 = _iterator30.n()).done;) {\n                var id = _step30.value;\n                addShapeById(id);\n              }\n            } catch (err) {\n              _iterator30.e(err);\n            } finally {\n              _iterator30.f();\n            }\n            _this45.updateShapes(shapesToUpdate.map(function (shape) {\n              return {\n                id: shape.id,\n                type: shape.type,\n                opacity: opacity\n              };\n            }), ephemeral);\n          }\n        }\n        _this45.updateInstanceState({\n          opacityForNextShape: opacity\n        }, ephemeral, squashing);\n      });\n      return this;\n    }\n    /**\n     * Set the current styles\n     *\n     * @example\n     * ```ts\n     * editor.setProp(DefaultColorStyle, 'red')\n     * editor.setProp(DefaultColorStyle, 'red', true)\n     * ```\n     *\n     * @param style - The style to set.\n     * @param value - The value to set.\n     * @param ephemeral - Whether the style change is ephemeral. Ephemeral changes don't get added to the undo/redo stack. Defaults to false.\n     * @param squashing - Whether the style change will be squashed into the existing history entry rather than creating a new one. Defaults to false.\n     *\n     * @public\n     */\n  }, {\n    key: \"setStyle\",\n    value: function setStyle(style, value) {\n      var _this46 = this;\n      var ephemeral = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var squashing = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n      this.history.batch(function () {\n        if (_this46.isIn(\"select\")) {\n          var selectedIds = _this46.pageState.selectedIds;\n          if (selectedIds.length > 0) {\n            var updates = [];\n            var addShapeById = function addShapeById(id) {\n              var shape = _this46.getShapeById(id);\n              if (!shape) return;\n              if (_this46.isShapeOfType(shape, GroupShapeUtil)) {\n                var childIds = _this46.getSortedChildIds(id);\n                var _iterator31 = _createForOfIteratorHelper(childIds),\n                  _step31;\n                try {\n                  for (_iterator31.s(); !(_step31 = _iterator31.n()).done;) {\n                    var childId = _step31.value;\n                    addShapeById(childId);\n                  }\n                } catch (err) {\n                  _iterator31.e(err);\n                } finally {\n                  _iterator31.f();\n                }\n              } else {\n                var util = _this46.getShapeUtil(shape);\n                if (util.hasStyle(style)) {\n                  var shapePartial = {\n                    id: shape.id,\n                    type: shape.type,\n                    props: {}\n                  };\n                  updates.push({\n                    originalShape: shape,\n                    updatePartial: util.setStyleInPartial(style, shapePartial, value)\n                  });\n                }\n              }\n            };\n            var _iterator32 = _createForOfIteratorHelper(selectedIds),\n              _step32;\n            try {\n              for (_iterator32.s(); !(_step32 = _iterator32.n()).done;) {\n                var id = _step32.value;\n                addShapeById(id);\n              }\n            } catch (err) {\n              _iterator32.e(err);\n            } finally {\n              _iterator32.f();\n            }\n            _this46.updateShapes(updates.map(function (_ref50) {\n              var updatePartial = _ref50.updatePartial;\n              return updatePartial;\n            }), ephemeral);\n            var changes = [];\n            for (var _i10 = 0, _updates = updates; _i10 < _updates.length; _i10++) {\n              var originalShape = _updates[_i10].originalShape;\n              var currentShape = _this46.getShapeById(originalShape.id);\n              if (!currentShape) continue;\n              var util = _this46.getShapeUtil(currentShape);\n              var boundsA = util.bounds(originalShape);\n              var boundsB = util.bounds(currentShape);\n              var change = {\n                id: originalShape.id,\n                type: originalShape.type\n              };\n              var didChange = false;\n              if (boundsA.width !== boundsB.width) {\n                didChange = true;\n                if (_this46.isShapeOfType(originalShape, TextShapeUtil)) {\n                  switch (originalShape.props.align) {\n                    case \"middle\":\n                      {\n                        change.x = currentShape.x + (boundsA.width - boundsB.width) / 2;\n                        break;\n                      }\n                    case \"end\":\n                      {\n                        change.x = currentShape.x + boundsA.width - boundsB.width;\n                        break;\n                      }\n                  }\n                } else {\n                  change.x = currentShape.x + (boundsA.width - boundsB.width) / 2;\n                }\n              }\n              if (boundsA.height !== boundsB.height) {\n                didChange = true;\n                change.y = currentShape.y + (boundsA.height - boundsB.height) / 2;\n              }\n              if (didChange) {\n                changes.push(change);\n              }\n            }\n            if (changes.length) {\n              _this46.updateShapes(changes, ephemeral);\n            }\n          }\n        }\n        _this46.updateInstanceState({\n          stylesForNextShape: _objectSpread(_objectSpread({}, _this46._stylesForNextShape), {}, _defineProperty({}, style.id, value))\n        }, ephemeral, squashing);\n      });\n      return this;\n    }\n  }, {\n    key: \"_setCamera\",\n    value: /** @internal */\n    function _setCamera(x, y) {\n      var _this47 = this;\n      var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.camera.z;\n      var currentCamera = this.camera;\n      if (currentCamera.x === x && currentCamera.y === y && currentCamera.z === z) return this;\n      var nextCamera = _objectSpread(_objectSpread({}, currentCamera), {}, {\n        x: x,\n        y: y,\n        z: z\n      });\n      this.batch(function () {\n        var _this47$isPenMode;\n        _this47.store.put([nextCamera]);\n        var currentScreenPoint = _this47.inputs.currentScreenPoint;\n        _this47.dispatch({\n          type: \"pointer\",\n          target: \"canvas\",\n          name: \"pointer_move\",\n          point: currentScreenPoint,\n          pointerId: INTERNAL_POINTER_IDS.CAMERA_MOVE,\n          ctrlKey: _this47.inputs.ctrlKey,\n          altKey: _this47.inputs.altKey,\n          shiftKey: _this47.inputs.shiftKey,\n          button: 0,\n          isPen: (_this47$isPenMode = _this47.isPenMode) !== null && _this47$isPenMode !== void 0 ? _this47$isPenMode : false\n        });\n        _this47._tickCameraState();\n      });\n      return this;\n    }\n    /**\n     * Set the current camera.\n     *\n     * @example\n     * ```ts\n     * editor.setCamera(0, 0)\n     * editor.setCamera(0, 0, 1)\n     * ```\n     *\n     * @param x - The camera's x position.\n     * @param y - The camera's y position.\n     * @param z - The camera's z position. Defaults to the current zoom.\n     * @param options - Options for the camera change.\n     *\n     * @public\n     */\n  }, {\n    key: \"setCamera\",\n    value: function setCamera(x, y) {\n      var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.camera.z;\n      var _ref51 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},\n        _ref51$stopFollowing = _ref51.stopFollowing,\n        stopFollowing = _ref51$stopFollowing === void 0 ? true : _ref51$stopFollowing;\n      this.stopCameraAnimation();\n      if (stopFollowing && this.instanceState.followingUserId) {\n        this.stopFollowingUser();\n      }\n      x = Number.isNaN(x) ? 0 : x;\n      y = Number.isNaN(y) ? 0 : y;\n      z = Number.isNaN(z) ? 1 : z;\n      this._setCamera(x, y, z);\n      return this;\n    }\n    /**\n     * Animate the camera.\n     *\n     * @example\n     * ```ts\n     * editor.animateCamera(0, 0)\n     * editor.animateCamera(0, 0, 1)\n     * editor.animateCamera(0, 0, 1, { duration: 1000, easing: (t) => t * t })\n     * ```\n     *\n     * @param x - The camera's x position.\n     * @param y - The camera's y position.\n     * @param z - The camera's z position. Defaults to the current zoom.\n     * @param opts - Options for the animation.\n     *\n     * @public\n     */\n  }, {\n    key: \"animateCamera\",\n    value: function animateCamera(x, y) {\n      var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.camera.z;\n      var opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DEFAULT_ANIMATION_OPTIONS;\n      x = Number.isNaN(x) ? 0 : x;\n      y = Number.isNaN(y) ? 0 : y;\n      z = Number.isNaN(z) ? 1 : z;\n      var _this$viewportScreenB2 = this.viewportScreenBounds,\n        width = _this$viewportScreenB2.width,\n        height = _this$viewportScreenB2.height;\n      var w = width / z;\n      var h = height / z;\n      var targetViewport = new Box2d(-x, -y, w, h);\n      return this._animateToViewport(targetViewport, opts);\n    }\n    /**\n     * Center the camera on a point (in page space).\n     *\n     * @example\n     * ```ts\n     * editor.centerOnPoint(100, 100)\n     * ```\n     *\n     * @param x - The x position of the point.\n     * @param y - The y position of the point.\n     * @param opts - The options for an animation.\n     *\n     * @public\n     */\n  }, {\n    key: \"centerOnPoint\",\n    value: function centerOnPoint(x, y, opts) {\n      if (!this.canMoveCamera) return this;\n      var _this$viewportPageBou = this.viewportPageBounds,\n        pw = _this$viewportPageBou.width,\n        ph = _this$viewportPageBou.height,\n        camera = this.camera;\n      if (opts !== null && opts !== void 0 && opts.duration) {\n        this.animateCamera(-(x - pw / 2), -(y - ph / 2), camera.z, opts);\n      } else {\n        this.setCamera(-(x - pw / 2), -(y - ph / 2), camera.z);\n      }\n      return this;\n    }\n    /**\n     * Move the camera to the nearest content.\n     *\n     * @public\n     */\n  }, {\n    key: \"zoomToContent\",\n    value: function zoomToContent() {\n      var _this$selectedPageBou;\n      var bounds = (_this$selectedPageBou = this.selectedPageBounds) !== null && _this$selectedPageBou !== void 0 ? _this$selectedPageBou : this.allShapesCommonBounds;\n      if (bounds) {\n        this.zoomToBounds(bounds.minX, bounds.minY, bounds.width, bounds.height, Math.min(1, this.zoomLevel), {\n          duration: 220\n        });\n      }\n      return this;\n    }\n    /**\n     * Zoom the camera to fit the current page's content in the viewport.\n     *\n     * @example\n     * ```ts\n     * editor.zoomToFit()\n     * ```\n     *\n     * @public\n     */\n  }, {\n    key: \"zoomToFit\",\n    value: function zoomToFit(opts) {\n      var _this48 = this;\n      if (!this.canMoveCamera) return this;\n      var ids = _toConsumableArray(this.currentPageShapeIds);\n      if (ids.length <= 0) return this;\n      var pageBounds = Box2d.Common(compact(ids.map(function (id) {\n        return _this48.getPageBoundsById(id);\n      })));\n      this.zoomToBounds(pageBounds.minX, pageBounds.minY, pageBounds.width, pageBounds.height, void 0, opts);\n      return this;\n    }\n    /**\n     * Set the zoom back to 100%.\n     *\n     * @example\n     * ```ts\n     * editor.resetZoom()\n     * ```\n     *\n     * @param opts - The options for an animation.\n     *\n     * @public\n     */\n  }, {\n    key: \"resetZoom\",\n    value: function resetZoom() {\n      var point = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.viewportScreenCenter;\n      var opts = arguments.length > 1 ? arguments[1] : undefined;\n      if (!this.canMoveCamera) return this;\n      var _this$camera2 = this.camera,\n        cx = _this$camera2.x,\n        cy = _this$camera2.y,\n        cz = _this$camera2.z;\n      var x = point.x,\n        y = point.y;\n      if (opts !== null && opts !== void 0 && opts.duration) {\n        this.animateCamera(cx + (x / 1 - x) - (x / cz - x), cy + (y / 1 - y) - (y / cz - y), 1, opts);\n      } else {\n        this.setCamera(cx + (x / 1 - x) - (x / cz - x), cy + (y / 1 - y) - (y / cz - y), 1);\n      }\n      return this;\n    }\n    /**\n     * Zoom the camera in.\n     *\n     * @example\n     * ```ts\n     * editor.zoomIn()\n     * editor.zoomIn(editor.viewportScreenCenter, { duration: 120 })\n     * editor.zoomIn(editor.inputs.currentScreenPoint, { duration: 120 })\n     * ```\n     *\n     * @param opts - The options for an animation.\n     *\n     * @public\n     */\n  }, {\n    key: \"zoomIn\",\n    value: function zoomIn() {\n      var point = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.viewportScreenCenter;\n      var opts = arguments.length > 1 ? arguments[1] : undefined;\n      if (!this.canMoveCamera) return this;\n      var _this$camera3 = this.camera,\n        cx = _this$camera3.x,\n        cy = _this$camera3.y,\n        cz = _this$camera3.z;\n      var zoom = MAX_ZOOM;\n      for (var i = 1; i < ZOOMS.length; i++) {\n        var z1 = ZOOMS[i - 1];\n        var z2 = ZOOMS[i];\n        if (z2 - cz <= (z2 - z1) / 2) continue;\n        zoom = z2;\n        break;\n      }\n      var x = point.x,\n        y = point.y;\n      if (opts !== null && opts !== void 0 && opts.duration) {\n        this.animateCamera(cx + (x / zoom - x) - (x / cz - x), cy + (y / zoom - y) - (y / cz - y), zoom, opts);\n      } else {\n        this.setCamera(cx + (x / zoom - x) - (x / cz - x), cy + (y / zoom - y) - (y / cz - y), zoom);\n      }\n      return this;\n    }\n    /**\n     * Zoom the camera out.\n     *\n     * @example\n     * ```ts\n     * editor.zoomOut()\n     * editor.zoomOut(editor.viewportScreenCenter, { duration: 120 })\n     * editor.zoomOut(editor.inputs.currentScreenPoint, { duration: 120 })\n     * ```\n     *\n     * @param opts - The options for an animation.\n     *\n     * @public\n     */\n  }, {\n    key: \"zoomOut\",\n    value: function zoomOut() {\n      var point = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.viewportScreenCenter;\n      var opts = arguments.length > 1 ? arguments[1] : undefined;\n      if (!this.canMoveCamera) return this;\n      var _this$camera4 = this.camera,\n        cx = _this$camera4.x,\n        cy = _this$camera4.y,\n        cz = _this$camera4.z;\n      var zoom = MIN_ZOOM;\n      for (var i = ZOOMS.length - 1; i > 0; i--) {\n        var z1 = ZOOMS[i - 1];\n        var z2 = ZOOMS[i];\n        if (z2 - cz >= (z2 - z1) / 2) continue;\n        zoom = z1;\n        break;\n      }\n      var x = point.x,\n        y = point.y;\n      if (opts !== null && opts !== void 0 && opts.duration) {\n        this.animateCamera(cx + (x / zoom - x) - (x / cz - x), cy + (y / zoom - y) - (y / cz - y), zoom, opts);\n      } else {\n        this.setCamera(cx + (x / zoom - x) - (x / cz - x), cy + (y / zoom - y) - (y / cz - y), zoom);\n      }\n      return this;\n    }\n    /**\n     * Zoom the camera to fit the current selection in the viewport.\n     *\n     * @example\n     * ```ts\n     * editor.zoomToSelection()\n     * ```\n     *\n     * @param opts - The options for an animation.\n     *\n     * @public\n     */\n  }, {\n    key: \"zoomToSelection\",\n    value: function zoomToSelection(opts) {\n      var _this49 = this;\n      if (!this.canMoveCamera) return this;\n      var ids = this.selectedIds;\n      if (ids.length <= 0) return this;\n      var selectedBounds = Box2d.Common(compact(ids.map(function (id) {\n        return _this49.getPageBoundsById(id);\n      })));\n      this.zoomToBounds(selectedBounds.minX, selectedBounds.minY, selectedBounds.width, selectedBounds.height, Math.max(1, this.camera.z), opts);\n      return this;\n    }\n    /**\n     * Pan or pan/zoom the selected ids into view. This method tries to not change the zoom if possible.\n     *\n     * @param ids - The ids of the shapes to pan and zoom into view.\n     * @param opts - The options for an animation.\n     *\n     * @public\n     */\n  }, {\n    key: \"panZoomIntoView\",\n    value: function panZoomIntoView(ids, opts) {\n      var _this50 = this;\n      if (!this.canMoveCamera) return this;\n      if (ids.length <= 0) return this;\n      var selectedBounds = Box2d.Common(compact(ids.map(function (id) {\n        return _this50.getPageBoundsById(id);\n      })));\n      var viewportPageBounds = this.viewportPageBounds;\n      if (viewportPageBounds.h < selectedBounds.h || viewportPageBounds.w < selectedBounds.w) {\n        this.zoomToBounds(selectedBounds.minX, selectedBounds.minY, selectedBounds.width, selectedBounds.height, this.camera.z, opts);\n        return this;\n      } else {\n        var bufferOffsets = this._activeAreaManager.offsets.value;\n        var pageTop = viewportPageBounds.y + bufferOffsets.top;\n        var pageRight = viewportPageBounds.maxY - bufferOffsets.right;\n        var pageBottom = viewportPageBounds.maxY - bufferOffsets.bottom;\n        var pageLeft = viewportPageBounds.x + bufferOffsets.left;\n        var selectedTop = selectedBounds.y;\n        var selectedRight = selectedBounds.maxX;\n        var selectedBottom = selectedBounds.maxY;\n        var selectedLeft = selectedBounds.x;\n        var offsetX = 0;\n        var offsetY = 0;\n        if (pageBottom < selectedBottom) {\n          offsetY = pageBottom - selectedBottom;\n        } else if (pageTop > selectedTop) {\n          offsetY = pageTop - selectedTop;\n        } else {}\n        if (pageRight < selectedRight) {\n          offsetX = pageRight - selectedRight;\n        } else if (pageLeft > selectedLeft) {\n          offsetX = pageLeft - selectedLeft;\n        } else {}\n        var camera = this.camera;\n        if (opts !== null && opts !== void 0 && opts.duration) {\n          this.animateCamera(camera.x + offsetX, camera.y + offsetY, camera.z, opts);\n        } else {\n          this.setCamera(camera.x + offsetX, camera.y + offsetY, camera.z);\n        }\n      }\n      return this;\n    }\n    /**\n     * Zoom the camera to fit a bounding box (in page space).\n     *\n     * @example\n     * ```ts\n     * editor.zoomToBounds(0, 0, 100, 100)\n     * ```\n     *\n     * @param x - The bounding box's x position.\n     * @param y - The bounding box's y position.\n     * @param width - The bounding box's width.\n     * @param height - The bounding box's height.\n     * @param targetZoom - The desired zoom level. Defaults to 0.1.\n     *\n     * @public\n     */\n  }, {\n    key: \"zoomToBounds\",\n    value: function zoomToBounds(x, y, width, height, targetZoom, opts) {\n      if (!this.canMoveCamera) return this;\n      var viewportScreenBounds = this.viewportScreenBounds;\n      var inset = Math.min(256, viewportScreenBounds.width * 0.28);\n      var zoom = clamp(Math.min((viewportScreenBounds.width - inset) / width, (viewportScreenBounds.height - inset) / height), MIN_ZOOM, MAX_ZOOM);\n      if (targetZoom !== void 0) {\n        zoom = Math.min(targetZoom, zoom);\n      }\n      if (opts !== null && opts !== void 0 && opts.duration) {\n        this.animateCamera(-x + (viewportScreenBounds.width - width * zoom) / 2 / zoom, -y + (viewportScreenBounds.height - height * zoom) / 2 / zoom, zoom, opts);\n      } else {\n        this.setCamera(-x + (viewportScreenBounds.width - width * zoom) / 2 / zoom, -y + (viewportScreenBounds.height - height * zoom) / 2 / zoom, zoom);\n      }\n      return this;\n    }\n    /**\n     * Pan the camera.\n     *\n     * @example\n     * ```ts\n     * editor.pan(100, 100)\n     * editor.pan(100, 100, { duration: 1000 })\n     * ```\n     *\n     * @param dx - The amount to pan on the x axis.\n     * @param dy - The amount to pan on the y axis.\n     * @param opts - The animation options\n     */\n  }, {\n    key: \"pan\",\n    value: function pan(dx, dy, opts) {\n      var _opts$duration;\n      if (!this.canMoveCamera) return this;\n      var camera = this.camera;\n      var cx = camera.x,\n        cy = camera.y,\n        cz = camera.z;\n      var d = new Vec2d(dx, dy).div(cz);\n      if ((_opts$duration = opts === null || opts === void 0 ? void 0 : opts.duration) !== null && _opts$duration !== void 0 ? _opts$duration : 0 > 0) {\n        return this.animateCamera(cx + d.x, cy + d.y, cz, opts);\n      } else {\n        this.setCamera(cx + d.x, cy + d.y, cz);\n      }\n      return this;\n    }\n    /**\n     * Stop the current camera animation, if any.\n     *\n     * @public\n     */\n  }, {\n    key: \"stopCameraAnimation\",\n    value: function stopCameraAnimation() {\n      this.emit(\"stop-camera-animation\");\n      return this;\n    }\n  }, {\n    key: \"_animateViewport\",\n    value: /** @internal */\n    function _animateViewport(ms) {\n      var _this51 = this;\n      if (!this._viewportAnimation) return;\n      var cancel = function cancel() {\n        _this51.removeListener(\"tick\", _this51._animateViewport);\n        _this51.removeListener(\"stop-camera-animation\", cancel);\n        _this51._viewportAnimation = null;\n      };\n      this.once(\"stop-camera-animation\", cancel);\n      this._viewportAnimation.elapsed += ms;\n      var _this$_viewportAnimat = this._viewportAnimation,\n        elapsed = _this$_viewportAnimat.elapsed,\n        easing = _this$_viewportAnimat.easing,\n        duration = _this$_viewportAnimat.duration,\n        start = _this$_viewportAnimat.start,\n        end = _this$_viewportAnimat.end;\n      if (elapsed > duration) {\n        var z2 = this.viewportScreenBounds.width / end.width;\n        var x2 = -end.x;\n        var y2 = -end.y;\n        this._setCamera(x2, y2, z2);\n        cancel();\n        return;\n      }\n      var remaining = duration - elapsed;\n      var t = easing(1 - remaining / duration);\n      var left = start.minX + (end.minX - start.minX) * t;\n      var top = start.minY + (end.minY - start.minY) * t;\n      var right = start.maxX + (end.maxX - start.maxX) * t;\n      var bottom = start.maxY + (end.maxY - start.maxY) * t;\n      var easedViewport = new Box2d(left, top, right - left, bottom - top);\n      var z = this.viewportScreenBounds.width / easedViewport.width;\n      var x = -easedViewport.x;\n      var y = -easedViewport.y;\n      this._setCamera(x, y, z);\n    }\n    /** @internal */\n  }, {\n    key: \"_animateToViewport\",\n    value: function _animateToViewport(targetViewportPage) {\n      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var _opts$duration2 = opts.duration,\n        duration = _opts$duration2 === void 0 ? 0 : _opts$duration2,\n        _opts$easing = opts.easing,\n        easing = _opts$easing === void 0 ? EASINGS.easeInOutCubic : _opts$easing;\n      var animationSpeed = this.animationSpeed,\n        viewportPageBounds = this.viewportPageBounds;\n      this.stopCameraAnimation();\n      if (this.instanceState.followingUserId) {\n        this.stopFollowingUser();\n      }\n      if (duration === 0 || animationSpeed === 0) {\n        return this._setCamera(-targetViewportPage.x, -targetViewportPage.y, this.viewportScreenBounds.width / targetViewportPage.width);\n      }\n      this._viewportAnimation = {\n        elapsed: 0,\n        duration: duration / animationSpeed,\n        easing: easing,\n        start: viewportPageBounds.clone(),\n        end: targetViewportPage\n      };\n      this.addListener(\"tick\", this._animateViewport);\n      return this;\n    }\n    /**\n     * Slide the camera in a certain direction.\n     *\n     * @param opts - Options for the slide\n     * @public\n     */\n  }, {\n    key: \"slideCamera\",\n    value: function slideCamera() {\n      var _this52 = this;\n      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      if (!this.canMoveCamera) return this;\n      this.stopCameraAnimation();\n      var animationSpeed = this.animationSpeed;\n      if (animationSpeed === 0) return;\n      var speed = opts.speed,\n        friction = opts.friction,\n        direction = opts.direction,\n        _opts$speedThreshold = opts.speedThreshold,\n        speedThreshold = _opts$speedThreshold === void 0 ? 0.01 : _opts$speedThreshold;\n      var currentSpeed = Math.min(speed, 1);\n      var cancel = function cancel() {\n        _this52.removeListener(\"tick\", moveCamera);\n        _this52.removeListener(\"stop-camera-animation\", cancel);\n      };\n      this.once(\"stop-camera-animation\", cancel);\n      var moveCamera = function moveCamera(elapsed) {\n        var _this52$camera = _this52.camera,\n          cx = _this52$camera.x,\n          cy = _this52$camera.y,\n          cz = _this52$camera.z;\n        var movementVec = direction.clone().mul(currentSpeed * elapsed / cz);\n        currentSpeed *= 1 - friction;\n        if (currentSpeed < speedThreshold) {\n          cancel();\n        } else {\n          _this52._setCamera(cx + movementVec.x, cy + movementVec.y, cz);\n        }\n      };\n      this.addListener(\"tick\", moveCamera);\n      return this;\n    }\n    /**\n     * Animate the camera to a user's cursor position.\n     * This also briefly show the user's cursor if it's not currently visible.\n     *\n     * @param userId - The id of the user to aniamte to.\n     * @public\n     */\n  }, {\n    key: \"animateToUser\",\n    value: function animateToUser(userId) {\n      var _this53 = this;\n      var presences = this.store.query.records(\"instance_presence\", function () {\n        return {\n          userId: {\n            eq: userId\n          }\n        };\n      });\n      var presence = _toConsumableArray(presences.value).sort(function (a, b) {\n        return a.lastActivityTimestamp - b.lastActivityTimestamp;\n      }).pop();\n      if (!presence) return;\n      this.batch(function () {\n        if (_this53.instanceState.followingUserId !== null) {\n          _this53.stopFollowingUser();\n        }\n        var isOnSamePage = presence.currentPageId === _this53.currentPageId;\n        if (!isOnSamePage) {\n          _this53.setCurrentPageId(presence.currentPageId);\n        }\n        var options = isOnSamePage ? {\n          duration: 500\n        } : void 0;\n        var position = presence.cursor;\n        _this53.centerOnPoint(position.x, position.y, options);\n        var highlightedUserIds = _this53.instanceState.highlightedUserIds;\n        _this53.updateInstanceState({\n          highlightedUserIds: [].concat(_toConsumableArray(highlightedUserIds), [userId])\n        });\n        setTimeout(function () {\n          var highlightedUserIds2 = _toConsumableArray(_this53.instanceState.highlightedUserIds);\n          var index = highlightedUserIds2.indexOf(userId);\n          if (index < 0) return;\n          highlightedUserIds2.splice(index, 1);\n          _this53.updateInstanceState({\n            highlightedUserIds: highlightedUserIds2\n          });\n        }, COLLABORATOR_TIMEOUT);\n      });\n    }\n    /**\n     * Start viewport-following a user.\n     *\n     * @param userId - The id of the user to follow.\n     *\n     * @public\n     */\n  }, {\n    key: \"startFollowingUser\",\n    value: function startFollowingUser(userId) {\n      var _this54 = this;\n      var leaderPresences = this.store.query.records(\"instance_presence\", function () {\n        return {\n          userId: {\n            eq: userId\n          }\n        };\n      });\n      var thisUserId = this.user.id;\n      if (!thisUserId) {\n        console.warn(\"You should set the userId for the current instance before following a user\");\n      }\n      if (leaderPresences.value.some(function (p) {\n        return p.followingUserId === thisUserId;\n      })) {\n        return;\n      }\n      transact(function () {\n        _this54.stopFollowingUser();\n        _this54.updateInstanceState({\n          followingUserId: userId\n        }, true);\n      });\n      var cancel = function cancel() {\n        _this54.removeListener(\"frame\", moveTowardsUser);\n        _this54.removeListener(\"stop-following\", cancel);\n      };\n      var isCaughtUp = false;\n      var moveTowardsUser = function moveTowardsUser() {\n        var leaderPresence = _toConsumableArray(leaderPresences.value).sort(function (a, b) {\n          return a.lastActivityTimestamp - b.lastActivityTimestamp;\n        }).pop();\n        if (!leaderPresence) {\n          _this54.stopFollowingUser();\n          return;\n        }\n        var isOnSamePage = leaderPresence.currentPageId === _this54.currentPageId;\n        var chaseProportion = isOnSamePage ? FOLLOW_CHASE_PROPORTION : 1;\n        if (!isOnSamePage) {\n          _this54.setCurrentPageId(leaderPresence.currentPageId, {\n            stopFollowing: false\n          });\n        }\n        var _this54$viewportPageB = _this54.viewportPageBounds,\n          center = _this54$viewportPageB.center,\n          width = _this54$viewportPageB.width,\n          height = _this54$viewportPageB.height;\n        var leaderScreen = Box2d.From(leaderPresence.screenBounds);\n        var leaderWidth = leaderScreen.width / leaderPresence.camera.z;\n        var leaderHeight = leaderScreen.height / leaderPresence.camera.z;\n        var leaderCenter = new Vec2d(leaderWidth / 2 - leaderPresence.camera.x, leaderHeight / 2 - leaderPresence.camera.y);\n        var isFollowingFollower = leaderPresence.followingUserId === thisUserId;\n        var desiredWidth = width + (leaderWidth - width) * chaseProportion;\n        var desiredHeight = height + (leaderHeight - height) * chaseProportion;\n        var ratio = !isFollowingFollower ? Math.min(width / desiredWidth, height / desiredHeight) : height / desiredHeight;\n        var targetZoom = clamp(_this54.camera.z * ratio, MIN_ZOOM, MAX_ZOOM);\n        var targetWidth = _this54.viewportScreenBounds.w / targetZoom;\n        var targetHeight = _this54.viewportScreenBounds.h / targetZoom;\n        var displacement = leaderCenter.sub(center);\n        var targetCenter = Vec2d.Add(center, Vec2d.Mul(displacement, chaseProportion));\n        var distance = Vec2d.Sub(targetCenter, center).len();\n        var zoomChange = Math.abs(targetZoom - _this54.camera.z);\n        if (distance < FOLLOW_CHASE_PAN_SNAP && zoomChange < FOLLOW_CHASE_ZOOM_SNAP) {\n          isCaughtUp = true;\n          return;\n        }\n        if (isCaughtUp && distance < FOLLOW_CHASE_PAN_UNSNAP && zoomChange < FOLLOW_CHASE_ZOOM_UNSNAP) {\n          return;\n        }\n        isCaughtUp = false;\n        _this54.stopCameraAnimation();\n        _this54.setCamera(-(targetCenter.x - targetWidth / 2), -(targetCenter.y - targetHeight / 2), targetZoom, {\n          stopFollowing: false\n        });\n      };\n      this.once(\"stop-following\", cancel);\n      this.addListener(\"frame\", moveTowardsUser);\n      return this;\n    }\n    /**\n     * Stop viewport-following a user.\n     *\n     * @public\n     */\n  }, {\n    key: \"stopFollowingUser\",\n    value: function stopFollowingUser() {\n      this.updateInstanceState({\n        followingUserId: null\n      }, true);\n      this.emit(\"stop-following\");\n      return this;\n    }\n    /**\n     * Animate the camera to a shape.\n     *\n     * @public\n     */\n  }, {\n    key: \"animateToShape\",\n    value: function animateToShape(shapeId) {\n      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_ANIMATION_OPTIONS;\n      if (!this.canMoveCamera) return this;\n      var activeArea = getActiveAreaScreenSpace(this);\n      var viewportAspectRatio = activeArea.width / activeArea.height;\n      var shapePageBounds = this.getPageBoundsById(shapeId);\n      if (!shapePageBounds) return this;\n      var shapeAspectRatio = shapePageBounds.width / shapePageBounds.height;\n      var targetViewportPage = shapePageBounds.clone();\n      var z = shapePageBounds.width / activeArea.width;\n      targetViewportPage.width += (activeArea.left + activeArea.right) * z;\n      targetViewportPage.height += (activeArea.top + activeArea.bottom) * z;\n      targetViewportPage.x -= activeArea.left * z;\n      targetViewportPage.y -= activeArea.top * z;\n      if (shapeAspectRatio > viewportAspectRatio) {\n        targetViewportPage.height = shapePageBounds.width / viewportAspectRatio;\n        targetViewportPage.y -= (targetViewportPage.height - shapePageBounds.height) / 2;\n      } else {\n        targetViewportPage.width = shapePageBounds.height * viewportAspectRatio;\n        targetViewportPage.x -= (targetViewportPage.width - shapePageBounds.width) / 2;\n      }\n      return this._animateToViewport(targetViewportPage, opts);\n    }\n    /**\n     * Blur the app, cancelling any interaction state.\n     *\n     * @example\n     * ```ts\n     * editor.blur()\n     * ```\n     *\n     * @public\n     */\n  }, {\n    key: \"blur\",\n    value: function blur() {\n      this.complete();\n      this.getContainer().blur();\n      this._isFocused.set(false);\n      return this;\n    }\n    /**\n     * Focus the editor.\n     *\n     * @example\n     * ```ts\n     * editor.focus()\n     * ```\n     *\n     * @public\n     */\n  }, {\n    key: \"focus\",\n    value: function focus() {\n      this.getContainer().focus();\n      this._isFocused.set(true);\n      return this;\n    }\n    /**\n     * Dispatch a cancel event.\n     *\n     * @example\n     * ```ts\n     * editor.cancel()\n     * ```\n     *\n     * @public\n     */\n  }, {\n    key: \"cancel\",\n    value: function cancel() {\n      this.dispatch({\n        type: \"misc\",\n        name: \"cancel\"\n      });\n      return this;\n    }\n    /**\n     * Dispatch an interrupt event.\n     *\n     * @example\n     * ```ts\n     * editor.interrupt()\n     * ```\n     *\n     * @public\n     */\n  }, {\n    key: \"interrupt\",\n    value: function interrupt() {\n      this.dispatch({\n        type: \"misc\",\n        name: \"interrupt\"\n      });\n      return this;\n    }\n    /**\n     * Dispatch a complete event.\n     *\n     * @example\n     * ```ts\n     * editor.complete()\n     * ```\n     *\n     * @public\n     */\n  }, {\n    key: \"complete\",\n    value: function complete() {\n      this.dispatch({\n        type: \"misc\",\n        name: \"complete\"\n      });\n      return this;\n    }\n    /* -------------------- Callbacks ------------------- */\n    /**\n     * Handle external content, such as files, urls, embeds, or plain text which has been put into the app, for example by pasting external text or dropping external images onto canvas.\n     *\n     * @param info - Info about the external content.\n     */\n  }, {\n    key: \"putExternalContent\",\n    value: function () {\n      var _putExternalContent = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(info) {\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              this.externalContentManager.handleContent(info);\n            case 1:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n      function putExternalContent(_x6) {\n        return _putExternalContent.apply(this, arguments);\n      }\n      return putExternalContent;\n    }()\n  }, {\n    key: \"groupShapes\",\n    value: /* --------------------- Groups --------------------- */\n    /**\n     * Group some shapes together.\n     *\n     * @param ids - Ids of the shapes to group. Defaults to the selected shapes.\n     * @param groupId - Id of the group to create. Defaults to a new shape id.\n     *\n     * @public\n     */\n    function groupShapes() {\n      var _this55 = this,\n        _this$findCommonAnces2,\n        _shapesWithRootParent;\n      var ids = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.selectedIds;\n      var groupId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : createShapeId();\n      if (this.isReadOnly) return this;\n      if (ids.length <= 1) return this;\n      var shapes = compact(this._getUnlockedShapeIds(ids).map(function (id) {\n        return _this55.getShapeById(id);\n      }));\n      var sortedShapeIds = shapes.sort(sortByIndex).map(function (s) {\n        return s.id;\n      });\n      var pageBounds = Box2d.Common(compact(shapes.map(function (id) {\n        return _this55.getPageBounds(id);\n      })));\n      var _pageBounds$point = pageBounds.point,\n        x = _pageBounds$point.x,\n        y = _pageBounds$point.y;\n      var parentId = (_this$findCommonAnces2 = this.findCommonAncestor(shapes)) !== null && _this$findCommonAnces2 !== void 0 ? _this$findCommonAnces2 : this.currentPageId;\n      if (this.currentToolId !== \"select\") return this;\n      if (!this.isIn(\"select.idle\")) {\n        this.cancel();\n      }\n      var shapesWithRootParent = shapes.filter(function (shape) {\n        return shape.parentId === parentId;\n      }).sort(sortByIndex);\n      var highestIndex = (_shapesWithRootParent = shapesWithRootParent[shapesWithRootParent.length - 1]) === null || _shapesWithRootParent === void 0 ? void 0 : _shapesWithRootParent.index;\n      this.batch(function () {\n        _this55.createShapes([{\n          id: groupId,\n          type: \"group\",\n          parentId: parentId,\n          index: highestIndex,\n          x: x,\n          y: y,\n          opacity: 1,\n          props: {}\n        }]);\n        _this55.reparentShapesById(sortedShapeIds, groupId);\n        _this55.select(groupId);\n      });\n      return this;\n    }\n    /**\n     * Ungroup some shapes.\n     *\n     * @param ids - Ids of the shapes to ungroup. Defaults to the selected shapes.\n     *\n     * @public\n     */\n  }, {\n    key: \"ungroupShapes\",\n    value: function ungroupShapes() {\n      var _this56 = this;\n      var ids = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.selectedIds;\n      if (this.isReadOnly) return this;\n      if (ids.length === 0) return this;\n      if (this.currentToolId !== \"select\") return this;\n      if (!this.isIn(\"select.idle\")) {\n        this.cancel();\n      }\n      var idsToSelect = /* @__PURE__ */new Set();\n      var shapes = compact(ids.map(function (id) {\n        return _this56.getShapeById(id);\n      }));\n      var groups = [];\n      shapes.forEach(function (shape) {\n        if (_this56.isShapeOfType(shape, GroupShapeUtil)) {\n          groups.push(shape);\n        } else {\n          idsToSelect.add(shape.id);\n        }\n      });\n      if (groups.length === 0) return this;\n      this.batch(function () {\n        var group;\n        for (var i = 0, n = groups.length; i < n; i++) {\n          group = groups[i];\n          var childIds = _this56.getSortedChildIds(group.id);\n          for (var j = 0, n2 = childIds.length; j < n2; j++) {\n            idsToSelect.add(childIds[j]);\n          }\n          _this56.reparentShapesById(childIds, group.parentId, group.index);\n        }\n        _this56.deleteShapes(groups.map(function (group2) {\n          return group2.id;\n        }));\n        _this56.select.apply(_this56, _toConsumableArray(idsToSelect));\n      });\n      return this;\n    }\n    /**\n     * Get an exported SVG of the given shapes.\n     *\n     * @param ids - The ids of the shapes to export. Defaults to selected shapes.\n     * @param opts - Options for the export.\n     *\n     * @returns The SVG element.\n     *\n     * @public\n     */\n  }, {\n    key: \"getSvg\",\n    value: function () {\n      var _getSvg = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n        var _this57 = this;\n        var ids,\n          opts,\n          _opts$scale,\n          scale,\n          _opts$background,\n          background,\n          _opts$padding,\n          padding,\n          _opts$darkMode,\n          darkMode,\n          _opts$preserveAspectR,\n          preserveAspectRatio,\n          realContainerEl,\n          realContainerStyle,\n          fakeContainerEl,\n          containerStyle,\n          fontsUsedInExport,\n          colors,\n          shapeIdsToInclude,\n          renderingShapes,\n          bbox,\n          _iterator33,\n          _step33,\n          maskedPageBounds,\n          singleFrameShapeId,\n          w,\n          h,\n          svg,\n          defs,\n          _i11,\n          _Array$from,\n          element,\n          _document$body$focus,\n          _document$body,\n          unorderedShapeElements,\n          _iterator34,\n          _step34,\n          _element,\n          styles,\n          style,\n          fontInstances,\n          _args5 = arguments;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) switch (_context5.prev = _context5.next) {\n            case 0:\n              ids = _args5.length > 0 && _args5[0] !== undefined ? _args5[0] : this.selectedIds.length ? this.selectedIds : Object.keys(this.currentPageShapeIds);\n              opts = _args5.length > 1 && _args5[1] !== undefined ? _args5[1] : {};\n              if (!(ids.length === 0)) {\n                _context5.next = 4;\n                break;\n              }\n              return _context5.abrupt(\"return\");\n            case 4:\n              if (window.document) {\n                _context5.next = 6;\n                break;\n              }\n              throw Error(\"No document\");\n            case 6:\n              _opts$scale = opts.scale, scale = _opts$scale === void 0 ? 1 : _opts$scale, _opts$background = opts.background, background = _opts$background === void 0 ? false : _opts$background, _opts$padding = opts.padding, padding = _opts$padding === void 0 ? SVG_PADDING : _opts$padding, _opts$darkMode = opts.darkMode, darkMode = _opts$darkMode === void 0 ? this.isDarkMode : _opts$darkMode, _opts$preserveAspectR = opts.preserveAspectRatio, preserveAspectRatio = _opts$preserveAspectR === void 0 ? false : _opts$preserveAspectR;\n              realContainerEl = this.getContainer();\n              realContainerStyle = getComputedStyle(realContainerEl);\n              fakeContainerEl = document.createElement(\"div\");\n              fakeContainerEl.className = \"tl-container tl-theme__\".concat(darkMode ? \"dark\" : \"light\", \" tl-theme__force-sRGB\");\n              document.body.appendChild(fakeContainerEl);\n              containerStyle = getComputedStyle(fakeContainerEl);\n              fontsUsedInExport = /* @__PURE__ */new Map();\n              colors = {\n                fill: objectMapFromEntries(DefaultColorStyle.values.map(function (color) {\n                  return [color, containerStyle.getPropertyValue(\"--palette-\".concat(color))];\n                })),\n                pattern: objectMapFromEntries(DefaultColorStyle.values.map(function (color) {\n                  return [color, containerStyle.getPropertyValue(\"--palette-\".concat(color, \"-pattern\"))];\n                })),\n                semi: objectMapFromEntries(DefaultColorStyle.values.map(function (color) {\n                  return [color, containerStyle.getPropertyValue(\"--palette-\".concat(color, \"-semi\"))];\n                })),\n                highlight: objectMapFromEntries(DefaultColorStyle.values.map(function (color) {\n                  return [color, containerStyle.getPropertyValue(\"--palette-\".concat(color, \"-highlight\"))];\n                })),\n                text: containerStyle.getPropertyValue(\"--color-text\"),\n                background: containerStyle.getPropertyValue(\"--color-background\"),\n                solid: containerStyle.getPropertyValue(\"--palette-solid\")\n              };\n              document.body.removeChild(fakeContainerEl);\n              shapeIdsToInclude = this.getShapeAndDescendantIds(ids);\n              renderingShapes = this.computeUnorderedRenderingShapes([this.currentPageId]).filter(function (_ref52) {\n                var id = _ref52.id;\n                return shapeIdsToInclude.has(id);\n              });\n              bbox = null;\n              _iterator33 = _createForOfIteratorHelper(renderingShapes);\n              _context5.prev = 20;\n              _iterator33.s();\n            case 22:\n              if ((_step33 = _iterator33.n()).done) {\n                _context5.next = 29;\n                break;\n              }\n              maskedPageBounds = _step33.value.maskedPageBounds;\n              if (maskedPageBounds) {\n                _context5.next = 26;\n                break;\n              }\n              return _context5.abrupt(\"continue\", 27);\n            case 26:\n              if (bbox) {\n                bbox.union(maskedPageBounds);\n              } else {\n                bbox = maskedPageBounds.clone();\n              }\n            case 27:\n              _context5.next = 22;\n              break;\n            case 29:\n              _context5.next = 34;\n              break;\n            case 31:\n              _context5.prev = 31;\n              _context5.t0 = _context5[\"catch\"](20);\n              _iterator33.e(_context5.t0);\n            case 34:\n              _context5.prev = 34;\n              _iterator33.f();\n              return _context5.finish(34);\n            case 37:\n              if (bbox) {\n                _context5.next = 39;\n                break;\n              }\n              return _context5.abrupt(\"return\");\n            case 39:\n              singleFrameShapeId = ids.length === 1 && this.isShapeOfType(this.getShapeById(ids[0]), FrameShapeUtil) ? ids[0] : null;\n              if (!singleFrameShapeId) {\n                bbox.expandBy(padding);\n              }\n              w = bbox.width * scale;\n              h = bbox.height * scale;\n              svg = window.document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n              if (preserveAspectRatio) {\n                svg.setAttribute(\"preserveAspectRatio\", preserveAspectRatio);\n              }\n              svg.setAttribute(\"direction\", \"ltr\");\n              svg.setAttribute(\"width\", w + \"\");\n              svg.setAttribute(\"height\", h + \"\");\n              svg.setAttribute(\"viewBox\", \"\".concat(bbox.minX, \" \").concat(bbox.minY, \" \").concat(bbox.width, \" \").concat(bbox.height));\n              svg.setAttribute(\"stroke-linecap\", \"round\");\n              svg.setAttribute(\"stroke-linejoin\", \"round\");\n              if (background) {\n                if (singleFrameShapeId) {\n                  svg.style.setProperty(\"background\", colors.solid);\n                } else {\n                  svg.style.setProperty(\"background-color\", colors.background);\n                }\n              } else {\n                svg.style.setProperty(\"background-color\", \"transparent\");\n              }\n              defs = window.document.createElementNS(\"http://www.w3.org/2000/svg\", \"defs\");\n              for (_i11 = 0, _Array$from = Array.from(exportPatternSvgDefs(colors.solid)); _i11 < _Array$from.length; _i11++) {\n                element = _Array$from[_i11];\n                defs.appendChild(element);\n              }\n              try {\n                (_document$body$focus = (_document$body = document.body).focus) === null || _document$body$focus === void 0 || _document$body$focus.call(_document$body);\n              } catch (e) {}\n              svg.append(defs);\n              _context5.next = 58;\n              return Promise.all(renderingShapes.map( /*#__PURE__*/function () {\n                var _ref54 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(_ref53) {\n                  var _util$toSvg, _util$toBackgroundSvg, _shapeSvgElement, _backgroundSvgElement, _shapeSvgElement2, _backgroundSvgElement2;\n                  var id, opacity, index, backgroundIndex, shape, util, font, fontFromShape, shapeSvgElement, backgroundSvgElement, outerElement, _outerElement, bounds, elm, pageTransform, pageMask, clipPathEl, id2, mask, _outerElement2, _outerElement3, elements;\n                  return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n                    while (1) switch (_context3.prev = _context3.next) {\n                      case 0:\n                        id = _ref53.id, opacity = _ref53.opacity, index = _ref53.index, backgroundIndex = _ref53.backgroundIndex;\n                        if (!(id === singleFrameShapeId)) {\n                          _context3.next = 3;\n                          break;\n                        }\n                        return _context3.abrupt(\"return\", []);\n                      case 3:\n                        shape = _this57.getShapeById(id);\n                        if (!_this57.isShapeOfType(shape, GroupShapeUtil)) {\n                          _context3.next = 6;\n                          break;\n                        }\n                        return _context3.abrupt(\"return\", []);\n                      case 6:\n                        util = _this57.getShapeUtil(shape);\n                        fontFromShape = util.getStyleIfExists(DefaultFontStyle, shape);\n                        if (fontFromShape) {\n                          if (fontsUsedInExport.has(fontFromShape)) {\n                            font = fontsUsedInExport.get(fontFromShape);\n                          } else {\n                            font = realContainerStyle.getPropertyValue(\"--tl-font-\".concat(fontFromShape));\n                            fontsUsedInExport.set(fontFromShape, font);\n                          }\n                        }\n                        _context3.next = 11;\n                        return (_util$toSvg = util.toSvg) === null || _util$toSvg === void 0 ? void 0 : _util$toSvg.call(util, shape, font, colors);\n                      case 11:\n                        shapeSvgElement = _context3.sent;\n                        _context3.next = 14;\n                        return (_util$toBackgroundSvg = util.toBackgroundSvg) === null || _util$toBackgroundSvg === void 0 ? void 0 : _util$toBackgroundSvg.call(util, shape, font, colors);\n                      case 14:\n                        backgroundSvgElement = _context3.sent;\n                        if (shapeSvgElement) {\n                          outerElement = document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\");\n                          outerElement.appendChild(shapeSvgElement);\n                          shapeSvgElement = outerElement;\n                        }\n                        if (backgroundSvgElement) {\n                          _outerElement = document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\");\n                          _outerElement.appendChild(backgroundSvgElement);\n                          backgroundSvgElement = _outerElement;\n                        }\n                        if (!shapeSvgElement && !backgroundSvgElement) {\n                          bounds = _this57.getPageBounds(shape);\n                          elm = window.document.createElementNS(\"http://www.w3.org/2000/svg\", \"rect\");\n                          elm.setAttribute(\"width\", bounds.width + \"\");\n                          elm.setAttribute(\"height\", bounds.height + \"\");\n                          elm.setAttribute(\"fill\", colors.solid);\n                          elm.setAttribute(\"stroke\", colors.pattern.grey);\n                          elm.setAttribute(\"stroke-width\", \"1\");\n                          shapeSvgElement = elm;\n                        }\n                        pageTransform = _this57.getPageTransform(shape).toCssString();\n                        if (\"scale\" in shape.props) {\n                          if (shape.props.scale !== 1) {\n                            pageTransform = \"\".concat(pageTransform, \" scale(\").concat(shape.props.scale, \", \").concat(shape.props.scale, \")\");\n                          }\n                        }\n                        (_shapeSvgElement = shapeSvgElement) === null || _shapeSvgElement === void 0 || _shapeSvgElement.setAttribute(\"transform\", pageTransform);\n                        (_backgroundSvgElement = backgroundSvgElement) === null || _backgroundSvgElement === void 0 || _backgroundSvgElement.setAttribute(\"transform\", pageTransform);\n                        (_shapeSvgElement2 = shapeSvgElement) === null || _shapeSvgElement2 === void 0 || _shapeSvgElement2.setAttribute(\"opacity\", opacity + \"\");\n                        (_backgroundSvgElement2 = backgroundSvgElement) === null || _backgroundSvgElement2 === void 0 || _backgroundSvgElement2.setAttribute(\"opacity\", opacity + \"\");\n                        pageMask = _this57.getPageMaskById(shape.id);\n                        if (pageMask) {\n                          clipPathEl = document.createElementNS(\"http://www.w3.org/2000/svg\", \"clipPath\");\n                          defs.appendChild(clipPathEl);\n                          id2 = nanoid();\n                          clipPathEl.id = id2;\n                          mask = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n                          mask.setAttribute(\"d\", \"M\".concat(pageMask.map(function (_ref55) {\n                            var x = _ref55.x,\n                              y = _ref55.y;\n                            return \"\".concat(x, \",\").concat(y);\n                          }).join(\"L\"), \"Z\"));\n                          clipPathEl.appendChild(mask);\n                          if (shapeSvgElement) {\n                            _outerElement2 = document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\");\n                            _outerElement2.setAttribute(\"clip-path\", \"url(#\".concat(id2, \")\"));\n                            _outerElement2.appendChild(shapeSvgElement);\n                            shapeSvgElement = _outerElement2;\n                          }\n                          if (backgroundSvgElement) {\n                            _outerElement3 = document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\");\n                            _outerElement3.setAttribute(\"clip-path\", \"url(#\".concat(id2, \")\"));\n                            _outerElement3.appendChild(backgroundSvgElement);\n                            backgroundSvgElement = _outerElement3;\n                          }\n                        }\n                        elements = [];\n                        if (shapeSvgElement) {\n                          elements.push({\n                            zIndex: index,\n                            element: shapeSvgElement\n                          });\n                        }\n                        if (backgroundSvgElement) {\n                          elements.push({\n                            zIndex: backgroundIndex,\n                            element: backgroundSvgElement\n                          });\n                        }\n                        return _context3.abrupt(\"return\", elements);\n                      case 30:\n                      case \"end\":\n                        return _context3.stop();\n                    }\n                  }, _callee3);\n                }));\n                return function (_x7) {\n                  return _ref54.apply(this, arguments);\n                };\n              }()));\n            case 58:\n              unorderedShapeElements = _context5.sent.flat();\n              _iterator34 = _createForOfIteratorHelper(unorderedShapeElements.sort(function (a, b) {\n                return a.zIndex - b.zIndex;\n              }));\n              try {\n                for (_iterator34.s(); !(_step34 = _iterator34.n()).done;) {\n                  _element = _step34.value.element;\n                  svg.appendChild(_element);\n                }\n              } catch (err) {\n                _iterator34.e(err);\n              } finally {\n                _iterator34.f();\n              }\n              styles = \"\";\n              style = window.document.createElementNS(\"http://www.w3.org/2000/svg\", \"style\");\n              fontInstances = [];\n              if (\"fonts\" in document) {\n                document.fonts.forEach(function (font) {\n                  return fontInstances.push(font);\n                });\n              }\n              _context5.next = 67;\n              return Promise.all(fontInstances.map( /*#__PURE__*/function () {\n                var _ref56 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(font) {\n                  var fileReader, isUsed, url, fontFaceRule, fontFile, base64Font, newFontFaceRule;\n                  return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n                    while (1) switch (_context4.prev = _context4.next) {\n                      case 0:\n                        fileReader = new FileReader();\n                        isUsed = false;\n                        fontsUsedInExport.forEach(function (fontName) {\n                          if (fontName.includes(font.family)) {\n                            isUsed = true;\n                          }\n                        });\n                        if (isUsed) {\n                          _context4.next = 5;\n                          break;\n                        }\n                        return _context4.abrupt(\"return\");\n                      case 5:\n                        url = font.$$_url;\n                        fontFaceRule = font.$$_fontface;\n                        if (!url) {\n                          _context4.next = 18;\n                          break;\n                        }\n                        _context4.next = 10;\n                        return fetch(url);\n                      case 10:\n                        _context4.next = 12;\n                        return _context4.sent.blob();\n                      case 12:\n                        fontFile = _context4.sent;\n                        _context4.next = 15;\n                        return new Promise(function (resolve, reject) {\n                          fileReader.onload = function () {\n                            return resolve(fileReader.result);\n                          };\n                          fileReader.onerror = function () {\n                            return reject(fileReader.error);\n                          };\n                          fileReader.readAsDataURL(fontFile);\n                        });\n                      case 15:\n                        base64Font = _context4.sent;\n                        newFontFaceRule = \"\\n\" + fontFaceRule.replaceAll(url, base64Font);\n                        styles += newFontFaceRule;\n                      case 18:\n                      case \"end\":\n                        return _context4.stop();\n                    }\n                  }, _callee4);\n                }));\n                return function (_x8) {\n                  return _ref56.apply(this, arguments);\n                };\n              }()));\n            case 67:\n              style.textContent = styles;\n              defs.append(style);\n              return _context5.abrupt(\"return\", svg);\n            case 70:\n            case \"end\":\n              return _context5.stop();\n          }\n        }, _callee5, this, [[20, 31, 34, 37]]);\n      }));\n      function getSvg() {\n        return _getSvg.apply(this, arguments);\n      }\n      return getSvg;\n    }()\n  }]);\n  return Editor;\n}(EventEmitter);\n__decorateClass([computed], Editor.prototype, \"_pageTransformCache\", 1);\n__decorateClass([computed], Editor.prototype, \"_pageBoundsCache\", 1);\n__decorateClass([computed], Editor.prototype, \"canUndo\", 1);\n__decorateClass([computed], Editor.prototype, \"canRedo\", 1);\n__decorateClass([computed], Editor.prototype, \"_stylesForNextShape\", 1);\n__decorateClass([computed({\n  isEqual: function isEqual(a, b) {\n    return a.equals(b);\n  }\n})], Editor.prototype, \"sharedStyles\", 1);\n__decorateClass([computed], Editor.prototype, \"sharedOpacity\", 1);\n__decorateClass([computed], Editor.prototype, \"_arrowBindingsIndex\", 1);\n__decorateClass([computed], Editor.prototype, \"_allPageStates\", 1);\n__decorateClass([computed], Editor.prototype, \"openMenus\", 1);\n__decorateClass([computed], Editor.prototype, \"isMenuOpen\", 1);\n__decorateClass([computed], Editor.prototype, \"documentSettings\", 1);\n__decorateClass([computed], Editor.prototype, \"_pages\", 1);\n__decorateClass([computed], Editor.prototype, \"pages\", 1);\n__decorateClass([computed], Editor.prototype, \"_pageStates\", 1);\n__decorateClass([computed], Editor.prototype, \"pageStateId\", 1);\n__decorateClass([computed], Editor.prototype, \"pageState\", 1);\n__decorateClass([computed], Editor.prototype, \"selectedIds\", 1);\n__decorateClass([computed], Editor.prototype, \"selectedIdsSet\", 1);\n__decorateClass([computed], Editor.prototype, \"editingShape\", 1);\n__decorateClass([computed], Editor.prototype, \"hoveredId\", 1);\n__decorateClass([computed], Editor.prototype, \"hoveredShape\", 1);\n__decorateClass([computed], Editor.prototype, \"hintingIds\", 1);\n__decorateClass([computed], Editor.prototype, \"erasingIds\", 1);\n__decorateClass([computed], Editor.prototype, \"erasingIdsSet\", 1);\n__decorateClass([computed], Editor.prototype, \"cameraId\", 1);\n__decorateClass([computed], Editor.prototype, \"camera\", 1);\n__decorateClass([computed], Editor.prototype, \"zoomLevel\", 1);\n__decorateClass([computed], Editor.prototype, \"viewportScreenBounds\", 1);\n__decorateClass([computed], Editor.prototype, \"viewportScreenCenter\", 1);\n__decorateClass([computed], Editor.prototype, \"viewportPageBounds\", 1);\n__decorateClass([computed], Editor.prototype, \"viewportPageCenter\", 1);\n__decorateClass([computed], Editor.prototype, \"cameraState\", 1);\n__decorateClass([computed], Editor.prototype, \"renderingShapes\", 1);\n__decorateClass([computed], Editor.prototype, \"renderingBounds\", 1);\n__decorateClass([computed], Editor.prototype, \"renderingBoundsExpanded\", 1);\n__decorateClass([computed], Editor.prototype, \"_clipPathCache\", 1);\n__decorateClass([computed], Editor.prototype, \"_pageMaskCache\", 1);\n__decorateClass([computed], Editor.prototype, \"allShapesCommonBounds\", 1);\n__decorateClass([computed], Editor.prototype, \"selectedPageBounds\", 1);\n__decorateClass([computed], Editor.prototype, \"selectionRotation\", 1);\n__decorateClass([computed], Editor.prototype, \"selectionBounds\", 1);\n__decorateClass([computed], Editor.prototype, \"selectionPageCenter\", 1);\n__decorateClass([computed], Editor.prototype, \"_assets\", 1);\n__decorateClass([computed], Editor.prototype, \"shapesArray\", 1);\n__decorateClass([computed], Editor.prototype, \"sortedShapesArray\", 1);\n__decorateClass([computed], Editor.prototype, \"selectedShapes\", 1);\n__decorateClass([computed], Editor.prototype, \"onlySelectedShape\", 1);\nfunction alertMaxShapes(editor) {\n  var pageId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : editor.currentPageId;\n  var name = editor.getPageById(pageId).name;\n  editor.emit(\"max-shapes\", {\n    name: name,\n    pageId: pageId,\n    count: MAX_SHAPES_PER_PAGE\n  });\n}\nexport { Editor };","map":{"version":3,"names":["getIndexAbove","getIndexBetween","getIndices","getIndicesAbove","getIndicesBetween","sortByIndex","Box2d","EASINGS","Matrix2d","PI2","Vec2d","approximately","areAnglesCompatible","clamp","intersectPolygonPolygon","pointInPolygon","CameraRecordType","DefaultColorStyle","DefaultFontStyle","InstancePageStateRecordType","PageRecordType","TLDOCUMENT_ID","TLINSTANCE_ID","TLPOINTER_ID","createShapeId","getShapePropKeysByStyle","isPageId","isShape","isShapeId","annotateError","assert","compact","dedupe","deepCopy","getOwnProperty","hasOwnProperty","objectMapFromEntries","partition","sortById","structuredClone","EventEmitter","nanoid","EMPTY_ARRAY","atom","computed","transact","createTLUser","checkShapesAndAddCore","ANIMATION_MEDIUM_MS","CAMERA_MAX_RENDERING_INTERVAL","CAMERA_MOVING_TIMEOUT","COARSE_DRAG_DISTANCE","COLLABORATOR_TIMEOUT","DEFAULT_ANIMATION_OPTIONS","DRAG_DISTANCE","FOLLOW_CHASE_PAN_SNAP","FOLLOW_CHASE_PAN_UNSNAP","FOLLOW_CHASE_PROPORTION","FOLLOW_CHASE_ZOOM_SNAP","FOLLOW_CHASE_ZOOM_UNSNAP","GRID_INCREMENT","HAND_TOOL_FRICTION","INTERNAL_POINTER_IDS","MAJOR_NUDGE_FACTOR","MAX_PAGES","MAX_SHAPES_PER_PAGE","MAX_ZOOM","MINOR_NUDGE_FACTOR","MIN_ZOOM","SVG_PADDING","ZOOMS","exportPatternSvgDefs","SharedStyleMap","WeakMapCache","dataUrlToFile","getIncrementedName","uniqueId","applyRotationToSnapshotShapes","getRotationSnapshot","arrowBindingsIndex","parentsToChildrenWithIndexes","deriveShapeIdsInCurrentPage","ActiveAreaManager","getActiveAreaScreenSpace","ClickManager","DprManager","ExternalContentManager","HistoryManager","SnapManager","TextManager","TickManager","UserPreferencesManager","ShapeUtil","ArrowShapeUtil","getCurvedArrowInfo","getArrowTerminalsInArrowSpace","getIsArrowStraight","getStraightArrowInfo","FrameShapeUtil","GroupShapeUtil","TextShapeUtil","RootState","Editor","_EventEmitter","_inherits","_super","_createSuper","_ref","_this","store","user","shapes","tools","getContainer","_classCallCheck","call","_defineProperty","_assertThisInitialized","Set","_complete","error","origin","willCrashApp","crash","_assertThisInitialize","selectedShapes","sharedStyles","_iterator","_createForOfIteratorHelper","_step","s","n","done","selectedShape","value","_extractSharedStyles","err","e","f","history","createCommand","ids","squashing","arguments","length","undefined","prevSelectedIds","pageState","selectedIds","prevSet","size","every","id","has","data","preservesRedoStack","do","_do","_ref2","update","state","_objectSpread","undo","_ref3","squash","prev","next","canUndo","focusLayerId","_ref4","_ref5","_ref6","_ref7","Date","now","elapsed","_cameraStateTimeoutRemaining","off","_decayCameraStateTimeout","_cameraState","set","updateRenderingBounds","__unsafe__getWithoutCapture","_lastUpdateRenderingBoundsTimestamp","on","originPagePoint","originScreenPoint","previousPagePoint","previousScreenPoint","currentPagePoint","currentScreenPoint","keys","buttons","isPen","shiftKey","ctrlKey","altKey","isDragging","isPointing","isPinching","isEditing","isPanning","pointerVelocity","inputs","dispatch","type","name","key","code","partials","select","isReadOnly","_assertThisInitialize2","shapeIds","currentPageShapeIds","maxShapesReached","alertMaxShapes","partialsToCreate","slice","currentPageId","createdIds","map","p","_ref8","_assertThisInitialize3","partial","parentId","get","find","_partial$x","_partial$y","getParentIdForNewShapeAtPoint","x","y","_partial$x2","_partial$y2","_partial$rotation","point","getPointInShapeSpace","getShapeById","rotation","getPageRotationById","parentIndices","Map","shapeRecordsToCreate","_iterator2","_step2","_partial$opacity","_partial$parentId2","_this$getShapeUtil$on","_this$getShapeUtil","util","getShapeUtil","index","_partial$parentId","getHighestIndexForParent","initialProps","defaultProps","_iterator3","styleProps","_step3","_step3$value","_slicedToArray","style","propKey","getStyleForNextShape","shapeRecordToCreate","schema","types","shape","create","opacity","instanceState","opacityForNextShape","props","Error","onBeforeCreate","push","put","_ref9","remove","_partials","snapshots","Object","fromEntries","_ref10","updated","_newRecord","newRecord","_i","_Object$entries","entries","_Object$entries$_i","k","v","nextProps","_i2","_Object$entries2","_Object$entries2$_i","propValue","updates","_ref11","result","values","i","_this$getShapeUtil$on2","_this$getShapeUtil2","current","onBeforeUpdate","_ref12","prevData","nextData","_toConsumableArray","allIds","_iterator4","_step4","visitDescendants","childId","add","deletedIds","arrowBindings","_arrowBindingsIndex","flatMap","bindings","_ref13","arrowId","concat","postSelectedIds","filter","_ref14","_ref15","getPageById","_ref16","page","_ref17","title","_ref18","_pageInfo","_pageInfo2","createId","belowPageIndex","pages","pageInfo","topIndex","bottomIndex","findIndex","newPage","newCamera","newTabPageState","pageId","prevSelectedPageId","_ref19","_ref20","_assertThisInitialize4","deletedPage","deletedPageStates","_pageStates","_pages","setCurrentPageId","_ref21","_assertThisInitialize5","_pages2","_ref22","_partial$id","ephemeral","_ref23","_ref24","assets","_ref25","_ref26","a","_ref27","_ref28","_ref29","asset","_ref30","_ref31","_ref31$stopFollowing","stopFollowing","console","followingUserId","stopFollowingUser","toId","fromId","_ref32","getPageStateByPageId","camera","_ref33","_ref34","_ref35","_ref36","_ref37","_ref38","_ref39","document","body","textMeasure","root","allShapes","shapeTypesInSchema","migrations","subTypeMigrations","_iterator5","_step5","delete","shapeUtils","allStylesById","_iterator6","_step6","_step6$value","Util","propKeysByStyle","_iterator9","_step9","_iterator7","_step7","Tool","tool","children","_iterator8","_step8","window","isSafari","test","navigator","userAgent","isIos","match","isChromeForIos","onBeforeDelete","record","typeName","_shapeWillBeDeleted","_pageWillBeDeleted","onAfterChange","_updateDepth","_shapeDidChange","_pageStateDidChange","onAfterCreate","isShapeOfType","_arrowDidUpdate","cameraId","pageStateId","_currentPageShapeIds","_parentIdsToChildIds","disposables","listen","changes","emit","container","focusin","_isFocused","focusout","addEventListener","removeEventListener","ensureStoreIsUsable","setInstancePageState","editingId","hoveredId","erasingIds","enter","requestAnimationFrame","_tickManager","start","_createClass","_this2","createComputedCache","_this2$_pageTransform","getTransform","parent","_pageTransformCache","Identity","Compose","_this3","pageTransform","FromPoints","applyToPoints","outline","dispose","forEach","clear","numUndos","redo","numRedos","mark","reason","onUndo","onRedo","bail","bailToMark","batch","fn","shapeUtilConstructor","shapeUtil","prototype","sharedStyleMap","childIds","_iterator10","iterateStyles","_step10","_step10$value","applyValue","stylesForNextShape","_stylesForNextShape","defaultValue","isIn","_selectionSharedStyles","currentTool","styles","shapeType","_iterator11","_step11","_this4","shapesToCheck","addShape","shapeId","_iterator12","getSortedChildIds","_step12","_iterator13","_step13","_i3","_shapesToCheck","getArrowsBoundTo","_reparentArrow","_this5","arrow","_arrow$props","end","startShape","boundShapeId","endShape","parentPageId","getAncestorPageId","nextParentId","_this$findCommonAnces","findCommonAncestor","reparentShapesById","reparentedArrow","startSibling","getShapeNearestSibling","endSibling","highestSibling","finalIndex","higherSiblings","sibling","nextHighestNonArrowSibling","updateShapes","_unbindArrowTerminal","handleId","_getArrowTerminalsInA","query","records","deletedShape","_this6","_invalidParents","_iterator14","_step14","_step14$value","pageStates","_allPageStates","_cleanupInstancePageState","_i4","_arr","handle","terminal","boundShape","isShapeInSamePageAsArrow","_iterator15","_step15","_util$onChildrenChang","onChildrenChange","prevPageState","shapesNoLongerInPage","nextPageState","hintingIds","_this7","reparentBoundArrows","boundArrows","_iterator16","_step16","allMovingIds","_iterator17","_step17","instancePageState","_this8","filtered","_this8$getShapeById","_this8$getShapeById2","includes","nextFocusLayerId","_this$pages$find","backupPageId","instancePageStateId","_ref40","tags","extras","defaultAnnotations","createErrorAnnotations","markAsPossiblyCorrupted","activeStateNode","path","editingShape","_unused","_crashingError","_canMoveCamera","canMove","_dprManager","dpr","_isCoarsePointer","_openMenus","addOpenMenu","menus","openMenus","deleteOpenMenu","_isChangingStyle","_this9","clearTimeout","_isChangingStyleTimeout","setTimeout","isChangingStyle","_isPenMode","setPenMode","isPenMode","_touchEventsRemainingBeforeExitingPenMode","setReadOnly","_isReadOnly","setSelectedTool","updateDocumentSettings","settings","documentSettings","gridSize","setProjectName","isSnapMode","setSnapMode","updateUserPreferences","isDarkMode","setDarkMode","animationSpeed","setAnimationSpeed","cursor","brush","zoomBrush","scribble","isFocusMode","setFocusMode","updateInstanceState","isToolLocked","setToolLocked","isGridMode","setGridMode","sort","getPageInfoById","getShapeIdsInPage","exec","eq","getShapeAndDescendantIds","_setInstancePageState","setSelectedIds","_setSelectedIds","isSelected","selectedIdsSet","isWithinSelection","_this10","findAncestor","_len","Array","_key","deselect","_len2","_key2","selectAll","_getUnlockedShapeIds","selectNone","_this$pageState$focus","popFocusLayer","_this11","focusedShape","_match$id","setFocusLayer","_setFocusLayer","setEditingId","canEdit","viewportPageBounds","localEditingBounds","getEditingBounds","getPageTransformById","pageEditingBounds","corners","contains","width","height","zoomToBounds","minX","minY","centerOnPoint","midX","midY","_this$getShapeById","setHoveredId","_this$getShapeById2","setHintingIds","setErasingIds","erasingIdsSet","croppingId","setCroppingId","isInAny","canCrop","z","updateViewportScreenBounds","center","rect","getBoundingClientRect","screenBounds","Math","max","boundsAreEqual","equals","viewportScreenBounds","_willSetInitialBounds","toJson","zoomLevel","before","viewportPageCenter","after","pan","screenToPage","_tickCameraState","panZoomIntoView","_this$instanceState$s","w","h","_this$viewportScreenB","tl","br","_this$store$unsafeGet","unsafeGetWithoutCapture","cx","cy","_camera$z","cz","pageToScreen","_camera$z2","computeUnorderedRenderingShapes","_this12","_ref41","renderingBounds","renderingBoundsExpanded","renderingShapes","nextIndex","nextBackgroundIndex","addShapeById","parentOpacity","isAncestorErasing","_renderingBounds$incl","_ref42","isId","_iterator18","_step18","isShapeErasing","maskedPageBounds","getMaskedPageBoundsById","isInViewport","isCulled","backgroundIndex","backgroundIndexToRestore","providesBackgroundForChildren","_iterator19","_step19","_iterator20","_step20","_renderingBounds","_renderingBoundsExpanded","clone","expandBy","Translate","Rotate","getParentTransform","_this$_pageTransformC","getPageTransform","getPagePointById","applyToPoint","getPageCenter","getPageCenterById","getPageRotation","Decompose","getBounds","bounds","getBoundsById","getPageBounds","getPageBoundsById","_pageBoundsCache","_this13","pageMask","_pageMaskCache","localMask","Inverse","join","getClipPathById","_clipPathCache","_this14","frameAncestors","getAncestorsById","shape2","getOutline","reduce","acc","b","_intersectPolygonPoly","getPageMaskById","getMaskedPageBounds","pageBounds","intersection","getOutlineById","getAncestors","reverse","predicate","hasAncestor","ancestorId","getParentShape","_this15","_this$findAncestor","_shapes","_toArray","nodeA","others","ancestor","isShapeOrAncestorLocked","isLocked","_this16","commonBounds","expand","getPageCorners","ancestors","transform","apply","isPointInShape","hit","hitTestPoint","getShapesAtPoint","_this17","shapesArray","getPointInParentSpace","From","parentTransform","getDeltaInShapeSpace","delta","Rot","getDeltaInParentSpace","getParentsMappedToChildren","_this18","parents","_parents$get","_this19","Common","_this20","allRotations","PI","abs","_this21","selectionRotation","selectedPageBounds","allPoints","box","rot","selectionBounds","RotWith","_activeToolId","activeTool","activeToolId","_currentChildState$in","_currentChildState$in2","currentChildState","info","onInteractionEnd","transition","getStateDescendant","split","_state$children","pop","childState","_this22","_len3","paths","_key3","some","_updateInputsFromEvent","_this$store$get$lastA","_this$store$get","_this$inputs","_this$store$unsafeGet2","_info$point","sx","sy","sz","_this$camera","setTo","lastActivityTimestamp","pointerId","CAMERA_MOVE","cancelDoubleClick","_clickManager","cancelDoubleClickTimeout","_this23","crashingError","setCursor","_prevCursor","handleEvent","clearInterval","_shiftKeyTimeout","_setShiftKeyTimeout","_altKeyTimeout","_setAltKeyTimeout","_ctrlKeyTimeout","_setCtrlKeyTimeout","canMoveCamera","_pinchStart","_selectedIdsAtPointerDown","_didPinch","interrupt","_info$point2","_info$point2$z","_info$delta","dx","dy","_this23$camera","zoom","min","setCamera","_this23$camera2","_this23$viewportScree","viewportScreenCenter","animateCamera","duration","isMenuOpen","_info$delta$z","_this23$inputs$curren","_this23$camera3","dist","isCoarsePointer","button","capturedPointerId","_restoreToolId","currentToolId","complete","stopCameraAnimation","_this23$inputs","currentScreenPoint2","Sub","slideCamera","speed","len","direction","friction","otherEvent","transformPointerDownEvent","transformPointerUpEvent","handleMove","replaceStoreContentsWithRecordsForOtherDocument","_this24","_partition","_partition2","nonShapes","allShapesCommonBounds","getContent","_this25","pageTransforms","descendant","startBindingId","endBindingId","getArrowInfo","isValid","_info$start$point","_getArrowTerminalsInA2","_info$end$point","_getArrowTerminalsInA3","infoAfter","mpA","Med","distA","Dist","middle","distB","bend","rootShapeIds","pagePoint","pageRotation","assetsSet","assetId","serialize","from","getAssetById","putContent","content","_this26","options","_options$select","_options$preserveIds","preserveIds","_options$preservePosi","preservePosition","_options$point","idMap","pasteParentId","lowestDepth","Infinity","lowestAncestors","_iterator21","_step21","isFrame","depth","isDuplicating","rootShape","rootShapes","newShapes","newShape","mappedId","assetsToCreate","migratePersistedRecord","JSON","stringify","assetsToUpdate","_asset$props$src","src","startsWith","Promise","allSettled","_ref43","_asyncToGenerator","_regeneratorRuntime","_callee","_asset$props$mimeType","file","newAsset","wrap","_callee$","_context","mimeType","sent","externalContentManager","createAssetFromFile","abrupt","stop","_x4","then","assets2","updateAssets","status","createAssets","createShapes","newCreatedShapes","onlyRoot","_s$x","_s$y","_createShapes","animateShapes","_this27","_options$duration","_options$ease","ease","linear","animationId","remaining","t","animations","_i7","_arr2","prop","to","animatingShapes","handleTick","animatingShapes2","partialsToUpdate","removeListener","tPartials","_ref44","_updateShapes","addListener","_this28","compactedPartials","hasOwn","_this29","_this29$getShapeById","deleteShapes","_deleteShapes","locale","setLocale","updatePage","_updatePage","createPage","_createPage","duplicatePage","_this30","deletePage","_deletePage","_assets","_createAssets","deleteAssets","_deleteAssets","_updateAssets","getAssetBySrc","renamePage","moveShapesToPage","_this31","fromPageZ","_this31$selectionBoun","toggleLock","allLocked","allUnlocked","_iterator22","_step22","reorderShapes","operation","_this32","movingSet","siblings","below","above","_iterator23","_step23","indices","node","movingIndices","indexOf","selectIndex","isSelecting","count","isMoving","_siblings","_siblings2","sendToBack","sendBackward","bringForward","bringToFront","flipShapes","_this33","flat","scaleOriginPage","_iterator24","_step24","initialPageTransform","resizeShape","initialBounds","initialShape","mode","scaleOrigin","scaleAxisRotation","stackShapes","_this34","gap","val","dim","shapeGap","gaps","_loop","nextShape","nextBounds","gap2","g","maxCount","c","_this34$getShapeUtil$","_this34$getShapeUtil","localDelta","translateStartChanges","onTranslateStart","packShapes","_this35","padding","shapePageBounds","nextShapePageBounds","area","maxWidth","startWidth","ceil","sqrt","spaces","space","last","i2","maxY","maxX","commonAfter","centerDelta","_this$getShapeUtil$on3","_this$getShapeUtil3","change","translateStartChange","alignShapes","_this36","_this36$getShapeUtil$","_this36$getShapeUtil","translateChanges","distributeShapes","_this37","mid","first","midFirst","step","_this37$getShapeUtil$","_this37$getShapeUtil","_resizeUnalignedShape","scale","shapeScale","sign","_Matrix2d$Decompose","preScaleShapePageCenter","postScaleShapePageCenter","_scalePagePoint","currentPageCenter","pageDelta","postScaleShapePagePoint","Add","_this$getPointInParen","relativePoint","sub","newRelativePagePoint","MulV","destination","rotWith","_options$initialShape","_options$scaleOrigin","_this$getPageBoundsBy","_options$scaleAxisRot","_options$initialPageT","_options$initialBound","Number","isFinite","isAspectRatioLocked","onResize","canResize","_options$dragHandle","_options$mode","newPagePoint","newLocalPoint","myScale","areWidthAndHeightAlignedWithCorrectAxis","initialPagePoint","_this$getPointInParen2","newPoint","dragHandle","scaleX","scaleY","initialPageCenter","newPageCenter","initialPageCenterInParentSpace","newPageCenterInParentSpace","stretchShapes","_this38","shapeBounds","_iterator25","_step25","localOffset","_Vec2d$Add","_iterator26","_step26","_Vec2d$Add2","_this39","_this40","results","pushShapeWithDescendants","otherShape","_this41","siblingShape","targetShape","ancestor2","isShapeInPage","shapeIsInPage","isInPageSearch","insertIndex","_this42","parentPageRotation","decompose","sibs","id2","sibWithInsertIndex","sibAbove","sib","newRotation","withIndices","_childIdsCache","_ref47","_ref48","visitor","_iterator27","_step27","idsToInclude","idsToCheck","sortedShapesArray","canReceiveNewChildrenOfType","containsPoint","getDroppingShape","_this43","droppingShapes","_loop2","canDropShapes","_ret","getOutermostSelectableShape","_filter","focusLayerShape","_ref49","_ref49$stopFollowing","_setCurrentPageId","_updateInstanceState","color","setScribble","setBrush","setZoomBrush","rotateShapesBy","snapshot","editor","stage","nudgeShapes","major","steppedDelta","Mul","_iterator28","_step28","_this$getShapeUtil$on4","_this$getShapeUtil4","duplicateShapes","_this44","offset","initialIds","idsToCreate","idsMap","shapesToCreate","_shape$parentId","ox","oy","vec","currentIndex","siblingAboveId","siblingAbove","newStartShapeId","newEndShapeId","_info$start$point2","_getArrowTerminalsInA4","_info$end$point2","_getArrowTerminalsInA5","ids2","setOpacity","_this45","shapesToUpdate","_iterator29","_step29","_iterator30","_step30","setStyle","_this46","_iterator31","_step31","hasStyle","shapePartial","originalShape","updatePartial","setStyleInPartial","_iterator32","_step32","_ref50","_i10","_updates","currentShape","boundsA","boundsB","didChange","align","_setCamera","_this47","currentCamera","nextCamera","_this47$isPenMode","target","_ref51","_ref51$stopFollowing","isNaN","opts","_this$viewportScreenB2","targetViewport","_animateToViewport","_this$viewportPageBou","pw","ph","zoomToContent","_this$selectedPageBou","zoomToFit","_this48","resetZoom","_this$camera2","zoomIn","_this$camera3","z1","z2","zoomOut","_this$camera4","zoomToSelection","_this49","selectedBounds","_this50","bufferOffsets","_activeAreaManager","offsets","pageTop","top","pageRight","right","pageBottom","bottom","pageLeft","left","selectedTop","selectedRight","selectedBottom","selectedLeft","offsetX","offsetY","targetZoom","inset","_opts$duration","d","div","_animateViewport","ms","_this51","_viewportAnimation","cancel","once","_this$_viewportAnimat","easing","x2","y2","easedViewport","targetViewportPage","_opts$duration2","_opts$easing","easeInOutCubic","_this52","_opts$speedThreshold","speedThreshold","currentSpeed","moveCamera","_this52$camera","movementVec","mul","animateToUser","userId","_this53","presences","presence","isOnSamePage","position","highlightedUserIds","highlightedUserIds2","splice","startFollowingUser","_this54","leaderPresences","thisUserId","warn","moveTowardsUser","isCaughtUp","leaderPresence","chaseProportion","_this54$viewportPageB","leaderScreen","leaderWidth","leaderHeight","leaderCenter","isFollowingFollower","desiredWidth","desiredHeight","ratio","targetWidth","targetHeight","displacement","targetCenter","distance","zoomChange","animateToShape","activeArea","viewportAspectRatio","shapeAspectRatio","blur","focus","_putExternalContent","_callee2","_callee2$","_context2","handleContent","putExternalContent","_x6","groupShapes","_this55","_this$findCommonAnces2","_shapesWithRootParent","groupId","sortedShapeIds","_pageBounds$point","shapesWithRootParent","highestIndex","ungroupShapes","_this56","idsToSelect","groups","group","j","n2","group2","_getSvg","_callee5","_this57","_opts$scale","_opts$background","background","_opts$padding","_opts$darkMode","darkMode","_opts$preserveAspectR","preserveAspectRatio","realContainerEl","realContainerStyle","fakeContainerEl","containerStyle","fontsUsedInExport","colors","shapeIdsToInclude","bbox","_iterator33","_step33","singleFrameShapeId","svg","defs","_i11","_Array$from","element","_document$body$focus","_document$body","unorderedShapeElements","_iterator34","_step34","_element","fontInstances","_args5","_callee5$","_context5","getComputedStyle","createElement","className","appendChild","fill","getPropertyValue","pattern","semi","highlight","text","solid","removeChild","_ref52","union","t0","finish","createElementNS","setAttribute","setProperty","append","all","_ref54","_callee3","_ref53","_util$toSvg","_util$toBackgroundSvg","_shapeSvgElement","_backgroundSvgElement","_shapeSvgElement2","_backgroundSvgElement2","font","fontFromShape","shapeSvgElement","backgroundSvgElement","outerElement","_outerElement","elm","clipPathEl","mask","_outerElement2","_outerElement3","elements","_callee3$","_context3","getStyleIfExists","toSvg","toBackgroundSvg","grey","toCssString","_ref55","zIndex","_x7","fonts","_ref56","_callee4","fileReader","isUsed","url","fontFaceRule","fontFile","base64Font","newFontFaceRule","_callee4$","_context4","FileReader","fontName","family","$$_url","$$_fontface","fetch","blob","resolve","reject","onload","onerror","readAsDataURL","replaceAll","_x8","textContent","getSvg","__decorateClass","isEqual"],"sources":["/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@tldraw/editor/src/lib/editor/Editor.ts"],"sourcesContent":["import {\n\tgetIndexAbove,\n\tgetIndexBetween,\n\tgetIndices,\n\tgetIndicesAbove,\n\tgetIndicesBetween,\n\tsortByIndex,\n} from '@tldraw/indices'\nimport {\n\tBox2d,\n\tEASINGS,\n\tMatLike,\n\tMatrix2d,\n\tMatrix2dModel,\n\tPI2,\n\tVec2d,\n\tVecLike,\n\tapproximately,\n\tareAnglesCompatible,\n\tclamp,\n\tintersectPolygonPolygon,\n\tpointInPolygon,\n} from '@tldraw/primitives'\nimport { ComputedCache, RecordType } from '@tldraw/store'\nimport {\n\tBox2dModel,\n\tCameraRecordType,\n\tDefaultColorStyle,\n\tDefaultFontStyle,\n\tInstancePageStateRecordType,\n\tPageRecordType,\n\tStyleProp,\n\tTLArrowShape,\n\tTLAsset,\n\tTLAssetId,\n\tTLAssetPartial,\n\tTLCursor,\n\tTLCursorType,\n\tTLDOCUMENT_ID,\n\tTLDocument,\n\tTLFrameShape,\n\tTLGroupShape,\n\tTLINSTANCE_ID,\n\tTLImageAsset,\n\tTLInstance,\n\tTLInstancePageState,\n\tTLPOINTER_ID,\n\tTLPage,\n\tTLPageId,\n\tTLParentId,\n\tTLRecord,\n\tTLScribble,\n\tTLShape,\n\tTLShapeId,\n\tTLShapePartial,\n\tTLStore,\n\tTLUnknownShape,\n\tTLVideoAsset,\n\tVec2dModel,\n\tcreateShapeId,\n\tgetShapePropKeysByStyle,\n\tisPageId,\n\tisShape,\n\tisShapeId,\n} from '@tldraw/tlschema'\nimport {\n\tannotateError,\n\tassert,\n\tcompact,\n\tdedupe,\n\tdeepCopy,\n\tgetOwnProperty,\n\thasOwnProperty,\n\tobjectMapFromEntries,\n\tpartition,\n\tsortById,\n\tstructuredClone,\n} from '@tldraw/utils'\nimport { EventEmitter } from 'eventemitter3'\nimport { nanoid } from 'nanoid'\nimport { EMPTY_ARRAY, atom, computed, transact } from 'signia'\nimport { TLUser, createTLUser } from '../config/createTLUser'\nimport { checkShapesAndAddCore } from '../config/defaultShapes'\nimport { AnyTLShapeInfo } from '../config/defineShape'\nimport {\n\tANIMATION_MEDIUM_MS,\n\tCAMERA_MAX_RENDERING_INTERVAL,\n\tCAMERA_MOVING_TIMEOUT,\n\tCOARSE_DRAG_DISTANCE,\n\tCOLLABORATOR_TIMEOUT,\n\tDEFAULT_ANIMATION_OPTIONS,\n\tDRAG_DISTANCE,\n\tFOLLOW_CHASE_PAN_SNAP,\n\tFOLLOW_CHASE_PAN_UNSNAP,\n\tFOLLOW_CHASE_PROPORTION,\n\tFOLLOW_CHASE_ZOOM_SNAP,\n\tFOLLOW_CHASE_ZOOM_UNSNAP,\n\tGRID_INCREMENT,\n\tHAND_TOOL_FRICTION,\n\tINTERNAL_POINTER_IDS,\n\tMAJOR_NUDGE_FACTOR,\n\tMAX_PAGES,\n\tMAX_SHAPES_PER_PAGE,\n\tMAX_ZOOM,\n\tMINOR_NUDGE_FACTOR,\n\tMIN_ZOOM,\n\tSVG_PADDING,\n\tZOOMS,\n} from '../constants'\nimport { exportPatternSvgDefs } from '../hooks/usePattern'\nimport { ReadonlySharedStyleMap, SharedStyle, SharedStyleMap } from '../utils/SharedStylesMap'\nimport { WeakMapCache } from '../utils/WeakMapCache'\nimport { dataUrlToFile } from '../utils/assets'\nimport { getIncrementedName, uniqueId } from '../utils/data'\nimport { applyRotationToSnapshotShapes, getRotationSnapshot } from '../utils/rotation'\nimport { arrowBindingsIndex } from './derivations/arrowBindingsIndex'\nimport { parentsToChildrenWithIndexes } from './derivations/parentsToChildrenWithIndexes'\nimport { deriveShapeIdsInCurrentPage } from './derivations/shapeIdsInCurrentPage'\nimport { ActiveAreaManager, getActiveAreaScreenSpace } from './managers/ActiveAreaManager'\nimport { ClickManager } from './managers/ClickManager'\nimport { DprManager } from './managers/DprManager'\nimport { ExternalContentManager, TLExternalContent } from './managers/ExternalContentManager'\nimport { HistoryManager } from './managers/HistoryManager'\nimport { SnapManager } from './managers/SnapManager'\nimport { TextManager } from './managers/TextManager'\nimport { TickManager } from './managers/TickManager'\nimport { UserPreferencesManager } from './managers/UserPreferencesManager'\nimport { ShapeUtil, TLResizeMode } from './shapes/ShapeUtil'\nimport { ArrowShapeUtil } from './shapes/arrow/ArrowShapeUtil'\nimport { getCurvedArrowInfo } from './shapes/arrow/arrow/curved-arrow'\nimport { getArrowTerminalsInArrowSpace, getIsArrowStraight } from './shapes/arrow/arrow/shared'\nimport { getStraightArrowInfo } from './shapes/arrow/arrow/straight-arrow'\nimport { FrameShapeUtil } from './shapes/frame/FrameShapeUtil'\nimport { GroupShapeUtil } from './shapes/group/GroupShapeUtil'\nimport { TLExportColors } from './shapes/shared/TLExportColors'\nimport { TextShapeUtil } from './shapes/text/TextShapeUtil'\nimport { RootState } from './tools/RootState'\nimport { StateNode, TLStateNodeConstructor } from './tools/StateNode'\nimport { TLContent } from './types/clipboard-types'\nimport { TLEventMap } from './types/emit-types'\nimport { TLEventInfo, TLPinchEventInfo, TLPointerEventInfo } from './types/event-types'\nimport { RequiredKeys } from './types/misc-types'\nimport { TLResizeHandle } from './types/selection-types'\n\n/** @public */\nexport type TLAnimationOptions = Partial<{\n\tduration: number\n\teasing: typeof EASINGS.easeInOutCubic\n}>\n\n/** @public */\nexport type TLViewportOptions = Partial<{\n\t/** Whether to animate the viewport change or not. Defaults to true. */\n\tstopFollowing: boolean\n}>\n\n/** @public */\nexport interface TLEditorOptions {\n\t/**\n\t * The Store instance to use for keeping the app's data. This may be prepopulated, e.g. by loading\n\t * from a server or database.\n\t */\n\tstore: TLStore\n\t/**\n\t * An array of shapes to use in the editor. These will be used to create and manage shapes in the editor.\n\t */\n\tshapes: readonly AnyTLShapeInfo[]\n\t/**\n\t * An array of tools to use in the editor. These will be used to handle events and manage user interactions in the editor.\n\t */\n\ttools: readonly TLStateNodeConstructor[]\n\t/**\n\t * A user defined externally to replace the default user.\n\t */\n\tuser?: TLUser\n\t/**\n\t * Should return a containing html element which has all the styles applied to the editor. If not\n\t * given, the body element will be used.\n\t */\n\tgetContainer: () => HTMLElement\n}\n\n/** @public */\nexport class Editor extends EventEmitter<TLEventMap> {\n\tconstructor({ store, user, shapes, tools, getContainer }: TLEditorOptions) {\n\t\tsuper()\n\n\t\tthis.store = store\n\n\t\tthis.user = new UserPreferencesManager(user ?? createTLUser())\n\n\t\tthis.getContainer = getContainer ?? (() => document.body)\n\n\t\tthis.textMeasure = new TextManager(this)\n\n\t\tthis.root = new RootState(this)\n\n\t\tconst allShapes = checkShapesAndAddCore(shapes)\n\n\t\tconst shapeTypesInSchema = new Set(\n\t\t\tObject.keys(store.schema.types.shape.migrations.subTypeMigrations!)\n\t\t)\n\t\tfor (const shape of allShapes) {\n\t\t\tif (!shapeTypesInSchema.has(shape.type)) {\n\t\t\t\tthrow Error(\n\t\t\t\t\t`Editor and store have different shapes: \"${shape.type}\" was passed into the editor but not the schema`\n\t\t\t\t)\n\t\t\t}\n\t\t\tshapeTypesInSchema.delete(shape.type)\n\t\t}\n\t\tif (shapeTypesInSchema.size > 0) {\n\t\t\tthrow Error(\n\t\t\t\t`Editor and store have different shapes: \"${\n\t\t\t\t\t[...shapeTypesInSchema][0]\n\t\t\t\t}\" is present in the store schema but not provided to the editor`\n\t\t\t)\n\t\t}\n\t\tconst shapeUtils = {} as Record<string, ShapeUtil>\n\t\tconst allStylesById = new Map<string, StyleProp<unknown>>()\n\n\t\tfor (const { util: Util, props } of allShapes) {\n\t\t\tconst propKeysByStyle = getShapePropKeysByStyle(props ?? {})\n\t\t\tshapeUtils[Util.type] = new Util(this, Util.type, propKeysByStyle)\n\n\t\t\tfor (const style of propKeysByStyle.keys()) {\n\t\t\t\tif (!allStylesById.has(style.id)) {\n\t\t\t\t\tallStylesById.set(style.id, style)\n\t\t\t\t} else if (allStylesById.get(style.id) !== style) {\n\t\t\t\t\tthrow Error(\n\t\t\t\t\t\t`Multiple style props with id \"${style.id}\" in use. Style prop IDs must be unique.`\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.shapeUtils = shapeUtils\n\n\t\t// Tools.\n\t\t// Accept tools from constructor parameters which may not conflict with the root note's default or\n\t\t// \"baked in\" tools, select and zoom.\n\t\tfor (const { tool: Tool } of allShapes) {\n\t\t\tif (Tool) {\n\t\t\t\tif (hasOwnProperty(this.root.children!, Tool.id)) {\n\t\t\t\t\tthrow Error(`Can't override tool with id \"${Tool.id}\"`)\n\t\t\t\t}\n\t\t\t\tthis.root.children![Tool.id] = new Tool(this)\n\t\t\t}\n\t\t}\n\t\tfor (const Tool of tools) {\n\t\t\tif (hasOwnProperty(this.root.children!, Tool.id)) {\n\t\t\t\tthrow Error(`Can't override tool with id \"${Tool.id}\"`)\n\t\t\t}\n\t\t\tthis.root.children![Tool.id] = new Tool(this)\n\t\t}\n\n\t\tif (typeof window !== 'undefined' && 'navigator' in window) {\n\t\t\tthis.isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent)\n\t\t\tthis.isIos = !!navigator.userAgent.match(/iPad/i) || !!navigator.userAgent.match(/iPhone/i)\n\t\t\tthis.isChromeForIos = /crios.*safari/i.test(navigator.userAgent)\n\t\t} else {\n\t\t\tthis.isSafari = false\n\t\t\tthis.isIos = false\n\t\t\tthis.isChromeForIos = false\n\t\t}\n\n\t\tthis.store.onBeforeDelete = (record) => {\n\t\t\tif (record.typeName === 'shape') {\n\t\t\t\tthis._shapeWillBeDeleted(record)\n\t\t\t} else if (record.typeName === 'page') {\n\t\t\t\tthis._pageWillBeDeleted(record)\n\t\t\t}\n\t\t}\n\n\t\tthis.store.onAfterChange = (prev, next) => {\n\t\t\tthis._updateDepth++\n\t\t\tif (this._updateDepth > 1000) {\n\t\t\t\tconsole.error('[onAfterChange] Maximum update depth exceeded, bailing out.')\n\t\t\t}\n\t\t\tif (prev.typeName === 'shape' && next.typeName === 'shape') {\n\t\t\t\tthis._shapeDidChange(prev, next)\n\t\t\t} else if (\n\t\t\t\tprev.typeName === 'instance_page_state' &&\n\t\t\t\tnext.typeName === 'instance_page_state'\n\t\t\t) {\n\t\t\t\tthis._pageStateDidChange(prev, next)\n\t\t\t}\n\n\t\t\tthis._updateDepth--\n\t\t}\n\t\tthis.store.onAfterCreate = (record) => {\n\t\t\tif (record.typeName === 'shape' && this.isShapeOfType(record, ArrowShapeUtil)) {\n\t\t\t\tthis._arrowDidUpdate(record)\n\t\t\t}\n\t\t\tif (record.typeName === 'page') {\n\t\t\t\tconst cameraId = CameraRecordType.createId(record.id)\n\t\t\t\tconst pageStateId = InstancePageStateRecordType.createId(record.id)\n\t\t\t\tif (!this.store.has(cameraId)) {\n\t\t\t\t\tthis.store.put([CameraRecordType.create({ id: cameraId })])\n\t\t\t\t}\n\t\t\t\tif (!this.store.has(pageStateId)) {\n\t\t\t\t\tthis.store.put([\n\t\t\t\t\t\tInstancePageStateRecordType.create({ id: pageStateId, pageId: record.id }),\n\t\t\t\t\t])\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis._currentPageShapeIds = deriveShapeIdsInCurrentPage(this.store, () => this.currentPageId)\n\t\tthis._parentIdsToChildIds = parentsToChildrenWithIndexes(this.store)\n\n\t\tthis.disposables.add(\n\t\t\tthis.store.listen((changes) => {\n\t\t\t\tthis.emit('change', changes)\n\t\t\t})\n\t\t)\n\n\t\tconst container = this.getContainer()\n\t\tconst focusin = () => {\n\t\t\tthis._isFocused.set(true)\n\t\t}\n\t\tconst focusout = () => {\n\t\t\tthis._isFocused.set(false)\n\t\t}\n\n\t\tcontainer.addEventListener('focusin', focusin)\n\t\tcontainer.addEventListener('focus', focusin)\n\t\tcontainer.addEventListener('focusout', focusout)\n\t\tcontainer.addEventListener('blur', focusout)\n\n\t\tthis.disposables.add(() => {\n\t\t\tcontainer.removeEventListener('focusin', focusin)\n\t\t\tcontainer.removeEventListener('focus', focusin)\n\t\t\tcontainer.removeEventListener('focusout', focusout)\n\t\t\tcontainer.removeEventListener('blur', focusout)\n\t\t})\n\n\t\tthis.store.ensureStoreIsUsable()\n\n\t\t// clear ephemeral state\n\t\tthis.setInstancePageState(\n\t\t\t{\n\t\t\t\teditingId: null,\n\t\t\t\thoveredId: null,\n\t\t\t\terasingIds: [],\n\t\t\t},\n\t\t\ttrue\n\t\t)\n\n\t\tthis.root.enter(undefined, 'initial')\n\n\t\tif (this.instanceState.followingUserId) {\n\t\t\tthis.stopFollowingUser()\n\t\t}\n\n\t\tthis.updateRenderingBounds()\n\n\t\trequestAnimationFrame(() => {\n\t\t\tthis._tickManager.start()\n\t\t})\n\t}\n\n\t/**\n\t * The editor's store\n\t *\n\t * @public\n\t */\n\treadonly store: TLStore\n\n\t/**\n\t * The root state of the statechart.\n\t *\n\t * @public\n\t */\n\treadonly root: RootState\n\n\t/**\n\t * A set of functions to call when the app is disposed.\n\t *\n\t * @public\n\t */\n\treadonly disposables = new Set<() => void>()\n\n\t/** @internal */\n\tprivate _dprManager = new DprManager(this)\n\n\t/** @internal */\n\tprivate _activeAreaManager = new ActiveAreaManager(this)\n\n\t/** @internal */\n\tprivate _tickManager = new TickManager(this)\n\n\t/** @internal */\n\tprivate _updateDepth = 0\n\n\t/** @public */\n\texternalContentManager = new ExternalContentManager(this)\n\n\t/**\n\t * A manager for the app's snapping feature.\n\t *\n\t * @public\n\t */\n\treadonly snaps = new SnapManager(this)\n\n\t/**\n\t * A manager for the user and their preferences.\n\t *\n\t * @public\n\t */\n\treadonly user: UserPreferencesManager\n\n\t/**\n\t * Whether the editor is running in Safari.\n\t *\n\t * @public\n\t */\n\treadonly isSafari: boolean\n\n\t/**\n\t * Whether the editor is running on iOS.\n\t *\n\t * @public\n\t */\n\treadonly isIos: boolean\n\n\t/**\n\t * Whether the editor is running on iOS.\n\t *\n\t * @public\n\t */\n\treadonly isChromeForIos: boolean\n\n\t/**\n\t * The current HTML element containing the editor.\n\t *\n\t * @example\n\t * ```ts\n\t * const container = editor.getContainer()\n\t * ```\n\t *\n\t * @public\n\t */\n\tgetContainer: () => HTMLElement\n\n\t/**\n\t * A cache of page transforms.\n\t *\n\t * @internal\n\t */\n\t@computed private get _pageTransformCache(): ComputedCache<Matrix2d, TLShape> {\n\t\treturn this.store.createComputedCache<Matrix2d, TLShape>('pageTransformCache', (shape) => {\n\t\t\tif (isPageId(shape.parentId)) {\n\t\t\t\treturn this.getTransform(shape)\n\t\t\t}\n\n\t\t\t// If the shape's parent doesn't exist yet (e.g. when merging in changes from remote in the wrong order)\n\t\t\t// then we can't compute the transform yet, so just return the identity matrix.\n\t\t\t// In the future we should look at creating a store update mechanism that understands and preserves\n\t\t\t// ordering.\n\t\t\tconst parent = this._pageTransformCache.get(shape.parentId) ?? Matrix2d.Identity()\n\n\t\t\treturn Matrix2d.Compose(parent, this.getTransform(shape))\n\t\t})\n\t}\n\n\t/**\n\t * A cache of axis aligned page bounding boxes.\n\t *\n\t * @internal\n\t */\n\t@computed private get _pageBoundsCache(): ComputedCache<Box2d, TLShape> {\n\t\treturn this.store.createComputedCache<Box2d, TLShape>('pageBoundsCache', (shape) => {\n\t\t\tconst pageTransform = this._pageTransformCache.get(shape.id)\n\n\t\t\tif (!pageTransform) return new Box2d()\n\n\t\t\tconst result = Box2d.FromPoints(\n\t\t\t\tMatrix2d.applyToPoints(pageTransform, this.getShapeUtil(shape).outline(shape))\n\t\t\t)\n\n\t\t\treturn result\n\t\t})\n\t}\n\n\t/**\n\t * Dispose the editor.\n\t *\n\t * @public\n\t */\n\tdispose() {\n\t\tthis.disposables.forEach((dispose) => dispose())\n\t\tthis.disposables.clear()\n\t}\n\n\t/**\n\t * A manager for the app's history.\n\t *\n\t * @readonly\n\t */\n\treadonly history = new HistoryManager(\n\t\tthis,\n\t\t() => this._complete(),\n\t\t(error) => {\n\t\t\tthis.annotateError(error, { origin: 'history.batch', willCrashApp: true })\n\t\t\tthis.crash(error)\n\t\t}\n\t)\n\n\t/**\n\t * Undo to the last mark.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.undo()\n\t * ```\n\t *\n\t * @public\n\t */\n\tundo() {\n\t\treturn this.history.undo()\n\t}\n\n\t/**\n\t * Whether the app can undo.\n\t *\n\t * @public\n\t */\n\t@computed get canUndo() {\n\t\treturn this.history.numUndos > 0\n\t}\n\n\t/**\n\t * Redo to the next mark.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.redo()\n\t * ```\n\t *\n\t * @public\n\t */\n\tredo() {\n\t\tthis.history.redo()\n\t\treturn this\n\t}\n\n\t/**\n\t * Whether the app can redo.\n\t *\n\t * @public\n\t */\n\t@computed get canRedo() {\n\t\treturn this.history.numRedos > 0\n\t}\n\n\t/**\n\t * Create a new \"mark\", or stopping point, in the undo redo history. Creating a mark will clear\n\t * any redos.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.mark()\n\t * editor.mark('flip shapes')\n\t * ```\n\t *\n\t * @param reason - The reason for the mark.\n\t * @param onUndo - Whether to stop at the mark when undoing.\n\t * @param onRedo - Whether to stop at the mark when redoing.\n\t *\n\t * @public\n\t */\n\tmark(reason?: string, onUndo?: boolean, onRedo?: boolean) {\n\t\treturn this.history.mark(reason, onUndo, onRedo)\n\t}\n\n\t/**\n\t * Clear all marks in the undo stack back to the next mark.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.bail()\n\t * ```\n\t *\n\t * @public\n\t */\n\tbail() {\n\t\tthis.history.bail()\n\t\treturn this\n\t}\n\n\t/**\n\t * Clear all marks in the undo stack back to the mark with the provided mark id.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.bailToMark('creating')\n\t * ```\n\t *\n\t * @public\n\t */\n\tbailToMark(id: string) {\n\t\tthis.history.bailToMark(id)\n\t\treturn this\n\t}\n\n\t/**\n\t * Run a function in a batch, which will be undone/redone as a single action.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.batch(() => {\n\t * \teditor.selectAll()\n\t * \teditor.deleteShapes()\n\t * \teditor.createShapes(myShapes)\n\t * \teditor.selectNone()\n\t * })\n\t *\n\t * editor.undo() // will undo all of the above\n\t * ```\n\t *\n\t * @public\n\t */\n\tbatch(fn: () => void) {\n\t\tthis.history.batch(fn)\n\t\treturn this\n\t}\n\n\t/**\n\t * A map of shape utility classes (TLShapeUtils) by shape type.\n\t *\n\t * @public\n\t */\n\tshapeUtils: { readonly [K in string]?: ShapeUtil<TLUnknownShape> }\n\n\t/**\n\t * Get a shape util by its definition.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.getShapeUtil(ArrowShapeUtil)\n\t * ```\n\t *\n\t * @param util - The shape util.\n\t *\n\t * @public\n\t */\n\tgetShapeUtil<C extends { new (...args: any[]): ShapeUtil<any>; type: string }>(\n\t\tutil: C\n\t): InstanceType<C>\n\t/**\n\t * Get a shape util from a shape itself.\n\t *\n\t * @example\n\t * ```ts\n\t * const util = editor.getShapeUtil(myShape)\n\t * const util = editor.getShapeUtil<ArrowShapeUtil>(myShape)\n\t * const util = editor.getShapeUtil(ArrowShapeUtil)\n\t * ```\n\t *\n\t * @param shape - A shape or shape partial.\n\t *\n\t * @public\n\t */\n\tgetShapeUtil<S extends TLUnknownShape>(shape: S | TLShapePartial<S>): ShapeUtil<S>\n\tgetShapeUtil<T extends ShapeUtil>(shapeUtilConstructor: {\n\t\ttype: T extends ShapeUtil<infer R> ? R['type'] : string\n\t}): T {\n\t\tconst shapeUtil = getOwnProperty(this.shapeUtils, shapeUtilConstructor.type) as T | undefined\n\t\tassert(shapeUtil, `No shape util found for type \"${shapeUtilConstructor.type}\"`)\n\n\t\t// does shapeUtilConstructor extends ShapeUtil?\n\t\tif (\n\t\t\t'prototype' in shapeUtilConstructor &&\n\t\t\tshapeUtilConstructor.prototype instanceof ShapeUtil\n\t\t) {\n\t\t\tassert(\n\t\t\t\tshapeUtil instanceof (shapeUtilConstructor as any),\n\t\t\t\t`Shape util found for type \"${shapeUtilConstructor.type}\" is not an instance of the provided constructor`\n\t\t\t)\n\t\t}\n\n\t\treturn shapeUtil as T\n\t}\n\n\t/* ---------------------- Props --------------------- */\n\n\t/**\n\t * Get all the current styles among the users selected shapes\n\t *\n\t * @internal\n\t */\n\tprivate _extractSharedStyles(shape: TLShape, sharedStyleMap: SharedStyleMap) {\n\t\tif (this.isShapeOfType(shape, GroupShapeUtil)) {\n\t\t\t// For groups, ignore the styles of the group shape and instead include the styles of the\n\t\t\t// group's children. These are the shapes that would have their styles changed if the\n\t\t\t// user called `setStyle` on the current selection.\n\t\t\tconst childIds = this._parentIdsToChildIds.value[shape.id]\n\t\t\tif (!childIds) return\n\n\t\t\tfor (let i = 0, n = childIds.length; i < n; i++) {\n\t\t\t\tthis._extractSharedStyles(this.getShapeById(childIds[i][0])!, sharedStyleMap)\n\t\t\t}\n\t\t} else {\n\t\t\tconst util = this.getShapeUtil(shape)\n\t\t\tfor (const [style, value] of util.iterateStyles(shape)) {\n\t\t\t\tsharedStyleMap.applyValue(style, value)\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * A derived map containing all current styles among the user's selected shapes.\n\t *\n\t * @internal\n\t */\n\tprivate _selectionSharedStyles = computed<ReadonlySharedStyleMap>(\n\t\t'_selectionSharedStyles',\n\t\t() => {\n\t\t\tconst { selectedShapes } = this\n\n\t\t\tconst sharedStyles = new SharedStyleMap()\n\t\t\tfor (const selectedShape of selectedShapes) {\n\t\t\t\tthis._extractSharedStyles(selectedShape, sharedStyles)\n\t\t\t}\n\n\t\t\treturn sharedStyles\n\t\t}\n\t)\n\n\t@computed private get _stylesForNextShape() {\n\t\treturn this.instanceState.stylesForNextShape\n\t}\n\n\t/** @internal */\n\tgetStyleForNextShape<T>(style: StyleProp<T>): T {\n\t\tconst value = this._stylesForNextShape[style.id]\n\t\treturn value === undefined ? style.defaultValue : (value as T)\n\t}\n\n\t/**\n\t * A derived object containing either all current styles among the user's selected shapes, or\n\t * else the user's most recent style choices that correspond to the current active state (i.e.\n\t * the selected tool).\n\t *\n\t * @public\n\t */\n\t@computed<ReadonlySharedStyleMap>({ isEqual: (a, b) => a.equals(b) })\n\tget sharedStyles(): ReadonlySharedStyleMap {\n\t\t// If we're in selecting and if we have a selection, return the shared styles from the\n\t\t// current selection\n\t\tif (this.isIn('select') && this.selectedIds.length > 0) {\n\t\t\treturn this._selectionSharedStyles.value\n\t\t}\n\n\t\t// If the current tool is associated with a shape, return the styles for that shape.\n\t\t// Otherwise, just return an empty map.\n\t\tconst currentTool = this.root.current.value!\n\t\tconst styles = new SharedStyleMap()\n\t\tif (currentTool.shapeType) {\n\t\t\tfor (const style of this.getShapeUtil(currentTool.shapeType).styleProps.keys()) {\n\t\t\t\tstyles.applyValue(style, this.getStyleForNextShape(style))\n\t\t\t}\n\t\t}\n\n\t\treturn styles\n\t}\n\n\t/**\n\t * Get the currently selected shared opacity.\n\t * If any shapes are selected, this returns the shared opacity of the selected shapes.\n\t * Otherwise, this returns the chosen opacity for the next shape.\n\t *\n\t * @public\n\t */\n\t@computed get sharedOpacity(): SharedStyle<number> {\n\t\tif (this.isIn('select') && this.selectedIds.length > 0) {\n\t\t\tconst shapesToCheck: TLShape[] = []\n\t\t\tconst addShape = (shapeId: TLShapeId) => {\n\t\t\t\tconst shape = this.getShapeById(shapeId)\n\t\t\t\tif (!shape) return\n\t\t\t\t// For groups, ignore the opacity of the group shape and instead include\n\t\t\t\t// the opacity of the group's children. These are the shapes that would have\n\t\t\t\t// their opacity changed if the user called `setOpacity` on the current selection.\n\t\t\t\tif (this.isShapeOfType(shape, GroupShapeUtil)) {\n\t\t\t\t\tfor (const childId of this.getSortedChildIds(shape.id)) {\n\t\t\t\t\t\taddShape(childId)\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tshapesToCheck.push(shape)\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (const shapeId of this.selectedIds) {\n\t\t\t\taddShape(shapeId)\n\t\t\t}\n\n\t\t\tlet opacity: number | null = null\n\t\t\tfor (const shape of shapesToCheck) {\n\t\t\t\tif (opacity === null) {\n\t\t\t\t\topacity = shape.opacity\n\t\t\t\t} else if (opacity !== shape.opacity) {\n\t\t\t\t\treturn { type: 'mixed' }\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (opacity !== null) return { type: 'shared', value: opacity }\n\t\t}\n\t\treturn { type: 'shared', value: this.instanceState.opacityForNextShape }\n\t}\n\n\t/** @internal */\n\t@computed\n\tprivate get _arrowBindingsIndex() {\n\t\treturn arrowBindingsIndex(this)\n\t}\n\n\t/**\n\t * Get all arrows bound to a shape.\n\t *\n\t * @param shapeId - The id of the shape.\n\t *\n\t * @public\n\t */\n\tgetArrowsBoundTo(shapeId: TLShapeId) {\n\t\treturn this._arrowBindingsIndex.value[shapeId] || EMPTY_ARRAY\n\t}\n\n\t/** @internal */\n\tprivate _reparentArrow(arrowId: TLShapeId) {\n\t\tconst arrow = this.getShapeById<TLArrowShape>(arrowId)\n\t\tif (!arrow) return\n\t\tconst { start, end } = arrow.props\n\t\tconst startShape = start.type === 'binding' ? this.getShapeById(start.boundShapeId) : undefined\n\t\tconst endShape = end.type === 'binding' ? this.getShapeById(end.boundShapeId) : undefined\n\n\t\tconst parentPageId = this.getAncestorPageId(arrow)\n\t\tif (!parentPageId) return\n\n\t\tlet nextParentId: TLParentId\n\t\tif (startShape && endShape) {\n\t\t\t// if arrow has two bindings, always parent arrow to closest common ancestor of the bindings\n\t\t\tnextParentId = this.findCommonAncestor([startShape, endShape]) ?? parentPageId\n\t\t} else if (startShape || endShape) {\n\t\t\t// if arrow has one binding, keep arrow on its own page\n\t\t\tnextParentId = parentPageId\n\t\t} else {\n\t\t\treturn\n\t\t}\n\n\t\tif (nextParentId && nextParentId !== arrow.parentId) {\n\t\t\tthis.reparentShapesById([arrowId], nextParentId)\n\t\t}\n\n\t\tconst reparentedArrow = this.getShapeById<TLArrowShape>(arrowId)\n\t\tif (!reparentedArrow) throw Error('no reparented arrow')\n\n\t\tconst startSibling = this.getShapeNearestSibling(reparentedArrow, startShape)\n\t\tconst endSibling = this.getShapeNearestSibling(reparentedArrow, endShape)\n\n\t\tlet highestSibling: TLShape | undefined\n\n\t\tif (startSibling && endSibling) {\n\t\t\thighestSibling = startSibling.index > endSibling.index ? startSibling : endSibling\n\t\t} else if (startSibling && !endSibling) {\n\t\t\thighestSibling = startSibling\n\t\t} else if (endSibling && !startSibling) {\n\t\t\thighestSibling = endSibling\n\t\t} else {\n\t\t\treturn\n\t\t}\n\n\t\tlet finalIndex: string\n\n\t\tconst higherSiblings = this.getSortedChildIds(highestSibling.parentId)\n\t\t\t.map((id) => this.getShapeById(id)!)\n\t\t\t.filter((sibling) => sibling.index > highestSibling!.index)\n\n\t\tif (higherSiblings.length) {\n\t\t\t// there are siblings above the highest bound sibling, we need to\n\t\t\t// insert between them.\n\n\t\t\t// if the next sibling is also a bound arrow though, we can end up\n\t\t\t// all fighting for the same indexes. so lets find the next\n\t\t\t// non-arrow sibling...\n\t\t\tconst nextHighestNonArrowSibling = higherSiblings.find((sibling) => sibling.type !== 'arrow')\n\n\t\t\tif (\n\t\t\t\t// ...then, if we're above the last shape we want to be above...\n\t\t\t\treparentedArrow.index > highestSibling.index &&\n\t\t\t\t// ...but below the next non-arrow sibling...\n\t\t\t\t(!nextHighestNonArrowSibling || reparentedArrow.index < nextHighestNonArrowSibling.index)\n\t\t\t) {\n\t\t\t\t// ...then we're already in the right place. no need to update!\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// otherwise, we need to find the index between the highest sibling\n\t\t\t// we want to be above, and the next highest sibling we want to be\n\t\t\t// below:\n\t\t\tfinalIndex = getIndexBetween(highestSibling.index, higherSiblings[0].index)\n\t\t} else {\n\t\t\t// if there are no siblings above us, we can just get the next index:\n\t\t\tfinalIndex = getIndexAbove(highestSibling.index)\n\t\t}\n\n\t\tif (finalIndex !== reparentedArrow.index) {\n\t\t\tthis.updateShapes<TLArrowShape>([{ id: arrowId, type: 'arrow', index: finalIndex }])\n\t\t}\n\t}\n\n\t/** @internal */\n\tprivate _unbindArrowTerminal(arrow: TLArrowShape, handleId: 'start' | 'end') {\n\t\tconst { x, y } = getArrowTerminalsInArrowSpace(this, arrow)[handleId]\n\t\tthis.store.put([{ ...arrow, props: { ...arrow.props, [handleId]: { type: 'point', x, y } } }])\n\t}\n\n\t// private _shapeWillUpdate = (prev: TLShape, next: TLShape) => {\n\t// \tconst update = this.getShapeUtil(next).onUpdate?.(prev, next)\n\t// \treturn update ?? next\n\t// }\n\n\t@computed\n\tprivate get _allPageStates() {\n\t\treturn this.store.query.records('instance_page_state')\n\t}\n\n\t/** @internal */\n\tprivate _shapeWillBeDeleted(deletedShape: TLShape) {\n\t\t// if the deleted shape has a parent shape make sure we call it's onChildrenChange callback\n\t\tif (deletedShape.parentId && isShapeId(deletedShape.parentId)) {\n\t\t\tthis._invalidParents.add(deletedShape.parentId)\n\t\t}\n\t\t// clean up any arrows bound to this shape\n\t\tconst bindings = this._arrowBindingsIndex.value[deletedShape.id]\n\t\tif (bindings?.length) {\n\t\t\tfor (const { arrowId, handleId } of bindings) {\n\t\t\t\tconst arrow = this.getShapeById<TLArrowShape>(arrowId)\n\t\t\t\tif (!arrow) continue\n\t\t\t\tthis._unbindArrowTerminal(arrow, handleId)\n\t\t\t}\n\t\t}\n\t\tconst pageStates = this._allPageStates.value\n\n\t\tconst deletedIds = new Set([deletedShape.id])\n\t\tconst updates = compact(\n\t\t\tpageStates.map((pageState) => {\n\t\t\t\treturn this._cleanupInstancePageState(pageState, deletedIds)\n\t\t\t})\n\t\t)\n\n\t\tif (updates.length) {\n\t\t\tthis.store.put(updates)\n\t\t}\n\t}\n\n\t/** @internal */\n\tprivate _arrowDidUpdate(arrow: TLArrowShape) {\n\t\t// if the shape is an arrow and its bound shape is on another page\n\t\t// or was deleted, unbind it\n\t\tfor (const handle of ['start', 'end'] as const) {\n\t\t\tconst terminal = arrow.props[handle]\n\t\t\tif (terminal.type !== 'binding') continue\n\t\t\tconst boundShape = this.getShapeById(terminal.boundShapeId)\n\t\t\tconst isShapeInSamePageAsArrow =\n\t\t\t\tthis.getAncestorPageId(arrow) === this.getAncestorPageId(boundShape)\n\t\t\tif (!boundShape || !isShapeInSamePageAsArrow) {\n\t\t\t\tthis._unbindArrowTerminal(arrow, handle)\n\t\t\t}\n\t\t}\n\n\t\t// always check the arrow parents\n\t\tthis._reparentArrow(arrow.id)\n\t}\n\n\t/**\n\t * _invalidParents is used to trigger the 'onChildrenChange' callback that shapes can have.\n\t *\n\t * @internal\n\t */\n\tprivate readonly _invalidParents = new Set<TLShapeId>()\n\n\t/** @internal */\n\tprivate _complete() {\n\t\tfor (const parentId of this._invalidParents) {\n\t\t\tthis._invalidParents.delete(parentId)\n\t\t\tconst parent = this.getShapeById(parentId)\n\t\t\tif (!parent) continue\n\n\t\t\tconst util = this.getShapeUtil(parent)\n\t\t\tconst changes = util.onChildrenChange?.(parent)\n\n\t\t\tif (changes?.length) {\n\t\t\t\tthis.updateShapes(changes, true)\n\t\t\t}\n\t\t}\n\n\t\tthis.emit('update')\n\t}\n\n\t/** @internal */\n\tprivate _cleanupInstancePageState(\n\t\tprevPageState: TLInstancePageState,\n\t\tshapesNoLongerInPage: Set<TLShapeId>\n\t) {\n\t\tlet nextPageState = null as null | TLInstancePageState\n\n\t\tconst selectedIds = prevPageState.selectedIds.filter((id) => !shapesNoLongerInPage.has(id))\n\t\tif (selectedIds.length !== prevPageState.selectedIds.length) {\n\t\t\tif (!nextPageState) nextPageState = { ...prevPageState }\n\t\t\tnextPageState.selectedIds = selectedIds\n\t\t}\n\n\t\tconst erasingIds = prevPageState.erasingIds.filter((id) => !shapesNoLongerInPage.has(id))\n\t\tif (erasingIds.length !== prevPageState.erasingIds.length) {\n\t\t\tif (!nextPageState) nextPageState = { ...prevPageState }\n\t\t\tnextPageState.erasingIds = erasingIds\n\t\t}\n\n\t\tif (prevPageState.hoveredId && shapesNoLongerInPage.has(prevPageState.hoveredId)) {\n\t\t\tif (!nextPageState) nextPageState = { ...prevPageState }\n\t\t\tnextPageState.hoveredId = null\n\t\t}\n\n\t\tif (prevPageState.editingId && shapesNoLongerInPage.has(prevPageState.editingId)) {\n\t\t\tif (!nextPageState) nextPageState = { ...prevPageState }\n\t\t\tnextPageState.editingId = null\n\t\t}\n\n\t\tconst hintingIds = prevPageState.hintingIds.filter((id) => !shapesNoLongerInPage.has(id))\n\t\tif (hintingIds.length !== prevPageState.hintingIds.length) {\n\t\t\tif (!nextPageState) nextPageState = { ...prevPageState }\n\t\t\tnextPageState.hintingIds = hintingIds\n\t\t}\n\n\t\tif (prevPageState.focusLayerId && shapesNoLongerInPage.has(prevPageState.focusLayerId)) {\n\t\t\tif (!nextPageState) nextPageState = { ...prevPageState }\n\t\t\tnextPageState.focusLayerId = null\n\t\t}\n\t\treturn nextPageState\n\t}\n\n\t/** @internal */\n\tprivate _shapeDidChange(prev: TLShape, next: TLShape) {\n\t\tif (this.isShapeOfType(next, ArrowShapeUtil)) {\n\t\t\tthis._arrowDidUpdate(next)\n\t\t}\n\n\t\t// if the shape's parent changed and it is bound to an arrow, update the arrow's parent\n\t\tif (prev.parentId !== next.parentId) {\n\t\t\tconst reparentBoundArrows = (id: TLShapeId) => {\n\t\t\t\tconst boundArrows = this._arrowBindingsIndex.value[id]\n\t\t\t\tif (boundArrows?.length) {\n\t\t\t\t\tfor (const arrow of boundArrows) {\n\t\t\t\t\t\tthis._reparentArrow(arrow.arrowId)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treparentBoundArrows(next.id)\n\t\t\tthis.visitDescendants(next.id, reparentBoundArrows)\n\t\t}\n\n\t\t// if this shape moved to a new page, clean up any previous page's instance state\n\t\tif (prev.parentId !== next.parentId && isPageId(next.parentId)) {\n\t\t\tconst allMovingIds = new Set([prev.id])\n\t\t\tthis.visitDescendants(prev.id, (id) => {\n\t\t\t\tallMovingIds.add(id)\n\t\t\t})\n\n\t\t\tfor (const instancePageState of this._allPageStates.value) {\n\t\t\t\tif (instancePageState.pageId === next.parentId) continue\n\t\t\t\tconst nextPageState = this._cleanupInstancePageState(instancePageState, allMovingIds)\n\n\t\t\t\tif (nextPageState) {\n\t\t\t\t\tthis.store.put([nextPageState])\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (prev.parentId && isShapeId(prev.parentId)) {\n\t\t\tthis._invalidParents.add(prev.parentId)\n\t\t}\n\n\t\tif (next.parentId !== prev.parentId && isShapeId(next.parentId)) {\n\t\t\tthis._invalidParents.add(next.parentId)\n\t\t}\n\t}\n\n\t/** @internal */\n\tprivate _pageStateDidChange(prev: TLInstancePageState, next: TLInstancePageState) {\n\t\tif (prev?.selectedIds !== next?.selectedIds) {\n\t\t\t// ensure that descendants and ancestors are not selected at the same time\n\t\t\tconst filtered = next.selectedIds.filter((id) => {\n\t\t\t\tlet parentId = this.getShapeById(id)?.parentId\n\t\t\t\twhile (isShapeId(parentId)) {\n\t\t\t\t\tif (next.selectedIds.includes(parentId)) {\n\t\t\t\t\t\treturn false\n\t\t\t\t\t}\n\t\t\t\t\tparentId = this.getShapeById(parentId)?.parentId\n\t\t\t\t}\n\t\t\t\treturn true\n\t\t\t})\n\n\t\t\tconst nextFocusLayerId =\n\t\t\t\tfiltered.length === 0\n\t\t\t\t\t? next?.focusLayerId\n\t\t\t\t\t: this.findCommonAncestor(compact(filtered.map((id) => this.getShapeById(id))), (shape) =>\n\t\t\t\t\t\t\tthis.isShapeOfType(shape, GroupShapeUtil)\n\t\t\t\t\t  )\n\n\t\t\tif (filtered.length !== next.selectedIds.length || nextFocusLayerId != next.focusLayerId) {\n\t\t\t\tthis.store.put([{ ...next, selectedIds: filtered, focusLayerId: nextFocusLayerId ?? null }])\n\t\t\t}\n\t\t}\n\t}\n\n\t/** @internal */\n\tprivate _pageWillBeDeleted(page: TLPage) {\n\t\t// page was deleted, need to check whether it's the current page and select another one if so\n\t\tif (this.instanceState.currentPageId !== page.id) return\n\n\t\tconst backupPageId = this.pages.find((p) => p.id !== page.id)?.id\n\t\tif (!backupPageId) return\n\t\tthis.store.put([{ ...this.instanceState, currentPageId: backupPageId }])\n\n\t\t// delete the camera and state for the page if necessary\n\t\tconst cameraId = CameraRecordType.createId(page.id)\n\t\tconst instancePageStateId = InstancePageStateRecordType.createId(page.id)\n\t\tthis.store.remove([cameraId, instancePageStateId])\n\t}\n\n\t/* --------------------- Errors --------------------- */\n\n\t/** @internal */\n\tannotateError(\n\t\terror: unknown,\n\t\t{\n\t\t\torigin,\n\t\t\twillCrashApp,\n\t\t\ttags,\n\t\t\textras,\n\t\t}: {\n\t\t\torigin: string\n\t\t\twillCrashApp: boolean\n\t\t\ttags?: Record<string, string | boolean | number>\n\t\t\textras?: Record<string, unknown>\n\t\t}\n\t) {\n\t\tconst defaultAnnotations = this.createErrorAnnotations(origin, willCrashApp)\n\t\tannotateError(error, {\n\t\t\ttags: { ...defaultAnnotations.tags, ...tags },\n\t\t\textras: { ...defaultAnnotations.extras, ...extras },\n\t\t})\n\t\tif (willCrashApp) {\n\t\t\tthis.store.markAsPossiblyCorrupted()\n\t\t}\n\t}\n\n\t/** @internal */\n\tcreateErrorAnnotations(\n\t\torigin: string,\n\t\twillCrashApp: boolean | 'unknown'\n\t): {\n\t\ttags: { origin: string; willCrashApp: boolean | 'unknown' }\n\t\textras: {\n\t\t\tactiveStateNode?: string\n\t\t\tselectedShapes?: TLUnknownShape[]\n\t\t\teditingShape?: TLUnknownShape\n\t\t\tinputs?: Record<string, unknown>\n\t\t}\n\t} {\n\t\ttry {\n\t\t\treturn {\n\t\t\t\ttags: {\n\t\t\t\t\torigin: origin,\n\t\t\t\t\twillCrashApp,\n\t\t\t\t},\n\t\t\t\textras: {\n\t\t\t\t\tactiveStateNode: this.root.path.value,\n\t\t\t\t\tselectedShapes: this.selectedShapes,\n\t\t\t\t\teditingShape: this.editingId ? this.getShapeById(this.editingId) : undefined,\n\t\t\t\t\tinputs: this.inputs,\n\t\t\t\t},\n\t\t\t}\n\t\t} catch {\n\t\t\treturn {\n\t\t\t\ttags: {\n\t\t\t\t\torigin: origin,\n\t\t\t\t\twillCrashApp,\n\t\t\t\t},\n\t\t\t\textras: {},\n\t\t\t}\n\t\t}\n\t}\n\n\t/** @internal */\n\tprivate _crashingError: unknown | null = null\n\n\t/**\n\t * We can't use an `atom` here because there's a chance that when `crashAndReportError` is called,\n\t * we're in a transaction that's about to be rolled back due to the same error we're currently\n\t * reporting.\n\t *\n\t * Instead, to listen to changes to this value, you need to listen to app's `crash` event.\n\t *\n\t * @internal\n\t */\n\tget crashingError() {\n\t\treturn this._crashingError\n\t}\n\n\t/** @internal */\n\tcrash(error: unknown) {\n\t\tthis._crashingError = error\n\t\tthis.store.markAsPossiblyCorrupted()\n\t\tthis.emit('crash', { error })\n\t}\n\n\t/* ----------------- Internal State ----------------- */\n\n\tprivate _canMoveCamera = atom('can move camera', true)\n\n\t/**\n\t * Whether the editor's camera can move.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.canMoveCamera = false\n\t * ```\n\t *\n\t * @param canMove - Whether the camera can move.\n\t *\n\t * @public\n\t */\n\tget canMoveCamera() {\n\t\treturn this._canMoveCamera.value\n\t}\n\n\tset canMoveCamera(canMove: boolean) {\n\t\tthis._canMoveCamera.set(canMove)\n\t}\n\n\tprivate _isFocused = atom('_isFocused', false)\n\n\t/**\n\t * Whether or not the editor is focused.\n\t *\n\t * @public\n\t */\n\tget isFocused() {\n\t\treturn this._isFocused.value\n\t}\n\n\t/**\n\t * The window's device pixel ratio.\n\t *\n\t * @public\n\t */\n\tget devicePixelRatio() {\n\t\treturn this._dprManager.dpr.value\n\t}\n\n\t// Coarse Pointer\n\n\t/** @internal */\n\tprivate _isCoarsePointer = atom<boolean>('isCoarsePointer', false as any)\n\n\t/**\n\t * Whether the user is using a \"coarse\" pointer, such as on a touch screen. This is automatically set by the canvas.\n\t *\n\t * @public\n\t **/\n\tget isCoarsePointer() {\n\t\treturn this._isCoarsePointer.value\n\t}\n\n\tset isCoarsePointer(v) {\n\t\tthis._isCoarsePointer.set(v)\n\t}\n\n\t// Menus\n\n\tprivate _openMenus = atom('open-menus', [] as string[])\n\n\t/**\n\t * A set of strings representing any open menus. When menus are open,\n\t * certain interactions will behave differently; for example, when a\n\t * draw tool is selected and a menu is open, a pointer-down will not\n\t * create a dot (because the user is probably trying to close the menu)\n\t * however a pointer-down event followed by a drag will begin drawing\n\t * a line (because the user is BOTH trying to close the menu AND start\n\t * drawing a line).\n\t *\n\t * @public\n\t */\n\t@computed get openMenus(): string[] {\n\t\treturn this._openMenus.value\n\t}\n\n\t/**\n\t * Add an open menu.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.addOpenMenu('menu-id')\n\t * ```\n\t *\n\t * @public\n\t */\n\taddOpenMenu(id: string) {\n\t\tconst menus = new Set(this.openMenus)\n\t\tif (!menus.has(id)) {\n\t\t\tmenus.add(id)\n\t\t\tthis._openMenus.set([...menus])\n\t\t}\n\t\treturn this\n\t}\n\n\t/**\n\t * Delete an open menu.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.deleteOpenMenu('menu-id')\n\t * ```\n\t *\n\t * @public\n\t */\n\tdeleteOpenMenu(id: string) {\n\t\tconst menus = new Set(this.openMenus)\n\t\tif (menus.has(id)) {\n\t\t\tmenus.delete(id)\n\t\t\tthis._openMenus.set([...menus])\n\t\t}\n\t\treturn this\n\t}\n\n\t/**\n\t * Get whether any menus are open.\n\t *\n\t * @public\n\t */\n\t@computed get isMenuOpen() {\n\t\treturn this.openMenus.length > 0\n\t}\n\n\t// Changing style\n\n\t/** @internal */\n\tprivate _isChangingStyle = atom<boolean>('isChangingStyle', false as any)\n\n\t/** @internal */\n\tprivate _isChangingStyleTimeout = -1 as any\n\n\t/**\n\t * Whether the user is currently changing the style of a shape. This may cause the UI to change.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.isChangingStyle = true\n\t * ```\n\t *\n\t * @public\n\t */\n\tget isChangingStyle() {\n\t\treturn this._isChangingStyle.value\n\t}\n\n\tset isChangingStyle(v) {\n\t\tthis._isChangingStyle.set(v)\n\t\t// Clear any reset timeout\n\t\tclearTimeout(this._isChangingStyleTimeout)\n\t\tif (v) {\n\t\t\t// If we've set to true, set a new reset timeout to change the value back to false after 2 seconds\n\t\t\tthis._isChangingStyleTimeout = setTimeout(() => (this.isChangingStyle = false), 2000)\n\t\t}\n\t}\n\n\t// Pen Mode\n\n\t/** @internal */\n\tprivate _isPenMode = atom<boolean>('isPenMode', false as any)\n\n\t/** @internal */\n\tprivate _touchEventsRemainingBeforeExitingPenMode = 0\n\n\t/**\n\t * Whether the editor is in pen mode or not.\n\t *\n\t * @public\n\t **/\n\tget isPenMode() {\n\t\treturn this._isPenMode.value\n\t}\n\n\t/**\n\t * Set whether the editor is in pen mode or not.\n\t *\n\t * @public\n\t **/\n\tsetPenMode(isPenMode: boolean): this {\n\t\tif (isPenMode) this._touchEventsRemainingBeforeExitingPenMode = 3\n\t\tif (isPenMode !== this.isPenMode) {\n\t\t\tthis._isPenMode.set(isPenMode)\n\t\t}\n\t\treturn this\n\t}\n\n\t// Read only\n\n\tprivate _isReadOnly = atom<boolean>('isReadOnly', false as any)\n\n\t/**\n\t * Set whether the editor is in read-only mode or not.\n\t *\n\t * @public\n\t **/\n\tsetReadOnly(isReadOnly: boolean): this {\n\t\tthis._isReadOnly.set(isReadOnly)\n\t\tif (isReadOnly) {\n\t\t\tthis.setSelectedTool('hand')\n\t\t}\n\t\treturn this\n\t}\n\n\t/**\n\t * Whether the editor is in read-only mode or not.\n\t *\n\t * @public\n\t **/\n\tget isReadOnly() {\n\t\treturn this._isReadOnly.value\n\t}\n\n\t/* ---------------- Document Settings --------------- */\n\n\t/**\n\t * The global document settings that apply to all users.\n\t *\n\t * @public\n\t **/\n\t@computed get documentSettings() {\n\t\treturn this.store.get(TLDOCUMENT_ID)!\n\t}\n\n\t/**\n\t * Update the global document settings that apply to all users.\n\t *\n\t * @public\n\t **/\n\tupdateDocumentSettings(settings: Partial<TLDocument>) {\n\t\tthis.store.put([{ ...this.documentSettings, ...settings }])\n\t}\n\n\t/**\n\t * The document's grid size.\n\t *\n\t * @public\n\t **/\n\tget gridSize() {\n\t\treturn this.documentSettings.gridSize\n\t}\n\n\t/** @internal */\n\tget projectName() {\n\t\treturn this.documentSettings.name\n\t}\n\n\t/** @internal */\n\tsetProjectName(name: string) {\n\t\tthis.updateDocumentSettings({ name })\n\t}\n\n\t/* ---------------------- User ---------------------- */\n\n\t/**\n\t * Whether the user has \"always snap\" mode enabled.\n\t *\n\t * @public\n\t **/\n\tget isSnapMode() {\n\t\treturn this.user.isSnapMode\n\t}\n\n\t/**\n\t * Set whether the user has \"always snap\" mode enabled.\n\t *\n\t * @public\n\t **/\n\tsetSnapMode(isSnapMode: boolean) {\n\t\tif (isSnapMode !== this.isSnapMode) {\n\t\t\tthis.user.updateUserPreferences({ isSnapMode })\n\t\t}\n\t\treturn this\n\t}\n\n\t/**\n\t * Whether the user has dark mode enabled.\n\t *\n\t * @public\n\t **/\n\tget isDarkMode() {\n\t\treturn this.user.isDarkMode\n\t}\n\n\t/**\n\t * Set whether the user has dark mode enabled.\n\t *\n\t * @public\n\t **/\n\tsetDarkMode(isDarkMode: boolean) {\n\t\tif (isDarkMode !== this.isDarkMode) {\n\t\t\tthis.user.updateUserPreferences({ isDarkMode })\n\t\t}\n\t\treturn this\n\t}\n\n\t/**\n\t * The user's chosen animation speed.\n\t *\n\t * @public\n\t */\n\tget animationSpeed() {\n\t\treturn this.user.animationSpeed\n\t}\n\n\t/**\n\t * Set the user's chosen animation speed.\n\t * Set to 0.0 to disable animations.\n\t * Set to 1.0 for full speed.\n\t *\n\t * @public\n\t */\n\tsetAnimationSpeed(animationSpeed: number): this {\n\t\tif (animationSpeed !== this.animationSpeed) {\n\t\t\tthis.user.updateUserPreferences({ animationSpeed })\n\t\t}\n\t\treturn this\n\t}\n\n\t/* ----------------- Instance State ----------------- */\n\n\t/**\n\t * The current instance's state.\n\t *\n\t * @public\n\t */\n\tget instanceState(): TLInstance {\n\t\treturn this.store.get(TLINSTANCE_ID)!\n\t}\n\n\t/**\n\t * The instance's cursor state.\n\t *\n\t * @public\n\t **/\n\tget cursor() {\n\t\treturn this.instanceState.cursor\n\t}\n\n\t/**\n\t * The instance's brush state.\n\t *\n\t * @public\n\t **/\n\tget brush() {\n\t\treturn this.instanceState.brush\n\t}\n\n\t/**\n\t * The instance's zoom brush state.\n\t *\n\t * @public\n\t **/\n\tget zoomBrush() {\n\t\treturn this.instanceState.zoomBrush\n\t}\n\n\t/**\n\t * The instance's scribble state.\n\t *\n\t * @public\n\t **/\n\tget scribble() {\n\t\treturn this.instanceState.scribble\n\t}\n\n\t// Focus Mode\n\n\t/**\n\t * Whether the instance is in focus mode or not.\n\t *\n\t * @public\n\t **/\n\tget isFocusMode() {\n\t\treturn this.instanceState.isFocusMode\n\t}\n\n\t/**\n\t * Set whether the instance is in focus mode or not.\n\t *\n\t * @public\n\t **/\n\tsetFocusMode(isFocusMode: boolean): this {\n\t\tif (isFocusMode !== this.isFocusMode) {\n\t\t\tthis.updateInstanceState({ isFocusMode }, true)\n\t\t}\n\t\treturn this\n\t}\n\n\t// Tool Locked\n\n\t/**\n\t * Whether the instance has \"tool lock\" mode enabled.\n\t *\n\t * @public\n\t **/\n\tget isToolLocked() {\n\t\treturn this.instanceState.isToolLocked\n\t}\n\n\t/**\n\t * Set whether the instance has \"tool lock\" mode enabled.\n\t *\n\t * @public\n\t **/\n\tsetToolLocked(isToolLocked: boolean): this {\n\t\tif (isToolLocked !== this.isToolLocked) {\n\t\t\tthis.updateInstanceState({ isToolLocked }, true)\n\t\t}\n\t\treturn this\n\t}\n\n\t// Grid Mode\n\n\t/**\n\t * Whether the instance's grid is enabled.\n\t *\n\t * @public\n\t **/\n\tget isGridMode() {\n\t\treturn this.instanceState.isGridMode\n\t}\n\n\t/**\n\t * Set whether the instance's grid is enabled.\n\t *\n\t * @public\n\t **/\n\tsetGridMode(isGridMode: boolean): this {\n\t\tif (isGridMode !== this.isGridMode) {\n\t\t\tthis.updateInstanceState({ isGridMode }, true)\n\t\t}\n\t\treturn this\n\t}\n\n\t/* ---------------------- Pages --------------------- */\n\n\t/** @internal */\n\t@computed private get _pages() {\n\t\treturn this.store.query.records('page')\n\t}\n\n\t/**\n\t * Info about the project's current pages.\n\t *\n\t * @public\n\t */\n\t@computed get pages(): TLPage[] {\n\t\treturn this._pages.value.sort(sortByIndex)\n\t}\n\n\t/**\n\t * The current page.\n\t *\n\t * @public\n\t */\n\tget currentPage(): TLPage {\n\t\tconst page = this.getPageById(this.currentPageId)\n\t\tif (!page)\n\t\t\tthrow Error(`No current page (id ${this.currentPageId}, ${this.pages.length} pages))`)\n\t\treturn page\n\t}\n\n\t/**\n\t * The current page id.\n\t *\n\t * @public\n\t */\n\tget currentPageId(): TLPageId {\n\t\treturn this.instanceState.currentPageId\n\t}\n\n\t/**\n\t * Get a page by its ID.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.getPageById(myPage.id)\n\t * ```\n\t *\n\t * @public\n\t */\n\tgetPageById(id: TLPageId): TLPage | undefined {\n\t\treturn this.store.get(id)\n\t}\n\n\t/**\n\t * Get a page by its ID.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.getPageById(myPage.id)\n\t * ```\n\t *\n\t * @public\n\t */\n\tgetPageInfoById(id: TLPage['id']) {\n\t\treturn this.store.get(id)\n\t}\n\n\t/**\n\t * A cache of shape ids in the current page.\n\t *\n\t * @internal\n\t */\n\tprivate readonly _currentPageShapeIds: ReturnType<typeof deriveShapeIdsInCurrentPage>\n\n\t/**\n\t * An array of all of the shapes on the current page.\n\t *\n\t * @public\n\t */\n\tget currentPageShapeIds() {\n\t\treturn this._currentPageShapeIds.value\n\t}\n\n\t/**\n\t * Get the ids of shapes on a page.\n\t *\n\t * @example\n\t * ```ts\n\t * const idsOnPage1 = editor.getShapeIdsInPage('page1')\n\t * const idsOnPage2 = editor.getShapeIdsInPage('page2')\n\t * ```\n\t *\n\t * @param pageId - The id of the page.\n\t *\n\t * @public\n\t **/\n\tgetShapeIdsInPage(pageId: TLPageId): Set<TLShapeId> {\n\t\tconst result = this.store.query.exec('shape', { parentId: { eq: pageId } })\n\t\treturn this.getShapeAndDescendantIds(result.map((s) => s.id))\n\t}\n\n\t/* ------------------- Page State ------------------- */\n\n\t/** @internal */\n\t@computed private get _pageStates() {\n\t\treturn this.store.query.records('instance_page_state')\n\t}\n\n\t/**\n\t * Get a page state by its id.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.getPageStateByPageId('page1')\n\t * ```\n\t *\n\t * @public\n\t */\n\tgetPageStateByPageId(id: TLPageId) {\n\t\treturn this._pageStates.value.find((p) => p.pageId === id)\n\t}\n\n\t/** @internal */\n\t@computed private get pageStateId() {\n\t\treturn InstancePageStateRecordType.createId(this.currentPageId)\n\t}\n\n\t/**\n\t * The current page state.\n\t *\n\t * @public\n\t */\n\t@computed get pageState(): TLInstancePageState {\n\t\treturn this.store.get(this.pageStateId)!\n\t}\n\n\t/**\n\t * Update a page state.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.setInstancePageState({ id: 'page1', editingId: 'shape:123' })\n\t * editor.setInstancePageState({ id: 'page1', editingId: 'shape:123' }, true)\n\t * ```\n\t *\n\t * @param partial - The partial of the page state object containing the changes.\n\t * @param ephemeral - Whether the command is ephemeral.\n\t *\n\t * @public\n\t */\n\tsetInstancePageState(partial: Partial<TLInstancePageState>, ephemeral = false) {\n\t\tthis._setInstancePageState(partial, ephemeral)\n\t}\n\n\t// Selected Ids\n\n\t/**\n\t * The current selected ids.\n\t *\n\t * @public\n\t */\n\t@computed get selectedIds() {\n\t\treturn this.pageState.selectedIds\n\t}\n\n\t/**\n\t * The current selected ids as a set\n\t *\n\t * @public\n\t */\n\t@computed get selectedIdsSet(): ReadonlySet<TLShapeId> {\n\t\treturn new Set(this.selectedIds)\n\t}\n\n\t/**\n\t * Select one or more shapes.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.setSelectedIds(['id1'])\n\t * editor.setSelectedIds(['id1', 'id2'])\n\t * ```\n\t *\n\t * @param ids - The ids to select.\n\t * @param squashing - Whether the change should create a new history entry or combine with the\n\t *   previous (if the previous is the same type).\n\t *\n\t * @public\n\t */\n\tsetSelectedIds(ids: TLShapeId[], squashing = false) {\n\t\tthis._setSelectedIds(ids, squashing)\n\t\treturn this\n\t}\n\n\t/** @internal */\n\tprivate _setSelectedIds = this.history.createCommand(\n\t\t'setSelectedIds',\n\t\t(ids: TLShapeId[], squashing = false) => {\n\t\t\tconst prevSelectedIds = this.pageState.selectedIds\n\n\t\t\tconst prevSet = new Set(this.pageState.selectedIds)\n\n\t\t\tif (ids.length === prevSet.size && ids.every((id) => prevSet.has(id))) return null\n\n\t\t\treturn { data: { ids, prevSelectedIds }, squashing, preservesRedoStack: true }\n\t\t},\n\t\t{\n\t\t\tdo: ({ ids }) => {\n\t\t\t\tthis.store.update(this.pageState.id, (state) => ({ ...state, selectedIds: ids }))\n\t\t\t},\n\t\t\tundo: ({ prevSelectedIds }) => {\n\t\t\t\tthis.store.update(this.pageState.id, () => ({\n\t\t\t\t\t...this.pageState,\n\t\t\t\t\tselectedIds: prevSelectedIds,\n\t\t\t\t}))\n\t\t\t},\n\t\t\tsquash(prev, next) {\n\t\t\t\treturn { ids: next.ids, prevSelectedIds: prev.prevSelectedIds }\n\t\t\t},\n\t\t}\n\t)\n\n\t/**\n\t * Determine whether or not a shape is selected\n\t *\n\t * @example\n\t * ```ts\n\t * editor.isSelected('id1')\n\t * ```\n\t *\n\t * @param id - The id of the shape to check.\n\t *\n\t * @public\n\t */\n\tisSelected(id: TLShapeId) {\n\t\treturn this.selectedIdsSet.has(id)\n\t}\n\n\t/**\n\t * Determine whether a not a shape is within the current selection. A shape is within the\n\t * selection if it or any of its parents is selected.\n\t *\n\t * @param id - The id of the shape to check.\n\t *\n\t * @public\n\t */\n\tisWithinSelection(id: TLShapeId) {\n\t\tconst shape = this.getShapeById(id)\n\t\tif (!shape) return false\n\n\t\tif (this.isSelected(id)) return true\n\n\t\treturn !!this.findAncestor(shape, (parent) => this.isSelected(parent.id))\n\t}\n\n\t/**\n\t * Select one or more shapes.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.select('id1')\n\t * editor.select('id1', 'id2')\n\t * ```\n\t *\n\t * @param ids - The ids to select.\n\t *\n\t * @public\n\t */\n\tselect(...ids: TLShapeId[]) {\n\t\tthis.setSelectedIds(ids)\n\t\treturn this\n\t}\n\n\t/**\n\t * Remove a shape from the existing set of selected shapes.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.deselect(shape.id)\n\t * ```\n\t *\n\t * @public\n\t */\n\tdeselect(...ids: TLShapeId[]) {\n\t\tconst { selectedIds } = this\n\t\tif (selectedIds.length > 0 && ids.length > 0) {\n\t\t\tthis.setSelectedIds(selectedIds.filter((id) => !ids.includes(id)))\n\t\t}\n\t\treturn this\n\t}\n\n\t/**\n\t * Select all direct children of the current page.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.selectAll()\n\t * ```\n\t *\n\t * @public\n\t */\n\tselectAll() {\n\t\tconst ids = this.getSortedChildIds(this.currentPageId)\n\t\t// page might have no shapes\n\t\tif (ids.length <= 0) return this\n\t\tthis.setSelectedIds(this._getUnlockedShapeIds(ids))\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Clear the selection.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.selectNone()\n\t * ```\n\t *\n\t * @public\n\t */\n\tselectNone(): this {\n\t\tif (this.selectedIds.length > 0) {\n\t\t\tthis.setSelectedIds([])\n\t\t}\n\n\t\treturn this\n\t}\n\n\t// Focus Layer Id\n\n\t/**\n\t * The shape id of the current focus layer.\n\t *\n\t * @public\n\t */\n\tget focusLayerId() {\n\t\treturn this.pageState.focusLayerId ?? this.currentPageId\n\t}\n\n\t/**\n\t * The shape of the current focus layer.\n\t *\n\t * @public\n\t */\n\tget focusLayerShape(): TLShape | undefined {\n\t\tconst id = this.pageState.focusLayerId\n\t\tif (!id) {\n\t\t\treturn\n\t\t}\n\t\treturn this.getShapeById(id)\n\t}\n\n\t/**\n\t * Exit the current focus layer, moving up to the next group if there is one.\n\t *\n\t * @public\n\t */\n\tpopFocusLayer() {\n\t\tconst current = this.pageState.focusLayerId\n\t\tconst focusedShape = current && this.getShapeById(current)\n\n\t\tif (focusedShape) {\n\t\t\t// If we have a focused layer, look for an ancestor of the focused shape that is a group\n\t\t\tconst match = this.findAncestor(focusedShape, (shape) =>\n\t\t\t\tthis.isShapeOfType(shape, GroupShapeUtil)\n\t\t\t)\n\t\t\t// If we have an ancestor that can become a focused layer, set it as the focused layer\n\t\t\tthis.setFocusLayer(match?.id ?? null)\n\t\t\tthis.select(focusedShape.id)\n\t\t} else {\n\t\t\t// If there's no focused shape, then clear the focus layer and clear selection\n\t\t\tthis.setFocusLayer(null)\n\t\t\tthis.selectNone()\n\t\t}\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Set the focus layer to the given shape id.\n\t *\n\t * @param next - The next focus layer id or null to reset the focus layer to the page\n\t *\n\t * @public\n\t */\n\tsetFocusLayer(next: null | TLShapeId) {\n\t\tthis._setFocusLayer(next)\n\t\treturn this\n\t}\n\n\t/** @internal */\n\tprivate _setFocusLayer = this.history.createCommand(\n\t\t'setFocusLayer',\n\t\t(next: null | TLShapeId) => {\n\t\t\t// When we first click an empty canvas we don't want this to show up in the undo stack\n\t\t\tif (next === null && !this.canUndo) {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tconst prev = this.pageState.focusLayerId\n\t\t\treturn { data: { prev, next }, preservesRedoStack: true, squashing: true }\n\t\t},\n\t\t{\n\t\t\tdo: ({ next }) => {\n\t\t\t\tthis.store.update(this.pageState.id, (s) => ({ ...s, focusLayerId: next }))\n\t\t\t},\n\t\t\tundo: ({ prev }) => {\n\t\t\t\tthis.store.update(this.pageState.id, (s) => ({ ...s, focusLayerId: prev }))\n\t\t\t},\n\t\t\tsquash({ prev }, { next }) {\n\t\t\t\treturn { prev, next }\n\t\t\t},\n\t\t}\n\t)\n\n\t// Editing Id\n\n\t/**\n\t * The current editing shape's id.\n\t *\n\t * @public\n\t */\n\tget editingId() {\n\t\treturn this.pageState.editingId\n\t}\n\n\t/**\n\t * Set the current editing id.\n\t *\n\t * @param id - The id of the shape to edit or null to clear the editing id.\n\t *\n\t * @public\n\t */\n\tsetEditingId(id: TLShapeId | null): this {\n\t\tif (!id) {\n\t\t\tthis.setInstancePageState({ editingId: null })\n\t\t} else {\n\t\t\tif (id !== this.editingId) {\n\t\t\t\tconst shape = this.getShapeById(id)!\n\t\t\t\tconst util = this.getShapeUtil(shape)\n\t\t\t\tif (shape && util.canEdit(shape)) {\n\t\t\t\t\tthis.setInstancePageState({ editingId: id, hoveredId: null }, false)\n\n\t\t\t\t\t// todo: remove this camera move\n\n\t\t\t\t\tconst { viewportPageBounds } = this\n\t\t\t\t\tconst localEditingBounds = util.getEditingBounds(shape)!\n\t\t\t\t\tconst pageTransform = this.getPageTransformById(id)!\n\t\t\t\t\tconst pageEditingBounds = Box2d.FromPoints(\n\t\t\t\t\t\tMatrix2d.applyToPoints(pageTransform, localEditingBounds.corners)\n\t\t\t\t\t)\n\n\t\t\t\t\tif (!viewportPageBounds.contains(pageEditingBounds)) {\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tpageEditingBounds.width > viewportPageBounds.width ||\n\t\t\t\t\t\t\tpageEditingBounds.height > viewportPageBounds.height\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tthis.zoomToBounds(\n\t\t\t\t\t\t\t\tpageEditingBounds.minX,\n\t\t\t\t\t\t\t\tpageEditingBounds.minY,\n\t\t\t\t\t\t\t\tpageEditingBounds.width,\n\t\t\t\t\t\t\t\tpageEditingBounds.height\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis.centerOnPoint(pageEditingBounds.midX, pageEditingBounds.midY)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this\n\t}\n\n\t@computed get editingShape() {\n\t\tif (!this.editingId) return null\n\t\treturn this.getShapeById(this.editingId) ?? null\n\t}\n\n\t// Hovered Id\n\n\t/**\n\t * The current hovered shape id.\n\t *\n\t * @readonly\n\t * @public\n\t */\n\t@computed get hoveredId() {\n\t\treturn this.pageState.hoveredId\n\t}\n\n\t/**\n\t * Set the current hovered shape.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.setHoveredId('box1')\n\t * editor.setHoveredId() // Clears the hovered shape.\n\t * ```\n\t *\n\t * @param id - The id of the page to set as the current page\n\t *\n\t * @public\n\t */\n\tsetHoveredId(id: TLShapeId | null = null): this {\n\t\tif (id === this.pageState.hoveredId) return this\n\n\t\tthis.setInstancePageState({ hoveredId: id }, true)\n\t\treturn this\n\t}\n\n\t/**\n\t * The current hovered shape.\n\t *\n\t * @readonly\n\t * @public\n\t */\n\t@computed get hoveredShape() {\n\t\tif (!this.hoveredId) return null\n\t\treturn this.getShapeById(this.hoveredId) ?? null\n\t}\n\n\t// Hinting ids\n\n\t/**\n\t * The editor's current hinting ids.\n\t *\n\t * @public\n\t */\n\t@computed get hintingIds() {\n\t\treturn this.pageState.hintingIds\n\t}\n\n\t/**\n\t * Set the hinted shape ids.\n\t *\n\t * @param ids - The ids to set as hinted.\n\t *\n\t * @public\n\t */\n\tsetHintingIds(ids: TLShapeId[]): this {\n\t\t// always ephemeral\n\t\tthis.store.update(this.pageState.id, (s) => ({ ...s, hintingIds: dedupe(ids) }))\n\t\treturn this\n\t}\n\n\t// Erasing Ids\n\n\t/**\n\t * The editor's current erasing ids.\n\t *\n\t * @public\n\t */\n\t@computed get erasingIds() {\n\t\treturn this.pageState.erasingIds\n\t}\n\n\t/**\n\t * A derived set containing the current erasing ids.\n\t *\n\t * @public\n\t */\n\t@computed get erasingIdsSet() {\n\t\t// todo: Make incremental derivation, so that this only gets updated when erasingIds changes: we're creating this too often!\n\t\treturn new Set<TLShapeId>(this.erasingIds)\n\t}\n\n\t/**\n\t * Set the current erasing shapes.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.setErasingIds(['box1', 'box2'])\n\t * editor.setErasingIds() // Clears the erasing set\n\t * ```\n\t *\n\t * @param ids - The ids of shapes to set as erasing.\n\t *\n\t * @public\n\t */\n\tsetErasingIds(ids: TLShapeId[] = []): this {\n\t\tconst erasingIds = this.erasingIdsSet\n\t\tif (ids.length === erasingIds.size && ids.every((id) => erasingIds.has(id))) return this\n\n\t\tthis.setInstancePageState({ erasingIds: ids }, true)\n\t\treturn this\n\t}\n\n\t// Cropping Id\n\n\t/**\n\t * The current cropping shape's id.\n\t *\n\t * @public\n\t */\n\tget croppingId() {\n\t\treturn this.pageState.croppingId\n\t}\n\n\t/**\n\t * Set the current cropping shape's id.\n\t *\n\t * @param id - The id of the shape to crop or null to clear the cropping id.\n\t *\n\t * @public\n\t */\n\tsetCroppingId(id: TLShapeId | null): this {\n\t\tif (id !== this.croppingId) {\n\t\t\tif (!id) {\n\t\t\t\tthis.setInstancePageState({ croppingId: null })\n\t\t\t\tif (this.isInAny('select.crop', 'select.pointing_crop_handle', 'select.cropping')) {\n\t\t\t\t\tthis.setSelectedTool('select.idle')\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst shape = this.getShapeById(id)!\n\t\t\t\tconst util = this.getShapeUtil(shape)\n\t\t\t\tif (shape && util.canCrop(shape)) {\n\t\t\t\t\tthis.setInstancePageState({ croppingId: id, hoveredId: null })\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn this\n\t}\n\n\t/* --------------------- Camera --------------------- */\n\n\t/** @internal */\n\t@computed\n\tprivate get cameraId() {\n\t\treturn CameraRecordType.createId(this.currentPageId)\n\t}\n\n\t/**\n\t * The current camera.\n\t *\n\t * @public\n\t */\n\t@computed get camera() {\n\t\treturn this.store.get(this.cameraId)!\n\t}\n\n\t/**\n\t * The current camera zoom level.\n\t *\n\t * @public\n\t */\n\t@computed get zoomLevel() {\n\t\treturn this.camera.z\n\t}\n\n\t/* -------------------- Viewport -------------------- */\n\n\t/**\n\t * Update the viewport. The viewport will measure the size and screen position of its container\n\t * element. This should be done whenever the container's position on the screen changes.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.updateViewportScreenBounds()\n\t * editor.updateViewportScreenBounds(true)\n\t * ```\n\t *\n\t * @param center - (optional) Whether to preserve the viewport page center as the viewport changes.\n\t *\n\t * @public\n\t */\n\tupdateViewportScreenBounds(center = false) {\n\t\tconst container = this.getContainer()\n\n\t\tif (!container) return this\n\t\tconst rect = container.getBoundingClientRect()\n\t\tconst screenBounds = new Box2d(0, 0, Math.max(rect.width, 1), Math.max(rect.height, 1))\n\n\t\tconst boundsAreEqual = screenBounds.equals(this.viewportScreenBounds)\n\n\t\t// Get the current value\n\t\tconst { _willSetInitialBounds } = this\n\n\t\tif (boundsAreEqual) {\n\t\t\tthis._willSetInitialBounds = false\n\t\t} else {\n\t\t\tif (_willSetInitialBounds) {\n\t\t\t\t// If we have just received the initial bounds, don't center the camera.\n\t\t\t\tthis._willSetInitialBounds = false\n\t\t\t\tthis.updateInstanceState({ screenBounds: screenBounds.toJson() }, true, true)\n\t\t\t} else {\n\t\t\t\tconst { zoomLevel } = this\n\t\t\t\tif (center) {\n\t\t\t\t\tconst before = this.viewportPageCenter\n\t\t\t\t\tthis.updateInstanceState({ screenBounds: screenBounds.toJson() }, true, true)\n\t\t\t\t\tconst after = this.viewportPageCenter\n\t\t\t\t\tif (!this.instanceState.followingUserId) {\n\t\t\t\t\t\tthis.pan((after.x - before.x) * zoomLevel, (after.y - before.y) * zoomLevel)\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tconst before = this.screenToPage(0, 0)\n\t\t\t\t\tthis.updateInstanceState({ screenBounds: screenBounds.toJson() }, true, true)\n\t\t\t\t\tconst after = this.screenToPage(0, 0)\n\t\t\t\t\tif (!this.instanceState.followingUserId) {\n\t\t\t\t\t\tthis.pan((after.x - before.x) * zoomLevel, (after.y - before.y) * zoomLevel)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis._tickCameraState()\n\t\tthis.updateRenderingBounds()\n\n\t\tconst { editingId } = this\n\n\t\tif (editingId) {\n\t\t\tthis.panZoomIntoView([editingId])\n\t\t}\n\n\t\treturn this\n\t}\n\n\t/**\n\t * The bounds of the editor's viewport in screen space.\n\t *\n\t * @public\n\t */\n\t@computed get viewportScreenBounds() {\n\t\tconst { x, y, w, h } = this.instanceState.screenBounds\n\t\treturn new Box2d(x, y, w, h)\n\t}\n\n\t/**\n\t * The center of the editor's viewport in screen space.\n\t *\n\t * @public\n\t */\n\t@computed get viewportScreenCenter() {\n\t\treturn this.viewportScreenBounds.center\n\t}\n\n\t/**\n\t * The current viewport in page space.\n\t *\n\t * @public\n\t */\n\t@computed get viewportPageBounds() {\n\t\tconst { x, y, w, h } = this.viewportScreenBounds\n\t\tconst tl = this.screenToPage(x, y)\n\t\tconst br = this.screenToPage(x + w, y + h)\n\t\treturn new Box2d(tl.x, tl.y, br.x - tl.x, br.y - tl.y)\n\t}\n\n\t/**\n\t * The center of the viewport in page space.\n\t *\n\t * @public\n\t */\n\t@computed get viewportPageCenter() {\n\t\treturn this.viewportPageBounds.center\n\t}\n\n\t/**\n\t * Convert a point in screen space to a point in page space.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.screenToPage(100, 100)\n\t * ```\n\t *\n\t * @param x - The x coordinate of the point in screen space.\n\t * @param y - The y coordinate of the point in screen space.\n\t * @param camera - The camera to use. Defaults to the current camera.\n\t *\n\t * @public\n\t */\n\tscreenToPage(x: number, y: number, z = 0.5, camera: Vec2dModel = this.camera) {\n\t\tconst { screenBounds } = this.store.unsafeGetWithoutCapture(TLINSTANCE_ID)!\n\t\tconst { x: cx, y: cy, z: cz = 1 } = camera\n\t\treturn {\n\t\t\tx: (x - screenBounds.x) / cz - cx,\n\t\t\ty: (y - screenBounds.y) / cz - cy,\n\t\t\tz,\n\t\t}\n\t}\n\n\t/**\n\t * Convert a point in page space to a point in screen space.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.pageToScreen(100, 100)\n\t * ```\n\t *\n\t * @param x - The x coordinate of the point in screen space.\n\t * @param y - The y coordinate of the point in screen space.\n\t * @param camera - The camera to use. Defaults to the current camera.\n\t *\n\t * @public\n\t */\n\tpageToScreen(x: number, y: number, z = 0.5, camera: Vec2dModel = this.camera) {\n\t\tconst { x: cx, y: cy, z: cz = 1 } = camera\n\t\treturn {\n\t\t\tx: x + cx * cz,\n\t\t\ty: y + cy * cz,\n\t\t\tz,\n\t\t}\n\t}\n\n\t/* -------- Rendering Shapes / rendering Bounds ------- */\n\n\tprivate _cameraState = atom('camera state', 'idle' as 'idle' | 'moving')\n\n\t/**\n\t * Whether the camera is moving or idle.\n\t *\n\t * @public\n\t */\n\t@computed get cameraState() {\n\t\treturn this._cameraState.value\n\t}\n\n\t// Camera state does two things: first, it allows us to subscribe to whether\n\t// the camera is moving or not; and second, it allows us to update the rendering\n\t// shapes on the canvas. Changing the rendering shapes may cause shapes to\n\t// unmount / remount in the DOM, which is expensive; and computing visibility is\n\t// also expensive in large projects. For this reason, we use a second bounding\n\t// box just for rendering, and we only update after the camera stops moving.\n\n\tprivate _cameraStateTimeoutRemaining = 0\n\tprivate _lastUpdateRenderingBoundsTimestamp = Date.now()\n\n\tprivate _decayCameraStateTimeout = (elapsed: number) => {\n\t\tthis._cameraStateTimeoutRemaining -= elapsed\n\n\t\tif (this._cameraStateTimeoutRemaining <= 0) {\n\t\t\tthis.off('tick', this._decayCameraStateTimeout)\n\t\t\tthis._cameraState.set('idle')\n\t\t\tthis.updateRenderingBounds()\n\t\t}\n\t}\n\n\tprivate _tickCameraState = () => {\n\t\t// always reset the timeout\n\t\tthis._cameraStateTimeoutRemaining = CAMERA_MOVING_TIMEOUT\n\n\t\tconst now = Date.now()\n\n\t\t// If the state is idle, then start the tick\n\t\tif (this._cameraState.__unsafe__getWithoutCapture() === 'idle') {\n\t\t\tthis._lastUpdateRenderingBoundsTimestamp = now // don't render right away\n\t\t\tthis._cameraState.set('moving')\n\t\t\tthis.on('tick', this._decayCameraStateTimeout)\n\t\t} else {\n\t\t\tif (now - this._lastUpdateRenderingBoundsTimestamp > CAMERA_MAX_RENDERING_INTERVAL) {\n\t\t\t\tthis.updateRenderingBounds()\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate computeUnorderedRenderingShapes(\n\t\tids: TLParentId[],\n\t\t{\n\t\t\trenderingBounds,\n\t\t\trenderingBoundsExpanded,\n\t\t\terasingIdsSet,\n\t\t\teditingId,\n\t\t}: {\n\t\t\trenderingBounds?: Box2d\n\t\t\trenderingBoundsExpanded?: Box2d\n\t\t\terasingIdsSet?: Set<TLShapeId>\n\t\t\teditingId?: TLShapeId | null\n\t\t} = {}\n\t) {\n\t\t// Here we get the shape as well as any of its children, as well as their\n\t\t// opacities. If the shape is being erased, and none of its ancestors are\n\t\t// being erased, then we reduce the opacity of the shape and all of its\n\t\t// ancestors; but we don't apply this effect more than once among a set\n\t\t// of descendants so that it does not compound.\n\n\t\t// This is designed to keep all the shapes in a single list which\n\t\t// allows the DOM nodes to be reused even when they become children\n\t\t// of other nodes.\n\n\t\tconst renderingShapes: {\n\t\t\tid: TLShapeId\n\t\t\tindex: number\n\t\t\tbackgroundIndex: number\n\t\t\topacity: number\n\t\t\tisCulled: boolean\n\t\t\tisInViewport: boolean\n\t\t\tmaskedPageBounds: Box2d | undefined\n\t\t}[] = []\n\n\t\tlet nextIndex = MAX_SHAPES_PER_PAGE\n\t\tlet nextBackgroundIndex = 0\n\n\t\tconst addShapeById = (id: TLParentId, parentOpacity: number, isAncestorErasing: boolean) => {\n\t\t\tif (PageRecordType.isId(id)) {\n\t\t\t\tfor (const childId of this.getSortedChildIds(id)) {\n\t\t\t\t\taddShapeById(childId, parentOpacity, isAncestorErasing)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tconst shape = this.getShapeById(id)\n\t\t\tif (!shape) return\n\n\t\t\tlet opacity = shape.opacity * parentOpacity\n\t\t\tlet isShapeErasing = false\n\n\t\t\tif (!isAncestorErasing && erasingIdsSet?.has(id)) {\n\t\t\t\tisShapeErasing = true\n\t\t\t\topacity *= 0.32\n\t\t\t}\n\n\t\t\t// If a child is outside of its parent's clipping bounds, then bounds will be undefined.\n\t\t\tconst maskedPageBounds = this.getMaskedPageBoundsById(id)\n\n\t\t\t// Whether the shape is on screen. Use the \"strict\" viewport here.\n\t\t\tconst isInViewport = maskedPageBounds\n\t\t\t\t? renderingBounds?.includes(maskedPageBounds) ?? true\n\t\t\t\t: false\n\n\t\t\t// Whether the shape should actually be culled / unmounted.\n\t\t\t// - Use the \"expanded\" rendering viewport to include shapes that are just off-screen.\n\t\t\t// - Editing shapes should never be culled.\n\t\t\tconst isCulled = maskedPageBounds\n\t\t\t\t? (editingId !== id && !renderingBoundsExpanded?.includes(maskedPageBounds)) ?? true\n\t\t\t\t: true\n\n\t\t\trenderingShapes.push({\n\t\t\t\tid,\n\t\t\t\tindex: nextIndex,\n\t\t\t\tbackgroundIndex: nextBackgroundIndex,\n\t\t\t\topacity,\n\t\t\t\tisCulled,\n\t\t\t\tisInViewport,\n\t\t\t\tmaskedPageBounds,\n\t\t\t})\n\n\t\t\tnextIndex += 1\n\t\t\tnextBackgroundIndex += 1\n\n\t\t\tconst childIds = this.getSortedChildIds(id)\n\t\t\tif (!childIds.length) return\n\n\t\t\tlet backgroundIndexToRestore = null\n\t\t\tif (this.getShapeUtil(shape).providesBackgroundForChildren(shape)) {\n\t\t\t\tbackgroundIndexToRestore = nextBackgroundIndex\n\t\t\t\tnextBackgroundIndex = nextIndex\n\t\t\t\tnextIndex += MAX_SHAPES_PER_PAGE\n\t\t\t}\n\n\t\t\tfor (const childId of childIds) {\n\t\t\t\taddShapeById(childId, opacity, isAncestorErasing || isShapeErasing)\n\t\t\t}\n\n\t\t\tif (backgroundIndexToRestore !== null) {\n\t\t\t\tnextBackgroundIndex = backgroundIndexToRestore\n\t\t\t}\n\t\t}\n\n\t\tfor (const id of ids) {\n\t\t\taddShapeById(id, 1, false)\n\t\t}\n\n\t\treturn renderingShapes\n\t}\n\n\t/**\n\t * Get the shapes that should be displayed in the current viewport.\n\t *\n\t * @public\n\t */\n\t@computed get renderingShapes() {\n\t\tconst renderingShapes = this.computeUnorderedRenderingShapes([this.currentPageId], {\n\t\t\trenderingBounds: this.renderingBounds,\n\t\t\trenderingBoundsExpanded: this.renderingBoundsExpanded,\n\t\t\terasingIdsSet: this.erasingIdsSet,\n\t\t\teditingId: this.editingId,\n\t\t})\n\n\t\t// Its IMPORTANT that the result be sorted by id AND include the index\n\t\t// that the shape should be displayed at. Steve, this is the past you\n\t\t// telling the present you not to change this.\n\n\t\t// We want to sort by id because moving elements about in the DOM will\n\t\t// cause the element to get removed by react as it moves the DOM node. This\n\t\t// causes <iframes/> to re-render which is hella annoying and a perf\n\t\t// drain. By always sorting by 'id' we keep the shapes always in the\n\t\t// same order; but we later use index to set the element's 'z-index'\n\t\t// to change the \"rendered\" position in z-space.\n\t\treturn renderingShapes.sort(sortById)\n\t}\n\n\t/**\n\t * The current rendering bounds in page space, used for checking which shapes are \"on screen\".\n\t *\n\t * @public\n\t */\n\t@computed get renderingBounds() {\n\t\treturn this._renderingBounds.value\n\t}\n\n\t/** @internal */\n\treadonly _renderingBounds = atom('rendering viewport', new Box2d())\n\n\t/**\n\t * The current rendering bounds in page space, expanded slightly. Used for determining which shapes\n\t * to render and which to \"cull\".\n\t *\n\t * @public\n\t */\n\t@computed get renderingBoundsExpanded() {\n\t\treturn this._renderingBoundsExpanded.value\n\t}\n\n\t/** @internal */\n\treadonly _renderingBoundsExpanded = atom('rendering viewport expanded', new Box2d())\n\n\t/**\n\t * Update the rendering bounds. This should be called when the viewport has stopped changing, such\n\t * as at the end of a pan, zoom, or animation.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.updateRenderingBounds()\n\t * ```\n\t *\n\t *\n\t * @internal\n\t */\n\tupdateRenderingBounds(): this {\n\t\tconst { viewportPageBounds } = this\n\t\tif (viewportPageBounds.equals(this._renderingBounds.__unsafe__getWithoutCapture())) return this\n\t\tthis._renderingBounds.set(viewportPageBounds.clone())\n\t\tthis._renderingBoundsExpanded.set(viewportPageBounds.clone().expandBy(100 / this.zoomLevel))\n\t\treturn this\n\t}\n\n\t/* --------------------- Shapes --------------------- */\n\n\t/**\n\t * Get the local transform for a shape as a matrix model. This transform reflects both its\n\t * translation (x, y) from from either its parent's top left corner, if the shape's parent is\n\t * another shape, or else from the 0,0 of the page, if the shape's parent is the page; and the\n\t * shape's rotation.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.getTransform(myShape)\n\t * ```\n\t *\n\t * @param shape - The shape to get the local transform for.\n\t *\n\t * @public\n\t */\n\tgetTransform(shape: TLShape) {\n\t\treturn Matrix2d.Compose(Matrix2d.Translate(shape.x, shape.y), Matrix2d.Rotate(shape.rotation))\n\t}\n\n\t/**\n\t * Get the local transform of a shape's parent as a matrix model.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.getParentTransform(myShape)\n\t * ```\n\t *\n\t * @param shape - The shape to get the parent transform for.\n\t *\n\t * @public\n\t */\n\tgetParentTransform(shape: TLShape) {\n\t\tif (isPageId(shape.parentId)) {\n\t\t\treturn Matrix2d.Identity()\n\t\t}\n\t\treturn this._pageTransformCache.get(shape.parentId) ?? Matrix2d.Identity()\n\t}\n\n\t/**\n\t * Get the page transform (or absolute transform) of a shape.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.getPageTransform(myShape)\n\t * ```\n\t *\n\t * @param shape - The shape to get the page transform for.\n\t *\n\t * @public\n\t */\n\tgetPageTransform(shape: TLShape) {\n\t\treturn this.getPageTransformById(shape.id)\n\t}\n\n\t/**\n\t * Get the page transform (or absolute transform) of a shape by its id.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.getPageTransformById(myShape)\n\t * ```\n\t *\n\t * @param id - The if of the shape to get the page transform for.\n\t *\n\t * @public\n\t */\n\tgetPageTransformById(id: TLShapeId) {\n\t\treturn this._pageTransformCache.get(id)\n\t}\n\n\t/**\n\t * Get the page point (or absolute point) of a shape.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.getPagePoint(myShape)\n\t * ```\n\t *\n\t * @param shape - The shape to get the page point for.\n\t *\n\t * @public\n\t */\n\tgetPagePointById(id: TLShapeId) {\n\t\tconst pageTransform = this.getPageTransformById(id)\n\t\tif (!pageTransform) return\n\t\treturn Matrix2d.applyToPoint(pageTransform, new Vec2d())\n\t}\n\n\t/**\n\t * Get the page point (or absolute point) of a shape.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.getPagePoint(myShape)\n\t * ```\n\t *\n\t * @param shape - The shape to get the page point for.\n\t *\n\t * @public\n\t */\n\tgetPageCenter(shape: TLShape) {\n\t\tconst pageTransform = this.getPageTransformById(shape.id)\n\t\tif (!pageTransform) return null\n\t\tconst util = this.getShapeUtil(shape)\n\t\tconst center = util.center(shape)\n\t\treturn Matrix2d.applyToPoint(pageTransform, center)\n\t}\n\n\t/**\n\t * Get the page point (or absolute point) of a shape by its id.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.getPagePoint(myShape)\n\t * ```\n\t *\n\t * @param id - The shape id to get the page point for.\n\t *\n\t * @public\n\t */\n\tgetPageCenterById(id: TLShapeId) {\n\t\tconst shape = this.getShapeById(id)!\n\t\treturn this.getPageCenter(shape)\n\t}\n\n\t/**\n\t * Get the page rotation (or absolute rotation) of a shape.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.getPageRotation(myShape)\n\t * ```\n\t *\n\t * @param shape - The shape to get the page rotation for.\n\t *\n\t * @public\n\t */\n\tgetPageRotation(shape: TLShape): number {\n\t\treturn this.getPageRotationById(shape.id)\n\t}\n\n\t/**\n\t * Get the page rotation (or absolute rotation) of a shape by its id.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.getPageRotationById(myShapeId)\n\t * ```\n\t *\n\t * @param id - The id of the shape to get the page rotation for.\n\t */\n\tgetPageRotationById(id: TLShapeId): number {\n\t\tconst pageTransform = this.getPageTransformById(id)\n\t\tif (pageTransform) {\n\t\t\treturn Matrix2d.Decompose(pageTransform).rotation\n\t\t}\n\t\treturn 0\n\t}\n\n\t/**\n\t * Get the local bounds of a shape.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.getBounds(myShape)\n\t * ```\n\t *\n\t * @param shape - The shape to get the bounds for.\n\t *\n\t * @public\n\t */\n\tgetBounds(shape: TLShape): Box2d {\n\t\treturn this.getShapeUtil(shape).bounds(shape)\n\t}\n\n\t/**\n\t * Get the local bounds of a shape by its id.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.getBoundsById(myShape)\n\t * ```\n\t *\n\t * @param id - The id of the shape to get the bounds for.\n\t *\n\t * @public\n\t */\n\tgetBoundsById(id: TLShapeId): Box2d | undefined {\n\t\tconst shape = this.getShapeById(id)\n\t\tif (!shape) return undefined\n\t\treturn this.getBounds(shape)\n\t}\n\n\t/**\n\t * Get the page (or absolute) bounds of a shape.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.getPageBounds(myShape)\n\t * ```\n\t *\n\t * @param shape - The shape to get the bounds for.\n\t *\n\t * @public\n\t */\n\tgetPageBounds(shape: TLShape): Box2d | undefined {\n\t\treturn this.getPageBoundsById(shape.id)\n\t}\n\n\t/**\n\t * Get the page (or absolute) bounds of a shape by its id.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.getPageBoundsById(myShape)\n\t * ```\n\t *\n\t * @param id - The id of the shape to get the page bounds for.\n\t *\n\t * @public\n\t */\n\tgetPageBoundsById(id: TLShapeId): Box2d | undefined {\n\t\treturn this._pageBoundsCache.get(id)\n\t}\n\n\t/**\n\t * A cache of clip paths used for clipping.\n\t *\n\t * @internal\n\t */\n\t@computed private get _clipPathCache(): ComputedCache<string, TLShape> {\n\t\treturn this.store.createComputedCache<string, TLShape>('clipPathCache', (shape) => {\n\t\t\tconst pageMask = this._pageMaskCache.get(shape.id)\n\t\t\tif (!pageMask) return undefined\n\t\t\tconst pageTransform = this._pageTransformCache.get(shape.id)\n\t\t\tif (!pageTransform) return undefined\n\n\t\t\tif (pageMask.length === 0) {\n\t\t\t\treturn `polygon(0px 0px, 0px 0px, 0px 0px)`\n\t\t\t}\n\n\t\t\tconst localMask = Matrix2d.applyToPoints(Matrix2d.Inverse(pageTransform), pageMask)\n\n\t\t\treturn `polygon(${localMask.map((p) => `${p.x}px ${p.y}px`).join(',')})`\n\t\t})\n\t}\n\n\t/**\n\t * Get the clip path for a shape.\n\t *\n\t * @example\n\t * ```ts\n\t * const clipPath = editor.getClipPathById(shape.id)\n\t * ```\n\t *\n\t * @param id - The shape id.\n\t *\n\t * @returns The clip path or undefined.\n\t *\n\t * @public\n\t */\n\tgetClipPathById(id: TLShapeId) {\n\t\treturn this._clipPathCache.get(id)\n\t}\n\n\t/**\n\t * A cache of page masks used for clipping.\n\t *\n\t * @internal\n\t */\n\t@computed private get _pageMaskCache(): ComputedCache<VecLike[], TLShape> {\n\t\treturn this.store.createComputedCache<VecLike[], TLShape>('pageMaskCache', (shape) => {\n\t\t\tif (isPageId(shape.parentId)) {\n\t\t\t\treturn undefined\n\t\t\t}\n\n\t\t\tconst frameAncestors = this.getAncestorsById(shape.id).filter((shape) =>\n\t\t\t\tthis.isShapeOfType(shape, FrameShapeUtil)\n\t\t\t)\n\n\t\t\tif (frameAncestors.length === 0) return undefined\n\n\t\t\tconst pageMask = frameAncestors\n\t\t\t\t.map<VecLike[] | undefined>((s) =>\n\t\t\t\t\t// Apply the frame transform to the frame outline to get the frame outline in page space\n\t\t\t\t\tMatrix2d.applyToPoints(this._pageTransformCache.get(s.id)!, this.getOutline(s))\n\t\t\t\t)\n\t\t\t\t.reduce((acc, b) => (b && acc ? intersectPolygonPolygon(acc, b) ?? undefined : undefined))\n\n\t\t\treturn pageMask\n\t\t})\n\t}\n\n\t/**\n\t * Get the page mask for a shape.\n\t *\n\t * @example\n\t * ```ts\n\t * const pageMask = editor.getPageMaskById(shape.id)\n\t * ```\n\t *\n\t * @param id - The id of the shape to get the page mask for.\n\t *\n\t * @returns The page mask for the shape.\n\t *\n\t * @public\n\t */\n\tgetPageMaskById(id: TLShapeId) {\n\t\treturn this._pageMaskCache.get(id)\n\t}\n\n\t/**\n\t * Get the page (or absolute) bounds of a shape, incorporating any masks. For example, if the\n\t * shape were the child of a frame and was half way out of the frame, the bounds would be the half\n\t * of the shape that was in the frame.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.getMaskedPageBounds(myShape)\n\t * ```\n\t *\n\t * @param shape - The shape to get the masked bounds for.\n\t *\n\t * @public\n\t */\n\tgetMaskedPageBounds(shape: TLShape): Box2d | undefined {\n\t\treturn this.getMaskedPageBoundsById(shape.id)\n\t}\n\n\t/**\n\t * Get the page (or absolute) bounds of a shape by its id, incorporating any masks. For example,\n\t * if the shape were the child of a frame and was half way out of the frame, the bounds would be\n\t * the half of the shape that was in the frame.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.getMaskedPageBoundsById(myShape)\n\t * ```\n\t *\n\t * @param id - The id of the shape to get the masked page bounds for.\n\t *\n\t * @public\n\t */\n\tgetMaskedPageBoundsById(id: TLShapeId): Box2d | undefined {\n\t\tconst pageBounds = this._pageBoundsCache.get(id)\n\t\tif (!pageBounds) return\n\t\tconst pageMask = this._pageMaskCache.get(id)\n\t\tif (pageMask) {\n\t\t\tconst intersection = intersectPolygonPolygon(pageMask, pageBounds.corners)\n\t\t\tif (!intersection) return\n\t\t\treturn Box2d.FromPoints(intersection)\n\t\t}\n\t\treturn pageBounds\n\t}\n\n\t/**\n\t * Get the local outline of a shape.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.getOutline(myShape)\n\t * ```\n\t *\n\t * @param shape - The shape to get the outline for.\n\t *\n\t * @public\n\t */\n\tgetOutline(shape: TLShape) {\n\t\treturn this.getShapeUtil(shape).outline(shape)\n\t}\n\n\t/**\n\t * Get the local outline of a shape.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.getOutlineById(myShape)\n\t * ```\n\t *\n\t * @param id - The shape id to get the outline for.\n\t *\n\t * @public\n\t */\n\tgetOutlineById(id: TLShapeId) {\n\t\treturn this.getOutline(this.getShapeById(id)!)\n\t}\n\n\t/**\n\t * Get the ancestors of a shape.\n\t *\n\t * @example\n\t * ```ts\n\t * const ancestors = editor.getAncestors(myShape)\n\t * ```\n\t *\n\t * @param shape - The shape to get the ancestors for.\n\t *\n\t * @public\n\t */\n\tgetAncestors(shape: TLShape, acc: TLShape[] = []): TLShape[] {\n\t\tconst parentId = shape.parentId\n\t\tif (isPageId(parentId)) {\n\t\t\tacc.reverse()\n\t\t\treturn acc\n\t\t}\n\n\t\tconst parent = this.store.get(parentId)\n\t\tif (!parent) return acc\n\t\tacc.push(parent)\n\t\treturn this.getAncestors(parent, acc)\n\t}\n\n\t/**\n\t * Get the ancestors of a shape by its id.\n\t *\n\t * @example\n\t * ```ts\n\t * const ancestors = editor.getAncestorsById(myShape)\n\t * ```\n\t *\n\t * @param id - The id of the shape to get the ancestors for.\n\t *\n\t * @public\n\t */\n\tgetAncestorsById(id: TLShapeId, acc: TLShape[] = []): TLShape[] {\n\t\tconst shape = this.getShapeById(id)\n\t\tif (!shape) return acc\n\t\treturn this.getAncestors(shape, acc)\n\t}\n\n\t/**\n\t * Find the first ancestor matching the given predicate\n\t *\n\t * @example\n\t * ```ts\n\t * const ancestor = editor.findAncestor(myShape)\n\t * ```\n\t *\n\t * @param shape - The shape to check the ancestors for.\n\t *\n\t * @public\n\t */\n\tfindAncestor(shape: TLShape, predicate: (parent: TLShape) => boolean): TLShape | undefined {\n\t\tconst parentId = shape.parentId\n\n\t\tif (isPageId(parentId)) {\n\t\t\treturn undefined\n\t\t}\n\n\t\tconst parent = this.getShapeById(parentId)\n\n\t\tif (parent) {\n\t\t\tif (predicate(parent)) {\n\t\t\t\treturn parent\n\t\t\t}\n\t\t\treturn this.findAncestor(parent, predicate)\n\t\t}\n\n\t\treturn undefined\n\t}\n\n\t/**\n\t * Returns true if the the given shape has the given ancestor.\n\t *\n\t * @param shape - The shape.\n\t * @param ancestorId - The id of the ancestor.\n\t *\n\t * @public\n\t */\n\thasAncestor(shape: TLShape | undefined, ancestorId: TLShapeId): boolean {\n\t\tif (!shape) return false\n\t\tif (shape.parentId === ancestorId) return true\n\t\treturn this.hasAncestor(this.getParentShape(shape), ancestorId)\n\t}\n\n\t/**\n\t * Get the common ancestor of two or more shapes that matches a predicate.\n\t *\n\t * @param shapes - The shapes to check.\n\t * @param predicate - The predicate to match.\n\t */\n\tfindCommonAncestor(\n\t\tshapes: TLShape[],\n\t\tpredicate?: (shape: TLShape) => boolean\n\t): TLShapeId | undefined {\n\t\tif (shapes.length === 0) {\n\t\t\treturn\n\t\t}\n\t\tif (shapes.length === 1) {\n\t\t\tconst parentId = shapes[0].parentId\n\t\t\tif (isPageId(parentId)) {\n\t\t\t\treturn\n\t\t\t}\n\t\t\treturn predicate ? this.findAncestor(shapes[0], predicate)?.id : parentId\n\t\t}\n\n\t\tconst [nodeA, ...others] = shapes\n\t\tlet ancestor = this.getParentShape(nodeA)\n\t\twhile (ancestor) {\n\t\t\t// TODO: this is not ideal, optimize\n\t\t\tif (predicate && !predicate(ancestor)) {\n\t\t\t\tancestor = this.getParentShape(ancestor)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif (others.every((shape) => this.hasAncestor(shape, ancestor!.id))) {\n\t\t\t\treturn ancestor!.id\n\t\t\t}\n\t\t\tancestor = this.getParentShape(ancestor)\n\t\t}\n\t\treturn undefined\n\t}\n\n\t/**\n\t * Check whether a shape or its parent is locked.\n\t *\n\t * @param id - The id of the shape to check.\n\t *\n\t * @public\n\t */\n\tisShapeOrAncestorLocked(shape?: TLShape): boolean {\n\t\tif (shape === undefined) return false\n\t\tif (shape.isLocked) return true\n\t\treturn this.isShapeOrAncestorLocked(this.getParentShape(shape))\n\t}\n\n\t/**\n\t * The common bounds of all of the shapes on the page.\n\t *\n\t * @public\n\t */\n\t@computed get allShapesCommonBounds(): Box2d | null {\n\t\tlet commonBounds = null as Box2d | null\n\n\t\tthis.currentPageShapeIds.forEach((shapeId) => {\n\t\t\tconst bounds = this.getMaskedPageBoundsById(shapeId)\n\t\t\tif (bounds) {\n\t\t\t\tif (commonBounds) {\n\t\t\t\t\tcommonBounds.expand(bounds)\n\t\t\t\t} else {\n\t\t\t\t\tcommonBounds = bounds.clone()\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\n\t\treturn commonBounds\n\t}\n\n\t/**\n\t * Get the corners of a shape in page space.\n\t *\n\t * @example\n\t * ```ts\n\t * const corners = editor.getPageCorners(myShape)\n\t * ```\n\t *\n\t * @param shape - The shape to get the corners for.\n\t *\n\t * @public\n\t */\n\tgetPageCorners(shape: TLShape): Vec2d[] {\n\t\tconst ancestors = this.getAncestors(shape)\n\t\tconst corners = this.getBounds(shape).corners\n\n\t\tconst transform = Matrix2d.Compose(\n\t\t\t...ancestors.flatMap((s) => [Matrix2d.Translate(s.x, s.y), Matrix2d.Rotate(s.rotation)]),\n\t\t\tMatrix2d.Translate(shape.x, shape.y),\n\t\t\tMatrix2d.Rotate(shape.rotation, 0, 0)\n\t\t)\n\n\t\treturn Matrix2d.applyToPoints(transform, corners)\n\t}\n\n\t/**\n\t * Test whether a point (in page space) will will a shape. This method takes into account masks,\n\t * such as when a shape is the child of a frame and is partially clipped by the frame.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.isPointInShape({ x: 100, y: 100 }, myShape)\n\t * ```\n\t *\n\t * @param point - The page point to test.\n\t * @param shape - The shape to test against.\n\t *\n\t * @public\n\t */\n\tisPointInShape(point: VecLike, shape: TLShape): boolean {\n\t\tconst util = this.getShapeUtil(shape)\n\n\t\tconst pageMask = this._pageMaskCache.get(shape.id)\n\n\t\tif (pageMask) {\n\t\t\tconst hit = pointInPolygon(point, pageMask)\n\t\t\tif (!hit) return false\n\t\t}\n\n\t\treturn util.hitTestPoint(shape, this.getPointInShapeSpace(shape, point))\n\t}\n\n\t/**\n\t * Get the shapes, if any, at a given page point.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.getShapesAtPoint({ x: 100, y: 100 })\n\t * ```\n\t *\n\t * @param point - The page point to test.\n\t *\n\t * @public\n\t */\n\tgetShapesAtPoint(point: VecLike): TLShape[] {\n\t\treturn this.shapesArray.filter((shape) => {\n\t\t\t// Check the page mask too\n\t\t\tconst pageMask = this._pageMaskCache.get(shape.id)\n\t\t\tif (pageMask) {\n\t\t\t\treturn pointInPolygon(point, pageMask)\n\t\t\t}\n\n\t\t\t// Otherwise, use the shape's own hit test method\n\t\t\treturn this.getShapeUtil(shape).hitTestPoint(shape, this.getPointInShapeSpace(shape, point))\n\t\t})\n\t}\n\n\t/**\n\t * Convert a point in page space to a point in the local space of a shape. For example, if a\n\t * shape's page point were `{ x: 100, y: 100 }`, a page point at `{ x: 110, y: 110 }` would be at\n\t * `{ x: 10, y: 10 }` in the shape's local space.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.getPointInShapeSpace(myShape, { x: 100, y: 100 })\n\t * ```\n\t *\n\t * @param shape - The shape to get the point in the local space of.\n\t * @param point - The page point to get in the local space of the shape.\n\t *\n\t * @public\n\t */\n\tgetPointInShapeSpace(shape: TLShape, point: VecLike): Vec2d {\n\t\treturn Matrix2d.applyToPoint(Matrix2d.Inverse(this.getPageTransform(shape)!), point)\n\t}\n\n\t/**\n\t * Convert a delta in page space to a point in the local space of a shape. For example, if a\n\t * shape's page point were `{ x: 100, y: 100 }`, a page point at `{ x: 110, y: 110 }` would be at\n\t * `{ x: 10, y: 10 }` in the shape's local space.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.getPointInShapeSpace(myShape.id, { x: 100, y: 100 })\n\t * ```\n\t *\n\t * @param shape - The shape to get the point in the local space of.\n\t * @param point - The page point to get in the local space of the shape.\n\t *\n\t * @public\n\t */\n\tgetPointInParentSpace(shapeId: TLShapeId, point: VecLike): Vec2d {\n\t\tconst shape = this.getShapeById(shapeId)!\n\t\tif (!shape) {\n\t\t\treturn new Vec2d(0, 0)\n\t\t}\n\t\tif (isPageId(shape.parentId)) return Vec2d.From(point)\n\n\t\tconst parentTransform = this.getPageTransformById(shape.parentId)\n\t\tif (!parentTransform) return Vec2d.From(point)\n\n\t\treturn Matrix2d.applyToPoint(Matrix2d.Inverse(parentTransform), point)\n\t}\n\n\t/**\n\t * Convert a delta in page space to a delta in the local space of a shape.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.getDeltaInShapeSpace(myShape, { x: 100, y: 100 })\n\t * ```\n\t *\n\t * @param shape - The shape to get the delta in the local space of.\n\t * @param delta - The page delta to convert.\n\t *\n\t * @public\n\t */\n\tgetDeltaInShapeSpace(shape: TLShape, delta: VecLike): Vec2d {\n\t\tconst pageTransform = this.getPageTransform(shape)\n\t\tif (!pageTransform) return Vec2d.From(delta)\n\t\treturn Vec2d.Rot(delta, -Matrix2d.Decompose(pageTransform).rotation)\n\t}\n\n\t/**\n\t * Convert a delta in page space to a delta in the parent space of a shape.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.getDeltaInParentSpace(myShape, { x: 100, y: 100 })\n\t * ```\n\t *\n\t * @param shape - The shape to get the delta in the parent space of.\n\t * @param delta - The page delta to convert.\n\t *\n\t * @public\n\t */\n\tgetDeltaInParentSpace(shape: TLShape, delta: VecLike): Vec2d {\n\t\tif (isPageId(shape.parentId)) return Vec2d.From(delta)\n\n\t\tconst parent = this.getShapeById(shape.parentId)\n\t\tif (!parent) return Vec2d.From(delta)\n\n\t\treturn this.getDeltaInShapeSpace(parent, delta)\n\t}\n\n\t/**\n\t * For a given set of ids, get a map containing the ids of their parents and the children of those\n\t * parents.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.getParentsMappedToChildren(['id1', 'id2', 'id3'])\n\t * ```\n\t *\n\t * @param ids - The ids to get the parents and children of.\n\t *\n\t * @public\n\t */\n\tgetParentsMappedToChildren(ids: TLShapeId[]) {\n\t\tconst shapes = ids.map((id) => this.store.get(id)!)\n\t\tconst parents = new Map<TLParentId, Set<TLShape>>()\n\t\tshapes.forEach((shape) => {\n\t\t\tif (!parents.has(shape.parentId)) {\n\t\t\t\tparents.set(shape.parentId, new Set())\n\t\t\t}\n\t\t\tparents.get(shape.parentId)?.add(shape)\n\t\t})\n\t\treturn parents\n\t}\n\n\t/**\n\t * The current page bounds of all the selected shapes (Not the same thing as the page bounds of\n\t * the selection bounding box when the selection has been rotated)\n\t *\n\t * @readonly\n\t *\n\t * @public\n\t */\n\t@computed get selectedPageBounds(): Box2d | null {\n\t\tconst {\n\t\t\tpageState: { selectedIds },\n\t\t} = this\n\n\t\tif (selectedIds.length === 0) return null\n\n\t\treturn Box2d.Common(compact(selectedIds.map((id) => this.getPageBoundsById(id))))\n\t}\n\n\t/**\n\t * The rotation of the selection bounding box.\n\t *\n\t * @readonly\n\t * @public\n\t */\n\t@computed get selectionRotation(): number {\n\t\tconst { selectedIds } = this\n\t\tif (selectedIds.length === 0) {\n\t\t\treturn 0\n\t\t}\n\t\tif (selectedIds.length === 1) {\n\t\t\treturn this.getPageRotationById(this.selectedIds[0])\n\t\t}\n\n\t\tconst allRotations = selectedIds.map((id) => this.getPageRotationById(id) % (Math.PI / 2))\n\t\t// if the rotations are all compatible with each other, return the rotation of any one of them\n\t\tif (allRotations.every((rotation) => Math.abs(rotation - allRotations[0]) < Math.PI / 180)) {\n\t\t\treturn this.getPageRotationById(selectedIds[0])\n\t\t}\n\t\treturn 0\n\t}\n\n\t/**\n\t * The bounds of the selection bounding box.\n\t *\n\t * @readonly\n\t * @public\n\t */\n\t@computed get selectionBounds(): Box2d | undefined {\n\t\tconst { selectedIds } = this\n\n\t\tif (selectedIds.length === 0) {\n\t\t\treturn undefined\n\t\t}\n\n\t\tconst { selectionRotation } = this\n\t\tif (selectionRotation === 0) {\n\t\t\treturn this.selectedPageBounds!\n\t\t}\n\n\t\tif (selectedIds.length === 1) {\n\t\t\tconst bounds = this.getBounds(this.getShapeById(selectedIds[0])!).clone()\n\t\t\tbounds.point = Matrix2d.applyToPoint(this.getPageTransformById(selectedIds[0])!, bounds.point)\n\t\t\treturn bounds\n\t\t}\n\n\t\t// need to 'un-rotate' all the outlines of the existing nodes so we can fit them inside a box\n\t\tconst allPoints = this.selectedIds\n\t\t\t.flatMap((id) => {\n\t\t\t\tconst pageTransform = this.getPageTransformById(id)\n\t\t\t\tif (!pageTransform) return []\n\t\t\t\treturn this.getOutlineById(id).map((point) => Matrix2d.applyToPoint(pageTransform, point))\n\t\t\t})\n\t\t\t.map((p) => Vec2d.Rot(p, -selectionRotation))\n\t\tconst box = Box2d.FromPoints(allPoints)\n\t\t// now position box so that it's top-left corner is in the right place\n\t\tbox.point = box.point.rot(selectionRotation)\n\t\treturn box\n\t}\n\n\t/**\n\t * The center of the selection bounding box.\n\t *\n\t * @readonly\n\t * @public\n\t */\n\t@computed get selectionPageCenter() {\n\t\tconst { selectionBounds, selectionRotation } = this\n\t\tif (!selectionBounds) return null\n\t\treturn Vec2d.RotWith(selectionBounds.center, selectionBounds.point, selectionRotation)\n\t}\n\n\t/* ------------------- Statechart ------------------- */\n\n\t/**\n\t * The id of the current selected tool.\n\t *\n\t * @public\n\t */\n\tget currentToolId(): string {\n\t\tconst activeTool = this.root.current.value\n\t\tlet activeToolId = activeTool?.id\n\n\t\t// Often a tool will transition into one of the following select states after the initial pointerdown: 'translating', 'resizing', 'dragging_handle'\n\t\t// It should then supply the tool id to the `onInteractionEnd` property to tell us which tool initially triggered the interaction.\n\t\t// If tool lock mode is on then tldraw will switch to the given tool id.\n\t\t// If tool lock mode is off then tldraw will switch back to the select tool when the interaction ends.\n\n\t\tif (activeToolId === 'select' || activeToolId === 'zoom') {\n\t\t\tconst currentChildState = activeTool?.current.value as any\n\t\t\tactiveToolId = currentChildState?.info?.onInteractionEnd ?? 'select'\n\t\t}\n\n\t\treturn activeToolId ?? 'select'\n\t}\n\n\t/**\n\t * Set the selected tool.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.setSelectedTool('hand')\n\t * editor.setSelectedTool('hand', { date: Date.now() })\n\t * ```\n\t *\n\t * @param id - The id of the tool to select.\n\t * @param info - Arbitrary data to pass along into the transition.\n\t *\n\t * @public\n\t */\n\tsetSelectedTool(id: string, info = {}) {\n\t\tthis.root.transition(id, info)\n\t\treturn this\n\t}\n\n\t/**\n\t * Get a descendant by its path.\n\t *\n\t * @example\n\t * ```ts\n\t * state.getStateDescendant('select')\n\t * state.getStateDescendant('select.brushing')\n\t * ```\n\t *\n\t * @param path - The descendant's path of state ids, separated by periods.\n\t *\n\t * @public\n\t */\n\tgetStateDescendant(path: string): StateNode | undefined {\n\t\tconst ids = path.split('.').reverse()\n\t\tlet state = this.root as StateNode\n\t\twhile (ids.length > 0) {\n\t\t\tconst id = ids.pop()\n\t\t\tif (!id) return state\n\t\t\tconst childState = state.children?.[id]\n\t\t\tif (!childState) return undefined\n\t\t\tstate = childState\n\t\t}\n\t\treturn state\n\t}\n\n\t/**\n\t * Get whether a certain tool (or other state node) is currently active.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.isIn('select')\n\t * editor.isIn('select.brushing')\n\t * ```\n\t *\n\t * @param path - The path of active states, separated by periods.\n\t *\n\t * @public\n\t */\n\tisIn(path: string): boolean {\n\t\tconst ids = path.split('.').reverse()\n\t\tlet state = this.root as StateNode\n\t\twhile (ids.length > 0) {\n\t\t\tconst id = ids.pop()\n\t\t\tif (!id) return true\n\t\t\tconst current = state.current.value\n\t\t\tif (current?.id === id) {\n\t\t\t\tif (ids.length === 0) return true\n\t\t\t\tstate = current\n\t\t\t\tcontinue\n\t\t\t} else return false\n\t\t}\n\t\treturn false\n\t}\n\n\t/**\n\t * Get whether the state node is in any of the given active paths.\n\t *\n\t * @example\n\t * ```ts\n\t * state.isInAny('select', 'erase')\n\t * state.isInAny('select.brushing', 'erase.idle')\n\t * ```\n\t *\n\t * @public\n\t */\n\tisInAny(...paths: string[]): boolean {\n\t\treturn paths.some((path) => this.isIn(path))\n\t}\n\n\t/* --------------------- Inputs --------------------- */\n\n\t/**\n\t * The app's current input state.\n\t *\n\t * @public\n\t */\n\tinputs = {\n\t\t/** The most recent pointer down's position in page space. */\n\t\toriginPagePoint: new Vec2d(),\n\t\t/** The most recent pointer down's position in screen space. */\n\t\toriginScreenPoint: new Vec2d(),\n\t\t/** The previous pointer position in page space. */\n\t\tpreviousPagePoint: new Vec2d(),\n\t\t/** The previous pointer position in screen space. */\n\t\tpreviousScreenPoint: new Vec2d(),\n\t\t/** The most recent pointer position in page space. */\n\t\tcurrentPagePoint: new Vec2d(),\n\t\t/** The most recent pointer position in screen space. */\n\t\tcurrentScreenPoint: new Vec2d(),\n\t\t/** A set containing the currently pressed keys. */\n\t\tkeys: new Set<string>(),\n\t\t/** A set containing the currently pressed buttons. */\n\t\tbuttons: new Set<number>(),\n\t\t/** Whether the input is from a pe. */\n\t\tisPen: false,\n\t\t/** Whether the shift key is currently pressed. */\n\t\tshiftKey: false,\n\t\t/** Whether the control or command key is currently pressed. */\n\t\tctrlKey: false,\n\t\t/** Whether the alt or option key is currently pressed. */\n\t\taltKey: false,\n\t\t/** Whether the user is dragging. */\n\t\tisDragging: false,\n\t\t/** Whether the user is pointing. */\n\t\tisPointing: false,\n\t\t/** Whether the user is pinching. */\n\t\tisPinching: false,\n\t\t/** Whether the user is editing. */\n\t\tisEditing: false,\n\t\t/** Whether the user is panning. */\n\t\tisPanning: false,\n\t\t/** Velocity of mouse pointer, in pixels per millisecond */\n\t\tpointerVelocity: new Vec2d(),\n\t}\n\n\t/**\n\t * Update the input points from a pointer or pinch event.\n\t *\n\t * @param info - The event info.\n\t */\n\tprivate _updateInputsFromEvent(info: TLPointerEventInfo | TLPinchEventInfo) {\n\t\tconst { previousScreenPoint, previousPagePoint, currentScreenPoint, currentPagePoint } =\n\t\t\tthis.inputs\n\n\t\tconst { screenBounds } = this.store.unsafeGetWithoutCapture(TLINSTANCE_ID)!\n\t\tconst { x: sx, y: sy, z: sz } = info.point\n\t\tconst { x: cx, y: cy, z: cz } = this.camera\n\n\t\tpreviousScreenPoint.setTo(currentScreenPoint)\n\t\tpreviousPagePoint.setTo(currentPagePoint)\n\n\t\tcurrentScreenPoint.set(sx, sy)\n\t\tcurrentPagePoint.set(\n\t\t\t(sx - screenBounds.x) / cz - cx,\n\t\t\t(sy - screenBounds.y) / cz - cy,\n\t\t\tsz ?? 0.5\n\t\t)\n\n\t\tthis.inputs.isPen = info.type === 'pointer' && info.isPen\n\n\t\t// Reset velocity on pointer down\n\t\tif (info.name === 'pointer_down') {\n\t\t\tthis.inputs.pointerVelocity.set(0, 0)\n\t\t}\n\n\t\t// todo: We only have to do this if there are multiple users in the document\n\t\tthis.store.put([\n\t\t\t{\n\t\t\t\tid: TLPOINTER_ID,\n\t\t\t\ttypeName: 'pointer',\n\t\t\t\tx: currentPagePoint.x,\n\t\t\t\ty: currentPagePoint.y,\n\t\t\t\tlastActivityTimestamp:\n\t\t\t\t\t// If our pointer moved only because we're following some other user, then don't\n\t\t\t\t\t// update our last activity timestamp; otherwise, update it to the current timestamp.\n\t\t\t\t\tinfo.type === 'pointer' && info.pointerId === INTERNAL_POINTER_IDS.CAMERA_MOVE\n\t\t\t\t\t\t? this.store.get(TLPOINTER_ID)?.lastActivityTimestamp ?? Date.now()\n\t\t\t\t\t\t: Date.now(),\n\t\t\t},\n\t\t])\n\t}\n\n\t/* --------------------- Events --------------------- */\n\n\t/**\n\t * A manager for recording multiple click events.\n\t *\n\t * @internal\n\t */\n\tprotected _clickManager = new ClickManager(this)\n\n\t/**\n\t * Prevent a double click event from firing the next time the user clicks\n\t *\n\t * @public\n\t */\n\tcancelDoubleClick() {\n\t\tthis._clickManager.cancelDoubleClickTimeout()\n\t}\n\n\t/**\n\t * The previous cursor. Used for restoring the cursor after pan events.\n\t *\n\t * @internal\n\t */\n\tprivate _prevCursor: TLCursorType = 'default'\n\n\t/** @internal */\n\tprivate _shiftKeyTimeout = -1 as any\n\n\t/** @internal */\n\tprivate _setShiftKeyTimeout = () => {\n\t\tthis.inputs.shiftKey = false\n\t\tthis.dispatch({\n\t\t\ttype: 'keyboard',\n\t\t\tname: 'key_up',\n\t\t\tkey: 'Shift',\n\t\t\tshiftKey: this.inputs.shiftKey,\n\t\t\tctrlKey: this.inputs.ctrlKey,\n\t\t\taltKey: this.inputs.altKey,\n\t\t\tcode: 'ShiftLeft',\n\t\t})\n\t}\n\n\t/** @internal */\n\tprivate _altKeyTimeout = -1 as any\n\n\t/** @internal */\n\tprivate _setAltKeyTimeout = () => {\n\t\tthis.inputs.altKey = false\n\t\tthis.dispatch({\n\t\t\ttype: 'keyboard',\n\t\t\tname: 'key_up',\n\t\t\tkey: 'Alt',\n\t\t\tshiftKey: this.inputs.shiftKey,\n\t\t\tctrlKey: this.inputs.ctrlKey,\n\t\t\taltKey: this.inputs.altKey,\n\t\t\tcode: 'AltLeft',\n\t\t})\n\t}\n\n\t/** @internal */\n\tprivate _ctrlKeyTimeout = -1 as any\n\n\t/** @internal */\n\tprivate _setCtrlKeyTimeout = () => {\n\t\tthis.inputs.ctrlKey = false\n\t\tthis.dispatch({\n\t\t\ttype: 'keyboard',\n\t\t\tname: 'key_up',\n\t\t\tkey: 'Ctrl',\n\t\t\tshiftKey: this.inputs.shiftKey,\n\t\t\tctrlKey: this.inputs.ctrlKey,\n\t\t\taltKey: this.inputs.altKey,\n\t\t\tcode: 'ControlLeft',\n\t\t})\n\t}\n\n\t/** @internal */\n\tprivate _restoreToolId = 'select'\n\n\t/** @internal */\n\tprivate _pinchStart = 1\n\n\t/** @internal */\n\tprivate _didPinch = false\n\n\t/** @internal */\n\tprivate _selectedIdsAtPointerDown: TLShapeId[] = []\n\n\t/** @internal */\n\tcapturedPointerId: number | null = null\n\n\t/**\n\t * Dispatch an event to the editor.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.dispatch(myPointerEvent)\n\t * ```\n\t *\n\t * @param info - The event info.\n\t *\n\t * @public\n\t */\n\tdispatch(info: TLEventInfo): this {\n\t\t// prevent us from spamming similar event errors if we're crashed.\n\t\t// todo: replace with new readonly mode?\n\t\tif (this.crashingError) return this\n\n\t\tconst { inputs } = this\n\t\tconst { type } = info\n\n\t\tthis.batch(() => {\n\t\t\tif (info.type === 'misc') {\n\t\t\t\t// stop panning if the interaction is cancelled or completed\n\t\t\t\tif (info.name === 'cancel' || info.name === 'complete') {\n\t\t\t\t\tthis.inputs.isDragging = false\n\n\t\t\t\t\tif (this.inputs.isPanning) {\n\t\t\t\t\t\tthis.inputs.isPanning = false\n\t\t\t\t\t\tthis.setCursor({\n\t\t\t\t\t\t\ttype: this._prevCursor,\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis.root.handleEvent(info)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif (info.shiftKey) {\n\t\t\t\tclearInterval(this._shiftKeyTimeout)\n\t\t\t\tthis._shiftKeyTimeout = -1\n\t\t\t\tinputs.shiftKey = true\n\t\t\t} else if (!info.shiftKey && inputs.shiftKey && this._shiftKeyTimeout === -1) {\n\t\t\t\tthis._shiftKeyTimeout = setTimeout(this._setShiftKeyTimeout, 150)\n\t\t\t}\n\n\t\t\tif (info.altKey) {\n\t\t\t\tclearInterval(this._altKeyTimeout)\n\t\t\t\tthis._altKeyTimeout = -1\n\t\t\t\tinputs.altKey = true\n\t\t\t} else if (!info.altKey && inputs.altKey && this._altKeyTimeout === -1) {\n\t\t\t\tthis._altKeyTimeout = setTimeout(this._setAltKeyTimeout, 150)\n\t\t\t}\n\n\t\t\tif (info.ctrlKey) {\n\t\t\t\tclearInterval(this._ctrlKeyTimeout)\n\t\t\t\tthis._ctrlKeyTimeout = -1\n\t\t\t\tinputs.ctrlKey = true /** @internal */ /** @internal */ /** @internal */\n\t\t\t} else if (!info.ctrlKey && inputs.ctrlKey && this._ctrlKeyTimeout === -1) {\n\t\t\t\tthis._ctrlKeyTimeout = setTimeout(this._setCtrlKeyTimeout, 150)\n\t\t\t}\n\n\t\t\tconst { originPagePoint, originScreenPoint, currentPagePoint, currentScreenPoint } = inputs\n\n\t\t\tif (!inputs.isPointing) {\n\t\t\t\tinputs.isDragging = false\n\t\t\t}\n\n\t\t\tswitch (type) {\n\t\t\t\tcase 'pinch': {\n\t\t\t\t\tif (!this.canMoveCamera) return\n\t\t\t\t\tthis._updateInputsFromEvent(info)\n\n\t\t\t\t\tswitch (info.name) {\n\t\t\t\t\t\tcase 'pinch_start': {\n\t\t\t\t\t\t\tif (inputs.isPinching) return\n\n\t\t\t\t\t\t\tif (!inputs.isEditing) {\n\t\t\t\t\t\t\t\tthis._pinchStart = this.camera.z\n\t\t\t\t\t\t\t\tif (!this._selectedIdsAtPointerDown.length) {\n\t\t\t\t\t\t\t\t\tthis._selectedIdsAtPointerDown = this.selectedIds.slice()\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tthis._didPinch = true\n\n\t\t\t\t\t\t\t\tinputs.isPinching = true\n\n\t\t\t\t\t\t\t\tthis.interrupt()\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn // Stop here!\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 'pinch': {\n\t\t\t\t\t\t\tif (!inputs.isPinching) return\n\n\t\t\t\t\t\t\tconst {\n\t\t\t\t\t\t\t\tpoint: { x, y, z = 1 },\n\t\t\t\t\t\t\t\tdelta: { x: dx, y: dy },\n\t\t\t\t\t\t\t} = info\n\n\t\t\t\t\t\t\tconst {\n\t\t\t\t\t\t\t\tcamera: { x: cx, y: cy, z: cz },\n\t\t\t\t\t\t\t} = this\n\n\t\t\t\t\t\t\tconst zoom = Math.min(MAX_ZOOM, Math.max(MIN_ZOOM, z))\n\n\t\t\t\t\t\t\tthis.setCamera(\n\t\t\t\t\t\t\t\tcx + dx / cz - x / cz + x / zoom,\n\t\t\t\t\t\t\t\tcy + dy / cz - y / cz + y / zoom,\n\t\t\t\t\t\t\t\tzoom\n\t\t\t\t\t\t\t)\n\n\t\t\t\t\t\t\treturn // Stop here!\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 'pinch_end': {\n\t\t\t\t\t\t\tif (!inputs.isPinching) return this\n\n\t\t\t\t\t\t\tinputs.isPinching = false\n\t\t\t\t\t\t\tconst { _selectedIdsAtPointerDown } = this\n\t\t\t\t\t\t\tthis.setSelectedIds(this._selectedIdsAtPointerDown, true)\n\t\t\t\t\t\t\tthis._selectedIdsAtPointerDown = []\n\n\t\t\t\t\t\t\tconst {\n\t\t\t\t\t\t\t\tcamera: { x: cx, y: cy, z: cz },\n\t\t\t\t\t\t\t} = this\n\n\t\t\t\t\t\t\tlet zoom: number | undefined\n\n\t\t\t\t\t\t\tif (cz > 0.9 && cz < 1.05) {\n\t\t\t\t\t\t\t\tzoom = 1\n\t\t\t\t\t\t\t} else if (cz > 0.49 && cz < 0.505) {\n\t\t\t\t\t\t\t\tzoom = 0.5\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (cz > this._pinchStart - 0.1 && cz < this._pinchStart + 0.05) {\n\t\t\t\t\t\t\t\tzoom = this._pinchStart\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (zoom !== undefined) {\n\t\t\t\t\t\t\t\tconst { x, y } = this.viewportScreenCenter\n\t\t\t\t\t\t\t\tthis.animateCamera(\n\t\t\t\t\t\t\t\t\tcx + (x / zoom - x) - (x / cz - x),\n\t\t\t\t\t\t\t\t\tcy + (y / zoom - y) - (y / cz - y),\n\t\t\t\t\t\t\t\t\tzoom,\n\t\t\t\t\t\t\t\t\t{ duration: 100 }\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (this._didPinch) {\n\t\t\t\t\t\t\t\tthis._didPinch = false\n\t\t\t\t\t\t\t\trequestAnimationFrame(() => {\n\t\t\t\t\t\t\t\t\tif (!this._didPinch) {\n\t\t\t\t\t\t\t\t\t\tthis.setSelectedIds(_selectedIdsAtPointerDown, true)\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn // Stop here!\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcase 'wheel': {\n\t\t\t\t\tif (!this.canMoveCamera) return\n\n\t\t\t\t\tif (this.isMenuOpen) {\n\t\t\t\t\t\t// noop\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (inputs.ctrlKey) {\n\t\t\t\t\t\t\t// todo: Start or update the zoom end interval\n\n\t\t\t\t\t\t\t// If the alt or ctrl keys are pressed,\n\t\t\t\t\t\t\t// zoom or pan the camera and then return.\n\t\t\t\t\t\t\tconst { x, y } = this.inputs.currentScreenPoint\n\t\t\t\t\t\t\tconst { x: cx, y: cy, z: cz } = this.camera\n\n\t\t\t\t\t\t\tconst zoom = Math.min(MAX_ZOOM, Math.max(MIN_ZOOM, cz + (info.delta.z ?? 0) * cz))\n\n\t\t\t\t\t\t\tthis.setCamera(\n\t\t\t\t\t\t\t\tcx + (x / zoom - x) - (x / cz - x),\n\t\t\t\t\t\t\t\tcy + (y / zoom - y) - (y / cz - y),\n\t\t\t\t\t\t\t\tzoom\n\t\t\t\t\t\t\t)\n\n\t\t\t\t\t\t\t// We want to return here because none of the states in our\n\t\t\t\t\t\t\t// statechart should respond to this event (a camera zoom)\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Update the camera here, which will dispatch a pointer move...\n\t\t\t\t\t\t// this will also update the pointer position, etc\n\t\t\t\t\t\tthis.pan(info.delta.x, info.delta.y)\n\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t!inputs.isDragging &&\n\t\t\t\t\t\t\tinputs.isPointing &&\n\t\t\t\t\t\t\toriginPagePoint.dist(currentPagePoint) >\n\t\t\t\t\t\t\t\t(this.isCoarsePointer ? COARSE_DRAG_DISTANCE : DRAG_DISTANCE) / this.zoomLevel\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tinputs.isDragging = true\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tcase 'pointer': {\n\t\t\t\t\t// If we're pinching, return\n\t\t\t\t\tif (inputs.isPinching) return\n\n\t\t\t\t\tthis._updateInputsFromEvent(info)\n\n\t\t\t\t\tconst { isPen } = info\n\n\t\t\t\t\tswitch (info.name) {\n\t\t\t\t\t\tcase 'pointer_down': {\n\t\t\t\t\t\t\tthis._selectedIdsAtPointerDown = this.selectedIds.slice()\n\n\t\t\t\t\t\t\t// Firefox bug fix...\n\t\t\t\t\t\t\t// If it's a left-mouse-click, we store the pointer id for later user\n\t\t\t\t\t\t\tif (info.button === 0) {\n\t\t\t\t\t\t\t\tthis.capturedPointerId = info.pointerId\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Add the button from the buttons set\n\t\t\t\t\t\t\tinputs.buttons.add(info.button)\n\n\t\t\t\t\t\t\tinputs.isPointing = true\n\t\t\t\t\t\t\tinputs.isDragging = false\n\n\t\t\t\t\t\t\tif (this.isPenMode) {\n\t\t\t\t\t\t\t\tif (!isPen) {\n\t\t\t\t\t\t\t\t\t// decrement the remaining taps before exiting pen mode\n\t\t\t\t\t\t\t\t\tthis._touchEventsRemainingBeforeExitingPenMode--\n\t\t\t\t\t\t\t\t\tif (this._touchEventsRemainingBeforeExitingPenMode === 0) {\n\t\t\t\t\t\t\t\t\t\tthis.setPenMode(false)\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t// reset the remaining taps before exiting pen mode\n\t\t\t\t\t\t\t\t\tthis._touchEventsRemainingBeforeExitingPenMode = 3\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (isPen) {\n\t\t\t\t\t\t\t\t\tthis.setPenMode(true)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (info.button === 5) {\n\t\t\t\t\t\t\t\t// Eraser button activates eraser\n\t\t\t\t\t\t\t\tthis._restoreToolId = this.currentToolId\n\t\t\t\t\t\t\t\tthis.complete()\n\t\t\t\t\t\t\t\tthis.setSelectedTool('eraser')\n\t\t\t\t\t\t\t} else if (info.button === 1) {\n\t\t\t\t\t\t\t\t// Middle mouse pan activates panning\n\t\t\t\t\t\t\t\tif (!this.inputs.isPanning) {\n\t\t\t\t\t\t\t\t\tthis._prevCursor = this.instanceState.cursor.type\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tthis.inputs.isPanning = true\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (this.inputs.isPanning) {\n\t\t\t\t\t\t\t\tthis.stopCameraAnimation()\n\t\t\t\t\t\t\t\tthis.setCursor({\n\t\t\t\t\t\t\t\t\ttype: 'grabbing',\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\treturn this\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\toriginScreenPoint.setTo(currentScreenPoint)\n\t\t\t\t\t\t\toriginPagePoint.setTo(currentPagePoint)\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 'pointer_move': {\n\t\t\t\t\t\t\t// If the user is in pen mode, but the pointer is not a pen, stop here.\n\t\t\t\t\t\t\tif (!isPen && this.isPenMode) {\n\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (this.inputs.isPanning && this.inputs.isPointing) {\n\t\t\t\t\t\t\t\t// Handle panning\n\t\t\t\t\t\t\t\tconst { currentScreenPoint, previousScreenPoint } = this.inputs\n\t\t\t\t\t\t\t\tconst delta = Vec2d.Sub(currentScreenPoint, previousScreenPoint)\n\t\t\t\t\t\t\t\tthis.pan(delta.x, delta.y)\n\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t!inputs.isDragging &&\n\t\t\t\t\t\t\t\tinputs.isPointing &&\n\t\t\t\t\t\t\t\toriginPagePoint.dist(currentPagePoint) >\n\t\t\t\t\t\t\t\t\t(this.isCoarsePointer ? COARSE_DRAG_DISTANCE : DRAG_DISTANCE) / this.zoomLevel\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tinputs.isDragging = true\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 'pointer_up': {\n\t\t\t\t\t\t\t// Remove the button from the buttons set\n\t\t\t\t\t\t\tinputs.buttons.delete(info.button)\n\n\t\t\t\t\t\t\tinputs.isPointing = false\n\t\t\t\t\t\t\tinputs.isDragging = false\n\n\t\t\t\t\t\t\tif (this.isMenuOpen) {\n\t\t\t\t\t\t\t\t// Suppressing pointerup here as <ContextMenu/> doesn't seem to do what we what here.\n\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (!isPen && this.isPenMode) {\n\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Firefox bug fix...\n\t\t\t\t\t\t\t// If it's the same pointer that we stored earlier...\n\t\t\t\t\t\t\t// ... then it's probably still a left-mouse-click!\n\t\t\t\t\t\t\tif (this.capturedPointerId === info.pointerId) {\n\t\t\t\t\t\t\t\tthis.capturedPointerId = null\n\t\t\t\t\t\t\t\tinfo.button = 0\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (inputs.isPanning) {\n\t\t\t\t\t\t\t\tif (info.button === 1) {\n\t\t\t\t\t\t\t\t\tif (!this.inputs.keys.has(' ')) {\n\t\t\t\t\t\t\t\t\t\tinputs.isPanning = false\n\n\t\t\t\t\t\t\t\t\t\tthis.slideCamera({\n\t\t\t\t\t\t\t\t\t\t\tspeed: Math.min(2, this.inputs.pointerVelocity.len()),\n\t\t\t\t\t\t\t\t\t\t\tdirection: this.inputs.pointerVelocity,\n\t\t\t\t\t\t\t\t\t\t\tfriction: HAND_TOOL_FRICTION,\n\t\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t\t\tthis.setCursor({\n\t\t\t\t\t\t\t\t\t\t\ttype: this._prevCursor,\n\t\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tthis.slideCamera({\n\t\t\t\t\t\t\t\t\t\t\tspeed: Math.min(2, this.inputs.pointerVelocity.len()),\n\t\t\t\t\t\t\t\t\t\t\tdirection: this.inputs.pointerVelocity,\n\t\t\t\t\t\t\t\t\t\t\tfriction: HAND_TOOL_FRICTION,\n\t\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t\t\tthis.setCursor({\n\t\t\t\t\t\t\t\t\t\t\ttype: 'grab',\n\t\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else if (info.button === 0) {\n\t\t\t\t\t\t\t\t\tthis.slideCamera({\n\t\t\t\t\t\t\t\t\t\tspeed: Math.min(2, this.inputs.pointerVelocity.len()),\n\t\t\t\t\t\t\t\t\t\tdirection: this.inputs.pointerVelocity,\n\t\t\t\t\t\t\t\t\t\tfriction: HAND_TOOL_FRICTION,\n\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t\tthis.setCursor({\n\t\t\t\t\t\t\t\t\t\ttype: 'grab',\n\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (info.button === 5) {\n\t\t\t\t\t\t\t\t\t// Eraser button activates eraser\n\t\t\t\t\t\t\t\t\tthis.complete()\n\t\t\t\t\t\t\t\t\tthis.setSelectedTool(this._restoreToolId)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tcase 'keyboard': {\n\t\t\t\t\t// please, please\n\t\t\t\t\tif (info.key === 'ShiftRight') info.key = 'ShiftLeft'\n\t\t\t\t\tif (info.key === 'AltRight') info.key = 'AltLeft'\n\t\t\t\t\tif (info.code === 'ControlRight') info.code = 'ControlLeft'\n\n\t\t\t\t\tswitch (info.name) {\n\t\t\t\t\t\tcase 'key_down': {\n\t\t\t\t\t\t\t// Add the key from the keys set\n\t\t\t\t\t\t\tinputs.keys.add(info.code)\n\n\t\t\t\t\t\t\t// If the space key is pressed (but meta / control isn't!) activate panning\n\t\t\t\t\t\t\tif (!info.ctrlKey && info.code === 'Space') {\n\t\t\t\t\t\t\t\tif (!this.inputs.isPanning) {\n\t\t\t\t\t\t\t\t\tthis._prevCursor = this.instanceState.cursor.type\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tthis.inputs.isPanning = true\n\t\t\t\t\t\t\t\tthis.setCursor({\n\t\t\t\t\t\t\t\t\ttype: this.inputs.isPointing ? 'grabbing' : 'grab',\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 'key_up': {\n\t\t\t\t\t\t\t// Remove the key from the keys set\n\t\t\t\t\t\t\tinputs.keys.delete(info.code)\n\n\t\t\t\t\t\t\tif (info.code === 'Space' && !this.inputs.buttons.has(1)) {\n\t\t\t\t\t\t\t\tthis.inputs.isPanning = false\n\t\t\t\t\t\t\t\tthis.setCursor({\n\t\t\t\t\t\t\t\t\ttype: this._prevCursor,\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 'key_repeat': {\n\t\t\t\t\t\t\t// noop\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Correct the info name for right / middle clicks\n\t\t\tif (info.type === 'pointer') {\n\t\t\t\tif (info.button === 1) {\n\t\t\t\t\tinfo.name = 'middle_click'\n\t\t\t\t} else if (info.button === 2) {\n\t\t\t\t\tinfo.name = 'right_click'\n\t\t\t\t}\n\n\t\t\t\t// If a pointer event, send the event to the click manager.\n\t\t\t\tif (info.isPen === this.isPenMode) {\n\t\t\t\t\tswitch (info.name) {\n\t\t\t\t\t\tcase 'pointer_down': {\n\t\t\t\t\t\t\tconst otherEvent = this._clickManager.transformPointerDownEvent(info)\n\t\t\t\t\t\t\tif (info.name !== otherEvent.name) {\n\t\t\t\t\t\t\t\tthis.root.handleEvent(info)\n\t\t\t\t\t\t\t\tthis.emit('event', info)\n\t\t\t\t\t\t\t\tthis.root.handleEvent(otherEvent)\n\t\t\t\t\t\t\t\tthis.emit('event', otherEvent)\n\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 'pointer_up': {\n\t\t\t\t\t\t\tconst otherEvent = this._clickManager.transformPointerUpEvent(info)\n\t\t\t\t\t\t\tif (info.name !== otherEvent.name) {\n\t\t\t\t\t\t\t\tthis.root.handleEvent(info)\n\t\t\t\t\t\t\t\tthis.emit('event', info)\n\t\t\t\t\t\t\t\tthis.root.handleEvent(otherEvent)\n\t\t\t\t\t\t\t\tthis.emit('event', otherEvent)\n\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 'pointer_move': {\n\t\t\t\t\t\t\tthis._clickManager.handleMove()\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Send the event to the statechart. It will be handled by all\n\t\t\t// active states, starting at the root.\n\t\t\tthis.root.handleEvent(info)\n\t\t\tthis.emit('event', info)\n\t\t})\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Replace the store's contents with the given records.\n\t *\n\t * @param records - The records to replace the store's contents with.\n\t */\n\treplaceStoreContentsWithRecordsForOtherDocument(records: TLRecord[]) {\n\t\ttransact(() => {\n\t\t\tthis.store.clear()\n\t\t\tconst [shapes, nonShapes] = partition(records, (record) => record.typeName === 'shape')\n\t\t\tthis.store.put(nonShapes, 'initialize')\n\t\t\tthis.store.ensureStoreIsUsable()\n\t\t\tthis.store.put(shapes, 'initialize')\n\t\t\tthis.history.clear()\n\t\t\tthis.updateViewportScreenBounds()\n\t\t\tthis.updateRenderingBounds()\n\n\t\t\tconst bounds = this.allShapesCommonBounds\n\t\t\tif (bounds) {\n\t\t\t\tthis.zoomToBounds(bounds.minX, bounds.minY, bounds.width, bounds.height, 1)\n\t\t\t}\n\t\t})\n\t}\n\n\t/**\n\t * Get content that can be exported for the given shape ids.\n\t *\n\t * @param ids - The ids of the shapes to get content for. Defaults to the selected shape ids.\n\t *\n\t * @returns The exported content.\n\t *\n\t * @public\n\t */\n\tgetContent(ids: TLShapeId[] = this.selectedIds): TLContent | undefined {\n\t\tif (!ids) return\n\t\tif (ids.length === 0) return\n\n\t\tconst pageTransforms: Record<string, Matrix2dModel> = {}\n\n\t\tlet shapes = dedupe(\n\t\t\tids\n\t\t\t\t.map((id) => this.getShapeById(id)!)\n\t\t\t\t.sort(sortByIndex)\n\t\t\t\t.flatMap((shape) => {\n\t\t\t\t\tconst allShapes = [shape]\n\t\t\t\t\tthis.visitDescendants(shape.id, (descendant) => {\n\t\t\t\t\t\tallShapes.push(this.getShapeById(descendant)!)\n\t\t\t\t\t})\n\t\t\t\t\treturn allShapes\n\t\t\t\t})\n\t\t)\n\n\t\tshapes = shapes.map((shape) => {\n\t\t\tpageTransforms[shape.id] = this.getPageTransformById(shape.id)!\n\n\t\t\tshape = structuredClone(shape) as typeof shape\n\n\t\t\tif (this.isShapeOfType(shape, ArrowShapeUtil)) {\n\t\t\t\tconst startBindingId =\n\t\t\t\t\tshape.props.start.type === 'binding' ? shape.props.start.boundShapeId : undefined\n\n\t\t\t\tconst endBindingId =\n\t\t\t\t\tshape.props.end.type === 'binding' ? shape.props.end.boundShapeId : undefined\n\n\t\t\t\tconst info = this.getShapeUtil(ArrowShapeUtil).getArrowInfo(shape)\n\n\t\t\t\tif (shape.props.start.type === 'binding') {\n\t\t\t\t\tif (!shapes.some((s) => s.id === startBindingId)) {\n\t\t\t\t\t\t// Uh oh, the arrow's bound-to shape isn't among the shapes\n\t\t\t\t\t\t// that we're getting the content for. We should try to adjust\n\t\t\t\t\t\t// the arrow so that it appears in the place it would be\n\t\t\t\t\t\tif (info?.isValid) {\n\t\t\t\t\t\t\tconst { x, y } = info.start.point\n\t\t\t\t\t\t\tshape.props.start = {\n\t\t\t\t\t\t\t\ttype: 'point',\n\t\t\t\t\t\t\t\tx,\n\t\t\t\t\t\t\t\ty,\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst { start } = getArrowTerminalsInArrowSpace(this, shape)\n\t\t\t\t\t\t\tshape.props.start = {\n\t\t\t\t\t\t\t\ttype: 'point',\n\t\t\t\t\t\t\t\tx: start.x,\n\t\t\t\t\t\t\t\ty: start.y,\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (shape.props.end.type === 'binding') {\n\t\t\t\t\tif (!shapes.some((s) => s.id === endBindingId)) {\n\t\t\t\t\t\tif (info?.isValid) {\n\t\t\t\t\t\t\tconst { x, y } = info.end.point\n\t\t\t\t\t\t\tshape.props.end = {\n\t\t\t\t\t\t\t\ttype: 'point',\n\t\t\t\t\t\t\t\tx,\n\t\t\t\t\t\t\t\ty,\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst { end } = getArrowTerminalsInArrowSpace(this, shape)\n\t\t\t\t\t\t\tshape.props.end = {\n\t\t\t\t\t\t\t\ttype: 'point',\n\t\t\t\t\t\t\t\tx: end.x,\n\t\t\t\t\t\t\t\ty: end.y,\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst infoAfter = getIsArrowStraight(shape)\n\t\t\t\t\t? getStraightArrowInfo(this, shape)\n\t\t\t\t\t: getCurvedArrowInfo(this, shape)\n\n\t\t\t\tif (info?.isValid && infoAfter?.isValid && !getIsArrowStraight(shape)) {\n\t\t\t\t\tconst mpA = Vec2d.Med(info.start.handle, info.end.handle)\n\t\t\t\t\tconst distA = Vec2d.Dist(info.middle, mpA)\n\t\t\t\t\tconst distB = Vec2d.Dist(infoAfter.middle, mpA)\n\t\t\t\t\tif (shape.props.bend < 0) {\n\t\t\t\t\t\tshape.props.bend += distB - distA\n\t\t\t\t\t} else {\n\t\t\t\t\t\tshape.props.bend -= distB - distA\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn shape\n\t\t\t}\n\n\t\t\treturn shape\n\t\t})\n\n\t\tconst rootShapeIds: TLShapeId[] = []\n\n\t\tshapes.forEach((shape) => {\n\t\t\tif (shapes.find((s) => s.id === shape.parentId) === undefined) {\n\t\t\t\t// Need to get page point and rotation of the shape because shapes in\n\t\t\t\t// groups use local position/rotation\n\n\t\t\t\tconst pagePoint = this.getPagePointById(shape.id)!\n\t\t\t\tconst pageRotation = this.getPageRotationById(shape.id)!\n\t\t\t\tshape.x = pagePoint.x\n\t\t\t\tshape.y = pagePoint.y\n\t\t\t\tshape.rotation = pageRotation\n\t\t\t\tshape.parentId = this.currentPageId\n\n\t\t\t\trootShapeIds.push(shape.id)\n\t\t\t}\n\t\t})\n\n\t\tconst assetsSet = new Set<TLAssetId>()\n\n\t\tshapes.forEach((shape) => {\n\t\t\tif ('assetId' in shape.props) {\n\t\t\t\tif (shape.props.assetId !== null) {\n\t\t\t\t\tassetsSet.add(shape.props.assetId)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\n\t\treturn {\n\t\t\tshapes,\n\t\t\trootShapeIds,\n\t\t\tschema: this.store.schema.serialize(),\n\t\t\tassets: compact(Array.from(assetsSet).map((id) => this.getAssetById(id))),\n\t\t}\n\t}\n\n\t/* --------------------- Commands --------------------- */\n\n\t/**\n\t * Place content into the editor.\n\t *\n\t * @param content - The content.\n\t * @param options - Options for placing the content.\n\t *\n\t * @public\n\t */\n\tputContent(\n\t\tcontent: TLContent,\n\t\toptions: {\n\t\t\tpoint?: VecLike\n\t\t\tselect?: boolean\n\t\t\tpreservePosition?: boolean\n\t\t\tpreserveIds?: boolean\n\t\t} = {}\n\t): this {\n\t\tif (this.isReadOnly) return this\n\n\t\tif (!content.schema) {\n\t\t\tthrow Error('Could not put content: content is missing a schema.')\n\t\t}\n\n\t\tconst { select = false, preserveIds = false, preservePosition = false } = options\n\t\tlet { point = undefined } = options\n\n\t\t// decide on a parent for the put shapes; if the parent is among the put shapes(?) then use its parent\n\n\t\tconst { currentPageId } = this\n\t\tconst { assets, shapes, rootShapeIds } = content\n\n\t\tconst idMap = new Map<any, TLShapeId>(shapes.map((shape) => [shape.id, createShapeId()]))\n\n\t\t// By default, the paste parent will be the current page.\n\t\tlet pasteParentId = this.currentPageId as TLPageId | TLShapeId\n\t\tlet lowestDepth = Infinity\n\t\tlet lowestAncestors: TLShape[] = []\n\n\t\t// Among the selected shapes, find the shape with the fewest ancestors and use its first ancestor.\n\t\tfor (const shape of this.selectedShapes) {\n\t\t\tif (lowestDepth === 0) break\n\n\t\t\tconst isFrame = this.isShapeOfType(shape, FrameShapeUtil)\n\t\t\tconst ancestors = this.getAncestors(shape)\n\t\t\tif (isFrame) ancestors.push(shape)\n\n\t\t\tconst depth = isFrame ? ancestors.length + 1 : ancestors.length\n\n\t\t\tif (depth < lowestDepth) {\n\t\t\t\tlowestDepth = depth\n\t\t\t\tlowestAncestors = ancestors\n\t\t\t\tpasteParentId = isFrame ? shape.id : shape.parentId\n\t\t\t} else if (depth === lowestDepth) {\n\t\t\t\tif (lowestAncestors.length !== ancestors.length) {\n\t\t\t\t\tthrow Error(`Ancestors: ${lowestAncestors.length} !== ${ancestors.length}`)\n\t\t\t\t}\n\n\t\t\t\tif (lowestAncestors.length === 0) {\n\t\t\t\t\tpasteParentId = currentPageId\n\t\t\t\t\tbreak\n\t\t\t\t} else {\n\t\t\t\t\tpasteParentId = currentPageId\n\t\t\t\t\tfor (let i = 0; i < lowestAncestors.length; i++) {\n\t\t\t\t\t\tif (ancestors[i] !== lowestAncestors[i]) break\n\t\t\t\t\t\tpasteParentId = ancestors[i].id\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlet isDuplicating = false\n\n\t\tif (!isPageId(pasteParentId)) {\n\t\t\tconst parent = this.getShapeById(pasteParentId)\n\t\t\tif (parent) {\n\t\t\t\tif (!this.viewportPageBounds.includes(this.getPageBounds(parent)!)) {\n\t\t\t\t\tpasteParentId = currentPageId\n\t\t\t\t} else {\n\t\t\t\t\tif (rootShapeIds.length === 1) {\n\t\t\t\t\t\tconst rootShape = shapes.find((s) => s.id === rootShapeIds[0])!\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tthis.isShapeOfType(parent, FrameShapeUtil) &&\n\t\t\t\t\t\t\tthis.isShapeOfType(rootShape, FrameShapeUtil) &&\n\t\t\t\t\t\t\trootShape.props.w === parent?.props.w &&\n\t\t\t\t\t\t\trootShape.props.h === parent?.props.h\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tisDuplicating = true\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpasteParentId = currentPageId\n\t\t\t}\n\t\t}\n\n\t\tif (!isDuplicating) {\n\t\t\tisDuplicating = idMap.has(pasteParentId)\n\t\t}\n\n\t\tif (isDuplicating) {\n\t\t\tpasteParentId = this.getShapeById(pasteParentId)!.parentId\n\t\t}\n\n\t\tlet index = this.getHighestIndexForParent(pasteParentId)\n\n\t\tconst rootShapes: TLShape[] = []\n\n\t\tconst newShapes: TLShape[] = shapes.map((shape): TLShape => {\n\t\t\tlet newShape: TLShape\n\n\t\t\tif (preserveIds) {\n\t\t\t\tnewShape = deepCopy(shape)\n\t\t\t\tidMap.set(shape.id, shape.id)\n\t\t\t} else {\n\t\t\t\tconst id = idMap.get(shape.id)!\n\n\t\t\t\t// Create the new shape (new except for the id)\n\t\t\t\tnewShape = deepCopy({ ...shape, id })\n\t\t\t}\n\n\t\t\tif (rootShapeIds.includes(shape.id)) {\n\t\t\t\tnewShape.parentId = currentPageId\n\t\t\t\trootShapes.push(newShape)\n\t\t\t}\n\n\t\t\t// Assign the child to its new parent.\n\n\t\t\t// If the child's parent is among the putting shapes, then assign\n\t\t\t// it to the new parent's id.\n\t\t\tif (idMap.has(newShape.parentId)) {\n\t\t\t\tnewShape.parentId = idMap.get(shape.parentId)!\n\t\t\t} else {\n\t\t\t\trootShapeIds.push(newShape.id)\n\t\t\t\t// newShape.parentId = pasteParentId\n\t\t\t\tnewShape.index = index\n\t\t\t\tindex = getIndexAbove(index)\n\t\t\t}\n\n\t\t\tif (this.isShapeOfType(newShape, ArrowShapeUtil)) {\n\t\t\t\tif (newShape.props.start.type === 'binding') {\n\t\t\t\t\tconst mappedId = idMap.get(newShape.props.start.boundShapeId)\n\t\t\t\t\tnewShape.props.start = mappedId\n\t\t\t\t\t\t? { ...newShape.props.start, boundShapeId: mappedId }\n\t\t\t\t\t\t: // this shouldn't happen, if you copy an arrow but not it's bound shape it should\n\t\t\t\t\t\t  // convert the binding to a point at the time of copying\n\t\t\t\t\t\t  { type: 'point', x: 0, y: 0 }\n\t\t\t\t}\n\t\t\t\tif (newShape.props.end.type === 'binding') {\n\t\t\t\t\tconst mappedId = idMap.get(newShape.props.end.boundShapeId)\n\t\t\t\t\tnewShape.props.end = mappedId\n\t\t\t\t\t\t? { ...newShape.props.end, boundShapeId: mappedId }\n\t\t\t\t\t\t: // this shouldn't happen, if you copy an arrow but not it's bound shape it should\n\t\t\t\t\t\t  // convert the binding to a point at the time of copying\n\t\t\t\t\t\t  { type: 'point', x: 0, y: 0 }\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn newShape\n\t\t})\n\n\t\tif (newShapes.length + this.currentPageShapeIds.size > MAX_SHAPES_PER_PAGE) {\n\t\t\t// There's some complexity here involving children\n\t\t\t// that might be created without their parents, so\n\t\t\t// if we're going over the limit then just don't paste.\n\t\t\talertMaxShapes(this)\n\t\t\treturn this\n\t\t}\n\n\t\t// Migrate the new shapes\n\n\t\tlet assetsToCreate: TLAsset[] = []\n\n\t\tif (assets) {\n\t\t\tfor (let i = 0; i < assets.length; i++) {\n\t\t\t\tconst asset = assets[i]\n\t\t\t\tconst result = this.store.schema.migratePersistedRecord(asset, content.schema)\n\t\t\t\tif (result.type === 'success') {\n\t\t\t\t\tassets[i] = result.value as TLAsset\n\t\t\t\t} else {\n\t\t\t\t\tthrow Error(\n\t\t\t\t\t\t`Could not put content: could not migrate content for asset:\\n${JSON.stringify(\n\t\t\t\t\t\t\tasset,\n\t\t\t\t\t\t\tnull,\n\t\t\t\t\t\t\t2\n\t\t\t\t\t\t)}`\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst assetsToUpdate: (TLImageAsset | TLVideoAsset)[] = []\n\n\t\t\tassetsToCreate = assets\n\t\t\t\t.filter((asset) => !this.store.has(asset.id))\n\t\t\t\t.map((asset) => {\n\t\t\t\t\tif (asset.type === 'image' || asset.type === 'video') {\n\t\t\t\t\t\tif (asset.props.src && asset.props.src?.startsWith('data:image')) {\n\t\t\t\t\t\t\tassetsToUpdate.push(structuredClone(asset))\n\t\t\t\t\t\t\tasset.props.src = null\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tassetsToUpdate.push(structuredClone(asset))\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn asset\n\t\t\t\t})\n\n\t\t\tPromise.allSettled(\n\t\t\t\tassetsToUpdate.map(async (asset) => {\n\t\t\t\t\tconst file = await dataUrlToFile(\n\t\t\t\t\t\tasset.props.src!,\n\t\t\t\t\t\tasset.props.name,\n\t\t\t\t\t\tasset.props.mimeType ?? 'image/png'\n\t\t\t\t\t)\n\n\t\t\t\t\tconst newAsset = await this.externalContentManager.createAssetFromFile(this, file)\n\n\t\t\t\t\treturn [asset, newAsset] as const\n\t\t\t\t})\n\t\t\t).then((assets) => {\n\t\t\t\tthis.updateAssets(\n\t\t\t\t\tcompact(\n\t\t\t\t\t\tassets.map((result) =>\n\t\t\t\t\t\t\tresult.status === 'fulfilled'\n\t\t\t\t\t\t\t\t? { ...result.value[1], id: result.value[0].id }\n\t\t\t\t\t\t\t\t: undefined\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t})\n\t\t}\n\n\t\tfor (let i = 0; i < newShapes.length; i++) {\n\t\t\tconst shape = newShapes[i]\n\t\t\tconst result = this.store.schema.migratePersistedRecord(shape, content.schema)\n\t\t\tif (result.type === 'success') {\n\t\t\t\tnewShapes[i] = result.value as TLShape\n\t\t\t} else {\n\t\t\t\tthrow Error(\n\t\t\t\t\t`Could not put content: could not migrate content for shape:\\n${JSON.stringify(\n\t\t\t\t\t\tshape,\n\t\t\t\t\t\tnull,\n\t\t\t\t\t\t2\n\t\t\t\t\t)}`\n\t\t\t\t)\n\t\t\t}\n\t\t}\n\n\t\tthis.batch(() => {\n\t\t\t// Create any assets that need to be created\n\t\t\tif (assetsToCreate.length > 0) {\n\t\t\t\tthis.createAssets(assetsToCreate)\n\t\t\t}\n\n\t\t\t// Create the shapes with root shapes as children of the page\n\t\t\tthis.createShapes(newShapes, select)\n\n\t\t\t// And then, if needed, reparent the root shapes to the paste parent\n\t\t\tif (pasteParentId !== currentPageId) {\n\t\t\t\tthis.reparentShapesById(\n\t\t\t\t\trootShapes.map((s) => s.id),\n\t\t\t\t\tpasteParentId\n\t\t\t\t)\n\t\t\t}\n\n\t\t\tconst newCreatedShapes = newShapes.map((s) => this.getShapeById(s.id)!)\n\t\t\tconst bounds = Box2d.Common(newCreatedShapes.map((s) => this.getPageBounds(s)!))\n\n\t\t\tif (point === undefined) {\n\t\t\t\tif (!isPageId(pasteParentId)) {\n\t\t\t\t\t// Put the shapes in the middle of the (on screen) parent\n\t\t\t\t\tconst shape = this.getShapeById(pasteParentId)!\n\t\t\t\t\tconst util = this.getShapeUtil(shape)\n\t\t\t\t\tpoint = util.center(shape)\n\t\t\t\t} else {\n\t\t\t\t\tconst { viewportPageBounds } = this\n\t\t\t\t\tif (preservePosition || viewportPageBounds.includes(Box2d.From(bounds))) {\n\t\t\t\t\t\t// Otherwise, put shapes where they used to be\n\t\t\t\t\t\tpoint = bounds.center\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// If the old bounds are outside of the viewport...\n\t\t\t\t\t\t// put the shapes in the middle of the viewport\n\t\t\t\t\t\tpoint = viewportPageBounds.center\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (rootShapes.length === 1) {\n\t\t\t\tconst onlyRoot = rootShapes[0] as TLFrameShape\n\t\t\t\t// If the old bounds are in the viewport...\n\t\t\t\tif (this.isShapeOfType(onlyRoot, FrameShapeUtil)) {\n\t\t\t\t\twhile (\n\t\t\t\t\t\tthis.getShapesAtPoint(point).some(\n\t\t\t\t\t\t\t(shape) =>\n\t\t\t\t\t\t\t\tthis.isShapeOfType(shape, FrameShapeUtil) &&\n\t\t\t\t\t\t\t\tshape.props.w === onlyRoot.props.w &&\n\t\t\t\t\t\t\t\tshape.props.h === onlyRoot.props.h\n\t\t\t\t\t\t)\n\t\t\t\t\t) {\n\t\t\t\t\t\tpoint.x += bounds.w + 16\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.updateShapes(\n\t\t\t\trootShapes.map((s) => {\n\t\t\t\t\tconst delta = {\n\t\t\t\t\t\tx: (s.x ?? 0) - (bounds.x + bounds.w / 2),\n\t\t\t\t\t\ty: (s.y ?? 0) - (bounds.y + bounds.h / 2),\n\t\t\t\t\t}\n\n\t\t\t\t\treturn { id: s.id, type: s.type, x: point!.x + delta.x, y: point!.y + delta.y }\n\t\t\t\t})\n\t\t\t)\n\t\t})\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Create shapes.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.createShapes([{ id: 'box1', type: 'text', props: { text: \"ok\" } }])\n\t * ```\n\t *\n\t * @param partials - The shape partials to create.\n\t * @param select - Whether to select the created shapes. Defaults to false.\n\t *\n\t * @public\n\t */\n\tcreateShapes<T extends TLUnknownShape>(partials: TLShapePartial<T>[], select = false) {\n\t\tthis._createShapes(partials, select)\n\t\treturn this\n\t}\n\n\t/** @internal */\n\tprivate _createShapes = this.history.createCommand(\n\t\t'createShapes',\n\t\t(partials: TLShapePartial[], select = false) => {\n\t\t\tif (this.isReadOnly) return null\n\t\t\tif (partials.length <= 0) return null\n\n\t\t\tconst { currentPageShapeIds: shapeIds, selectedIds } = this\n\n\t\t\tconst prevSelectedIds = select ? selectedIds : undefined\n\n\t\t\tconst maxShapesReached = partials.length + shapeIds.size > MAX_SHAPES_PER_PAGE\n\n\t\t\tif (maxShapesReached) {\n\t\t\t\talertMaxShapes(this)\n\t\t\t}\n\n\t\t\tconst partialsToCreate = maxShapesReached\n\t\t\t\t? partials.slice(0, MAX_SHAPES_PER_PAGE - shapeIds.size)\n\t\t\t\t: partials\n\n\t\t\tif (partialsToCreate.length === 0) return null\n\n\t\t\treturn {\n\t\t\t\tdata: {\n\t\t\t\t\tcurrentPageId: this.currentPageId,\n\t\t\t\t\tcreatedIds: partials.map((p) => p.id),\n\t\t\t\t\tprevSelectedIds,\n\t\t\t\t\tpartials: partialsToCreate,\n\t\t\t\t\tselect,\n\t\t\t\t},\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\tdo: ({ createdIds, partials, select }) => {\n\t\t\t\tconst { focusLayerId } = this\n\n\t\t\t\t// 1. Parents\n\n\t\t\t\t// Make sure that each partial will become the child of either the\n\t\t\t\t// page or another shape that exists (or that will exist) in this page.\n\n\t\t\t\tpartials = partials.map((partial) => {\n\t\t\t\t\tif (\n\t\t\t\t\t\t// No parentId provided\n\t\t\t\t\t\t!partial.parentId ||\n\t\t\t\t\t\t// A parentId is proved but the parent is neither a) in the store\n\t\t\t\t\t\t// or b) among the other creating shape partials\n\t\t\t\t\t\t(!this.store.get(partial.parentId) && !partials.find((p) => p.id === partial.parentId))\n\t\t\t\t\t) {\n\t\t\t\t\t\tpartial = { ...partial }\n\t\t\t\t\t\tconst parentId = this.getParentIdForNewShapeAtPoint(\n\t\t\t\t\t\t\t{ x: partial.x ?? 0, y: partial.y ?? 0 },\n\t\t\t\t\t\t\tpartial.type\n\t\t\t\t\t\t)\n\t\t\t\t\t\tpartial.parentId = parentId\n\t\t\t\t\t\t// If the parent is a shape (rather than a page) then insert the\n\t\t\t\t\t\t// shapes into the shape's children. Adjust the point and page rotation to be\n\t\t\t\t\t\t// preserved relative to the parent.\n\t\t\t\t\t\tif (isShapeId(parentId)) {\n\t\t\t\t\t\t\tconst point = this.getPointInShapeSpace(this.getShapeById(parentId)!, {\n\t\t\t\t\t\t\t\tx: partial.x ?? 0,\n\t\t\t\t\t\t\t\ty: partial.y ?? 0,\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\tpartial.x = point.x\n\t\t\t\t\t\t\tpartial.y = point.y\n\t\t\t\t\t\t\tpartial.rotation = -this.getPageRotationById(parentId) + (partial.rotation ?? 0)\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// a shape cannot be it's own parent. This was a rare issue with frames/groups in the syncFuzz tests.\n\t\t\t\t\t\tif (partial.parentId === partial.id) {\n\t\t\t\t\t\t\tpartial.parentId = focusLayerId\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn partial\n\t\t\t\t\t}\n\t\t\t\t\treturn partial\n\t\t\t\t})\n\n\t\t\t\t// 2. Indices\n\n\t\t\t\t// Get the highest index among the parents of each of the\n\t\t\t\t// the shapes being created; we'll increment from there.\n\n\t\t\t\tconst parentIndices = new Map<string, string>()\n\n\t\t\t\tconst shapeRecordsToCreate: TLShape[] = []\n\n\t\t\t\tfor (const partial of partials) {\n\t\t\t\t\tconst util = this.getShapeUtil(partial)\n\n\t\t\t\t\t// If an index is not explicitly provided, then add the\n\t\t\t\t\t// shapes to the top of their parents' children; using the\n\t\t\t\t\t// value in parentsMappedToIndex, get the index above, use it,\n\t\t\t\t\t// and set it back to parentsMappedToIndex for next time.\n\t\t\t\t\tlet index = partial.index\n\n\t\t\t\t\tif (!index) {\n\t\t\t\t\t\tconst parentId = partial.parentId ?? focusLayerId\n\t\t\t\t\t\tif (!parentIndices.has(parentId)) {\n\t\t\t\t\t\t\tparentIndices.set(parentId, this.getHighestIndexForParent(parentId))\n\t\t\t\t\t\t}\n\t\t\t\t\t\tindex = parentIndices.get(parentId)!\n\t\t\t\t\t\tparentIndices.set(parentId, getIndexAbove(index))\n\t\t\t\t\t}\n\n\t\t\t\t\t// The initial props starts as the shape utility's default props\n\t\t\t\t\tconst initialProps = util.defaultProps()\n\n\t\t\t\t\t// We then look up each key in the tab state's styles; and if it's there,\n\t\t\t\t\t// we use the value from the tab state's styles instead of the default.\n\t\t\t\t\tfor (const [style, propKey] of util.styleProps) {\n\t\t\t\t\t\t;(initialProps as any)[propKey] = this.getStyleForNextShape(style)\n\t\t\t\t\t}\n\n\t\t\t\t\t// When we create the shape, take in the partial (the props coming into the\n\t\t\t\t\t// function) and merge it with the default props.\n\t\t\t\t\tlet shapeRecordToCreate = (\n\t\t\t\t\t\tthis.store.schema.types.shape as RecordType<\n\t\t\t\t\t\t\tTLShape,\n\t\t\t\t\t\t\t'type' | 'props' | 'index' | 'parentId'\n\t\t\t\t\t\t>\n\t\t\t\t\t).create({\n\t\t\t\t\t\t...partial,\n\t\t\t\t\t\tindex,\n\t\t\t\t\t\topacity: partial.opacity ?? this.instanceState.opacityForNextShape,\n\t\t\t\t\t\tparentId: partial.parentId ?? focusLayerId,\n\t\t\t\t\t\tprops: 'props' in partial ? { ...initialProps, ...partial.props } : initialProps,\n\t\t\t\t\t})\n\n\t\t\t\t\tif (shapeRecordToCreate.index === undefined) {\n\t\t\t\t\t\tthrow Error('no index!')\n\t\t\t\t\t}\n\n\t\t\t\t\tconst next = this.getShapeUtil(shapeRecordToCreate).onBeforeCreate?.(shapeRecordToCreate)\n\n\t\t\t\t\tif (next) {\n\t\t\t\t\t\tshapeRecordToCreate = next\n\t\t\t\t\t}\n\n\t\t\t\t\tshapeRecordsToCreate.push(shapeRecordToCreate)\n\t\t\t\t}\n\n\t\t\t\tthis.store.put(shapeRecordsToCreate)\n\n\t\t\t\t// If we're also selecting the newly created shapes, attempt to select all of them;\n\n\t\t\t\t// the engine will filter out any shapes that are descendants of other new shapes.\n\t\t\t\tif (select) {\n\t\t\t\t\tthis.store.update(this.pageState.id, (state) => ({\n\t\t\t\t\t\t...state,\n\t\t\t\t\t\tselectedIds: createdIds,\n\t\t\t\t\t}))\n\t\t\t\t}\n\t\t\t},\n\t\t\tundo: ({ createdIds, prevSelectedIds }) => {\n\t\t\t\tthis.store.remove(createdIds)\n\n\t\t\t\tif (prevSelectedIds) {\n\t\t\t\t\tthis.store.update(this.pageState.id, (state) => ({\n\t\t\t\t\t\t...state,\n\t\t\t\t\t\tselectedIds: prevSelectedIds,\n\t\t\t\t\t}))\n\t\t\t\t}\n\t\t\t},\n\t\t}\n\t)\n\n\tprivate animatingShapes = new Map<TLShapeId, string>()\n\n\t/**\n\t * Animate shapes.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.animateShapes([{ id: 'box1', type: 'box', x: 100, y: 100 }])\n\t * ```\n\t *\n\t * @param partials - The shape partials to update.\n\t *\n\t * @public\n\t */\n\tanimateShapes(\n\t\tpartials: (TLShapePartial | null | undefined)[],\n\t\toptions: {\n\t\t\t/** The animation's duration in milliseconds. */\n\t\t\tduration?: number\n\t\t\t/** The animation's easing function. */\n\t\t\tease?: (t: number) => number\n\t\t} = {}\n\t) {\n\t\tconst { duration = 500, ease = EASINGS.linear } = options\n\n\t\tconst animationId = uniqueId()\n\n\t\tlet remaining = duration\n\t\tlet t: number\n\n\t\ttype FromTo = { prop: string; from: number; to: number }\n\t\ttype ShapeAnimation = { partial: TLShapePartial; values: FromTo[] }\n\n\t\tconst animations: ShapeAnimation[] = []\n\n\t\tpartials.forEach((partial) => {\n\t\t\tif (!partial) return\n\n\t\t\tconst result: ShapeAnimation = {\n\t\t\t\tpartial,\n\t\t\t\tvalues: [],\n\t\t\t}\n\n\t\t\tconst shape = this.getShapeById(partial.id)!\n\n\t\t\tif (!shape) return\n\n\t\t\tfor (const key of ['x', 'y', 'rotation'] as const) {\n\t\t\t\tif (partial[key] !== undefined && shape[key] !== partial[key]) {\n\t\t\t\t\tresult.values.push({ prop: key, from: shape[key], to: partial[key] as number })\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tanimations.push(result)\n\t\t\tthis.animatingShapes.set(shape.id, animationId)\n\t\t})\n\n\t\tlet value: ShapeAnimation\n\n\t\tconst handleTick = (elapsed: number) => {\n\t\t\tremaining -= elapsed\n\n\t\t\tif (remaining < 0) {\n\t\t\t\tconst { animatingShapes } = this\n\t\t\t\tconst partialsToUpdate = partials.filter(\n\t\t\t\t\t(p) => p && animatingShapes.get(p.id) === animationId\n\t\t\t\t)\n\t\t\t\tif (partialsToUpdate.length) {\n\t\t\t\t\tthis.updateShapes(partialsToUpdate, false)\n\t\t\t\t\t// update shapes also removes the shape from animating shapes\n\t\t\t\t}\n\n\t\t\t\tthis.removeListener('tick', handleTick)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tt = ease(1 - remaining / duration)\n\n\t\t\tconst { animatingShapes } = this\n\n\t\t\ttry {\n\t\t\t\tconst tPartials: TLShapePartial[] = []\n\n\t\t\t\tfor (let i = 0; i < animations.length; i++) {\n\t\t\t\t\tvalue = animations[i]\n\n\t\t\t\t\tif (animatingShapes.get(value.partial.id) === animationId) {\n\t\t\t\t\t\ttPartials.push({\n\t\t\t\t\t\t\tid: value.partial.id,\n\t\t\t\t\t\t\ttype: value.partial.type,\n\t\t\t\t\t\t\t...value.values.reduce((acc, { prop, from, to }) => {\n\t\t\t\t\t\t\t\tacc[prop] = from + (to - from) * t\n\t\t\t\t\t\t\t\treturn acc\n\t\t\t\t\t\t\t}, {} as any),\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis._updateShapes(tPartials, true)\n\t\t\t} catch (e) {\n\t\t\t\t// noop\n\t\t\t}\n\t\t}\n\n\t\tthis.addListener('tick', handleTick)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Update shapes using partials of each shape.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.updateShapes([{ id: 'box1', type: 'geo', props: { w: 100, h: 100 } }])\n\t * ```\n\t *\n\t * @param partials - The shape partials to update.\n\t * @param squashing - Whether the change is ephemeral.\n\t *\n\t * @public\n\t */\n\tupdateShapes<T extends TLUnknownShape>(\n\t\tpartials: (TLShapePartial<T> | null | undefined)[],\n\t\tsquashing = false\n\t) {\n\t\tlet compactedPartials = compact(partials)\n\t\tif (this.animatingShapes.size > 0) {\n\t\t\tcompactedPartials.forEach((p) => this.animatingShapes.delete(p.id))\n\t\t}\n\n\t\tcompactedPartials = compactedPartials.filter((p) => {\n\t\t\tconst shape = this.getShapeById(p.id)\n\t\t\tif (!shape) return false\n\n\t\t\t// Only allow changes to unlocked shapes or changes to the isLocked property (otherwise we cannot unlock a shape)\n\t\t\tif (this.isShapeOrAncestorLocked(shape) && !Object.hasOwn(p, 'isLocked')) return false\n\t\t\treturn true\n\t\t})\n\n\t\tthis._updateShapes(compactedPartials, squashing)\n\t\treturn this\n\t}\n\n\t/** @internal */\n\tprivate _updateShapes = this.history.createCommand(\n\t\t'updateShapes',\n\t\t(_partials: (TLShapePartial | null | undefined)[], squashing = false) => {\n\t\t\tif (this.isReadOnly) return null\n\n\t\t\tconst partials = compact(_partials)\n\n\t\t\tconst snapshots = Object.fromEntries(\n\t\t\t\tcompact(partials.map(({ id }) => this.getShapeById(id))).map((shape) => {\n\t\t\t\t\treturn [shape.id, shape]\n\t\t\t\t})\n\t\t\t)\n\n\t\t\tif (partials.length <= 0) return null\n\n\t\t\tconst updated = compact(\n\t\t\t\tpartials.map((partial) => {\n\t\t\t\t\tconst prev = snapshots[partial.id]\n\t\t\t\t\tif (!prev) return null\n\t\t\t\t\tlet newRecord = null as null | TLShape\n\t\t\t\t\tfor (const [k, v] of Object.entries(partial)) {\n\t\t\t\t\t\tif (v === undefined) continue\n\t\t\t\t\t\tswitch (k) {\n\t\t\t\t\t\t\tcase 'id':\n\t\t\t\t\t\t\tcase 'type':\n\t\t\t\t\t\t\tcase 'typeName': {\n\t\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdefault: {\n\t\t\t\t\t\t\t\tif (v !== (prev as any)[k]) {\n\t\t\t\t\t\t\t\t\tif (!newRecord) {\n\t\t\t\t\t\t\t\t\t\tnewRecord = { ...prev }\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (k === 'props') {\n\t\t\t\t\t\t\t\t\t\tconst nextProps = { ...prev.props } as Record<string, unknown>\n\t\t\t\t\t\t\t\t\t\tfor (const [propKey, propValue] of Object.entries(v as object)) {\n\t\t\t\t\t\t\t\t\t\t\tif (propValue === undefined) continue\n\t\t\t\t\t\t\t\t\t\t\tnextProps[propKey] = propValue\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tnewRecord!.props = nextProps\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t;(newRecord as any)[k] = v\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn newRecord ?? prev\n\t\t\t\t})\n\t\t\t)\n\n\t\t\tconst updates = Object.fromEntries(updated.map((shape) => [shape.id, shape]))\n\n\t\t\treturn { data: { snapshots, updates }, squashing }\n\t\t},\n\t\t{\n\t\t\tdo: ({ updates }) => {\n\t\t\t\t// Iterate through array; if any shape has an onUpdate handler, call it\n\t\t\t\t// and, if the handler returns a new shape, replace the old shape with\n\t\t\t\t// the new one. This is used for example when repositioning a text shape\n\t\t\t\t// based on its new text content.\n\t\t\t\tconst result = Object.values(updates)\n\t\t\t\tfor (let i = 0; i < result.length; i++) {\n\t\t\t\t\tconst shape = result[i]\n\t\t\t\t\tconst current = this.store.get(shape.id)\n\t\t\t\t\tif (!current) continue\n\t\t\t\t\tconst next = this.getShapeUtil(shape).onBeforeUpdate?.(current, shape)\n\t\t\t\t\tif (next) {\n\t\t\t\t\t\tresult[i] = next\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.store.put(result)\n\t\t\t},\n\t\t\tundo: ({ snapshots }) => {\n\t\t\t\tthis.store.put(Object.values(snapshots))\n\t\t\t},\n\t\t\tsquash(prevData, nextData) {\n\t\t\t\treturn {\n\t\t\t\t\t// keep the oldest snapshots\n\t\t\t\t\tsnapshots: { ...nextData.snapshots, ...prevData.snapshots },\n\t\t\t\t\t// keep the newest updates\n\t\t\t\t\tupdates: { ...prevData.updates, ...nextData.updates },\n\t\t\t\t}\n\t\t\t},\n\t\t}\n\t)\n\n\t/** @internal */\n\tprivate _getUnlockedShapeIds(ids: TLShapeId[]): TLShapeId[] {\n\t\treturn ids.filter((id) => !this.getShapeById(id)?.isLocked)\n\t}\n\n\t/**\n\t * Delete shapes.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.deleteShapes()\n\t * editor.deleteShapes(['box1', 'box2'])\n\t * ```\n\t *\n\t * @param ids - The ids of the shapes to delete. Defaults to the selected shapes.\n\t *\n\t * @public\n\t */\n\tdeleteShapes(ids: TLShapeId[] = this.selectedIds) {\n\t\tthis._deleteShapes(this._getUnlockedShapeIds(ids))\n\t\treturn this\n\t}\n\n\t/** @internal */\n\tprivate _deleteShapes = this.history.createCommand(\n\t\t'delete_shapes',\n\t\t(ids: TLShapeId[]) => {\n\t\t\tif (this.isReadOnly) return null\n\t\t\tif (ids.length === 0) return null\n\t\t\tconst prevSelectedIds = [...this.pageState.selectedIds]\n\n\t\t\tconst allIds = new Set(ids)\n\n\t\t\tfor (const id of ids) {\n\t\t\t\tthis.visitDescendants(id, (childId) => {\n\t\t\t\t\tallIds.add(childId)\n\t\t\t\t})\n\t\t\t}\n\n\t\t\tconst deletedIds = [...allIds]\n\t\t\tconst arrowBindings = this._arrowBindingsIndex.value\n\t\t\tconst snapshots = compact(\n\t\t\t\tdeletedIds.flatMap((id) => {\n\t\t\t\t\tconst shape = this.getShapeById(id)\n\n\t\t\t\t\t// Add any bound arrows to the snapshots, so that we can restore the bindings on undo\n\t\t\t\t\tconst bindings = arrowBindings[id]\n\t\t\t\t\tif (bindings && bindings.length > 0) {\n\t\t\t\t\t\treturn bindings.map(({ arrowId }) => this.getShapeById(arrowId)).concat(shape)\n\t\t\t\t\t}\n\t\t\t\t\treturn shape\n\t\t\t\t})\n\t\t\t)\n\n\t\t\tconst postSelectedIds = prevSelectedIds.filter((id) => !allIds.has(id))\n\n\t\t\treturn { data: { deletedIds, snapshots, prevSelectedIds, postSelectedIds } }\n\t\t},\n\t\t{\n\t\t\tdo: ({ deletedIds, postSelectedIds }) => {\n\t\t\t\tthis.store.remove(deletedIds)\n\t\t\t\tthis.store.update(this.pageState.id, (state) => ({\n\t\t\t\t\t...state,\n\t\t\t\t\tselectedIds: postSelectedIds,\n\t\t\t\t}))\n\t\t\t},\n\t\t\tundo: ({ snapshots, prevSelectedIds }) => {\n\t\t\t\tthis.store.put(snapshots)\n\t\t\t\tthis.store.update(this.pageState.id, (state) => ({\n\t\t\t\t\t...state,\n\t\t\t\t\tselectedIds: prevSelectedIds,\n\t\t\t\t}))\n\t\t\t},\n\t\t}\n\t)\n\n\t/**\n\t * Get the user's locale.\n\t *\n\t * @public\n\t */\n\tget locale() {\n\t\treturn this.user.locale\n\t}\n\n\t/**\n\t * Update the user's locale. This affects which translations are used when rendering UI elements.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.setLocale('fr')\n\t * ```\n\t *\n\t * @public\n\t */\n\tsetLocale(locale: string) {\n\t\tthis.user.updateUserPreferences({ locale })\n\t}\n\n\t/**\n\t * Update a page.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.updatePage({ id: 'page2', name: 'Page 2' })\n\t * ```\n\t *\n\t * @param partial - The partial of the shape to update.\n\t *\n\t * @public\n\t */\n\tupdatePage(partial: RequiredKeys<TLPage, 'id'>, squashing = false) {\n\t\tthis._updatePage(partial, squashing)\n\t\treturn this\n\t}\n\n\t/** @internal */\n\tprivate _updatePage = this.history.createCommand(\n\t\t'updatePage',\n\t\t(partial: RequiredKeys<TLPage, 'id'>, squashing = false) => {\n\t\t\tif (this.isReadOnly) return null\n\n\t\t\tconst prev = this.getPageById(partial.id)\n\n\t\t\tif (!prev) return null\n\n\t\t\treturn { data: { prev, partial }, squashing }\n\t\t},\n\t\t{\n\t\t\tdo: ({ partial }) => {\n\t\t\t\tthis.store.update(partial.id, (page) => ({ ...page, ...partial }))\n\t\t\t},\n\t\t\tundo: ({ prev, partial }) => {\n\t\t\t\tthis.store.update(partial.id, () => prev)\n\t\t\t},\n\t\t\tsquash(prevData, nextData) {\n\t\t\t\treturn {\n\t\t\t\t\tprev: { ...prevData.prev, ...nextData.prev },\n\t\t\t\t\tpartial: nextData.partial,\n\t\t\t\t}\n\t\t\t},\n\t\t}\n\t)\n\n\t/**\n\t * Create a page.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.createPage('New Page')\n\t * editor.createPage('New Page', 'page1')\n\t * ```\n\t *\n\t * @param id - The new page's id.\n\t * @param title - The new page's title.\n\t *\n\t * @public\n\t */\n\tcreatePage(title: string, id: TLPageId = PageRecordType.createId(), belowPageIndex?: string) {\n\t\tthis._createPage(title, id, belowPageIndex)\n\t\treturn this\n\t}\n\n\t/** @internal */\n\tprivate _createPage = this.history.createCommand(\n\t\t'createPage',\n\t\t(title: string, id: TLPageId = PageRecordType.createId(), belowPageIndex?: string) => {\n\t\t\tif (this.isReadOnly) return null\n\t\t\tif (this.pages.length >= MAX_PAGES) return null\n\t\t\tconst pageInfo = this.pages\n\t\t\tconst topIndex = belowPageIndex ?? pageInfo[pageInfo.length - 1]?.index ?? 'a1'\n\t\t\tconst bottomIndex = pageInfo[pageInfo.findIndex((p) => p.index === topIndex) + 1]?.index\n\n\t\t\ttitle = getIncrementedName(\n\t\t\t\ttitle,\n\t\t\t\tpageInfo.map((p) => p.name)\n\t\t\t)\n\n\t\t\tconst newPage = PageRecordType.create({\n\t\t\t\tid,\n\t\t\t\tname: title,\n\t\t\t\tindex:\n\t\t\t\t\tbottomIndex && topIndex !== bottomIndex\n\t\t\t\t\t\t? getIndexBetween(topIndex, bottomIndex)\n\t\t\t\t\t\t: getIndexAbove(topIndex),\n\t\t\t})\n\n\t\t\tconst newCamera = CameraRecordType.create({\n\t\t\t\tid: CameraRecordType.createId(newPage.id),\n\t\t\t})\n\n\t\t\tconst newTabPageState = InstancePageStateRecordType.create({\n\t\t\t\tid: InstancePageStateRecordType.createId(newPage.id),\n\t\t\t\tpageId: newPage.id,\n\t\t\t})\n\n\t\t\treturn {\n\t\t\t\tdata: {\n\t\t\t\t\tprevSelectedPageId: this.currentPageId,\n\t\t\t\t\tnewPage,\n\t\t\t\t\tnewTabPageState,\n\t\t\t\t\tnewCamera,\n\t\t\t\t},\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\tdo: ({ newPage, newTabPageState, newCamera }) => {\n\t\t\t\tthis.store.put([\n\t\t\t\t\tnewPage,\n\t\t\t\t\tnewCamera,\n\t\t\t\t\tnewTabPageState,\n\t\t\t\t\t{ ...this.instanceState, currentPageId: newPage.id },\n\t\t\t\t])\n\t\t\t\tthis.updateRenderingBounds()\n\t\t\t},\n\t\t\tundo: ({ newPage, prevSelectedPageId, newTabPageState, newCamera }) => {\n\t\t\t\tif (this.pages.length === 1) return\n\t\t\t\tthis.store.remove([newTabPageState.id, newPage.id, newCamera.id])\n\n\t\t\t\tif (this.store.has(prevSelectedPageId) && this.currentPageId !== prevSelectedPageId) {\n\t\t\t\t\tthis.store.put([{ ...this.instanceState, currentPageId: prevSelectedPageId }])\n\t\t\t\t}\n\n\t\t\t\tthis.updateRenderingBounds()\n\t\t\t},\n\t\t}\n\t)\n\n\t/**\n\t * Duplicate a page.\n\t *\n\t * @param id - The id of the page to duplicate. Defaults to the current page.\n\t * @param createId - The id of the new page. Defaults to a new id.\n\t *\n\t * @public\n\t */\n\tduplicatePage(id: TLPageId = this.currentPageId, createId: TLPageId = PageRecordType.createId()) {\n\t\tif (this.pages.length >= MAX_PAGES) return this\n\t\tconst page = this.getPageById(id)\n\t\tif (!page) return this\n\n\t\tconst camera = { ...this.camera }\n\t\tconst content = this.getContent(this.getSortedChildIds(page.id))\n\n\t\tthis.batch(() => {\n\t\t\tthis.createPage(page.name + ' Copy', createId, page.index)\n\t\t\tthis.setCurrentPageId(createId)\n\t\t\tthis.setCamera(camera.x, camera.y, camera.z)\n\n\t\t\t// will change page automatically\n\t\t\tif (content) {\n\t\t\t\treturn this.putContent(content)\n\t\t\t}\n\t\t})\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Delete a page.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.deletePage('page1')\n\t * ```\n\t *\n\t * @param id - The id of the page to delete.\n\t *\n\t * @public\n\t */\n\tdeletePage(id: TLPageId) {\n\t\tthis._deletePage(id)\n\t}\n\n\t/** @internal */\n\tprivate _deletePage = this.history.createCommand(\n\t\t'delete_page',\n\t\t(id: TLPageId) => {\n\t\t\tif (this.isReadOnly) return null\n\t\t\tconst { pages } = this\n\t\t\tif (pages.length === 1) return null\n\n\t\t\tconst deletedPage = this.getPageById(id)\n\t\t\tconst deletedPageStates = this._pageStates.value.filter((s) => s.pageId === id)\n\n\t\t\tif (!deletedPage) return null\n\n\t\t\tif (id === this.currentPageId) {\n\t\t\t\tconst index = pages.findIndex((page) => page.id === id)\n\t\t\t\tconst next = pages[index - 1] ?? pages[index + 1]\n\t\t\t\tthis.setCurrentPageId(next.id)\n\t\t\t}\n\n\t\t\treturn { data: { id, deletedPage, deletedPageStates } }\n\t\t},\n\t\t{\n\t\t\tdo: ({ deletedPage, deletedPageStates }) => {\n\t\t\t\tconst { pages } = this\n\t\t\t\tif (pages.length === 1) return\n\n\t\t\t\tif (deletedPage.id === this.currentPageId) {\n\t\t\t\t\tconst index = pages.findIndex((page) => page.id === deletedPage.id)\n\t\t\t\t\tconst next = pages[index - 1] ?? pages[index + 1]\n\t\t\t\t\tthis.setCurrentPageId(next.id)\n\t\t\t\t}\n\n\t\t\t\tthis.store.remove(deletedPageStates.map((s) => s.id)) // remove the page state\n\t\t\t\tthis.store.remove([deletedPage.id]) // remove the page\n\t\t\t\tthis.updateRenderingBounds()\n\t\t\t},\n\t\t\tundo: ({ deletedPage, deletedPageStates }) => {\n\t\t\t\tthis.store.put([deletedPage])\n\t\t\t\tthis.store.put(deletedPageStates)\n\t\t\t\tthis.updateRenderingBounds()\n\t\t\t},\n\t\t}\n\t)\n\n\t/** @internal */\n\tprivate _setInstancePageState = this.history.createCommand(\n\t\t'setInstancePageState',\n\t\t(partial: Partial<TLInstancePageState>, ephemeral = false) => {\n\t\t\tconst prev = this.store.get(partial.id ?? this.pageState.id)!\n\t\t\treturn { data: { prev, partial }, ephemeral }\n\t\t},\n\t\t{\n\t\t\tdo: ({ prev, partial }) => {\n\t\t\t\tthis.store.update(prev.id, (state) => ({ ...state, ...partial }))\n\t\t\t},\n\t\t\tundo: ({ prev }) => {\n\t\t\t\tthis.store.update(prev.id, () => prev)\n\t\t\t},\n\t\t}\n\t)\n\n\t/* --------------------- Assets --------------------- */\n\n\t/** @internal */\n\t@computed private get _assets() {\n\t\treturn this.store.query.records('asset')\n\t}\n\n\t/**\n\t * Get all assets in the editor.\n\t *\n\t * @public\n\t */\n\tget assets() {\n\t\treturn this._assets.value\n\t}\n\n\t/**\n\t * Create one or more assets.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.createAssets([...myAssets])\n\t * ```\n\t *\n\t * @param assets - The assets to create.\n\t *\n\t * @public\n\t */\n\tcreateAssets(assets: TLAsset[]) {\n\t\tthis._createAssets(assets)\n\t\treturn this\n\t}\n\n\t/** @internal */\n\tprivate _createAssets = this.history.createCommand(\n\t\t'createAssets',\n\t\t(assets: TLAsset[]) => {\n\t\t\tif (this.isReadOnly) return null\n\t\t\tif (assets.length <= 0) return null\n\n\t\t\treturn { data: { assets } }\n\t\t},\n\t\t{\n\t\t\tdo: ({ assets }) => {\n\t\t\t\tthis.store.put(assets)\n\t\t\t},\n\t\t\tundo: ({ assets }) => {\n\t\t\t\t// todo: should we actually remove assets here? or on cleanup elsewhere?\n\t\t\t\tthis.store.remove(assets.map((a) => a.id))\n\t\t\t},\n\t\t}\n\t)\n\n\t/**\n\t * Delete one or more assets.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.deleteAssets(['asset1', 'asset2'])\n\t * ```\n\t *\n\t * @param ids - The assets to delete.\n\t *\n\t * @public\n\t */\n\tdeleteAssets(ids: TLAssetId[]) {\n\t\tthis._deleteAssets(ids)\n\t\treturn this\n\t}\n\n\t/** @internal */\n\tprivate _deleteAssets = this.history.createCommand(\n\t\t'deleteAssets',\n\t\t(ids: TLAssetId[]) => {\n\t\t\tif (this.isReadOnly) return\n\t\t\tif (ids.length <= 0) return\n\n\t\t\tconst prev = compact(ids.map((id) => this.store.get(id)))\n\n\t\t\treturn { data: { ids, prev } }\n\t\t},\n\t\t{\n\t\t\tdo: ({ ids }) => {\n\t\t\t\tthis.store.remove(ids)\n\t\t\t},\n\t\t\tundo: ({ prev }) => {\n\t\t\t\tthis.store.put(prev)\n\t\t\t},\n\t\t}\n\t)\n\n\t/**\n\t * Update one or more assets.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.updateAssets([{ id: 'asset1', name: 'New name' }])\n\t * ```\n\t *\n\t * @param assets - The assets to update.\n\t *\n\t * @public\n\t */\n\tupdateAssets(assets: TLAssetPartial[]) {\n\t\tthis._updateAssets(assets)\n\t\treturn this\n\t}\n\n\t/** @internal */\n\tprivate _updateAssets = this.history.createCommand(\n\t\t'updateAssets',\n\t\t(assets: TLAssetPartial[]) => {\n\t\t\tif (this.isReadOnly) return\n\t\t\tif (assets.length <= 0) return\n\n\t\t\tconst snapshots: Record<string, TLAsset> = {}\n\n\t\t\treturn { data: { snapshots, assets } }\n\t\t},\n\t\t{\n\t\t\tdo: ({ assets, snapshots }) => {\n\t\t\t\tthis.store.put(\n\t\t\t\t\tassets.map((a) => {\n\t\t\t\t\t\tconst asset = this.store.get(a.id)!\n\t\t\t\t\t\tsnapshots[a.id] = asset\n\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t...asset,\n\t\t\t\t\t\t\t...a,\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t)\n\t\t\t},\n\t\t\tundo: ({ snapshots }) => {\n\t\t\t\tthis.store.put(Object.values(snapshots))\n\t\t\t},\n\t\t}\n\t)\n\n\t/**\n\t * Get an asset by its src property.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.getAssetBySource('https://example.com/image.png')\n\t * ```\n\t *\n\t * @param src - The source value of the asset.\n\t *\n\t * @public\n\t */\n\tgetAssetBySrc(src: string) {\n\t\treturn this.assets.find((a) => a.props.src === src)\n\t}\n\n\t/**\n\t * Get an asset by its id.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.getAssetById('asset1')\n\t * ```\n\t *\n\t * @param id - The id of the asset.\n\t *\n\t * @public\n\t */\n\tgetAssetById(id: TLAssetId): TLAsset | undefined {\n\t\treturn this.store.get(id) as TLAsset | undefined\n\t}\n\n\t/**\n\t * Rename a page.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.renamePage('page1', 'My Page')\n\t * ```\n\t *\n\t * @param id - The id of the page to rename.\n\t * @param name - The new name.\n\t *\n\t * @public\n\t */\n\trenamePage(id: TLPageId, name: string, squashing = false) {\n\t\tif (this.isReadOnly) return this\n\t\tthis.updatePage({ id, name }, squashing)\n\t\treturn this\n\t}\n\n\t/**\n\t * Move shapes to page.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.moveShapesToPage(['box1', 'box2'], 'page1')\n\t * ```\n\t *\n\t * @param ids - The ids of the shapes to move.\n\t * @param pageId - The id of the page where the shapes will be moved.\n\t *\n\t * @public\n\t */\n\tmoveShapesToPage(ids: TLShapeId[], pageId: TLPageId): this {\n\t\tif (ids.length === 0) return this\n\t\tif (this.isReadOnly) return this\n\n\t\tconst { currentPageId } = this\n\n\t\tif (pageId === currentPageId) return this\n\t\tif (!this.store.has(pageId)) return this\n\n\t\t// Basically copy the shapes\n\t\tconst content = this.getContent(ids)\n\n\t\t// Just to be sure\n\t\tif (!content) return this\n\n\t\t// If there is no space on pageId, or if the selected shapes\n\t\t// would take the new page above the limit, don't move the shapes\n\t\tif (this.getShapeIdsInPage(pageId).size + content.shapes.length > MAX_SHAPES_PER_PAGE) {\n\t\t\talertMaxShapes(this, pageId)\n\t\t\treturn this\n\t\t}\n\n\t\tconst fromPageZ = this.camera.z\n\n\t\tthis.history.batch(() => {\n\t\t\t// Delete the shapes on the current page\n\t\t\tthis.deleteShapes(ids)\n\n\t\t\t// Move to the next page\n\t\t\tthis.setCurrentPageId(pageId)\n\n\t\t\t// Put the shape content onto the new page; parents and indices will\n\t\t\t// be taken care of by the putContent method; make sure to pop any focus\n\t\t\t// layers so that the content will be put onto the page.\n\t\t\tthis.setFocusLayer(null)\n\t\t\tthis.selectNone()\n\t\t\tthis.putContent(content, { select: true, preserveIds: true, preservePosition: true })\n\n\t\t\t// Force the new page's camera to be at the same zoom level as the\n\t\t\t// \"from\" page's camera, then center the \"to\" page's camera on the\n\t\t\t// pasted shapes\n\t\t\tconst {\n\t\t\t\tcenter: { x, y },\n\t\t\t} = this.selectionBounds!\n\t\t\tthis.setCamera(this.camera.x, this.camera.y, fromPageZ)\n\t\t\tthis.centerOnPoint(x, y)\n\t\t})\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Toggle the lock state of one or more shapes. If there is a mix of locked and unlocked shapes, all shapes will be locked.\n\t *\n\t * @param ids - The ids of the shapes to toggle. Defaults to selected shapes.\n\t *\n\t * @public\n\t */\n\ttoggleLock(ids: TLShapeId[] = this.selectedIds): this {\n\t\tif (this.isReadOnly || ids.length === 0) return this\n\n\t\tlet allLocked = true,\n\t\t\tallUnlocked = true\n\t\tconst shapes: TLShape[] = []\n\t\tfor (const id of ids) {\n\t\t\tconst shape = this.getShapeById(id)\n\t\t\tif (shape) {\n\t\t\t\tshapes.push(shape)\n\t\t\t\tif (shape.isLocked) {\n\t\t\t\t\tallUnlocked = false\n\t\t\t\t} else {\n\t\t\t\t\tallLocked = false\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (allUnlocked) {\n\t\t\tthis.updateShapes(shapes.map((shape) => ({ id: shape.id, type: shape.type, isLocked: true })))\n\t\t\tthis.setSelectedIds([])\n\t\t} else if (allLocked) {\n\t\t\tthis.updateShapes(\n\t\t\t\tshapes.map((shape) => ({ id: shape.id, type: shape.type, isLocked: false }))\n\t\t\t)\n\t\t} else {\n\t\t\tthis.updateShapes(shapes.map((shape) => ({ id: shape.id, type: shape.type, isLocked: true })))\n\t\t}\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Reorder shapes.\n\t *\n\t * @param operation - The operation to perform.\n\t * @param ids - The ids to reorder.\n\t *\n\t * @public\n\t */\n\treorderShapes(operation: 'toBack' | 'toFront' | 'forward' | 'backward', ids: TLShapeId[]) {\n\t\tif (this.isReadOnly) return this\n\t\tif (ids.length === 0) return this\n\t\t// this.emit('reorder-shapes', { pageId: this.currentPageId, ids, operation })\n\n\t\tconst parents = this.getParentsMappedToChildren(ids)\n\n\t\tconst changes: TLShapePartial[] = []\n\n\t\tswitch (operation) {\n\t\t\tcase 'toBack': {\n\t\t\t\tparents.forEach((movingSet, parentId) => {\n\t\t\t\t\tconst siblings = compact(\n\t\t\t\t\t\tthis.getSortedChildIds(parentId).map((id) => this.getShapeById(id))\n\t\t\t\t\t)\n\n\t\t\t\t\tif (movingSet.size === siblings.length) return\n\n\t\t\t\t\tlet below: string | undefined\n\t\t\t\t\tlet above: string | undefined\n\n\t\t\t\t\tfor (const shape of siblings) {\n\t\t\t\t\t\tif (!movingSet.has(shape)) {\n\t\t\t\t\t\t\tabove = shape.index\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmovingSet.delete(shape)\n\t\t\t\t\t\tbelow = shape.index\n\t\t\t\t\t}\n\n\t\t\t\t\tif (movingSet.size === 0) return\n\n\t\t\t\t\tconst indices = getIndicesBetween(below, above, movingSet.size)\n\n\t\t\t\t\tArray.from(movingSet.values())\n\t\t\t\t\t\t.sort(sortByIndex)\n\t\t\t\t\t\t.forEach((node, i) =>\n\t\t\t\t\t\t\tchanges.push({ id: node.id as any, type: node.type, index: indices[i] })\n\t\t\t\t\t\t)\n\t\t\t\t})\n\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase 'toFront': {\n\t\t\t\tparents.forEach((movingSet, parentId) => {\n\t\t\t\t\tconst siblings = compact(\n\t\t\t\t\t\tthis.getSortedChildIds(parentId).map((id) => this.getShapeById(id))\n\t\t\t\t\t)\n\t\t\t\t\tconst len = siblings.length\n\n\t\t\t\t\tif (movingSet.size === len) return\n\n\t\t\t\t\tlet below: string | undefined\n\t\t\t\t\tlet above: string | undefined\n\n\t\t\t\t\tfor (let i = len - 1; i > -1; i--) {\n\t\t\t\t\t\tconst shape = siblings[i]\n\n\t\t\t\t\t\tif (!movingSet.has(shape)) {\n\t\t\t\t\t\t\tbelow = shape.index\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmovingSet.delete(shape)\n\t\t\t\t\t\tabove = shape.index\n\t\t\t\t\t}\n\n\t\t\t\t\tif (movingSet.size === 0) return\n\n\t\t\t\t\tconst indices = getIndicesBetween(below, above, movingSet.size)\n\n\t\t\t\t\tArray.from(movingSet.values())\n\t\t\t\t\t\t.sort(sortByIndex)\n\t\t\t\t\t\t.forEach((node, i) =>\n\t\t\t\t\t\t\tchanges.push({ id: node.id as any, type: node.type, index: indices[i] })\n\t\t\t\t\t\t)\n\t\t\t\t})\n\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase 'forward': {\n\t\t\t\tparents.forEach((movingSet, parentId) => {\n\t\t\t\t\tconst siblings = compact(\n\t\t\t\t\t\tthis.getSortedChildIds(parentId).map((id) => this.getShapeById(id))\n\t\t\t\t\t)\n\t\t\t\t\tconst len = siblings.length\n\n\t\t\t\t\tif (movingSet.size === len) return\n\n\t\t\t\t\tconst movingIndices = new Set(Array.from(movingSet).map((n) => siblings.indexOf(n)))\n\n\t\t\t\t\tlet selectIndex = -1\n\t\t\t\t\tlet isSelecting = false\n\t\t\t\t\tlet below: string | undefined\n\t\t\t\t\tlet above: string | undefined\n\t\t\t\t\tlet count: number\n\n\t\t\t\t\tfor (let i = 0; i < len; i++) {\n\t\t\t\t\t\tconst isMoving = movingIndices.has(i)\n\n\t\t\t\t\t\tif (!isSelecting && isMoving) {\n\t\t\t\t\t\t\tisSelecting = true\n\t\t\t\t\t\t\tselectIndex = i\n\t\t\t\t\t\t\tabove = undefined\n\t\t\t\t\t\t} else if (isSelecting && !isMoving) {\n\t\t\t\t\t\t\tisSelecting = false\n\t\t\t\t\t\t\tcount = i - selectIndex\n\t\t\t\t\t\t\tbelow = siblings[i].index\n\t\t\t\t\t\t\tabove = siblings[i + 1]?.index\n\n\t\t\t\t\t\t\tconst indices = getIndicesBetween(below, above, count)\n\n\t\t\t\t\t\t\tfor (let k = 0; k < count; k++) {\n\t\t\t\t\t\t\t\tconst node = siblings[selectIndex + k]\n\t\t\t\t\t\t\t\tchanges.push({ id: node.id as any, type: node.type, index: indices[k] })\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t})\n\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase 'backward': {\n\t\t\t\tparents.forEach((movingSet, parentId) => {\n\t\t\t\t\tconst siblings = compact(\n\t\t\t\t\t\tthis.getSortedChildIds(parentId).map((id) => this.getShapeById(id))\n\t\t\t\t\t)\n\t\t\t\t\tconst len = siblings.length\n\n\t\t\t\t\tif (movingSet.size === len) return\n\n\t\t\t\t\tconst movingIndices = new Set(Array.from(movingSet).map((n) => siblings.indexOf(n)))\n\n\t\t\t\t\tlet selectIndex = -1\n\t\t\t\t\tlet isSelecting = false\n\t\t\t\t\tlet count: number\n\n\t\t\t\t\tfor (let i = len - 1; i > -1; i--) {\n\t\t\t\t\t\tconst isMoving = movingIndices.has(i)\n\n\t\t\t\t\t\tif (!isSelecting && isMoving) {\n\t\t\t\t\t\t\tisSelecting = true\n\t\t\t\t\t\t\tselectIndex = i\n\t\t\t\t\t\t} else if (isSelecting && !isMoving) {\n\t\t\t\t\t\t\tisSelecting = false\n\t\t\t\t\t\t\tcount = selectIndex - i\n\n\t\t\t\t\t\t\tconst indices = getIndicesBetween(siblings[i - 1]?.index, siblings[i].index, count)\n\n\t\t\t\t\t\t\tfor (let k = 0; k < count; k++) {\n\t\t\t\t\t\t\t\tconst node = siblings[i + k + 1]\n\t\t\t\t\t\t\t\tchanges.push({ id: node.id as any, type: node.type, index: indices[k] })\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t})\n\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tthis.updateShapes(changes)\n\t\treturn this\n\t}\n\n\t/**\n\t * Send shapes to the back of the page's object list.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.sendToBack()\n\t * editor.sendToBack(['id1', 'id2'])\n\t * ```\n\t *\n\t * @param ids - The ids of the shapes to move. Defaults to the ids of the selected shapes.\n\t *\n\t * @public\n\t */\n\tsendToBack(ids = this.pageState.selectedIds) {\n\t\tthis.reorderShapes('toBack', ids)\n\t\treturn this\n\t}\n\n\t/**\n\t * Send shapes backward in the page's object list.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.sendBackward()\n\t * editor.sendBackward(['id1', 'id2'])\n\t * ```\n\t *\n\t * @param ids - The ids of the shapes to move. Defaults to the ids of the selected shapes.\n\t *\n\t * @public\n\t */\n\tsendBackward(ids = this.pageState.selectedIds) {\n\t\tthis.reorderShapes('backward', ids)\n\t\treturn this\n\t}\n\n\t/**\n\t * Bring shapes forward in the page's object list.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.bringForward()\n\t * editor.bringForward(['id1', 'id2'])\n\t * ```\n\t *\n\t * @param ids - The ids of the shapes to move. Defaults to the ids of the selected shapes.\n\t *\n\t * @public\n\t */\n\tbringForward(ids = this.pageState.selectedIds) {\n\t\tthis.reorderShapes('forward', ids)\n\t\treturn this\n\t}\n\n\t/**\n\t * Bring shapes to the front of the page's object list.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.bringToFront()\n\t * editor.bringToFront(['id1', 'id2'])\n\t * ```\n\t *\n\t * @param ids - The ids of the shapes to move. Defaults to the ids of the selected shapes.\n\t *\n\t * @public\n\t */\n\tbringToFront(ids = this.pageState.selectedIds) {\n\t\tthis.reorderShapes('toFront', ids)\n\t\treturn this\n\t}\n\n\t/**\n\t * Flip shape positions.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.flipShapes('horizontal')\n\t * editor.flipShapes('horizontal', ['box1', 'box2'])\n\t * ```\n\t *\n\t * @param operation - Whether to flip horizontally or vertically.\n\t * @param ids - The ids of the shapes to flip. Defaults to selected shapes.\n\t *\n\t * @public\n\t */\n\tflipShapes(operation: 'horizontal' | 'vertical', ids: TLShapeId[] = this.selectedIds) {\n\t\tif (this.isReadOnly) return this\n\n\t\tlet shapes = compact(ids.map((id) => this.getShapeById(id)))\n\n\t\tif (!shapes.length) return this\n\n\t\tshapes = compact(\n\t\t\tshapes\n\t\t\t\t.map((shape) => {\n\t\t\t\t\tif (this.isShapeOfType(shape, GroupShapeUtil)) {\n\t\t\t\t\t\treturn this.getSortedChildIds(shape.id).map((id) => this.getShapeById(id))\n\t\t\t\t\t}\n\n\t\t\t\t\treturn shape\n\t\t\t\t})\n\t\t\t\t.flat()\n\t\t)\n\n\t\tconst scaleOriginPage = Box2d.Common(compact(shapes.map((id) => this.getPageBounds(id)))).center\n\n\t\tthis.batch(() => {\n\t\t\tfor (const shape of shapes) {\n\t\t\t\tconst util = this.getShapeUtil(shape)\n\t\t\t\tconst bounds = util.bounds(shape)\n\t\t\t\tconst initialPageTransform = this.getPageTransformById(shape.id)\n\t\t\t\tif (!initialPageTransform) continue\n\t\t\t\tthis.resizeShape(\n\t\t\t\t\tshape.id,\n\t\t\t\t\t{ x: operation === 'horizontal' ? -1 : 1, y: operation === 'vertical' ? -1 : 1 },\n\t\t\t\t\t{\n\t\t\t\t\t\tinitialBounds: bounds,\n\t\t\t\t\t\tinitialPageTransform,\n\t\t\t\t\t\tinitialShape: shape,\n\t\t\t\t\t\tmode: 'scale_shape',\n\t\t\t\t\t\tscaleOrigin: scaleOriginPage,\n\t\t\t\t\t\tscaleAxisRotation: 0,\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t}\n\t\t})\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Stack shape.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.stackShapes('horizontal')\n\t * editor.stackShapes('horizontal', ['box1', 'box2'])\n\t * editor.stackShapes('horizontal', ['box1', 'box2'], 20)\n\t * ```\n\t *\n\t * @param operation - Whether to stack horizontally or vertically.\n\t * @param ids - The ids of the shapes to stack. Defaults to selected shapes.\n\t * @param gap - A specific gap to use when stacking.\n\t *\n\t * @public\n\t */\n\tstackShapes(\n\t\toperation: 'horizontal' | 'vertical',\n\t\tids: TLShapeId[] = this.pageState.selectedIds,\n\t\tgap?: number\n\t) {\n\t\tif (this.isReadOnly) return this\n\n\t\tconst shapes = compact(ids.map((id) => this.getShapeById(id))).filter((shape) => {\n\t\t\tif (!shape) return false\n\n\t\t\tif (this.isShapeOfType(shape, ArrowShapeUtil)) {\n\t\t\t\tif (shape.props.start.type === 'binding' || shape.props.end.type === 'binding') {\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn true\n\t\t})\n\n\t\tconst len = shapes.length\n\n\t\tif ((gap === undefined && len < 3) || len < 2) return this\n\n\t\tconst pageBounds = Object.fromEntries(\n\t\t\tshapes.map((shape) => [shape.id, this.getPageBounds(shape)!])\n\t\t)\n\n\t\tlet val: 'x' | 'y'\n\t\tlet min: 'minX' | 'minY'\n\t\tlet max: 'maxX' | 'maxY'\n\t\tlet dim: 'width' | 'height'\n\n\t\tif (operation === 'horizontal') {\n\t\t\tval = 'x'\n\t\t\tmin = 'minX'\n\t\t\tmax = 'maxX'\n\t\t\tdim = 'width'\n\t\t} else {\n\t\t\tval = 'y'\n\t\t\tmin = 'minY'\n\t\t\tmax = 'maxY'\n\t\t\tdim = 'height'\n\t\t}\n\n\t\tlet shapeGap: number\n\n\t\tif (gap === undefined) {\n\t\t\tconst gaps: { gap: number; count: number }[] = []\n\n\t\t\tshapes.sort((a, b) => pageBounds[a.id][min] - pageBounds[b.id][min])\n\n\t\t\t// Collect all of the gaps between shapes. We want to find\n\t\t\t// patterns (equal gaps between shapes) and use the most common\n\t\t\t// one as the gap for all of the shapes.\n\t\t\tfor (let i = 0; i < len - 1; i++) {\n\t\t\t\tconst shape = shapes[i]\n\t\t\t\tconst nextShape = shapes[i + 1]\n\n\t\t\t\tconst bounds = pageBounds[shape.id]\n\t\t\t\tconst nextBounds = pageBounds[nextShape.id]\n\n\t\t\t\tconst gap = nextBounds[min] - bounds[max]\n\n\t\t\t\tconst current = gaps.find((g) => g.gap === gap)\n\n\t\t\t\tif (current) {\n\t\t\t\t\tcurrent.count++\n\t\t\t\t} else {\n\t\t\t\t\tgaps.push({ gap, count: 1 })\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Which gap is the most common?\n\t\t\tlet maxCount = 0\n\t\t\tgaps.forEach((g) => {\n\t\t\t\tif (g.count > maxCount) {\n\t\t\t\t\tmaxCount = g.count\n\t\t\t\t\tshapeGap = g.gap\n\t\t\t\t}\n\t\t\t})\n\n\t\t\t// If there is no most-common gap, use the average gap.\n\t\t\tif (maxCount === 1) {\n\t\t\t\tshapeGap = Math.max(0, gaps.reduce((a, c) => a + c.gap * c.count, 0) / (len - 1))\n\t\t\t}\n\t\t} else {\n\t\t\t// If a gap was provided, then use that instead.\n\t\t\tshapeGap = gap\n\t\t}\n\n\t\tconst changes: TLShapePartial[] = []\n\n\t\tlet v = pageBounds[shapes[0].id][max]\n\n\t\tshapes.forEach((shape, i) => {\n\t\t\tif (i === 0) return\n\n\t\t\tconst delta = { x: 0, y: 0 }\n\t\t\tdelta[val] = v + shapeGap - pageBounds[shape.id][val]\n\n\t\t\tconst parent = this.getParentShape(shape)\n\t\t\tconst localDelta = parent ? Vec2d.Rot(delta, -this.getPageRotation(parent)) : delta\n\n\t\t\tconst translateStartChanges = this.getShapeUtil(shape).onTranslateStart?.(shape)\n\n\t\t\tchanges.push(\n\t\t\t\ttranslateStartChanges\n\t\t\t\t\t? {\n\t\t\t\t\t\t\t...translateStartChanges,\n\t\t\t\t\t\t\t[val]: shape[val] + localDelta[val],\n\t\t\t\t\t  }\n\t\t\t\t\t: {\n\t\t\t\t\t\t\tid: shape.id as any,\n\t\t\t\t\t\t\ttype: shape.type,\n\t\t\t\t\t\t\t[val]: shape[val] + localDelta[val],\n\t\t\t\t\t  }\n\t\t\t)\n\n\t\t\tv += pageBounds[shape.id][dim] + shapeGap\n\t\t})\n\n\t\tthis.updateShapes(changes)\n\t\treturn this\n\t}\n\n\t/**\n\t * Pack shapes into a grid centered on their current position. Based on potpack\n\t * (https://github.com/mapbox/potpack)\n\t * @param ids - The ids of the shapes to pack. Defaults to selected shapes.\n\t * @param padding - The padding to apply to the packed shapes.\n\t */\n\tpackShapes(ids: TLShapeId[] = this.pageState.selectedIds, padding = 16) {\n\t\tif (this.isReadOnly) return this\n\t\tif (ids.length < 2) return this\n\n\t\tconst shapes = compact(\n\t\t\tids\n\t\t\t\t.map((id) => this.getShapeById(id))\n\t\t\t\t.filter((shape) => {\n\t\t\t\t\tif (!shape) return false\n\n\t\t\t\t\tif (this.isShapeOfType(shape, ArrowShapeUtil)) {\n\t\t\t\t\t\tif (shape.props.start.type === 'binding' || shape.props.end.type === 'binding') {\n\t\t\t\t\t\t\treturn false\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true\n\t\t\t\t})\n\t\t)\n\t\tconst shapePageBounds: Record<string, Box2d> = {}\n\t\tconst nextShapePageBounds: Record<string, Box2d> = {}\n\n\t\tlet shape: TLShape,\n\t\t\tbounds: Box2d,\n\t\t\tarea = 0\n\n\t\tfor (let i = 0; i < shapes.length; i++) {\n\t\t\tshape = shapes[i]\n\t\t\tbounds = this.getPageBounds(shape)!\n\t\t\tshapePageBounds[shape.id] = bounds\n\t\t\tnextShapePageBounds[shape.id] = bounds.clone()\n\t\t\tarea += bounds.width * bounds.height\n\t\t}\n\n\t\tconst commonBounds = Box2d.Common(compact(Object.values(shapePageBounds)))\n\n\t\tconst maxWidth = commonBounds.width\n\n\t\t// sort the shapes by height, descending\n\t\tshapes.sort((a, b) => shapePageBounds[b.id].height - shapePageBounds[a.id].height)\n\n\t\t// Start with is (sort of) the square of the area\n\t\tconst startWidth = Math.max(Math.ceil(Math.sqrt(area / 0.95)), maxWidth)\n\n\t\t// first shape fills the width and is infinitely tall\n\t\tconst spaces: Box2d[] = [new Box2d(commonBounds.x, commonBounds.y, startWidth, Infinity)]\n\n\t\tlet width = 0\n\t\tlet height = 0\n\t\tlet space: Box2d\n\t\tlet last: Box2d\n\n\t\tfor (let i = 0; i < shapes.length; i++) {\n\t\t\tshape = shapes[i]\n\t\t\tbounds = nextShapePageBounds[shape.id]\n\n\t\t\t// starting at the back (smaller shapes)\n\t\t\tfor (let i = spaces.length - 1; i >= 0; i--) {\n\t\t\t\tspace = spaces[i]\n\n\t\t\t\t// find a space that is big enough to contain the shape\n\t\t\t\tif (bounds.width > space.width || bounds.height > space.height) continue\n\n\t\t\t\t// add the shape to its top-left corner\n\t\t\t\tbounds.x = space.x\n\t\t\t\tbounds.y = space.y\n\n\t\t\t\theight = Math.max(height, bounds.maxY)\n\t\t\t\twidth = Math.max(width, bounds.maxX)\n\n\t\t\t\tif (bounds.width === space.width && bounds.height === space.height) {\n\t\t\t\t\t// remove the space on a perfect fit\n\t\t\t\t\tlast = spaces.pop()!\n\t\t\t\t\tif (i < spaces.length) spaces[i] = last\n\t\t\t\t} else if (bounds.height === space.height) {\n\t\t\t\t\t// fit the shape into the space (width)\n\t\t\t\t\tspace.x += bounds.width + padding\n\t\t\t\t\tspace.width -= bounds.width + padding\n\t\t\t\t} else if (bounds.width === space.width) {\n\t\t\t\t\t// fit the shape into the space (height)\n\t\t\t\t\tspace.y += bounds.height + padding\n\t\t\t\t\tspace.height -= bounds.height + padding\n\t\t\t\t} else {\n\t\t\t\t\t// split the space into two spaces\n\t\t\t\t\tspaces.push(\n\t\t\t\t\t\tnew Box2d(\n\t\t\t\t\t\t\tspace.x + (bounds.width + padding),\n\t\t\t\t\t\t\tspace.y,\n\t\t\t\t\t\t\tspace.width - (bounds.width + padding),\n\t\t\t\t\t\t\tbounds.height\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t\tspace.y += bounds.height + padding\n\t\t\t\t\tspace.height -= bounds.height + padding\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tconst commonAfter = Box2d.Common(Object.values(nextShapePageBounds))\n\t\tconst centerDelta = Vec2d.Sub(commonBounds.center, commonAfter.center)\n\n\t\tlet nextBounds: Box2d\n\n\t\tconst changes: TLShapePartial<any>[] = []\n\n\t\tfor (let i = 0; i < shapes.length; i++) {\n\t\t\tshape = shapes[i]\n\t\t\tbounds = shapePageBounds[shape.id]\n\t\t\tnextBounds = nextShapePageBounds[shape.id]\n\n\t\t\tconst delta = this.getDeltaInParentSpace(\n\t\t\t\tshape,\n\t\t\t\tVec2d.Sub(nextBounds.point, bounds.point).add(centerDelta)\n\t\t\t)\n\n\t\t\tconst change: TLShapePartial = {\n\t\t\t\tid: shape.id,\n\t\t\t\ttype: shape.type,\n\t\t\t\tx: shape.x + delta.x,\n\t\t\t\ty: shape.y + delta.y,\n\t\t\t}\n\n\t\t\tconst translateStartChange = this.getShapeUtil(shape).onTranslateStart?.({\n\t\t\t\t...shape,\n\t\t\t\t...change,\n\t\t\t})\n\n\t\t\tif (translateStartChange) {\n\t\t\t\tchanges.push({ ...change, ...translateStartChange })\n\t\t\t} else {\n\t\t\t\tchanges.push(change)\n\t\t\t}\n\t\t}\n\n\t\tif (changes.length) {\n\t\t\tthis.updateShapes(changes)\n\t\t}\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Align shape positions.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.alignShapes('left')\n\t * editor.alignShapes('left', ['box1', 'box2'])\n\t * ```\n\t *\n\t * @param operation - The align operation to apply.\n\t * @param ids - The ids of the shapes to align. Defaults to selected shapes.\n\t *\n\t * @public\n\t */\n\talignShapes(\n\t\toperation: 'left' | 'center-horizontal' | 'right' | 'top' | 'center-vertical' | 'bottom',\n\t\tids: TLShapeId[] = this.pageState.selectedIds\n\t) {\n\t\tif (this.isReadOnly) return this\n\t\tif (ids.length < 2) return this\n\n\t\tconst shapes = compact(ids.map((id) => this.getShapeById(id)))\n\t\tconst shapePageBounds = Object.fromEntries(\n\t\t\tshapes.map((shape) => [shape.id, this.getPageBounds(shape)])\n\t\t)\n\t\tconst commonBounds = Box2d.Common(compact(Object.values(shapePageBounds)))\n\n\t\tconst changes: TLShapePartial[] = []\n\n\t\tshapes.forEach((shape) => {\n\t\t\tconst pageBounds = shapePageBounds[shape.id]\n\t\t\tif (!pageBounds) return\n\n\t\t\tconst delta = { x: 0, y: 0 }\n\n\t\t\tswitch (operation) {\n\t\t\t\tcase 'top': {\n\t\t\t\t\tdelta.y = commonBounds.minY - pageBounds.minY\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tcase 'center-vertical': {\n\t\t\t\t\tdelta.y = commonBounds.midY - pageBounds.minY - pageBounds.height / 2\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tcase 'bottom': {\n\t\t\t\t\tdelta.y = commonBounds.maxY - pageBounds.minY - pageBounds.height\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tcase 'left': {\n\t\t\t\t\tdelta.x = commonBounds.minX - pageBounds.minX\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tcase 'center-horizontal': {\n\t\t\t\t\tdelta.x = commonBounds.midX - pageBounds.minX - pageBounds.width / 2\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tcase 'right': {\n\t\t\t\t\tdelta.x = commonBounds.maxX - pageBounds.minX - pageBounds.width\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst parent = this.getParentShape(shape)\n\t\t\tconst localDelta = parent ? Vec2d.Rot(delta, -this.getPageRotation(parent)) : delta\n\n\t\t\tconst translateChanges = this.getShapeUtil(shape).onTranslateStart?.(shape)\n\n\t\t\tchanges.push(\n\t\t\t\ttranslateChanges\n\t\t\t\t\t? {\n\t\t\t\t\t\t\t...translateChanges,\n\t\t\t\t\t\t\tx: shape.x + localDelta.x,\n\t\t\t\t\t\t\ty: shape.y + localDelta.y,\n\t\t\t\t\t  }\n\t\t\t\t\t: {\n\t\t\t\t\t\t\tid: shape.id,\n\t\t\t\t\t\t\ttype: shape.type,\n\t\t\t\t\t\t\tx: shape.x + localDelta.x,\n\t\t\t\t\t\t\ty: shape.y + localDelta.y,\n\t\t\t\t\t  }\n\t\t\t)\n\t\t})\n\n\t\tthis.updateShapes(changes)\n\t\treturn this\n\t}\n\n\t/**\n\t * Distribute shape positions.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.distributeShapes('left')\n\t * editor.distributeShapes('left', ['box1', 'box2'])\n\t * ```\n\t *\n\t * @param operation - Whether to distribute shapes horizontally or vertically.\n\t * @param ids - The ids of the shapes to distribute. Defaults to selected shapes.\n\t *\n\t * @public\n\t */\n\tdistributeShapes(\n\t\toperation: 'horizontal' | 'vertical',\n\t\tids: TLShapeId[] = this.pageState.selectedIds\n\t) {\n\t\tif (this.isReadOnly) return this\n\t\tif (ids.length < 3) return this\n\n\t\tconst len = ids.length\n\t\tconst shapes = compact(ids.map((id) => this.getShapeById(id)))\n\t\tconst pageBounds = Object.fromEntries(\n\t\t\tshapes.map((shape) => [shape.id, this.getPageBounds(shape)!])\n\t\t)\n\n\t\tlet val: 'x' | 'y'\n\t\tlet min: 'minX' | 'minY'\n\t\tlet max: 'maxX' | 'maxY'\n\t\tlet mid: 'midX' | 'midY'\n\t\tlet dim: 'width' | 'height'\n\n\t\tif (operation === 'horizontal') {\n\t\t\tval = 'x'\n\t\t\tmin = 'minX'\n\t\t\tmax = 'maxX'\n\t\t\tmid = 'midX'\n\t\t\tdim = 'width'\n\t\t} else {\n\t\t\tval = 'y'\n\t\t\tmin = 'minY'\n\t\t\tmax = 'maxY'\n\t\t\tmid = 'midY'\n\t\t\tdim = 'height'\n\t\t}\n\t\tconst changes: TLShapePartial[] = []\n\n\t\t// Clustered\n\t\tconst first = shapes.sort((a, b) => pageBounds[a.id][min] - pageBounds[b.id][min])[0]\n\t\tconst last = shapes.sort((a, b) => pageBounds[b.id][max] - pageBounds[a.id][max])[0]\n\n\t\tconst midFirst = pageBounds[first.id][mid]\n\t\tconst step = (pageBounds[last.id][mid] - midFirst) / (len - 1)\n\t\tconst v = midFirst + step\n\n\t\tshapes\n\t\t\t.filter((shape) => shape !== first && shape !== last)\n\t\t\t.sort((a, b) => pageBounds[a.id][mid] - pageBounds[b.id][mid])\n\t\t\t.forEach((shape, i) => {\n\t\t\t\tconst delta = { x: 0, y: 0 }\n\t\t\t\tdelta[val] = v + step * i - pageBounds[shape.id][dim] / 2 - pageBounds[shape.id][val]\n\n\t\t\t\tconst parent = this.getParentShape(shape)\n\t\t\t\tconst localDelta = parent ? Vec2d.Rot(delta, -this.getPageRotation(parent)) : delta\n\t\t\t\tconst translateStartChanges = this.getShapeUtil(shape).onTranslateStart?.(shape)\n\n\t\t\t\tchanges.push(\n\t\t\t\t\ttranslateStartChanges\n\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t...translateStartChanges,\n\t\t\t\t\t\t\t\t[val]: shape[val] + localDelta[val],\n\t\t\t\t\t\t  }\n\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\tid: shape.id,\n\t\t\t\t\t\t\t\ttype: shape.type,\n\t\t\t\t\t\t\t\t[val]: shape[val] + localDelta[val],\n\t\t\t\t\t\t  }\n\t\t\t\t)\n\t\t\t})\n\n\t\tthis.updateShapes(changes)\n\t\treturn this\n\t}\n\n\t/** @internal */\n\tprivate _resizeUnalignedShape(\n\t\tid: TLShapeId,\n\t\tscale: VecLike,\n\t\toptions: {\n\t\t\tinitialBounds: Box2d\n\t\t\tscaleOrigin: VecLike\n\t\t\tscaleAxisRotation: number\n\t\t\tinitialShape: TLShape\n\t\t\tinitialPageTransform: MatLike\n\t\t}\n\t) {\n\t\tconst { type } = options.initialShape\n\t\t// If a shape is not aligned with the scale axis we need to treat it differently to avoid skewing.\n\t\t// Instead of skewing we normalize the scale aspect ratio (i.e. keep the same scale magnitude in both axes)\n\t\t// and then after applying the scale to the shape we also rotate it if required and translate it so that it's center\n\t\t// point ends up in the right place.\n\n\t\tconst shapeScale = new Vec2d(scale.x, scale.y)\n\n\t\t// // make sure we are constraining aspect ratio, and using the smallest scale axis to avoid shapes getting bigger\n\t\t// // than the selection bounding box\n\t\tif (Math.abs(scale.x) > Math.abs(scale.y)) {\n\t\t\tshapeScale.x = Math.sign(scale.x) * Math.abs(scale.y)\n\t\t} else {\n\t\t\tshapeScale.y = Math.sign(scale.y) * Math.abs(scale.x)\n\t\t}\n\n\t\t// first we can scale the shape about its center point\n\t\tthis.resizeShape(id, shapeScale, {\n\t\t\tinitialShape: options.initialShape,\n\t\t\tinitialBounds: options.initialBounds,\n\t\t})\n\n\t\t// then if the shape is flipped in one axis only, we need to apply an extra rotation\n\t\t// to make sure the shape is mirrored correctly\n\t\tif (Math.sign(scale.x) * Math.sign(scale.y) < 0) {\n\t\t\tlet { rotation } = Matrix2d.Decompose(options.initialPageTransform)\n\t\t\trotation -= 2 * rotation\n\t\t\tthis.updateShapes([{ id, type, rotation }], true)\n\t\t}\n\n\t\t// Next we need to translate the shape so that it's center point ends up in the right place.\n\t\t// To do that we first need to calculate the center point of the shape in page space before the scale was applied.\n\t\tconst preScaleShapePageCenter = Matrix2d.applyToPoint(\n\t\t\toptions.initialPageTransform,\n\t\t\toptions.initialBounds.center\n\t\t)\n\n\t\t// And now we scale the center point by the original scale factor\n\t\tconst postScaleShapePageCenter = this._scalePagePoint(\n\t\t\tpreScaleShapePageCenter,\n\t\t\toptions.scaleOrigin,\n\t\t\tscale,\n\t\t\toptions.scaleAxisRotation\n\t\t)\n\n\t\t// now calculate how far away the shape is from where it needs to be\n\t\tconst currentPageCenter = this.getPageCenterById(id)\n\t\tconst currentPagePoint = this.getPagePointById(id)\n\t\tif (!currentPageCenter || !currentPagePoint) return this\n\t\tconst pageDelta = Vec2d.Sub(postScaleShapePageCenter, currentPageCenter)\n\n\t\t// and finally figure out what the shape's new position should be\n\t\tconst postScaleShapePagePoint = Vec2d.Add(currentPagePoint, pageDelta)\n\t\tconst { x, y } = this.getPointInParentSpace(id, postScaleShapePagePoint)\n\n\t\tthis.updateShapes([{ id, type, x, y }], true)\n\n\t\treturn this\n\t}\n\n\t/** @internal */\n\tprivate _scalePagePoint(\n\t\tpoint: VecLike,\n\t\tscaleOrigin: VecLike,\n\t\tscale: VecLike,\n\t\tscaleAxisRotation: number\n\t) {\n\t\tconst relativePoint = Vec2d.RotWith(point, scaleOrigin, -scaleAxisRotation).sub(scaleOrigin)\n\n\t\t// calculate the new point position relative to the scale origin\n\t\tconst newRelativePagePoint = Vec2d.MulV(relativePoint, scale)\n\n\t\t// and rotate it back to page coords to get the new page point of the resized shape\n\t\tconst destination = Vec2d.Add(newRelativePagePoint, scaleOrigin).rotWith(\n\t\t\tscaleOrigin,\n\t\t\tscaleAxisRotation\n\t\t)\n\n\t\treturn destination\n\t}\n\n\t/**\n\t * Resize a shape.\n\t *\n\t * @param id - The id of the shape to resize.\n\t * @param scale - The scale factor to apply to the shape.\n\t * @param options - Additional options.\n\t *\n\t * @public\n\t */\n\tresizeShape(\n\t\tid: TLShapeId,\n\t\tscale: VecLike,\n\t\toptions: {\n\t\t\tinitialBounds?: Box2d\n\t\t\tscaleOrigin?: VecLike\n\t\t\tscaleAxisRotation?: number\n\t\t\tinitialShape?: TLShape\n\t\t\tinitialPageTransform?: MatLike\n\t\t\tdragHandle?: TLResizeHandle\n\t\t\tmode?: TLResizeMode\n\t\t} = {}\n\t) {\n\t\tif (this.isReadOnly) return this\n\n\t\tif (!Number.isFinite(scale.x)) scale = new Vec2d(1, scale.y)\n\t\tif (!Number.isFinite(scale.y)) scale = new Vec2d(scale.x, 1)\n\n\t\tconst initialShape = options.initialShape ?? this.getShapeById(id)\n\t\tif (!initialShape) return this\n\n\t\tconst scaleOrigin = options.scaleOrigin ?? this.getPageBoundsById(id)?.center\n\t\tif (!scaleOrigin) return this\n\n\t\tconst pageRotation = this.getPageRotationById(id)\n\n\t\tif (pageRotation == null) return this\n\n\t\tconst scaleAxisRotation = options.scaleAxisRotation ?? pageRotation\n\n\t\tconst pageTransform = options.initialPageTransform ?? this.getPageTransformById(id)\n\t\tif (!pageTransform) return this\n\n\t\tconst initialBounds = options.initialBounds ?? this.getBoundsById(id)\n\n\t\tif (!initialBounds) return this\n\n\t\tif (!areAnglesCompatible(pageRotation, scaleAxisRotation)) {\n\t\t\t// shape is awkwardly rotated, keep the aspect ratio locked and adopt the scale factor\n\t\t\t// from whichever axis is being scaled the least, to avoid the shape getting bigger\n\t\t\t// than the bounds of the selection\n\t\t\t// const minScale = Math.min(Math.abs(scale.x), Math.abs(scale.y))\n\t\t\treturn this._resizeUnalignedShape(id, scale, {\n\t\t\t\t...options,\n\t\t\t\tinitialBounds,\n\t\t\t\tscaleOrigin,\n\t\t\t\tscaleAxisRotation,\n\t\t\t\tinitialPageTransform: pageTransform,\n\t\t\t\tinitialShape,\n\t\t\t})\n\t\t}\n\n\t\tconst util = this.getShapeUtil(initialShape)\n\n\t\tif (util.isAspectRatioLocked(initialShape)) {\n\t\t\tif (Math.abs(scale.x) > Math.abs(scale.y)) {\n\t\t\t\tscale = new Vec2d(scale.x, Math.sign(scale.y) * Math.abs(scale.x))\n\t\t\t} else {\n\t\t\t\tscale = new Vec2d(Math.sign(scale.x) * Math.abs(scale.y), scale.y)\n\t\t\t}\n\t\t}\n\n\t\tif (util.onResize && util.canResize(initialShape)) {\n\t\t\t// get the model changes from the shape util\n\t\t\tconst newPagePoint = this._scalePagePoint(\n\t\t\t\tMatrix2d.applyToPoint(pageTransform, new Vec2d(0, 0)),\n\t\t\t\tscaleOrigin,\n\t\t\t\tscale,\n\t\t\t\tscaleAxisRotation\n\t\t\t)\n\n\t\t\tconst newLocalPoint = this.getPointInParentSpace(initialShape.id, newPagePoint)\n\n\t\t\t// resize the shape's local bounding box\n\t\t\tconst myScale = new Vec2d(scale.x, scale.y)\n\t\t\t// the shape is aligned with the rest of the shapes in the selection, but may be\n\t\t\t// 90deg offset from the main rotation of the selection, in which case\n\t\t\t// we need to flip the width and height scale factors\n\t\t\tconst areWidthAndHeightAlignedWithCorrectAxis = approximately(\n\t\t\t\t(pageRotation - scaleAxisRotation) % Math.PI,\n\t\t\t\t0\n\t\t\t)\n\t\t\tmyScale.x = areWidthAndHeightAlignedWithCorrectAxis ? scale.x : scale.y\n\t\t\tmyScale.y = areWidthAndHeightAlignedWithCorrectAxis ? scale.y : scale.x\n\n\t\t\t// adjust initial model for situations where the parent has moved during the resize\n\t\t\t// e.g. groups\n\t\t\tconst initialPagePoint = Matrix2d.applyToPoint(pageTransform, new Vec2d())\n\n\t\t\t// need to adjust the shape's x and y points in case the parent has moved since start of resizing\n\t\t\tconst { x, y } = this.getPointInParentSpace(initialShape.id, initialPagePoint)\n\n\t\t\tthis.updateShapes(\n\t\t\t\t[\n\t\t\t\t\t{\n\t\t\t\t\t\tid,\n\t\t\t\t\t\ttype: initialShape.type as any,\n\t\t\t\t\t\tx: newLocalPoint.x,\n\t\t\t\t\t\ty: newLocalPoint.y,\n\t\t\t\t\t\t...util.onResize(\n\t\t\t\t\t\t\t{ ...initialShape, x, y },\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tnewPoint: newLocalPoint,\n\t\t\t\t\t\t\t\thandle: options.dragHandle ?? 'bottom_right',\n\t\t\t\t\t\t\t\t// don't set isSingle to true for children\n\t\t\t\t\t\t\t\tmode: options.mode ?? 'scale_shape',\n\t\t\t\t\t\t\t\tscaleX: myScale.x,\n\t\t\t\t\t\t\t\tscaleY: myScale.y,\n\t\t\t\t\t\t\t\tinitialBounds,\n\t\t\t\t\t\t\t\tinitialShape,\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t),\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\ttrue\n\t\t\t)\n\t\t} else {\n\t\t\tconst initialPageCenter = Matrix2d.applyToPoint(pageTransform, initialBounds.center)\n\t\t\t// get the model changes from the shape util\n\t\t\tconst newPageCenter = this._scalePagePoint(\n\t\t\t\tinitialPageCenter,\n\t\t\t\tscaleOrigin,\n\t\t\t\tscale,\n\t\t\t\tscaleAxisRotation\n\t\t\t)\n\n\t\t\tconst initialPageCenterInParentSpace = this.getPointInParentSpace(\n\t\t\t\tinitialShape.id,\n\t\t\t\tinitialPageCenter\n\t\t\t)\n\t\t\tconst newPageCenterInParentSpace = this.getPointInParentSpace(initialShape.id, newPageCenter)\n\n\t\t\tconst delta = Vec2d.Sub(newPageCenterInParentSpace, initialPageCenterInParentSpace)\n\t\t\t// apply the changes to the model\n\t\t\tthis.updateShapes(\n\t\t\t\t[\n\t\t\t\t\t{\n\t\t\t\t\t\tid,\n\t\t\t\t\t\ttype: initialShape.type as any,\n\t\t\t\t\t\tx: initialShape.x + delta.x,\n\t\t\t\t\t\ty: initialShape.y + delta.y,\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\ttrue\n\t\t\t)\n\t\t}\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Stretch shape sizes and positions to fill their common bounding box.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.stretchShapes('horizontal')\n\t * editor.stretchShapes('horizontal', ['box1', 'box2'])\n\t * ```\n\t *\n\t * @param operation - Whether to stretch shapes horizontally or vertically.\n\t * @param ids - The ids of the shapes to stretch. Defaults to selected shapes.\n\t *\n\t * @public\n\t */\n\tstretchShapes(\n\t\toperation: 'horizontal' | 'vertical',\n\t\tids: TLShapeId[] = this.pageState.selectedIds\n\t) {\n\t\tif (this.isReadOnly) return this\n\t\tif (ids.length < 2) return this\n\n\t\tconst shapes = compact(ids.map((id) => this.getShapeById(id)))\n\t\tconst shapeBounds = Object.fromEntries(shapes.map((shape) => [shape.id, this.getBounds(shape)]))\n\t\tconst shapePageBounds = Object.fromEntries(\n\t\t\tshapes.map((shape) => [shape.id, this.getPageBounds(shape)!])\n\t\t)\n\t\tconst commonBounds = Box2d.Common(compact(Object.values(shapePageBounds)))\n\n\t\tconst changes: TLShapePartial[] = []\n\n\t\tswitch (operation) {\n\t\t\tcase 'vertical': {\n\t\t\t\tthis.batch(() => {\n\t\t\t\t\tfor (const shape of shapes) {\n\t\t\t\t\t\tconst pageRotation = this.getPageRotation(shape)\n\t\t\t\t\t\tif (pageRotation % PI2) continue\n\t\t\t\t\t\tconst bounds = shapeBounds[shape.id]\n\t\t\t\t\t\tconst pageBounds = shapePageBounds[shape.id]\n\t\t\t\t\t\tconst localOffset = this.getDeltaInParentSpace(\n\t\t\t\t\t\t\tshape,\n\t\t\t\t\t\t\tnew Vec2d(0, commonBounds.minY - pageBounds.minY)\n\t\t\t\t\t\t)\n\t\t\t\t\t\tconst { x, y } = Vec2d.Add(localOffset, shape)\n\t\t\t\t\t\tthis.updateShapes([{ id: shape.id, type: shape.type, x, y }], true)\n\t\t\t\t\t\tconst scale = new Vec2d(1, commonBounds.height / pageBounds.height)\n\t\t\t\t\t\tthis.resizeShape(shape.id, scale, {\n\t\t\t\t\t\t\tinitialBounds: bounds,\n\t\t\t\t\t\t\tscaleOrigin: new Vec2d(pageBounds.center.x, commonBounds.minY),\n\t\t\t\t\t\t\tscaleAxisRotation: 0,\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase 'horizontal': {\n\t\t\t\tthis.batch(() => {\n\t\t\t\t\tfor (const shape of shapes) {\n\t\t\t\t\t\tconst bounds = shapeBounds[shape.id]\n\t\t\t\t\t\tconst pageBounds = shapePageBounds[shape.id]\n\t\t\t\t\t\tconst pageRotation = this.getPageRotation(shape)\n\t\t\t\t\t\tif (pageRotation % PI2) continue\n\t\t\t\t\t\tconst localOffset = this.getDeltaInParentSpace(\n\t\t\t\t\t\t\tshape,\n\t\t\t\t\t\t\tnew Vec2d(commonBounds.minX - pageBounds.minX, 0)\n\t\t\t\t\t\t)\n\t\t\t\t\t\tconst { x, y } = Vec2d.Add(localOffset, shape)\n\t\t\t\t\t\tthis.updateShapes([{ id: shape.id, type: shape.type, x, y }], true)\n\t\t\t\t\t\tconst scale = new Vec2d(commonBounds.width / pageBounds.width, 1)\n\t\t\t\t\t\tthis.resizeShape(shape.id, scale, {\n\t\t\t\t\t\t\tinitialBounds: bounds,\n\t\t\t\t\t\t\tscaleOrigin: new Vec2d(commonBounds.minX, pageBounds.center.y),\n\t\t\t\t\t\t\tscaleAxisRotation: 0,\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t})\n\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tthis.updateShapes(changes)\n\t\treturn this\n\t}\n\n\t/**\n\t * An array containing all of the shapes in the current page.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.shapesArray\n\t * ```\n\t *\n\t * @readonly\n\t *\n\t * @public\n\t */\n\t@computed get shapesArray() {\n\t\treturn Array.from(this.currentPageShapeIds, (id) => this.store.get(id)! as TLShape)\n\t}\n\n\t/**\n\t * An array containing all of the shapes in the current page, sorted in z-index order (accounting\n\t * for nested shapes): e.g. A, B, BA, BB, C.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.sortedShapesArray\n\t * ```\n\t *\n\t * @readonly\n\t *\n\t * @public\n\t */\n\t@computed get sortedShapesArray(): TLShape[] {\n\t\tconst shapes = new Set(this.shapesArray.sort(sortByIndex))\n\n\t\tconst results: TLShape[] = []\n\n\t\tfunction pushShapeWithDescendants(shape: TLShape): void {\n\t\t\tresults.push(shape)\n\t\t\tshapes.delete(shape)\n\n\t\t\tshapes.forEach((otherShape) => {\n\t\t\t\tif (otherShape.parentId === shape.id) {\n\t\t\t\t\tpushShapeWithDescendants(otherShape)\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\n\t\tshapes.forEach((shape) => {\n\t\t\tconst parent = this.getShapeById(shape.parentId)\n\t\t\tif (!isShape(parent)) {\n\t\t\t\tpushShapeWithDescendants(shape)\n\t\t\t}\n\t\t})\n\n\t\treturn results\n\t}\n\n\t/**\n\t * An array containing all of the currently selected shapes.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.selectedShapes\n\t * ```\n\t *\n\t * @public\n\t * @readonly\n\t */\n\t@computed get selectedShapes(): TLShape[] {\n\t\tconst { selectedIds } = this.pageState\n\t\treturn compact(selectedIds.map((id) => this.store.get(id)))\n\t}\n\n\t/**\n\t * The app's only selected shape.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.onlySelectedShape\n\t * ```\n\t *\n\t * @returns Null if there is no shape or more than one selected shape, otherwise the selected\n\t *   shape.\n\t *\n\t * @public\n\t * @readonly\n\t */\n\t@computed get onlySelectedShape(): TLShape | null {\n\t\tconst { selectedShapes } = this\n\t\treturn selectedShapes.length === 1 ? selectedShapes[0] : null\n\t}\n\n\t/**\n\t * Get whether a shape matches the type of a TLShapeUtil.\n\t *\n\t * @example\n\t * ```ts\n\t * const isArrowShape = isShapeOfType(someShape, ArrowShapeUtil)\n\t * ```\n\t *\n\t * @param util - the TLShapeUtil constructor to test against\n\t * @param shape - the shape to test\n\t *\n\t * @public\n\t */\n\tisShapeOfType<T extends TLUnknownShape>(\n\t\tshape: TLUnknownShape,\n\t\tutil: { new (...args: any): ShapeUtil<T>; type: string }\n\t): shape is T {\n\t\treturn shape.type === util.type\n\t}\n\n\t/**\n\t * Get a shape by its id.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.getShapeById('box1')\n\t * ```\n\t *\n\t * @param id - The id of the shape to get.\n\t *\n\t * @public\n\t */\n\tgetShapeById<T extends TLShape = TLShape>(id: TLParentId): T | undefined {\n\t\tif (!isShapeId(id)) return undefined\n\t\treturn this.store.get(id) as T\n\t}\n\n\t/**\n\t * Get the parent shape for a given shape. Returns undefined if the shape is the direct child of\n\t * the page.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.getParentShape(myShape)\n\t * ```\n\t *\n\t * @public\n\t */\n\tgetParentShape(shape?: TLShape): TLShape | undefined {\n\t\tif (shape === undefined || !isShapeId(shape.parentId)) return undefined\n\t\treturn this.store.get(shape.parentId)\n\t}\n\n\t/**\n\t * If siblingShape and targetShape are siblings, this returns targetShape. If targetShape has an\n\t * ancestor who is a sibling of siblingShape, this returns that ancestor. Otherwise, this returns\n\t * undefined.\n\t *\n\t * @internal\n\t */\n\tprivate getShapeNearestSibling(\n\t\tsiblingShape: TLShape,\n\t\ttargetShape: TLShape | undefined\n\t): TLShape | undefined {\n\t\tif (!targetShape) {\n\t\t\treturn undefined\n\t\t}\n\t\tif (targetShape.parentId === siblingShape.parentId) {\n\t\t\treturn targetShape\n\t\t}\n\n\t\tconst ancestor = this.findAncestor(\n\t\t\ttargetShape,\n\t\t\t(ancestor) => ancestor.parentId === siblingShape.parentId\n\t\t)\n\n\t\treturn ancestor\n\t}\n\n\t/**\n\t * Get whether the given shape is the descendant of the given page.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.isShapeInPage(myShape)\n\t * editor.isShapeInPage(myShape, 'page1')\n\t * ```\n\t *\n\t * @param shape - The shape to check.\n\t * @param pageId - The id of the page to check against. Defaults to the current page.\n\t *\n\t * @public\n\t */\n\tisShapeInPage(shape: TLShape, pageId = this.currentPageId): boolean {\n\t\tlet shapeIsInPage = false\n\n\t\tif (shape.parentId === pageId) {\n\t\t\tshapeIsInPage = true\n\t\t} else {\n\t\t\tlet parent = this.getShapeById(shape.parentId)\n\t\t\tisInPageSearch: while (parent) {\n\t\t\t\tif (parent.parentId === pageId) {\n\t\t\t\t\tshapeIsInPage = true\n\t\t\t\t\tbreak isInPageSearch\n\t\t\t\t}\n\t\t\t\tparent = this.getShapeById(parent.parentId)\n\t\t\t}\n\t\t}\n\n\t\treturn shapeIsInPage\n\t}\n\n\t/**\n\t * Get the id of the containing page for a given shape.\n\t *\n\t * @param shape - The shape to get the page id for.\n\t *\n\t * @returns The id of the page that contains the shape, or undefined if the shape is undefined.\n\t *\n\t * @public\n\t */\n\tgetAncestorPageId(shape?: TLShape): TLPageId | undefined {\n\t\tif (shape === undefined) return undefined\n\t\tif (isPageId(shape.parentId)) {\n\t\t\treturn shape.parentId\n\t\t} else {\n\t\t\treturn this.getAncestorPageId(this.getShapeById(shape.parentId))\n\t\t}\n\t}\n\n\t// Parents and children\n\n\t/**\n\t * A cache of parents to children.\n\t *\n\t * @internal\n\t */\n\tprivate readonly _parentIdsToChildIds: ReturnType<typeof parentsToChildrenWithIndexes>\n\n\t/**\n\t * Reparent shapes to a new parent. This operation preserves the shape's current page positions /\n\t * rotations.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.reparentShapesById(['box1', 'box2'], 'frame1')\n\t * ```\n\t *\n\t * @param ids - The ids of the shapes to reparent.\n\t * @param parentId - The id of the new parent shape.\n\t * @param insertIndex - The index to insert the children.\n\t *\n\t * @public\n\t */\n\treparentShapesById(ids: TLShapeId[], parentId: TLParentId, insertIndex?: string) {\n\t\tconst changes: TLShapePartial[] = []\n\n\t\tconst parentTransform = isPageId(parentId)\n\t\t\t? Matrix2d.Identity()\n\t\t\t: this.getPageTransformById(parentId)!\n\n\t\tconst parentPageRotation = parentTransform.decompose().rotation\n\n\t\tlet indices: string[] = []\n\n\t\tconst sibs = compact(this.getSortedChildIds(parentId).map((id) => this.getShapeById(id)))\n\n\t\tif (insertIndex) {\n\t\t\tconst sibWithInsertIndex = sibs.find((s) => s.index === insertIndex)\n\t\t\tif (sibWithInsertIndex) {\n\t\t\t\t// If there's a sibling with the same index as the insert index...\n\t\t\t\tconst sibAbove = sibs[sibs.indexOf(sibWithInsertIndex) + 1]\n\t\t\t\tif (sibAbove) {\n\t\t\t\t\t// If the sibling has a sibling above it, insert the shapes\n\t\t\t\t\t// between the sibling and its sibling above it.\n\t\t\t\t\tindices = getIndicesBetween(insertIndex, sibAbove.index, ids.length)\n\t\t\t\t} else {\n\t\t\t\t\t// Or if the sibling is the top sibling, insert the shapes\n\t\t\t\t\t// above the sibling\n\t\t\t\t\tindices = getIndicesAbove(insertIndex, ids.length)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// If there's no collision, then we can start at the insert index\n\t\t\t\tconst sibAbove = sibs.sort(sortByIndex).find((s) => s.index > insertIndex)\n\n\t\t\t\tif (sibAbove) {\n\t\t\t\t\t// If the siblings include a sibling with a higher index, insert the shapes\n\t\t\t\t\t// between the insert index and the sibling with the higher index.\n\t\t\t\t\tindices = getIndicesBetween(insertIndex, sibAbove.index, ids.length)\n\t\t\t\t} else {\n\t\t\t\t\t// Otherwise, we're at the top of the order, so insert the shapes above\n\t\t\t\t\t// the insert index.\n\t\t\t\t\tindices = getIndicesAbove(insertIndex, ids.length)\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// If insert index is not specified, start the index at the top.\n\t\t\tconst sib = sibs.length && sibs[sibs.length - 1]\n\t\t\tindices = sib ? getIndicesAbove(sib.index, ids.length) : getIndices(ids.length)\n\t\t}\n\n\t\tlet id: TLShapeId\n\t\tfor (let i = 0; i < ids.length; i++) {\n\t\t\tid = ids[i]\n\t\t\tconst shape = this.getShapeById(id)\n\t\t\tconst pagePoint = this.getPagePointById(id)\n\n\t\t\tif (!shape || !pagePoint) continue\n\n\t\t\tconst newPoint = Matrix2d.applyToPoint(Matrix2d.Inverse(parentTransform), pagePoint)\n\t\t\tconst newRotation = this.getPageRotation(shape) - parentPageRotation\n\n\t\t\tchanges.push({\n\t\t\t\tid: shape.id,\n\t\t\t\ttype: shape.type,\n\t\t\t\tparentId: parentId,\n\t\t\t\tx: newPoint.x,\n\t\t\t\ty: newPoint.y,\n\t\t\t\trotation: newRotation,\n\t\t\t\tindex: indices[i],\n\t\t\t})\n\t\t}\n\n\t\tthis.updateShapes(changes)\n\t\treturn this\n\t}\n\n\t/**\n\t * Get the index above the highest child of a given parent.\n\t *\n\t * @param parentId - The id of the parent.\n\t *\n\t * @returns The index.\n\t *\n\t * @public\n\t */\n\tgetHighestIndexForParent(parentId: TLShapeId | TLPageId) {\n\t\tconst children = this._parentIdsToChildIds.value[parentId]\n\n\t\tif (!children || children.length === 0) {\n\t\t\treturn 'a1'\n\t\t}\n\t\treturn getIndexAbove(children[children.length - 1][1])\n\t}\n\n\t/**\n\t * A cache of children for each parent.\n\t *\n\t * @internal\n\t */\n\tprivate _childIdsCache = new WeakMapCache<any[], TLShapeId[]>()\n\n\t/**\n\t * Get an array of all the children of a shape.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.getSortedChildIds('frame1')\n\t * ```\n\t *\n\t * @param parentId - The id of the parent shape.\n\t *\n\t * @public\n\t */\n\tgetSortedChildIds(parentId: TLParentId): TLShapeId[] {\n\t\tconst withIndices = this._parentIdsToChildIds.value[parentId]\n\t\tif (!withIndices) return EMPTY_ARRAY\n\t\treturn this._childIdsCache.get(withIndices, () => withIndices.map(([id]) => id))\n\t}\n\n\t/**\n\t * Run a visitor function for all descendants of a shape.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.visitDescendants('frame1', myCallback)\n\t * ```\n\t *\n\t * @param parentId - The id of the parent shape.\n\t * @param visitor - The visitor function.\n\t *\n\t * @public\n\t */\n\tvisitDescendants(parentId: TLParentId, visitor: (id: TLShapeId) => void | false) {\n\t\tconst children = this.getSortedChildIds(parentId)\n\t\tfor (const id of children) {\n\t\t\tif (visitor(id) === false) continue\n\t\t\tthis.visitDescendants(id, visitor)\n\t\t}\n\t}\n\n\t/**\n\t * Get the shape ids of all descendants of the given shapes (including the shapes themselves).\n\t *\n\t * @param ids - The ids of the shapes to get descendants of.\n\t *\n\t * @returns The decscendant ids.\n\t *\n\t * @public\n\t */\n\tgetShapeAndDescendantIds(ids: TLShapeId[]): Set<TLShapeId> {\n\t\tconst idsToInclude = new Set<TLShapeId>()\n\n\t\tconst idsToCheck = [...ids]\n\n\t\twhile (idsToCheck.length > 0) {\n\t\t\tconst id = idsToCheck.pop()\n\t\t\tif (!id) break\n\t\t\tif (idsToInclude.has(id)) continue\n\t\t\tidsToInclude.add(id)\n\t\t\tthis.getSortedChildIds(id).forEach((id) => {\n\t\t\t\tidsToCheck.push(id)\n\t\t\t})\n\t\t}\n\n\t\treturn idsToInclude\n\t}\n\n\t/**\n\t * Get the id of what should be the parent of a new shape at a given point. The parent can be a page or shape.\n\t *\n\t * @param point - The point to find the parent for.\n\t * @param shapeType - The type of shape that will be created.\n\t *\n\t * @returns The id of the parent.\n\t *\n\t * @public\n\t */\n\tgetParentIdForNewShapeAtPoint(point: VecLike, shapeType: TLShape['type']) {\n\t\tconst shapes = this.sortedShapesArray\n\n\t\tfor (let i = shapes.length - 1; i >= 0; i--) {\n\t\t\tconst shape = shapes[i]\n\t\t\tconst util = this.getShapeUtil(shape)\n\t\t\tif (!util.canReceiveNewChildrenOfType(shape, shapeType)) continue\n\t\t\tconst maskedPageBounds = this.getMaskedPageBoundsById(shape.id)\n\t\t\tif (\n\t\t\t\tmaskedPageBounds &&\n\t\t\t\tmaskedPageBounds.containsPoint(point) &&\n\t\t\t\tutil.hitTestPoint(shape, this.getPointInShapeSpace(shape, point))\n\t\t\t) {\n\t\t\t\treturn shape.id\n\t\t\t}\n\t\t}\n\n\t\treturn this.focusLayerId\n\t}\n\n\t/**\n\t * Get the shape that some shapes should be dropped on at a given point.\n\t *\n\t * @param point - The point to find the parent for.\n\t * @param droppingShapes - The shapes that are being dropped.\n\t *\n\t * @returns The shape to drop on.\n\t *\n\t * @public\n\t */\n\tgetDroppingShape(point: VecLike, droppingShapes: TLShape[] = []) {\n\t\tconst shapes = this.sortedShapesArray\n\n\t\tfor (let i = shapes.length - 1; i >= 0; i--) {\n\t\t\tconst shape = shapes[i]\n\t\t\t// don't allow dropping a shape on itself or one of it's children\n\t\t\tif (droppingShapes.find((s) => s.id === shape.id || this.hasAncestor(shape, s.id))) continue\n\t\t\tconst util = this.getShapeUtil(shape)\n\t\t\tif (!util.canDropShapes(shape, droppingShapes)) continue\n\t\t\tconst maskedPageBounds = this.getMaskedPageBoundsById(shape.id)\n\t\t\tif (\n\t\t\t\tmaskedPageBounds &&\n\t\t\t\tmaskedPageBounds.containsPoint(point) &&\n\t\t\t\tutil.hitTestPoint(shape, this.getPointInShapeSpace(shape, point))\n\t\t\t) {\n\t\t\t\treturn shape\n\t\t\t}\n\t\t}\n\n\t\treturn undefined\n\t}\n\n\t/**\n\t * Get the shape that should be selected when you click on a given shape, assuming there is\n\t * nothing already selected. It will not return anything higher than or including the current\n\t * focus layer.\n\t *\n\t * @param shape - The shape to get the outermost selectable shape for.\n\t * @param filter - A function to filter the selectable shapes.\n\t *\n\t * @returns The outermost selectable shape.\n\t *\n\t * @public\n\t */\n\tgetOutermostSelectableShape(shape: TLShape, filter?: (shape: TLShape) => boolean): TLShape {\n\t\tlet match = shape\n\t\tlet node = shape as TLShape | undefined\n\t\twhile (node) {\n\t\t\tif (\n\t\t\t\tthis.isShapeOfType(node, GroupShapeUtil) &&\n\t\t\t\tthis.focusLayerId !== node.id &&\n\t\t\t\t!this.hasAncestor(this.focusLayerShape, node.id) &&\n\t\t\t\t(filter?.(node) ?? true)\n\t\t\t) {\n\t\t\t\tmatch = node\n\t\t\t} else if (this.focusLayerId === node.id) {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tnode = this.getParentShape(node)\n\t\t}\n\n\t\treturn match\n\t}\n\n\t/* -------------------- Commands -------------------- */\n\n\t/**\n\t * Set the current page.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.setCurrentPageId('page1')\n\t * ```\n\t *\n\t * @param pageId - The id of the page to set as the current page.\n\t * @param options - Options for setting the current page.\n\t *\n\t * @public\n\t */\n\tsetCurrentPageId(pageId: TLPageId, { stopFollowing = true }: TLViewportOptions = {}): this {\n\t\tthis._setCurrentPageId(pageId, { stopFollowing })\n\t\treturn this\n\t}\n\n\t/** @internal */\n\tprivate _setCurrentPageId = this.history.createCommand(\n\t\t'setCurrentPage',\n\t\t(pageId: TLPageId, { stopFollowing = true }: TLViewportOptions = {}) => {\n\t\t\tif (!this.store.has(pageId)) {\n\t\t\t\tconsole.error(\"Tried to set the current page id to a page that doesn't exist.\")\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif (stopFollowing && this.instanceState.followingUserId) {\n\t\t\t\tthis.stopFollowingUser()\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tdata: { toId: pageId, fromId: this.currentPageId },\n\t\t\t\tsquashing: true,\n\t\t\t\tpreservesRedoStack: true,\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\tdo: ({ toId }) => {\n\t\t\t\tif (!this.store.has(toId)) {\n\t\t\t\t\t// in multiplayer contexts this page might have been deleted\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif (!this.getPageStateByPageId(toId)) {\n\t\t\t\t\tconst camera = CameraRecordType.create({\n\t\t\t\t\t\tid: CameraRecordType.createId(toId),\n\t\t\t\t\t})\n\t\t\t\t\tthis.store.put([\n\t\t\t\t\t\tcamera,\n\t\t\t\t\t\tInstancePageStateRecordType.create({\n\t\t\t\t\t\t\tid: InstancePageStateRecordType.createId(toId),\n\t\t\t\t\t\t\tpageId: toId,\n\t\t\t\t\t\t}),\n\t\t\t\t\t])\n\t\t\t\t}\n\n\t\t\t\tthis.store.put([{ ...this.instanceState, currentPageId: toId }])\n\n\t\t\t\tthis.updateRenderingBounds()\n\t\t\t},\n\t\t\tundo: ({ fromId }) => {\n\t\t\t\tif (!this.store.has(fromId)) {\n\t\t\t\t\t// in multiplayer contexts this page might have been deleted\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tthis.store.put([{ ...this.instanceState, currentPageId: fromId }])\n\n\t\t\t\tthis.updateRenderingBounds()\n\t\t\t},\n\t\t\tsquash: ({ fromId }, { toId }) => {\n\t\t\t\treturn { toId, fromId }\n\t\t\t},\n\t\t}\n\t)\n\n\t/**\n\t * Update the instance's state.\n\t *\n\t * @param partial - A partial object to update the instance state with.\n\t * @param ephemeral - Whether the change is ephemeral. Ephemeral changes don't get added to the undo/redo stack. Defaults to false.\n\t * @param squashing - Whether the change will be squashed into the existing history entry rather than creating a new one. Defaults to false.\n\t *\n\t * @public\n\t */\n\tupdateInstanceState(\n\t\tpartial: Partial<Omit<TLInstance, 'currentPageId'>>,\n\t\tephemeral = false,\n\t\tsquashing = false\n\t) {\n\t\tthis._updateInstanceState(partial, ephemeral, squashing)\n\t\treturn this\n\t}\n\n\t/** @internal */\n\tprivate _updateInstanceState = this.history.createCommand(\n\t\t'updateTabState',\n\t\t(partial: Partial<Omit<TLInstance, 'currentPageId'>>, ephemeral = false, squashing = false) => {\n\t\t\tconst prev = this.instanceState\n\t\t\tconst next = { ...prev, ...partial }\n\n\t\t\treturn {\n\t\t\t\tdata: { prev, next },\n\t\t\t\tsquashing,\n\t\t\t\tephemeral,\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\tdo: ({ next }) => {\n\t\t\t\tthis.store.put([next])\n\t\t\t},\n\t\t\tundo: ({ prev }) => {\n\t\t\t\tthis.store.put([prev])\n\t\t\t},\n\t\t\tsquash({ prev }, { next }) {\n\t\t\t\treturn { prev, next }\n\t\t\t},\n\t\t}\n\t)\n\n\t/**\n\t * Set the current cursor.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.setCursor({ type: 'default' })\n\t * editor.setCursor({ type: 'default', rotation: Math.PI / 2, color: 'red' })\n\t * ```\n\t *\n\t * @param cursor - A partial of the cursor object.\n\t *\n\t * @public\n\t */\n\tsetCursor(cursor: Partial<TLCursor>): this {\n\t\tconst current = this.cursor\n\t\tconst next = {\n\t\t\t...current,\n\t\t\trotation: 0,\n\t\t\t...cursor,\n\t\t}\n\n\t\tif (\n\t\t\t!(\n\t\t\t\tcurrent.type === next.type &&\n\t\t\t\tcurrent.rotation === next.rotation &&\n\t\t\t\tcurrent.color === next.color\n\t\t\t)\n\t\t) {\n\t\t\tthis.updateInstanceState({ cursor: next }, true)\n\t\t}\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Set the current scribble.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.setScribble(nextScribble)\n\t * editor.setScribble() // clears the scribble\n\t * ```\n\t *\n\t * @param scribble - The new scribble object.\n\t *\n\t * @public\n\t */\n\tsetScribble(scribble: TLScribble | null = null): this {\n\t\tthis.updateInstanceState({ scribble }, true)\n\t\treturn this\n\t}\n\n\t/**\n\t * Set the current brush.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.setBrush({ x: 0, y: 0, w: 100, h: 100 })\n\t * editor.setBrush() // Clears the brush\n\t * ```\n\t *\n\t * @param brush - The brush box model to set, or null for no brush model.\n\t *\n\t * @public\n\t */\n\tsetBrush(brush: Box2dModel | null = null): this {\n\t\tif (!brush && !this.brush) return this\n\t\tthis.updateInstanceState({ brush }, true)\n\t\treturn this\n\t}\n\n\t/**\n\t * Set the current zoom brush.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.setZoomBrush({ x: 0, y: 0, w: 100, h: 100 })\n\t * editor.setZoomBrush() // Clears the zoom\n\t * ```\n\t *\n\t * @param zoomBrush - The zoom box model to set, or null for no zoom model.\n\t *\n\t * @public\n\t */\n\tsetZoomBrush(zoomBrush: Box2dModel | null = null): this {\n\t\tif (!zoomBrush && !this.zoomBrush) return this\n\t\tthis.updateInstanceState({ zoomBrush }, true)\n\t\treturn this\n\t}\n\n\t/**\n\t * Rotate shapes by a delta in radians.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.rotateShapesBy(['box1', 'box2'], Math.PI)\n\t * editor.rotateShapesBy(['box1', 'box2'], Math.PI / 2)\n\t * ```\n\t *\n\t * @param ids - The ids of the shapes to move.\n\t * @param delta - The delta in radians to apply to the selection rotation.\n\t */\n\trotateShapesBy(ids: TLShapeId[], delta: number): this {\n\t\tif (ids.length <= 0) return this\n\n\t\tconst snapshot = getRotationSnapshot({ editor: this })\n\t\tapplyRotationToSnapshotShapes({ delta, snapshot, editor: this, stage: 'one-off' })\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Move shapes by a delta.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.nudgeShapes(['box1', 'box2'], { x: 0, y: 1 })\n\t * editor.nudgeShapes(['box1', 'box2'], { x: 0, y: 1 }, true)\n\t * ```\n\t *\n\t * @param ids - The ids of the shapes to move.\n\t * @param direction - The direction in which to move the shapes.\n\t * @param major - Whether this is a major nudge, e.g. a shift + arrow nudge.\n\t */\n\tnudgeShapes(ids: TLShapeId[], direction: Vec2dModel, major = false, ephemeral = false): this {\n\t\tif (ids.length <= 0) return this\n\n\t\tconst step = this.isGridMode\n\t\t\t? major\n\t\t\t\t? this.gridSize * GRID_INCREMENT\n\t\t\t\t: this.gridSize\n\t\t\t: major\n\t\t\t? MAJOR_NUDGE_FACTOR\n\t\t\t: MINOR_NUDGE_FACTOR\n\n\t\tconst steppedDelta = Vec2d.Mul(direction, step)\n\t\tconst changes: TLShapePartial[] = []\n\n\t\tfor (const id of ids) {\n\t\t\tconst shape = this.getShapeById(id)\n\n\t\t\tif (!shape) {\n\t\t\t\tthrow Error(`Could not find a shape with the id ${id}.`)\n\t\t\t}\n\n\t\t\tconst localDelta = this.getDeltaInParentSpace(shape, steppedDelta)\n\t\t\tconst translateStartChanges = this.getShapeUtil(shape).onTranslateStart?.(shape)\n\n\t\t\tchanges.push(\n\t\t\t\ttranslateStartChanges\n\t\t\t\t\t? {\n\t\t\t\t\t\t\t...translateStartChanges,\n\t\t\t\t\t\t\tx: shape.x + localDelta.x,\n\t\t\t\t\t\t\ty: shape.y + localDelta.y,\n\t\t\t\t\t  }\n\t\t\t\t\t: {\n\t\t\t\t\t\t\tid,\n\t\t\t\t\t\t\tx: shape.x + localDelta.x,\n\t\t\t\t\t\t\ty: shape.y + localDelta.y,\n\t\t\t\t\t\t\ttype: shape.type,\n\t\t\t\t\t  }\n\t\t\t)\n\t\t}\n\n\t\tthis.updateShapes(changes, ephemeral)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Duplicate shapes.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.duplicateShapes()\n\t * editor.duplicateShapes(['id1', 'id2'])\n\t * editor.duplicateShapes(['id1', 'id2'], { x: 8, y: 8 })\n\t * ```\n\t *\n\t * @param ids - The ids of the shapes to duplicate. Defaults to the ids of the selected shapes.\n\t * @param offset - The offset (in pixels) to apply to the duplicated shapes.\n\t *\n\t * @public\n\t */\n\tduplicateShapes(ids: TLShapeId[] = this.selectedIds, offset?: VecLike): this {\n\t\tif (ids.length <= 0) return this\n\n\t\tconst initialIds = new Set(ids)\n\t\tconst idsToCreate: TLShapeId[] = []\n\t\tconst idsToCheck = [...ids]\n\n\t\twhile (idsToCheck.length > 0) {\n\t\t\tconst id = idsToCheck.pop()\n\t\t\tif (!id) break\n\t\t\tidsToCreate.push(id)\n\t\t\tthis.getSortedChildIds(id).forEach((childId) => idsToCheck.push(childId))\n\t\t}\n\n\t\tidsToCreate.reverse()\n\n\t\tconst idsMap = new Map<any, TLShapeId>(idsToCreate.map((id) => [id, createShapeId()]))\n\n\t\tconst shapesToCreate = compact(\n\t\t\tidsToCreate.map((id) => {\n\t\t\t\tconst shape = this.getShapeById(id)\n\n\t\t\t\tif (!shape) {\n\t\t\t\t\treturn null\n\t\t\t\t}\n\n\t\t\t\tconst createId = idsMap.get(id)!\n\n\t\t\t\tlet ox = 0\n\t\t\t\tlet oy = 0\n\n\t\t\t\tif (offset && initialIds.has(id)) {\n\t\t\t\t\tconst parentTransform = this.getParentTransform(shape)\n\t\t\t\t\tconst vec = new Vec2d(offset.x, offset.y).rot(\n\t\t\t\t\t\t-Matrix2d.Decompose(parentTransform).rotation\n\t\t\t\t\t)\n\t\t\t\t\tox = vec.x\n\t\t\t\t\toy = vec.y\n\t\t\t\t}\n\n\t\t\t\tconst parentId = shape.parentId ?? this.currentPageId\n\t\t\t\tconst siblings = this.getSortedChildIds(parentId)\n\t\t\t\tconst currentIndex = siblings.indexOf(shape.id)\n\t\t\t\tconst siblingAboveId = siblings[currentIndex + 1]\n\t\t\t\tconst siblingAbove = siblingAboveId ? this.getShapeById(siblingAboveId) : null\n\n\t\t\t\tconst index = siblingAbove\n\t\t\t\t\t? getIndexBetween(shape.index, siblingAbove.index)\n\t\t\t\t\t: getIndexAbove(shape.index)\n\n\t\t\t\tlet newShape: TLShape = deepCopy(shape)\n\n\t\t\t\tif (\n\t\t\t\t\tthis.isShapeOfType(shape, ArrowShapeUtil) &&\n\t\t\t\t\tthis.isShapeOfType(newShape, ArrowShapeUtil)\n\t\t\t\t) {\n\t\t\t\t\tconst info = this.getShapeUtil(ArrowShapeUtil).getArrowInfo(shape)\n\t\t\t\t\tlet newStartShapeId: TLShapeId | undefined = undefined\n\t\t\t\t\tlet newEndShapeId: TLShapeId | undefined = undefined\n\n\t\t\t\t\tif (shape.props.start.type === 'binding') {\n\t\t\t\t\t\tnewStartShapeId = idsMap.get(shape.props.start.boundShapeId)\n\n\t\t\t\t\t\tif (!newStartShapeId) {\n\t\t\t\t\t\t\tif (info?.isValid) {\n\t\t\t\t\t\t\t\tconst { x, y } = info.start.point\n\t\t\t\t\t\t\t\tnewShape.props.start = {\n\t\t\t\t\t\t\t\t\ttype: 'point',\n\t\t\t\t\t\t\t\t\tx,\n\t\t\t\t\t\t\t\t\ty,\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tconst { start } = getArrowTerminalsInArrowSpace(this, shape)\n\t\t\t\t\t\t\t\tnewShape.props.start = {\n\t\t\t\t\t\t\t\t\ttype: 'point',\n\t\t\t\t\t\t\t\t\tx: start.x,\n\t\t\t\t\t\t\t\t\ty: start.y,\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (shape.props.end.type === 'binding') {\n\t\t\t\t\t\tnewEndShapeId = idsMap.get(shape.props.end.boundShapeId)\n\t\t\t\t\t\tif (!newEndShapeId) {\n\t\t\t\t\t\t\tif (info?.isValid) {\n\t\t\t\t\t\t\t\tconst { x, y } = info.end.point\n\t\t\t\t\t\t\t\tnewShape.props.end = {\n\t\t\t\t\t\t\t\t\ttype: 'point',\n\t\t\t\t\t\t\t\t\tx,\n\t\t\t\t\t\t\t\t\ty,\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tconst { end } = getArrowTerminalsInArrowSpace(this, shape)\n\t\t\t\t\t\t\t\tnewShape.props.start = {\n\t\t\t\t\t\t\t\t\ttype: 'point',\n\t\t\t\t\t\t\t\t\tx: end.x,\n\t\t\t\t\t\t\t\t\ty: end.y,\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tconst infoAfter = getIsArrowStraight(newShape)\n\t\t\t\t\t\t? getStraightArrowInfo(this, newShape)\n\t\t\t\t\t\t: getCurvedArrowInfo(this, newShape)\n\n\t\t\t\t\tif (info?.isValid && infoAfter?.isValid && !getIsArrowStraight(shape)) {\n\t\t\t\t\t\tconst mpA = Vec2d.Med(info.start.handle, info.end.handle)\n\t\t\t\t\t\tconst distA = Vec2d.Dist(info.middle, mpA)\n\t\t\t\t\t\tconst distB = Vec2d.Dist(infoAfter.middle, mpA)\n\t\t\t\t\t\tif (newShape.props.bend < 0) {\n\t\t\t\t\t\t\tnewShape.props.bend += distB - distA\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnewShape.props.bend -= distB - distA\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (newShape.props.start.type === 'binding' && newStartShapeId) {\n\t\t\t\t\t\tnewShape.props.start.boundShapeId = newStartShapeId\n\t\t\t\t\t}\n\n\t\t\t\t\tif (newShape.props.end.type === 'binding' && newEndShapeId) {\n\t\t\t\t\t\tnewShape.props.end.boundShapeId = newEndShapeId\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tnewShape = { ...newShape, id: createId, x: shape.x + ox, y: shape.y + oy, index }\n\n\t\t\t\treturn newShape\n\t\t\t})\n\t\t)\n\n\t\tshapesToCreate.forEach((shape) => {\n\t\t\tif (isShapeId(shape.parentId)) {\n\t\t\t\tif (idsMap.has(shape.parentId)) {\n\t\t\t\t\tshape.parentId = idsMap.get(shape.parentId)!\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\n\t\tthis.history.batch(() => {\n\t\t\tconst maxShapesReached =\n\t\t\t\tshapesToCreate.length + this.currentPageShapeIds.size > MAX_SHAPES_PER_PAGE\n\n\t\t\tif (maxShapesReached) {\n\t\t\t\talertMaxShapes(this)\n\t\t\t}\n\n\t\t\tconst newShapes = maxShapesReached\n\t\t\t\t? shapesToCreate.slice(0, MAX_SHAPES_PER_PAGE - this.currentPageShapeIds.size)\n\t\t\t\t: shapesToCreate\n\n\t\t\tconst ids = newShapes.map((s) => s.id)\n\n\t\t\tthis.createShapes(newShapes)\n\t\t\tthis.setSelectedIds(ids)\n\n\t\t\tif (offset !== undefined) {\n\t\t\t\t// If we've offset the duplicated shapes, check to see whether their new bounds is entirely\n\t\t\t\t// contained in the current viewport. If not, then animate the camera to be centered on the\n\t\t\t\t// new shapes.\n\t\t\t\tconst { viewportPageBounds, selectedPageBounds } = this\n\t\t\t\tif (selectedPageBounds && !viewportPageBounds.contains(selectedPageBounds)) {\n\t\t\t\t\tthis.centerOnPoint(selectedPageBounds.center.x, selectedPageBounds.center.y, {\n\t\t\t\t\t\tduration: ANIMATION_MEDIUM_MS,\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Set the current opacity. This will effect any selected shapes, or the\n\t * next-created shape.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.setOpacity(0.5)\n\t * editor.setOpacity(0.5, true)\n\t * ```\n\t *\n\t * @param opacity - The opacity to set. Must be a number between 0 and 1 inclusive.\n\t * @param ephemeral - Whether the opacity change is ephemeral. Ephemeral changes don't get added to the undo/redo stack. Defaults to false.\n\t * @param squashing - Whether the opacity change will be squashed into the existing history entry rather than creating a new one. Defaults to false.\n\t */\n\tsetOpacity(opacity: number, ephemeral = false, squashing = false): this {\n\t\tthis.history.batch(() => {\n\t\t\tif (this.isIn('select')) {\n\t\t\t\tconst {\n\t\t\t\t\tpageState: { selectedIds },\n\t\t\t\t} = this\n\n\t\t\t\tconst shapesToUpdate: TLShape[] = []\n\n\t\t\t\t// We can have many deep levels of grouped shape\n\t\t\t\t// Making a recursive function to look through all the levels\n\t\t\t\tconst addShapeById = (id: TLShape['id']) => {\n\t\t\t\t\tconst shape = this.getShapeById(id)\n\t\t\t\t\tif (!shape) return\n\t\t\t\t\tif (this.isShapeOfType(shape, GroupShapeUtil)) {\n\t\t\t\t\t\tconst childIds = this.getSortedChildIds(id)\n\t\t\t\t\t\tfor (const childId of childIds) {\n\t\t\t\t\t\t\taddShapeById(childId)\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tshapesToUpdate.push(shape)\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (selectedIds.length > 0) {\n\t\t\t\t\tfor (const id of selectedIds) {\n\t\t\t\t\t\taddShapeById(id)\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.updateShapes(\n\t\t\t\t\t\tshapesToUpdate.map((shape) => {\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tid: shape.id,\n\t\t\t\t\t\t\t\ttype: shape.type,\n\t\t\t\t\t\t\t\topacity,\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tephemeral\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.updateInstanceState({ opacityForNextShape: opacity }, ephemeral, squashing)\n\t\t})\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Set the current styles\n\t *\n\t * @example\n\t * ```ts\n\t * editor.setProp(DefaultColorStyle, 'red')\n\t * editor.setProp(DefaultColorStyle, 'red', true)\n\t * ```\n\t *\n\t * @param style - The style to set.\n\t * @param value - The value to set.\n\t * @param ephemeral - Whether the style change is ephemeral. Ephemeral changes don't get added to the undo/redo stack. Defaults to false.\n\t * @param squashing - Whether the style change will be squashed into the existing history entry rather than creating a new one. Defaults to false.\n\t *\n\t * @public\n\t */\n\tsetStyle<T>(style: StyleProp<T>, value: T, ephemeral = false, squashing = false): this {\n\t\tthis.history.batch(() => {\n\t\t\tif (this.isIn('select')) {\n\t\t\t\tconst {\n\t\t\t\t\tpageState: { selectedIds },\n\t\t\t\t} = this\n\n\t\t\t\tif (selectedIds.length > 0) {\n\t\t\t\t\tconst updates: { originalShape: TLShape; updatePartial: TLShapePartial }[] = []\n\n\t\t\t\t\t// We can have many deep levels of grouped shape\n\t\t\t\t\t// Making a recursive function to look through all the levels\n\t\t\t\t\tconst addShapeById = (id: TLShape['id']) => {\n\t\t\t\t\t\tconst shape = this.getShapeById(id)\n\t\t\t\t\t\tif (!shape) return\n\t\t\t\t\t\tif (this.isShapeOfType(shape, GroupShapeUtil)) {\n\t\t\t\t\t\t\tconst childIds = this.getSortedChildIds(id)\n\t\t\t\t\t\t\tfor (const childId of childIds) {\n\t\t\t\t\t\t\t\taddShapeById(childId)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst util = this.getShapeUtil(shape)\n\t\t\t\t\t\t\tif (util.hasStyle(style)) {\n\t\t\t\t\t\t\t\tconst shapePartial: TLShapePartial = {\n\t\t\t\t\t\t\t\t\tid: shape.id,\n\t\t\t\t\t\t\t\t\ttype: shape.type,\n\t\t\t\t\t\t\t\t\tprops: {},\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tupdates.push({\n\t\t\t\t\t\t\t\t\toriginalShape: shape,\n\t\t\t\t\t\t\t\t\tupdatePartial: util.setStyleInPartial(style, shapePartial, value),\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (const id of selectedIds) {\n\t\t\t\t\t\taddShapeById(id)\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.updateShapes(\n\t\t\t\t\t\tupdates.map(({ updatePartial }) => updatePartial),\n\t\t\t\t\t\tephemeral\n\t\t\t\t\t)\n\n\t\t\t\t\t// TODO: find a way to sink this stuff into shape utils directly?\n\t\t\t\t\tconst changes: TLShapePartial[] = []\n\t\t\t\t\tfor (const { originalShape: originalShape } of updates) {\n\t\t\t\t\t\tconst currentShape = this.getShapeById(originalShape.id)\n\t\t\t\t\t\tif (!currentShape) continue\n\t\t\t\t\t\tconst util = this.getShapeUtil(currentShape)\n\n\t\t\t\t\t\tconst boundsA = util.bounds(originalShape)\n\t\t\t\t\t\tconst boundsB = util.bounds(currentShape)\n\n\t\t\t\t\t\tconst change: TLShapePartial = { id: originalShape.id, type: originalShape.type }\n\n\t\t\t\t\t\tlet didChange = false\n\n\t\t\t\t\t\tif (boundsA.width !== boundsB.width) {\n\t\t\t\t\t\t\tdidChange = true\n\n\t\t\t\t\t\t\tif (this.isShapeOfType(originalShape, TextShapeUtil)) {\n\t\t\t\t\t\t\t\tswitch (originalShape.props.align) {\n\t\t\t\t\t\t\t\t\tcase 'middle': {\n\t\t\t\t\t\t\t\t\t\tchange.x = currentShape.x + (boundsA.width - boundsB.width) / 2\n\t\t\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tcase 'end': {\n\t\t\t\t\t\t\t\t\t\tchange.x = currentShape.x + boundsA.width - boundsB.width\n\t\t\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tchange.x = currentShape.x + (boundsA.width - boundsB.width) / 2\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (boundsA.height !== boundsB.height) {\n\t\t\t\t\t\t\tdidChange = true\n\t\t\t\t\t\t\tchange.y = currentShape.y + (boundsA.height - boundsB.height) / 2\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (didChange) {\n\t\t\t\t\t\t\tchanges.push(change)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (changes.length) {\n\t\t\t\t\t\tthis.updateShapes(changes, ephemeral)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.updateInstanceState(\n\t\t\t\t{\n\t\t\t\t\tstylesForNextShape: { ...this._stylesForNextShape, [style.id]: value },\n\t\t\t\t},\n\t\t\t\tephemeral,\n\t\t\t\tsquashing\n\t\t\t)\n\t\t})\n\n\t\treturn this\n\t}\n\n\t/** @internal */\n\tprivate _willSetInitialBounds = true\n\n\t/** @internal */\n\tprivate _setCamera(x: number, y: number, z = this.camera.z): this {\n\t\tconst currentCamera = this.camera\n\t\tif (currentCamera.x === x && currentCamera.y === y && currentCamera.z === z) return this\n\t\tconst nextCamera = { ...currentCamera, x, y, z }\n\n\t\tthis.batch(() => {\n\t\t\tthis.store.put([nextCamera])\n\n\t\t\tconst { currentScreenPoint } = this.inputs\n\n\t\t\tthis.dispatch({\n\t\t\t\ttype: 'pointer',\n\t\t\t\ttarget: 'canvas',\n\t\t\t\tname: 'pointer_move',\n\t\t\t\tpoint: currentScreenPoint,\n\t\t\t\tpointerId: INTERNAL_POINTER_IDS.CAMERA_MOVE,\n\t\t\t\tctrlKey: this.inputs.ctrlKey,\n\t\t\t\taltKey: this.inputs.altKey,\n\t\t\t\tshiftKey: this.inputs.shiftKey,\n\t\t\t\tbutton: 0,\n\t\t\t\tisPen: this.isPenMode ?? false,\n\t\t\t})\n\n\t\t\tthis._tickCameraState()\n\t\t})\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Set the current camera.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.setCamera(0, 0)\n\t * editor.setCamera(0, 0, 1)\n\t * ```\n\t *\n\t * @param x - The camera's x position.\n\t * @param y - The camera's y position.\n\t * @param z - The camera's z position. Defaults to the current zoom.\n\t * @param options - Options for the camera change.\n\t *\n\t * @public\n\t */\n\tsetCamera(\n\t\tx: number,\n\t\ty: number,\n\t\tz = this.camera.z,\n\t\t{ stopFollowing = true }: TLViewportOptions = {}\n\t): this {\n\t\tthis.stopCameraAnimation()\n\t\tif (stopFollowing && this.instanceState.followingUserId) {\n\t\t\tthis.stopFollowingUser()\n\t\t}\n\t\tx = Number.isNaN(x) ? 0 : x\n\t\ty = Number.isNaN(y) ? 0 : y\n\t\tz = Number.isNaN(z) ? 1 : z\n\t\tthis._setCamera(x, y, z)\n\t\treturn this\n\t}\n\n\t/**\n\t * Animate the camera.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.animateCamera(0, 0)\n\t * editor.animateCamera(0, 0, 1)\n\t * editor.animateCamera(0, 0, 1, { duration: 1000, easing: (t) => t * t })\n\t * ```\n\t *\n\t * @param x - The camera's x position.\n\t * @param y - The camera's y position.\n\t * @param z - The camera's z position. Defaults to the current zoom.\n\t * @param opts - Options for the animation.\n\t *\n\t * @public\n\t */\n\tanimateCamera(\n\t\tx: number,\n\t\ty: number,\n\t\tz = this.camera.z,\n\t\topts: TLAnimationOptions = DEFAULT_ANIMATION_OPTIONS\n\t): this {\n\t\tx = Number.isNaN(x) ? 0 : x\n\t\ty = Number.isNaN(y) ? 0 : y\n\t\tz = Number.isNaN(z) ? 1 : z\n\t\tconst { width, height } = this.viewportScreenBounds\n\t\tconst w = width / z\n\t\tconst h = height / z\n\n\t\tconst targetViewport = new Box2d(-x, -y, w, h)\n\n\t\treturn this._animateToViewport(targetViewport, opts)\n\t}\n\n\t/**\n\t * Center the camera on a point (in page space).\n\t *\n\t * @example\n\t * ```ts\n\t * editor.centerOnPoint(100, 100)\n\t * ```\n\t *\n\t * @param x - The x position of the point.\n\t * @param y - The y position of the point.\n\t * @param opts - The options for an animation.\n\t *\n\t * @public\n\t */\n\tcenterOnPoint(x: number, y: number, opts?: TLAnimationOptions): this {\n\t\tif (!this.canMoveCamera) return this\n\n\t\tconst {\n\t\t\tviewportPageBounds: { width: pw, height: ph },\n\t\t\tcamera,\n\t\t} = this\n\n\t\tif (opts?.duration) {\n\t\t\tthis.animateCamera(-(x - pw / 2), -(y - ph / 2), camera.z, opts)\n\t\t} else {\n\t\t\tthis.setCamera(-(x - pw / 2), -(y - ph / 2), camera.z)\n\t\t}\n\t\treturn this\n\t}\n\n\t/**\n\t * Move the camera to the nearest content.\n\t *\n\t * @public\n\t */\n\tzoomToContent() {\n\t\tconst bounds = this.selectedPageBounds ?? this.allShapesCommonBounds\n\n\t\tif (bounds) {\n\t\t\tthis.zoomToBounds(\n\t\t\t\tbounds.minX,\n\t\t\t\tbounds.minY,\n\t\t\t\tbounds.width,\n\t\t\t\tbounds.height,\n\t\t\t\tMath.min(1, this.zoomLevel),\n\t\t\t\t{ duration: 220 }\n\t\t\t)\n\t\t}\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Zoom the camera to fit the current page's content in the viewport.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.zoomToFit()\n\t * ```\n\t *\n\t * @public\n\t */\n\tzoomToFit(opts?: TLAnimationOptions): this {\n\t\tif (!this.canMoveCamera) return this\n\n\t\tconst ids = [...this.currentPageShapeIds]\n\t\tif (ids.length <= 0) return this\n\n\t\tconst pageBounds = Box2d.Common(compact(ids.map((id) => this.getPageBoundsById(id))))\n\t\tthis.zoomToBounds(\n\t\t\tpageBounds.minX,\n\t\t\tpageBounds.minY,\n\t\t\tpageBounds.width,\n\t\t\tpageBounds.height,\n\t\t\tundefined,\n\t\t\topts\n\t\t)\n\t\treturn this\n\t}\n\n\t/**\n\t * Set the zoom back to 100%.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.resetZoom()\n\t * ```\n\t *\n\t * @param opts - The options for an animation.\n\t *\n\t * @public\n\t */\n\tresetZoom(point = this.viewportScreenCenter, opts?: TLAnimationOptions): this {\n\t\tif (!this.canMoveCamera) return this\n\n\t\tconst { x: cx, y: cy, z: cz } = this.camera\n\t\tconst { x, y } = point\n\t\tif (opts?.duration) {\n\t\t\tthis.animateCamera(cx + (x / 1 - x) - (x / cz - x), cy + (y / 1 - y) - (y / cz - y), 1, opts)\n\t\t} else {\n\t\t\tthis.setCamera(cx + (x / 1 - x) - (x / cz - x), cy + (y / 1 - y) - (y / cz - y), 1)\n\t\t}\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Zoom the camera in.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.zoomIn()\n\t * editor.zoomIn(editor.viewportScreenCenter, { duration: 120 })\n\t * editor.zoomIn(editor.inputs.currentScreenPoint, { duration: 120 })\n\t * ```\n\t *\n\t * @param opts - The options for an animation.\n\t *\n\t * @public\n\t */\n\tzoomIn(point = this.viewportScreenCenter, opts?: TLAnimationOptions): this {\n\t\tif (!this.canMoveCamera) return this\n\n\t\tconst { x: cx, y: cy, z: cz } = this.camera\n\n\t\tlet zoom = MAX_ZOOM\n\n\t\tfor (let i = 1; i < ZOOMS.length; i++) {\n\t\t\tconst z1 = ZOOMS[i - 1]\n\t\t\tconst z2 = ZOOMS[i]\n\t\t\tif (z2 - cz <= (z2 - z1) / 2) continue\n\t\t\tzoom = z2\n\t\t\tbreak\n\t\t}\n\n\t\tconst { x, y } = point\n\t\tif (opts?.duration) {\n\t\t\tthis.animateCamera(\n\t\t\t\tcx + (x / zoom - x) - (x / cz - x),\n\t\t\t\tcy + (y / zoom - y) - (y / cz - y),\n\t\t\t\tzoom,\n\t\t\t\topts\n\t\t\t)\n\t\t} else {\n\t\t\tthis.setCamera(cx + (x / zoom - x) - (x / cz - x), cy + (y / zoom - y) - (y / cz - y), zoom)\n\t\t}\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Zoom the camera out.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.zoomOut()\n\t * editor.zoomOut(editor.viewportScreenCenter, { duration: 120 })\n\t * editor.zoomOut(editor.inputs.currentScreenPoint, { duration: 120 })\n\t * ```\n\t *\n\t * @param opts - The options for an animation.\n\t *\n\t * @public\n\t */\n\tzoomOut(point = this.viewportScreenCenter, opts?: TLAnimationOptions): this {\n\t\tif (!this.canMoveCamera) return this\n\n\t\tconst { x: cx, y: cy, z: cz } = this.camera\n\n\t\tlet zoom = MIN_ZOOM\n\n\t\tfor (let i = ZOOMS.length - 1; i > 0; i--) {\n\t\t\tconst z1 = ZOOMS[i - 1]\n\t\t\tconst z2 = ZOOMS[i]\n\t\t\tif (z2 - cz >= (z2 - z1) / 2) continue\n\t\t\tzoom = z1\n\t\t\tbreak\n\t\t}\n\n\t\tconst { x, y } = point\n\n\t\tif (opts?.duration) {\n\t\t\tthis.animateCamera(\n\t\t\t\tcx + (x / zoom - x) - (x / cz - x),\n\t\t\t\tcy + (y / zoom - y) - (y / cz - y),\n\t\t\t\tzoom,\n\t\t\t\topts\n\t\t\t)\n\t\t} else {\n\t\t\tthis.setCamera(cx + (x / zoom - x) - (x / cz - x), cy + (y / zoom - y) - (y / cz - y), zoom)\n\t\t}\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Zoom the camera to fit the current selection in the viewport.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.zoomToSelection()\n\t * ```\n\t *\n\t * @param opts - The options for an animation.\n\t *\n\t * @public\n\t */\n\tzoomToSelection(opts?: TLAnimationOptions): this {\n\t\tif (!this.canMoveCamera) return this\n\n\t\tconst ids = this.selectedIds\n\t\tif (ids.length <= 0) return this\n\n\t\tconst selectedBounds = Box2d.Common(compact(ids.map((id) => this.getPageBoundsById(id))))\n\n\t\tthis.zoomToBounds(\n\t\t\tselectedBounds.minX,\n\t\t\tselectedBounds.minY,\n\t\t\tselectedBounds.width,\n\t\t\tselectedBounds.height,\n\t\t\tMath.max(1, this.camera.z),\n\t\t\topts\n\t\t)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Pan or pan/zoom the selected ids into view. This method tries to not change the zoom if possible.\n\t *\n\t * @param ids - The ids of the shapes to pan and zoom into view.\n\t * @param opts - The options for an animation.\n\t *\n\t * @public\n\t */\n\tpanZoomIntoView(ids: TLShapeId[], opts?: TLAnimationOptions): this {\n\t\tif (!this.canMoveCamera) return this\n\n\t\tif (ids.length <= 0) return this\n\t\tconst selectedBounds = Box2d.Common(compact(ids.map((id) => this.getPageBoundsById(id))))\n\n\t\tconst { viewportPageBounds } = this\n\n\t\tif (viewportPageBounds.h < selectedBounds.h || viewportPageBounds.w < selectedBounds.w) {\n\t\t\tthis.zoomToBounds(\n\t\t\t\tselectedBounds.minX,\n\t\t\t\tselectedBounds.minY,\n\t\t\t\tselectedBounds.width,\n\t\t\t\tselectedBounds.height,\n\t\t\t\tthis.camera.z,\n\t\t\t\topts\n\t\t\t)\n\n\t\t\treturn this\n\t\t} else {\n\t\t\t// TODO: This buffer should calculate the 'active area' of the UI\n\t\t\tconst bufferOffsets = this._activeAreaManager.offsets.value\n\n\t\t\tconst pageTop = viewportPageBounds.y + bufferOffsets.top\n\t\t\tconst pageRight = viewportPageBounds.maxY - bufferOffsets.right\n\t\t\tconst pageBottom = viewportPageBounds.maxY - bufferOffsets.bottom\n\t\t\tconst pageLeft = viewportPageBounds.x + bufferOffsets.left\n\n\t\t\tconst selectedTop = selectedBounds.y\n\t\t\tconst selectedRight = selectedBounds.maxX\n\t\t\tconst selectedBottom = selectedBounds.maxY\n\t\t\tconst selectedLeft = selectedBounds.x\n\n\t\t\tlet offsetX = 0\n\t\t\tlet offsetY = 0\n\t\t\tif (pageBottom < selectedBottom) {\n\t\t\t\t// off bottom\n\t\t\t\toffsetY = pageBottom - selectedBottom\n\t\t\t} else if (pageTop > selectedTop) {\n\t\t\t\t// off top\n\t\t\t\toffsetY = pageTop - selectedTop\n\t\t\t} else {\n\t\t\t\t// inside y-bounds\n\t\t\t}\n\n\t\t\tif (pageRight < selectedRight) {\n\t\t\t\t// off right\n\t\t\t\toffsetX = pageRight - selectedRight\n\t\t\t} else if (pageLeft > selectedLeft) {\n\t\t\t\t// off left\n\t\t\t\toffsetX = pageLeft - selectedLeft\n\t\t\t} else {\n\t\t\t\t// inside x-bounds\n\t\t\t}\n\n\t\t\tconst { camera } = this\n\n\t\t\tif (opts?.duration) {\n\t\t\t\tthis.animateCamera(camera.x + offsetX, camera.y + offsetY, camera.z, opts)\n\t\t\t} else {\n\t\t\t\tthis.setCamera(camera.x + offsetX, camera.y + offsetY, camera.z)\n\t\t\t}\n\t\t}\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Zoom the camera to fit a bounding box (in page space).\n\t *\n\t * @example\n\t * ```ts\n\t * editor.zoomToBounds(0, 0, 100, 100)\n\t * ```\n\t *\n\t * @param x - The bounding box's x position.\n\t * @param y - The bounding box's y position.\n\t * @param width - The bounding box's width.\n\t * @param height - The bounding box's height.\n\t * @param targetZoom - The desired zoom level. Defaults to 0.1.\n\t *\n\t * @public\n\t */\n\tzoomToBounds(\n\t\tx: number,\n\t\ty: number,\n\t\twidth: number,\n\t\theight: number,\n\t\ttargetZoom?: number,\n\t\topts?: TLAnimationOptions\n\t): this {\n\t\tif (!this.canMoveCamera) return this\n\n\t\tconst { viewportScreenBounds } = this\n\n\t\tconst inset = Math.min(256, viewportScreenBounds.width * 0.28)\n\n\t\tlet zoom = clamp(\n\t\t\tMath.min(\n\t\t\t\t(viewportScreenBounds.width - inset) / width,\n\t\t\t\t(viewportScreenBounds.height - inset) / height\n\t\t\t),\n\t\t\tMIN_ZOOM,\n\t\t\tMAX_ZOOM\n\t\t)\n\n\t\tif (targetZoom !== undefined) {\n\t\t\tzoom = Math.min(targetZoom, zoom)\n\t\t}\n\n\t\tif (opts?.duration) {\n\t\t\tthis.animateCamera(\n\t\t\t\t-x + (viewportScreenBounds.width - width * zoom) / 2 / zoom,\n\t\t\t\t-y + (viewportScreenBounds.height - height * zoom) / 2 / zoom,\n\t\t\t\tzoom,\n\t\t\t\topts\n\t\t\t)\n\t\t} else {\n\t\t\tthis.setCamera(\n\t\t\t\t-x + (viewportScreenBounds.width - width * zoom) / 2 / zoom,\n\t\t\t\t-y + (viewportScreenBounds.height - height * zoom) / 2 / zoom,\n\t\t\t\tzoom\n\t\t\t)\n\t\t}\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Pan the camera.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.pan(100, 100)\n\t * editor.pan(100, 100, { duration: 1000 })\n\t * ```\n\t *\n\t * @param dx - The amount to pan on the x axis.\n\t * @param dy - The amount to pan on the y axis.\n\t * @param opts - The animation options\n\t */\n\tpan(dx: number, dy: number, opts?: TLAnimationOptions): this {\n\t\tif (!this.canMoveCamera) return this\n\n\t\tconst { camera } = this\n\t\tconst { x: cx, y: cy, z: cz } = camera\n\t\tconst d = new Vec2d(dx, dy).div(cz)\n\n\t\tif (opts?.duration ?? 0 > 0) {\n\t\t\treturn this.animateCamera(cx + d.x, cy + d.y, cz, opts)\n\t\t} else {\n\t\t\tthis.setCamera(cx + d.x, cy + d.y, cz)\n\t\t}\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Stop the current camera animation, if any.\n\t *\n\t * @public\n\t */\n\tstopCameraAnimation() {\n\t\tthis.emit('stop-camera-animation')\n\n\t\treturn this\n\t}\n\n\t/** @internal */\n\tprivate _viewportAnimation = null as null | {\n\t\telapsed: number\n\t\tduration: number\n\t\teasing: (t: number) => number\n\t\tstart: Box2d\n\t\tend: Box2d\n\t}\n\n\t/** @internal */\n\tprivate _animateViewport(ms: number) {\n\t\tif (!this._viewportAnimation) return\n\n\t\tconst cancel = () => {\n\t\t\tthis.removeListener('tick', this._animateViewport)\n\t\t\tthis.removeListener('stop-camera-animation', cancel)\n\t\t\tthis._viewportAnimation = null\n\t\t}\n\n\t\tthis.once('stop-camera-animation', cancel)\n\n\t\tthis._viewportAnimation.elapsed += ms\n\n\t\tconst { elapsed, easing, duration, start, end } = this._viewportAnimation\n\n\t\tif (elapsed > duration) {\n\t\t\tconst z = this.viewportScreenBounds.width / end.width\n\t\t\tconst x = -end.x\n\t\t\tconst y = -end.y\n\n\t\t\tthis._setCamera(x, y, z)\n\t\t\tcancel()\n\t\t\treturn\n\t\t}\n\n\t\tconst remaining = duration - elapsed\n\t\tconst t = easing(1 - remaining / duration)\n\n\t\tconst left = start.minX + (end.minX - start.minX) * t\n\t\tconst top = start.minY + (end.minY - start.minY) * t\n\t\tconst right = start.maxX + (end.maxX - start.maxX) * t\n\t\tconst bottom = start.maxY + (end.maxY - start.maxY) * t\n\n\t\tconst easedViewport = new Box2d(left, top, right - left, bottom - top)\n\n\t\tconst z = this.viewportScreenBounds.width / easedViewport.width\n\t\tconst x = -easedViewport.x\n\t\tconst y = -easedViewport.y\n\n\t\tthis._setCamera(x, y, z)\n\t}\n\n\t/** @internal */\n\tprivate _animateToViewport(targetViewportPage: Box2d, opts = {} as TLAnimationOptions) {\n\t\tconst { duration = 0, easing = EASINGS.easeInOutCubic } = opts\n\t\tconst { animationSpeed, viewportPageBounds } = this\n\n\t\t// If we have an existing animation, then stop it; also stop following any user\n\t\tthis.stopCameraAnimation()\n\t\tif (this.instanceState.followingUserId) {\n\t\t\tthis.stopFollowingUser()\n\t\t}\n\n\t\tif (duration === 0 || animationSpeed === 0) {\n\t\t\t// If we have no animation, then skip the animation and just set the camera\n\t\t\treturn this._setCamera(\n\t\t\t\t-targetViewportPage.x,\n\t\t\t\t-targetViewportPage.y,\n\t\t\t\tthis.viewportScreenBounds.width / targetViewportPage.width\n\t\t\t)\n\t\t}\n\n\t\t// Set our viewport animation\n\t\tthis._viewportAnimation = {\n\t\t\telapsed: 0,\n\t\t\tduration: duration / animationSpeed,\n\t\t\teasing,\n\t\t\tstart: viewportPageBounds.clone(),\n\t\t\tend: targetViewportPage,\n\t\t}\n\n\t\t// On each tick, animate the viewport\n\t\tthis.addListener('tick', this._animateViewport)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Slide the camera in a certain direction.\n\t *\n\t * @param opts - Options for the slide\n\t * @public\n\t */\n\tslideCamera(\n\t\topts = {} as {\n\t\t\tspeed: number\n\t\t\tdirection: Vec2d\n\t\t\tfriction: number\n\t\t\tspeedThreshold?: number\n\t\t}\n\t) {\n\t\tif (!this.canMoveCamera) return this\n\n\t\tthis.stopCameraAnimation()\n\n\t\tconst { animationSpeed } = this\n\n\t\tif (animationSpeed === 0) return\n\n\t\tconst { speed, friction, direction, speedThreshold = 0.01 } = opts\n\t\tlet currentSpeed = Math.min(speed, 1)\n\n\t\tconst cancel = () => {\n\t\t\tthis.removeListener('tick', moveCamera)\n\t\t\tthis.removeListener('stop-camera-animation', cancel)\n\t\t}\n\n\t\tthis.once('stop-camera-animation', cancel)\n\n\t\tconst moveCamera = (elapsed: number) => {\n\t\t\tconst { x: cx, y: cy, z: cz } = this.camera\n\t\t\tconst movementVec = direction.clone().mul((currentSpeed * elapsed) / cz)\n\n\t\t\t// Apply friction\n\t\t\tcurrentSpeed *= 1 - friction\n\t\t\tif (currentSpeed < speedThreshold) {\n\t\t\t\tcancel()\n\t\t\t} else {\n\t\t\t\tthis._setCamera(cx + movementVec.x, cy + movementVec.y, cz)\n\t\t\t}\n\t\t}\n\n\t\tthis.addListener('tick', moveCamera)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Animate the camera to a user's cursor position.\n\t * This also briefly show the user's cursor if it's not currently visible.\n\t *\n\t * @param userId - The id of the user to aniamte to.\n\t * @public\n\t */\n\tanimateToUser(userId: string) {\n\t\tconst presences = this.store.query.records('instance_presence', () => ({\n\t\t\tuserId: { eq: userId },\n\t\t}))\n\n\t\tconst presence = [...presences.value]\n\t\t\t.sort((a, b) => {\n\t\t\t\treturn a.lastActivityTimestamp - b.lastActivityTimestamp\n\t\t\t})\n\t\t\t.pop()\n\n\t\tif (!presence) return\n\n\t\tthis.batch(() => {\n\t\t\t// If we're following someone, stop following them\n\t\t\tif (this.instanceState.followingUserId !== null) {\n\t\t\t\tthis.stopFollowingUser()\n\t\t\t}\n\n\t\t\t// If we're not on the same page, move to the page they're on\n\t\t\tconst isOnSamePage = presence.currentPageId === this.currentPageId\n\t\t\tif (!isOnSamePage) {\n\t\t\t\tthis.setCurrentPageId(presence.currentPageId)\n\t\t\t}\n\n\t\t\t// Only animate the camera if the user is on the same page as us\n\t\t\tconst options = isOnSamePage ? { duration: 500 } : undefined\n\n\t\t\tconst position = presence.cursor\n\n\t\t\tthis.centerOnPoint(position.x, position.y, options)\n\n\t\t\t// Highlight the user's cursor\n\t\t\tconst { highlightedUserIds } = this.instanceState\n\t\t\tthis.updateInstanceState({ highlightedUserIds: [...highlightedUserIds, userId] })\n\n\t\t\t// Unhighlight the user's cursor after a few seconds\n\t\t\tsetTimeout(() => {\n\t\t\t\tconst highlightedUserIds = [...this.instanceState.highlightedUserIds]\n\t\t\t\tconst index = highlightedUserIds.indexOf(userId)\n\t\t\t\tif (index < 0) return\n\t\t\t\thighlightedUserIds.splice(index, 1)\n\t\t\t\tthis.updateInstanceState({ highlightedUserIds })\n\t\t\t}, COLLABORATOR_TIMEOUT)\n\t\t})\n\t}\n\n\t/**\n\t * Start viewport-following a user.\n\t *\n\t * @param userId - The id of the user to follow.\n\t *\n\t * @public\n\t */\n\tstartFollowingUser(userId: string) {\n\t\tconst leaderPresences = this.store.query.records('instance_presence', () => ({\n\t\t\tuserId: { eq: userId },\n\t\t}))\n\n\t\tconst thisUserId = this.user.id\n\n\t\tif (!thisUserId) {\n\t\t\tconsole.warn('You should set the userId for the current instance before following a user')\n\t\t}\n\n\t\t// If the leader is following us, then we can't follow them\n\t\tif (leaderPresences.value.some((p) => p.followingUserId === thisUserId)) {\n\t\t\treturn\n\t\t}\n\n\t\ttransact(() => {\n\t\t\tthis.stopFollowingUser()\n\n\t\t\tthis.updateInstanceState({ followingUserId: userId }, true)\n\t\t})\n\n\t\tconst cancel = () => {\n\t\t\tthis.removeListener('frame', moveTowardsUser)\n\t\t\tthis.removeListener('stop-following', cancel)\n\t\t}\n\n\t\tlet isCaughtUp = false\n\n\t\tconst moveTowardsUser = () => {\n\t\t\t// Stop following if we can't find the user\n\t\t\tconst leaderPresence = [...leaderPresences.value]\n\t\t\t\t.sort((a, b) => {\n\t\t\t\t\treturn a.lastActivityTimestamp - b.lastActivityTimestamp\n\t\t\t\t})\n\t\t\t\t.pop()\n\t\t\tif (!leaderPresence) {\n\t\t\t\tthis.stopFollowingUser()\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// Change page if leader is on a different page\n\t\t\tconst isOnSamePage = leaderPresence.currentPageId === this.currentPageId\n\t\t\tconst chaseProportion = isOnSamePage ? FOLLOW_CHASE_PROPORTION : 1\n\t\t\tif (!isOnSamePage) {\n\t\t\t\tthis.setCurrentPageId(leaderPresence.currentPageId, { stopFollowing: false })\n\t\t\t}\n\n\t\t\t// Get the bounds of the follower (me) and the leader (them)\n\t\t\tconst { center, width, height } = this.viewportPageBounds\n\t\t\tconst leaderScreen = Box2d.From(leaderPresence.screenBounds)\n\t\t\tconst leaderWidth = leaderScreen.width / leaderPresence.camera.z\n\t\t\tconst leaderHeight = leaderScreen.height / leaderPresence.camera.z\n\t\t\tconst leaderCenter = new Vec2d(\n\t\t\t\tleaderWidth / 2 - leaderPresence.camera.x,\n\t\t\t\tleaderHeight / 2 - leaderPresence.camera.y\n\t\t\t)\n\n\t\t\t// At this point, let's check if we're following someone who's following us.\n\t\t\t// If so, we can't try to contain their entire viewport\n\t\t\t// because that would become a feedback loop where we zoom, they zoom, etc.\n\t\t\tconst isFollowingFollower = leaderPresence.followingUserId === thisUserId\n\n\t\t\t// Figure out how much to zoom\n\t\t\tconst desiredWidth = width + (leaderWidth - width) * chaseProportion\n\t\t\tconst desiredHeight = height + (leaderHeight - height) * chaseProportion\n\t\t\tconst ratio = !isFollowingFollower\n\t\t\t\t? Math.min(width / desiredWidth, height / desiredHeight)\n\t\t\t\t: height / desiredHeight\n\n\t\t\tconst targetZoom = clamp(this.camera.z * ratio, MIN_ZOOM, MAX_ZOOM)\n\t\t\tconst targetWidth = this.viewportScreenBounds.w / targetZoom\n\t\t\tconst targetHeight = this.viewportScreenBounds.h / targetZoom\n\n\t\t\t// Figure out where to move the camera\n\t\t\tconst displacement = leaderCenter.sub(center)\n\t\t\tconst targetCenter = Vec2d.Add(center, Vec2d.Mul(displacement, chaseProportion))\n\n\t\t\t// Now let's assess whether we've caught up to the leader or not\n\t\t\tconst distance = Vec2d.Sub(targetCenter, center).len()\n\t\t\tconst zoomChange = Math.abs(targetZoom - this.camera.z)\n\n\t\t\t// If we're chasing the leader...\n\t\t\t// Stop chasing if we're close enough\n\t\t\tif (distance < FOLLOW_CHASE_PAN_SNAP && zoomChange < FOLLOW_CHASE_ZOOM_SNAP) {\n\t\t\t\tisCaughtUp = true\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// If we're already caught up with the leader...\n\t\t\t// Only start moving again if we're far enough away\n\t\t\tif (\n\t\t\t\tisCaughtUp &&\n\t\t\t\tdistance < FOLLOW_CHASE_PAN_UNSNAP &&\n\t\t\t\tzoomChange < FOLLOW_CHASE_ZOOM_UNSNAP\n\t\t\t) {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// Update the camera!\n\t\t\tisCaughtUp = false\n\t\t\tthis.stopCameraAnimation()\n\t\t\tthis.setCamera(\n\t\t\t\t-(targetCenter.x - targetWidth / 2),\n\t\t\t\t-(targetCenter.y - targetHeight / 2),\n\t\t\t\ttargetZoom,\n\t\t\t\t{ stopFollowing: false }\n\t\t\t)\n\t\t}\n\n\t\tthis.once('stop-following', cancel)\n\t\tthis.addListener('frame', moveTowardsUser)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Stop viewport-following a user.\n\t *\n\t * @public\n\t */\n\tstopFollowingUser() {\n\t\tthis.updateInstanceState({ followingUserId: null }, true)\n\t\tthis.emit('stop-following')\n\t\treturn this\n\t}\n\n\t/**\n\t * Animate the camera to a shape.\n\t *\n\t * @public\n\t */\n\tanimateToShape(shapeId: TLShapeId, opts: TLAnimationOptions = DEFAULT_ANIMATION_OPTIONS): this {\n\t\tif (!this.canMoveCamera) return this\n\n\t\tconst activeArea = getActiveAreaScreenSpace(this)\n\t\tconst viewportAspectRatio = activeArea.width / activeArea.height\n\n\t\tconst shapePageBounds = this.getPageBoundsById(shapeId)\n\n\t\tif (!shapePageBounds) return this\n\n\t\tconst shapeAspectRatio = shapePageBounds.width / shapePageBounds.height\n\n\t\tconst targetViewportPage = shapePageBounds.clone()\n\n\t\tconst z = shapePageBounds.width / activeArea.width\n\t\ttargetViewportPage.width += (activeArea.left + activeArea.right) * z\n\t\ttargetViewportPage.height += (activeArea.top + activeArea.bottom) * z\n\t\ttargetViewportPage.x -= activeArea.left * z\n\t\ttargetViewportPage.y -= activeArea.top * z\n\n\t\tif (shapeAspectRatio > viewportAspectRatio) {\n\t\t\ttargetViewportPage.height = shapePageBounds.width / viewportAspectRatio\n\t\t\ttargetViewportPage.y -= (targetViewportPage.height - shapePageBounds.height) / 2\n\t\t} else {\n\t\t\ttargetViewportPage.width = shapePageBounds.height * viewportAspectRatio\n\t\t\ttargetViewportPage.x -= (targetViewportPage.width - shapePageBounds.width) / 2\n\t\t}\n\n\t\treturn this._animateToViewport(targetViewportPage, opts)\n\t}\n\n\t/**\n\t * Blur the app, cancelling any interaction state.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.blur()\n\t * ```\n\t *\n\t * @public\n\t */\n\tblur() {\n\t\tthis.complete()\n\t\tthis.getContainer().blur()\n\t\tthis._isFocused.set(false)\n\t\treturn this\n\t}\n\n\t/**\n\t * Focus the editor.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.focus()\n\t * ```\n\t *\n\t * @public\n\t */\n\tfocus() {\n\t\tthis.getContainer().focus()\n\t\tthis._isFocused.set(true)\n\t\treturn this\n\t}\n\n\t/**\n\t * Dispatch a cancel event.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.cancel()\n\t * ```\n\t *\n\t * @public\n\t */\n\tcancel() {\n\t\tthis.dispatch({ type: 'misc', name: 'cancel' })\n\t\treturn this\n\t}\n\n\t/**\n\t * Dispatch an interrupt event.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.interrupt()\n\t * ```\n\t *\n\t * @public\n\t */\n\tinterrupt() {\n\t\tthis.dispatch({ type: 'misc', name: 'interrupt' })\n\t\treturn this\n\t}\n\n\t/**\n\t * Dispatch a complete event.\n\t *\n\t * @example\n\t * ```ts\n\t * editor.complete()\n\t * ```\n\t *\n\t * @public\n\t */\n\tcomplete() {\n\t\tthis.dispatch({ type: 'misc', name: 'complete' })\n\t\treturn this\n\t}\n\n\t/* -------------------- Callbacks ------------------- */\n\n\t/**\n\t * Handle external content, such as files, urls, embeds, or plain text which has been put into the app, for example by pasting external text or dropping external images onto canvas.\n\t *\n\t * @param info - Info about the external content.\n\t */\n\tasync putExternalContent(info: TLExternalContent): Promise<void> {\n\t\tthis.externalContentManager.handleContent(info)\n\t}\n\n\t/* ---------------- Text Measurement ---------------- */\n\n\t/**\n\t * A helper for measuring text.\n\t *\n\t * @public\n\t */\n\ttextMeasure: TextManager\n\n\t/* --------------------- Groups --------------------- */\n\n\t/**\n\t * Group some shapes together.\n\t *\n\t * @param ids - Ids of the shapes to group. Defaults to the selected shapes.\n\t * @param groupId - Id of the group to create. Defaults to a new shape id.\n\t *\n\t * @public\n\t */\n\tgroupShapes(ids: TLShapeId[] = this.selectedIds, groupId = createShapeId()) {\n\t\tif (this.isReadOnly) return this\n\n\t\tif (ids.length <= 1) return this\n\n\t\tconst shapes = compact(this._getUnlockedShapeIds(ids).map((id) => this.getShapeById(id)))\n\t\tconst sortedShapeIds = shapes.sort(sortByIndex).map((s) => s.id)\n\t\tconst pageBounds = Box2d.Common(compact(shapes.map((id) => this.getPageBounds(id))))\n\n\t\tconst { x, y } = pageBounds.point\n\n\t\tconst parentId = this.findCommonAncestor(shapes) ?? this.currentPageId\n\n\t\t// Only group when the select tool is active\n\t\tif (this.currentToolId !== 'select') return this\n\n\t\t// If not already in idle, cancel the current interaction (get back to idle)\n\t\tif (!this.isIn('select.idle')) {\n\t\t\tthis.cancel()\n\t\t}\n\n\t\t// Find all the shapes that have the same parentId, and use the highest index.\n\t\tconst shapesWithRootParent = shapes\n\t\t\t.filter((shape) => shape.parentId === parentId)\n\t\t\t.sort(sortByIndex)\n\n\t\tconst highestIndex = shapesWithRootParent[shapesWithRootParent.length - 1]?.index\n\n\t\tthis.batch(() => {\n\t\t\tthis.createShapes<TLGroupShape>([\n\t\t\t\t{\n\t\t\t\t\tid: groupId,\n\t\t\t\t\ttype: 'group',\n\t\t\t\t\tparentId,\n\t\t\t\t\tindex: highestIndex,\n\t\t\t\t\tx,\n\t\t\t\t\ty,\n\t\t\t\t\topacity: 1,\n\t\t\t\t\tprops: {},\n\t\t\t\t},\n\t\t\t])\n\t\t\tthis.reparentShapesById(sortedShapeIds, groupId)\n\t\t\tthis.select(groupId)\n\t\t})\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Ungroup some shapes.\n\t *\n\t * @param ids - Ids of the shapes to ungroup. Defaults to the selected shapes.\n\t *\n\t * @public\n\t */\n\tungroupShapes(ids: TLShapeId[] = this.selectedIds) {\n\t\tif (this.isReadOnly) return this\n\t\tif (ids.length === 0) return this\n\n\t\t// Only ungroup when the select tool is active\n\t\tif (this.currentToolId !== 'select') return this\n\n\t\t// If not already in idle, cancel the current interaction (get back to idle)\n\t\tif (!this.isIn('select.idle')) {\n\t\t\tthis.cancel()\n\t\t}\n\n\t\t// The ids of the selected shapes after ungrouping;\n\t\t// these include all of the grouped shapes children,\n\t\t// plus any shapes that were selected apart from the groups.\n\t\tconst idsToSelect = new Set<TLShapeId>()\n\n\t\t// Get all groups in the selection\n\t\tconst shapes = compact(ids.map((id) => this.getShapeById(id)))\n\n\t\tconst groups: TLGroupShape[] = []\n\n\t\tshapes.forEach((shape) => {\n\t\t\tif (this.isShapeOfType(shape, GroupShapeUtil)) {\n\t\t\t\tgroups.push(shape)\n\t\t\t} else {\n\t\t\t\tidsToSelect.add(shape.id)\n\t\t\t}\n\t\t})\n\n\t\tif (groups.length === 0) return this\n\n\t\tthis.batch(() => {\n\t\t\tlet group: TLGroupShape\n\n\t\t\tfor (let i = 0, n = groups.length; i < n; i++) {\n\t\t\t\tgroup = groups[i]\n\t\t\t\tconst childIds = this.getSortedChildIds(group.id)\n\n\t\t\t\tfor (let j = 0, n = childIds.length; j < n; j++) {\n\t\t\t\t\tidsToSelect.add(childIds[j])\n\t\t\t\t}\n\n\t\t\t\tthis.reparentShapesById(childIds, group.parentId, group.index)\n\t\t\t}\n\n\t\t\tthis.deleteShapes(groups.map((group) => group.id))\n\t\t\tthis.select(...idsToSelect)\n\t\t})\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Get an exported SVG of the given shapes.\n\t *\n\t * @param ids - The ids of the shapes to export. Defaults to selected shapes.\n\t * @param opts - Options for the export.\n\t *\n\t * @returns The SVG element.\n\t *\n\t * @public\n\t */\n\tasync getSvg(\n\t\tids: TLShapeId[] = this.selectedIds.length\n\t\t\t? this.selectedIds\n\t\t\t: (Object.keys(this.currentPageShapeIds) as TLShapeId[]),\n\t\topts = {} as Partial<{\n\t\t\tscale: number\n\t\t\tbackground: boolean\n\t\t\tpadding: number\n\t\t\tdarkMode?: boolean\n\t\t\tpreserveAspectRatio: React.SVGAttributes<SVGSVGElement>['preserveAspectRatio']\n\t\t}>\n\t) {\n\t\tif (ids.length === 0) return\n\t\tif (!window.document) throw Error('No document')\n\n\t\tconst {\n\t\t\tscale = 1,\n\t\t\tbackground = false,\n\t\t\tpadding = SVG_PADDING,\n\t\t\tdarkMode = this.isDarkMode,\n\t\t\tpreserveAspectRatio = false,\n\t\t} = opts\n\n\t\tconst realContainerEl = this.getContainer()\n\t\tconst realContainerStyle = getComputedStyle(realContainerEl)\n\n\t\t// Get the styles from the container. We'll use these to pull out colors etc.\n\t\t// NOTE: We can force force a light theme here because we don't want export\n\t\tconst fakeContainerEl = document.createElement('div')\n\t\tfakeContainerEl.className = `tl-container tl-theme__${\n\t\t\tdarkMode ? 'dark' : 'light'\n\t\t} tl-theme__force-sRGB`\n\t\tdocument.body.appendChild(fakeContainerEl)\n\n\t\tconst containerStyle = getComputedStyle(fakeContainerEl)\n\t\tconst fontsUsedInExport = new Map<string, string>()\n\n\t\tconst colors: TLExportColors = {\n\t\t\tfill: objectMapFromEntries(\n\t\t\t\tDefaultColorStyle.values.map((color) => [\n\t\t\t\t\tcolor,\n\t\t\t\t\tcontainerStyle.getPropertyValue(`--palette-${color}`),\n\t\t\t\t])\n\t\t\t),\n\t\t\tpattern: objectMapFromEntries(\n\t\t\t\tDefaultColorStyle.values.map((color) => [\n\t\t\t\t\tcolor,\n\t\t\t\t\tcontainerStyle.getPropertyValue(`--palette-${color}-pattern`),\n\t\t\t\t])\n\t\t\t),\n\t\t\tsemi: objectMapFromEntries(\n\t\t\t\tDefaultColorStyle.values.map((color) => [\n\t\t\t\t\tcolor,\n\t\t\t\t\tcontainerStyle.getPropertyValue(`--palette-${color}-semi`),\n\t\t\t\t])\n\t\t\t),\n\t\t\thighlight: objectMapFromEntries(\n\t\t\t\tDefaultColorStyle.values.map((color) => [\n\t\t\t\t\tcolor,\n\t\t\t\t\tcontainerStyle.getPropertyValue(`--palette-${color}-highlight`),\n\t\t\t\t])\n\t\t\t),\n\t\t\ttext: containerStyle.getPropertyValue(`--color-text`),\n\t\t\tbackground: containerStyle.getPropertyValue(`--color-background`),\n\t\t\tsolid: containerStyle.getPropertyValue(`--palette-solid`),\n\t\t}\n\n\t\t// Remove containerEl from DOM (temp DOM node)\n\t\tdocument.body.removeChild(fakeContainerEl)\n\n\t\t// ---Figure out which shapes we need to include\n\t\tconst shapeIdsToInclude = this.getShapeAndDescendantIds(ids)\n\t\tconst renderingShapes = this.computeUnorderedRenderingShapes([this.currentPageId]).filter(\n\t\t\t({ id }) => shapeIdsToInclude.has(id)\n\t\t)\n\n\t\t// --- Common bounding box of all shapes\n\t\tlet bbox = null\n\t\tfor (const { maskedPageBounds } of renderingShapes) {\n\t\t\tif (!maskedPageBounds) continue\n\t\t\tif (bbox) {\n\t\t\t\tbbox.union(maskedPageBounds)\n\t\t\t} else {\n\t\t\t\tbbox = maskedPageBounds.clone()\n\t\t\t}\n\t\t}\n\n\t\t// no unmasked shapes to export\n\t\tif (!bbox) return\n\n\t\tconst singleFrameShapeId =\n\t\t\tids.length === 1 && this.isShapeOfType(this.getShapeById(ids[0])!, FrameShapeUtil)\n\t\t\t\t? ids[0]\n\t\t\t\t: null\n\t\tif (!singleFrameShapeId) {\n\t\t\t// Expand by an extra 32 pixels\n\t\t\tbbox.expandBy(padding)\n\t\t}\n\n\t\t// We want the svg image to be BIGGER THAN USUAL to account for image quality\n\t\tconst w = bbox.width * scale\n\t\tconst h = bbox.height * scale\n\n\t\t// --- Create the SVG\n\n\t\t// Embed our custom fonts\n\t\tconst svg = window.document.createElementNS('http://www.w3.org/2000/svg', 'svg')\n\n\t\tif (preserveAspectRatio) {\n\t\t\tsvg.setAttribute('preserveAspectRatio', preserveAspectRatio)\n\t\t}\n\n\t\tsvg.setAttribute('direction', 'ltr')\n\t\tsvg.setAttribute('width', w + '')\n\t\tsvg.setAttribute('height', h + '')\n\t\tsvg.setAttribute('viewBox', `${bbox.minX} ${bbox.minY} ${bbox.width} ${bbox.height}`)\n\t\tsvg.setAttribute('stroke-linecap', 'round')\n\t\tsvg.setAttribute('stroke-linejoin', 'round')\n\t\t// Add current background color, or else background will be transparent\n\n\t\tif (background) {\n\t\t\tif (singleFrameShapeId) {\n\t\t\t\tsvg.style.setProperty('background', colors.solid)\n\t\t\t} else {\n\t\t\t\tsvg.style.setProperty('background-color', colors.background)\n\t\t\t}\n\t\t} else {\n\t\t\tsvg.style.setProperty('background-color', 'transparent')\n\t\t}\n\n\t\t// Add the defs to the svg\n\t\tconst defs = window.document.createElementNS('http://www.w3.org/2000/svg', 'defs')\n\n\t\tfor (const element of Array.from(exportPatternSvgDefs(colors.solid))) {\n\t\t\tdefs.appendChild(element)\n\t\t}\n\n\t\ttry {\n\t\t\tdocument.body.focus?.() // weird but necessary\n\t\t} catch (e) {\n\t\t\t// not implemented\n\t\t}\n\n\t\tsvg.append(defs)\n\n\t\tconst unorderedShapeElements = (\n\t\t\tawait Promise.all(\n\t\t\t\trenderingShapes.map(async ({ id, opacity, index, backgroundIndex }) => {\n\t\t\t\t\t// Don't render the frame if we're only exporting a single frame\n\t\t\t\t\tif (id === singleFrameShapeId) return []\n\n\t\t\t\t\tconst shape = this.getShapeById(id)!\n\n\t\t\t\t\tif (this.isShapeOfType(shape, GroupShapeUtil)) return []\n\n\t\t\t\t\tconst util = this.getShapeUtil(shape)\n\n\t\t\t\t\tlet font: string | undefined\n\t\t\t\t\t// TODO: `Editor` shouldn't know about `DefaultFontStyle`. We need another way\n\t\t\t\t\t// for shapes to register fonts for export.\n\t\t\t\t\tconst fontFromShape = util.getStyleIfExists(DefaultFontStyle, shape)\n\t\t\t\t\tif (fontFromShape) {\n\t\t\t\t\t\tif (fontsUsedInExport.has(fontFromShape)) {\n\t\t\t\t\t\t\tfont = fontsUsedInExport.get(fontFromShape)!\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// For some reason these styles aren't present in the fake element\n\t\t\t\t\t\t\t// so we need to get them from the real element\n\t\t\t\t\t\t\tfont = realContainerStyle.getPropertyValue(`--tl-font-${fontFromShape}`)\n\t\t\t\t\t\t\tfontsUsedInExport.set(fontFromShape, font)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tlet shapeSvgElement = await util.toSvg?.(shape, font, colors)\n\t\t\t\t\tlet backgroundSvgElement = await util.toBackgroundSvg?.(shape, font, colors)\n\n\t\t\t\t\t// wrap the shapes in groups so we can apply properties without overwriting ones from the shape util\n\t\t\t\t\tif (shapeSvgElement) {\n\t\t\t\t\t\tconst outerElement = document.createElementNS('http://www.w3.org/2000/svg', 'g')\n\t\t\t\t\t\touterElement.appendChild(shapeSvgElement)\n\t\t\t\t\t\tshapeSvgElement = outerElement\n\t\t\t\t\t}\n\n\t\t\t\t\tif (backgroundSvgElement) {\n\t\t\t\t\t\tconst outerElement = document.createElementNS('http://www.w3.org/2000/svg', 'g')\n\t\t\t\t\t\touterElement.appendChild(backgroundSvgElement)\n\t\t\t\t\t\tbackgroundSvgElement = outerElement\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!shapeSvgElement && !backgroundSvgElement) {\n\t\t\t\t\t\tconst bounds = this.getPageBounds(shape)!\n\t\t\t\t\t\tconst elm = window.document.createElementNS('http://www.w3.org/2000/svg', 'rect')\n\t\t\t\t\t\telm.setAttribute('width', bounds.width + '')\n\t\t\t\t\t\telm.setAttribute('height', bounds.height + '')\n\t\t\t\t\t\telm.setAttribute('fill', colors.solid)\n\t\t\t\t\t\telm.setAttribute('stroke', colors.pattern.grey)\n\t\t\t\t\t\telm.setAttribute('stroke-width', '1')\n\t\t\t\t\t\tshapeSvgElement = elm\n\t\t\t\t\t}\n\n\t\t\t\t\tlet pageTransform = this.getPageTransform(shape)!.toCssString()\n\t\t\t\t\tif ('scale' in shape.props) {\n\t\t\t\t\t\tif (shape.props.scale !== 1) {\n\t\t\t\t\t\t\tpageTransform = `${pageTransform} scale(${shape.props.scale}, ${shape.props.scale})`\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tshapeSvgElement?.setAttribute('transform', pageTransform)\n\t\t\t\t\tbackgroundSvgElement?.setAttribute('transform', pageTransform)\n\t\t\t\t\tshapeSvgElement?.setAttribute('opacity', opacity + '')\n\t\t\t\t\tbackgroundSvgElement?.setAttribute('opacity', opacity + '')\n\n\t\t\t\t\t// Create svg mask if shape has a frame as parent\n\t\t\t\t\tconst pageMask = this.getPageMaskById(shape.id)\n\t\t\t\t\tif (pageMask) {\n\t\t\t\t\t\t// Create a clip path and add it to defs\n\t\t\t\t\t\tconst clipPathEl = document.createElementNS('http://www.w3.org/2000/svg', 'clipPath')\n\t\t\t\t\t\tdefs.appendChild(clipPathEl)\n\t\t\t\t\t\tconst id = nanoid()\n\t\t\t\t\t\tclipPathEl.id = id\n\n\t\t\t\t\t\t// Create a polyline mask that does the clipping\n\t\t\t\t\t\tconst mask = document.createElementNS('http://www.w3.org/2000/svg', 'path')\n\t\t\t\t\t\tmask.setAttribute('d', `M${pageMask.map(({ x, y }) => `${x},${y}`).join('L')}Z`)\n\t\t\t\t\t\tclipPathEl.appendChild(mask)\n\n\t\t\t\t\t\t// Create group that uses the clip path and wraps the shape elements\n\t\t\t\t\t\tif (shapeSvgElement) {\n\t\t\t\t\t\t\tconst outerElement = document.createElementNS('http://www.w3.org/2000/svg', 'g')\n\t\t\t\t\t\t\touterElement.setAttribute('clip-path', `url(#${id})`)\n\t\t\t\t\t\t\touterElement.appendChild(shapeSvgElement)\n\t\t\t\t\t\t\tshapeSvgElement = outerElement\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (backgroundSvgElement) {\n\t\t\t\t\t\t\tconst outerElement = document.createElementNS('http://www.w3.org/2000/svg', 'g')\n\t\t\t\t\t\t\touterElement.setAttribute('clip-path', `url(#${id})`)\n\t\t\t\t\t\t\touterElement.appendChild(backgroundSvgElement)\n\t\t\t\t\t\t\tbackgroundSvgElement = outerElement\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tconst elements = []\n\t\t\t\t\tif (shapeSvgElement) {\n\t\t\t\t\t\telements.push({ zIndex: index, element: shapeSvgElement })\n\t\t\t\t\t}\n\t\t\t\t\tif (backgroundSvgElement) {\n\t\t\t\t\t\telements.push({ zIndex: backgroundIndex, element: backgroundSvgElement })\n\t\t\t\t\t}\n\n\t\t\t\t\treturn elements\n\t\t\t\t})\n\t\t\t)\n\t\t).flat()\n\n\t\tfor (const { element } of unorderedShapeElements.sort((a, b) => a.zIndex - b.zIndex)) {\n\t\t\tsvg.appendChild(element)\n\t\t}\n\n\t\t// Add styles to the defs\n\t\tlet styles = ``\n\t\tconst style = window.document.createElementNS('http://www.w3.org/2000/svg', 'style')\n\n\t\t// Insert fonts into app\n\t\tconst fontInstances: FontFace[] = []\n\n\t\tif ('fonts' in document) {\n\t\t\tdocument.fonts.forEach((font) => fontInstances.push(font))\n\t\t}\n\n\t\tawait Promise.all(\n\t\t\tfontInstances.map(async (font) => {\n\t\t\t\tconst fileReader = new FileReader()\n\n\t\t\t\tlet isUsed = false\n\n\t\t\t\tfontsUsedInExport.forEach((fontName) => {\n\t\t\t\t\tif (fontName.includes(font.family)) {\n\t\t\t\t\t\tisUsed = true\n\t\t\t\t\t}\n\t\t\t\t})\n\n\t\t\t\tif (!isUsed) return\n\n\t\t\t\tconst url = (font as any).$$_url\n\n\t\t\t\tconst fontFaceRule = (font as any).$$_fontface\n\n\t\t\t\tif (url) {\n\t\t\t\t\tconst fontFile = await (await fetch(url)).blob()\n\n\t\t\t\t\tconst base64Font = await new Promise<string>((resolve, reject) => {\n\t\t\t\t\t\tfileReader.onload = () => resolve(fileReader.result as string)\n\t\t\t\t\t\tfileReader.onerror = () => reject(fileReader.error)\n\t\t\t\t\t\tfileReader.readAsDataURL(fontFile)\n\t\t\t\t\t})\n\n\t\t\t\t\tconst newFontFaceRule = '\\n' + fontFaceRule.replaceAll(url, base64Font)\n\t\t\t\t\tstyles += newFontFaceRule\n\t\t\t\t}\n\t\t\t})\n\t\t)\n\n\t\tstyle.textContent = styles\n\n\t\tdefs.append(style)\n\n\t\treturn svg\n\t}\n}\n\nfunction alertMaxShapes(editor: Editor, pageId = editor.currentPageId) {\n\tconst name = editor.getPageById(pageId)!.name\n\teditor.emit('max-shapes', { name, pageId, count: MAX_SHAPES_PER_PAGE })\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}