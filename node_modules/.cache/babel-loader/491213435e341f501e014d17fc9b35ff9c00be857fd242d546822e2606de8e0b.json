{"ast":null,"code":"import _classCallCheck from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _defineProperty from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\n// src/Atom.ts\nimport { ArraySet } from \"./ArraySet.mjs\";\nimport { maybeCaptureParent } from \"./capture.mjs\";\nimport { EMPTY_ARRAY, equals } from \"./helpers.mjs\";\nimport { HistoryBuffer } from \"./HistoryBuffer.mjs\";\nimport { advanceGlobalEpoch, atomDidChange, globalEpoch } from \"./transactions.mjs\";\nimport { RESET_VALUE } from \"./types.mjs\";\nvar _Atom = /*#__PURE__*/function () {\n  function _Atom(name, current, options) {\n    var _options$isEqual;\n    _classCallCheck(this, _Atom);\n    _defineProperty(this, \"isEqual\", void 0);\n    _defineProperty(this, \"computeDiff\", void 0);\n    _defineProperty(this, \"lastChangedEpoch\", globalEpoch);\n    _defineProperty(this, \"children\", new ArraySet());\n    _defineProperty(this, \"historyBuffer\", void 0);\n    this.name = name;\n    this.current = current;\n    this.isEqual = (_options$isEqual = options === null || options === void 0 ? void 0 : options.isEqual) !== null && _options$isEqual !== void 0 ? _options$isEqual : null;\n    if (!options) return;\n    if (options.historyLength) {\n      this.historyBuffer = new HistoryBuffer(options.historyLength);\n    }\n    this.computeDiff = options.computeDiff;\n  }\n  _createClass(_Atom, [{\n    key: \"__unsafe__getWithoutCapture\",\n    value: function __unsafe__getWithoutCapture() {\n      return this.current;\n    }\n  }, {\n    key: \"value\",\n    get: function get() {\n      maybeCaptureParent(this);\n      return this.current;\n    }\n  }, {\n    key: \"set\",\n    value: function set(value, diff) {\n      var _this$isEqual, _this$isEqual2;\n      if ((_this$isEqual = (_this$isEqual2 = this.isEqual) === null || _this$isEqual2 === void 0 ? void 0 : _this$isEqual2.call(this, this.current, value)) !== null && _this$isEqual !== void 0 ? _this$isEqual : equals(this.current, value)) {\n        return this.current;\n      }\n      advanceGlobalEpoch();\n      if (this.historyBuffer) {\n        var _ref, _this$computeDiff;\n        this.historyBuffer.pushEntry(this.lastChangedEpoch, globalEpoch, (_ref = diff !== null && diff !== void 0 ? diff : (_this$computeDiff = this.computeDiff) === null || _this$computeDiff === void 0 ? void 0 : _this$computeDiff.call(this, this.current, value, this.lastChangedEpoch, globalEpoch)) !== null && _ref !== void 0 ? _ref : RESET_VALUE);\n      }\n      this.lastChangedEpoch = globalEpoch;\n      var oldValue = this.current;\n      this.current = value;\n      atomDidChange(this, oldValue);\n      return value;\n    }\n  }, {\n    key: \"update\",\n    value: function update(updater) {\n      return this.set(updater(this.current));\n    }\n  }, {\n    key: \"getDiffSince\",\n    value: function getDiffSince(epoch) {\n      var _this$historyBuffer$g, _this$historyBuffer;\n      maybeCaptureParent(this);\n      if (epoch >= this.lastChangedEpoch) {\n        return EMPTY_ARRAY;\n      }\n      return (_this$historyBuffer$g = (_this$historyBuffer = this.historyBuffer) === null || _this$historyBuffer === void 0 ? void 0 : _this$historyBuffer.getChangesSince(epoch)) !== null && _this$historyBuffer$g !== void 0 ? _this$historyBuffer$g : RESET_VALUE;\n    }\n  }]);\n  return _Atom;\n}();\nfunction atom(name, initialValue, options) {\n  return new _Atom(name, initialValue, options);\n}\nfunction isAtom(value) {\n  return value instanceof _Atom;\n}\nexport { _Atom, atom, isAtom };","map":{"version":3,"names":["ArraySet","maybeCaptureParent","EMPTY_ARRAY","equals","HistoryBuffer","advanceGlobalEpoch","atomDidChange","globalEpoch","RESET_VALUE","_Atom","name","current","options","_options$isEqual","_classCallCheck","_defineProperty","isEqual","historyLength","historyBuffer","computeDiff","_createClass","key","value","__unsafe__getWithoutCapture","get","set","diff","_this$isEqual","_this$isEqual2","call","_ref","_this$computeDiff","pushEntry","lastChangedEpoch","oldValue","update","updater","getDiffSince","epoch","_this$historyBuffer$g","_this$historyBuffer","getChangesSince","atom","initialValue","isAtom"],"sources":["/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/signia/src/Atom.ts"],"sourcesContent":["import { ArraySet } from './ArraySet.js'\nimport { maybeCaptureParent } from './capture.js'\nimport { EMPTY_ARRAY, equals } from './helpers.js'\nimport { HistoryBuffer } from './HistoryBuffer.js'\nimport { advanceGlobalEpoch, atomDidChange, globalEpoch } from './transactions.js'\nimport { Child, ComputeDiff, RESET_VALUE, Signal } from './types.js'\n\n/**\n * The options to configure an atom, passed into the [[atom]] function.\n * @public\n */\nexport interface AtomOptions<Value, Diff> {\n\t/**\n\t * The maximum number of diffs to keep in the history buffer.\n\t *\n\t * If you don't need to compute diffs, or if you will supply diffs manually via [[Atom.set]], you can leave this as `undefined` and no history buffer will be created.\n\t *\n\t * If you expect the value to be part of an active effect subscription all the time, and to not change multiple times inside of a single transaction, you can set this to a relatively low number (e.g. 10).\n\t *\n\t * Otherwise, set this to a higher number based on your usage pattern and memory constraints.\n\t *\n\t */\n\thistoryLength?: number\n\t/**\n\t * A method used to compute a diff between the atom's old and new values. If provided, it will not be used unless you also specify [[AtomOptions.historyLength]].\n\t */\n\tcomputeDiff?: ComputeDiff<Value, Diff>\n\t/**\n\t * If provided, this will be used to compare the old and new values of the atom to determine if the value has changed.\n\t * By default, values are compared using first using strict equality (`===`), then `Object.is`, and finally any `.equals` method present in the object's prototype chain.\n\t * @param a\n\t * @param b\n\t * @returns\n\t */\n\tisEqual?: (a: any, b: any) => boolean\n}\n\n/**\n * An Atom is a signal that can be updated directly by calling [[Atom.set]] or [[Atom.update]].\n *\n * Atoms are created using the [[atom]] function.\n *\n * @example\n * ```ts\n * const name = atom('name', 'John')\n *\n * console.log(name.value) // 'John'\n * ```\n *\n * @public\n */\nexport interface Atom<Value, Diff = unknown> extends Signal<Value, Diff> {\n\t/**\n\t * Sets the value of this atom to the given value. If the value is the same as the current value, this is a no-op.\n\t *\n\t * @param value - The new value to set.\n\t * @param diff - The diff to use for the update. If not provided, the diff will be computed using [[AtomOptions.computeDiff]].\n\t */\n\tset(value: Value, diff?: Diff): Value\n\t/**\n\t * Updates the value of this atom using the given updater function. If the returned value is the same as the current value, this is a no-op.\n\t *\n\t * @param updater - A function that takes the current value and returns the new value.\n\t */\n\tupdate(updater: (value: Value) => Value): Value\n}\n\n/**\n * @internal\n */\nexport class _Atom<Value, Diff = unknown> implements Atom<Value, Diff> {\n\tconstructor(\n\t\tpublic readonly name: string,\n\t\tprivate current: Value,\n\t\toptions?: AtomOptions<Value, Diff>\n\t) {\n\t\tthis.isEqual = options?.isEqual ?? null\n\n\t\tif (!options) return\n\n\t\tif (options.historyLength) {\n\t\t\tthis.historyBuffer = new HistoryBuffer(options.historyLength)\n\t\t}\n\n\t\tthis.computeDiff = options.computeDiff\n\t}\n\n\treadonly isEqual: null | ((a: any, b: any) => boolean)\n\n\tcomputeDiff?: ComputeDiff<Value, Diff>\n\n\tlastChangedEpoch = globalEpoch\n\n\tchildren = new ArraySet<Child>()\n\n\thistoryBuffer?: HistoryBuffer<Diff>\n\n\t__unsafe__getWithoutCapture(): Value {\n\t\treturn this.current\n\t}\n\n\tget value() {\n\t\tmaybeCaptureParent(this)\n\t\treturn this.current\n\t}\n\n\tset(value: Value, diff?: Diff): Value {\n\t\t// If the value has not changed, do nothing.\n\t\tif (this.isEqual?.(this.current, value) ?? equals(this.current, value)) {\n\t\t\treturn this.current\n\t\t}\n\n\t\t// Tick forward the global epoch\n\t\tadvanceGlobalEpoch()\n\n\t\t// Add the diff to the history buffer.\n\t\tif (this.historyBuffer) {\n\t\t\tthis.historyBuffer.pushEntry(\n\t\t\t\tthis.lastChangedEpoch,\n\t\t\t\tglobalEpoch,\n\t\t\t\tdiff ??\n\t\t\t\t\tthis.computeDiff?.(this.current, value, this.lastChangedEpoch, globalEpoch) ??\n\t\t\t\t\tRESET_VALUE\n\t\t\t)\n\t\t}\n\n\t\t// Update the atom's record of the epoch when last changed.\n\t\tthis.lastChangedEpoch = globalEpoch\n\n\t\tconst oldValue = this.current\n\t\tthis.current = value\n\n\t\t// Notify all children that this atom has changed.\n\t\tatomDidChange(this, oldValue)\n\n\t\treturn value\n\t}\n\n\tupdate(updater: (value: Value) => Value): Value {\n\t\treturn this.set(updater(this.current))\n\t}\n\n\tgetDiffSince(epoch: number): RESET_VALUE | Diff[] {\n\t\tmaybeCaptureParent(this)\n\n\t\t// If no changes have occurred since the given epoch, return an empty array.\n\t\tif (epoch >= this.lastChangedEpoch) {\n\t\t\treturn EMPTY_ARRAY\n\t\t}\n\n\t\treturn this.historyBuffer?.getChangesSince(epoch) ?? RESET_VALUE\n\t}\n}\n\n/**\n * Creates a new [[Atom]].\n *\n * An Atom is a signal that can be updated directly by calling [[Atom.set]] or [[Atom.update]].\n *\n * @example\n * ```ts\n * const name = atom('name', 'John')\n *\n * name.value // 'John'\n *\n * name.set('Jane')\n *\n * name.value // 'Jane'\n * ```\n *\n * @public\n */\nexport function atom<Value, Diff = unknown>(\n\t/**\n\t * A name for the signal. This is used for debugging and profiling purposes, it does not need to be unique.\n\t */\n\tname: string,\n\t/**\n\t * The initial value of the signal.\n\t */\n\tinitialValue: Value,\n\t/**\n\t * The options to configure the atom. See [[AtomOptions]].\n\t */\n\toptions?: AtomOptions<Value, Diff>\n): Atom<Value, Diff> {\n\treturn new _Atom(name, initialValue, options)\n}\n\n/**\n * Returns true if the given value is an [[Atom]].\n * @public\n */\nexport function isAtom(value: unknown): value is Atom<unknown> {\n\treturn value instanceof _Atom\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}