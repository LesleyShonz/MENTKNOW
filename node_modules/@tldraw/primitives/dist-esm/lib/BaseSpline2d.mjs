import { Box2d } from "./Box2d.mjs";
import { Vec2d } from "./Vec2d.mjs";
class BaseSpline2d {
  constructor(points, p = 50, k = 1) {
    this.points = points;
    this.p = p;
    this.k = k;
  }
  computed = {};
  get length() {
    if (this.computed.length !== void 0) {
      return this.computed.length;
    }
    const { segments } = this;
    const result = segments.reduce((acc, curr) => acc + curr.length, 0);
    this.computed.length = result;
    return result;
  }
  get bounds() {
    if (this.computed.bounds !== void 0) {
      return this.computed.bounds;
    }
    const { segments } = this;
    const result = Box2d.Common(segments.map((segment) => segment.bounds));
    this.computed.bounds = result;
    return result;
  }
  get head() {
    const { points } = this;
    return points[0];
  }
  get tail() {
    const { points } = this;
    return points[points.length - 1];
  }
  get path() {
    if (this.computed.path !== void 0) {
      return this.computed.path;
    }
    const result = this.segments.map((segment) => segment.path).filter((i) => i !== void 0 && i !== null && i !== "").join(" ");
    this.computed.path = result;
    return result;
  }
  addPoint(point) {
    const { points, k, p } = this;
    points.push(point);
    this.computed = {};
    this.getSegmentsFromPoints(this.points, p, k);
    return this;
  }
  removePoint(point) {
    const { points, k, p } = this;
    const index = typeof point === "number" ? Math.floor(point) : points.indexOf(point);
    if (index === -1)
      return this;
    points.splice(index, 1);
    this.computed = {};
    this.getSegmentsFromPoints(this.points, p, k);
    return this;
  }
  getPointAtLength(length) {
    const { segments } = this;
    let remaining = length;
    if (length <= 0)
      return segments[0].getPoint(0);
    if (length >= this.length)
      return segments[segments.length - 1].getPoint(1);
    for (let i = 0; i < segments.length; i++) {
      const segment = segments[i];
      const { length: segmentLength } = segment;
      if (remaining < segmentLength) {
        return segment.getPoint(remaining / segmentLength);
      }
      remaining -= segment.length;
    }
    return segments[segments.length - 1].getPoint(1);
  }
  getPoint(t) {
    if (t <= 0)
      return this.segments[0].getPoint(0);
    if (t >= 1)
      return this.segments[this.segments.length - 1].getPoint(1);
    return this.getPointAtLength(t * this.length);
  }
  getNormal(t) {
    const { length } = this;
    return this.getNormalAtLength(t * length);
  }
  getNormalAtLength(t) {
    const { segments } = this;
    if (t < 0)
      return new Vec2d(0, 0);
    let remaining = t;
    for (const segment of segments) {
      const segmentLength = segment.length;
      if (remaining <= segmentLength) {
        return segment.getNormal(remaining / segmentLength);
      }
      remaining -= segmentLength;
    }
    return new Vec2d(0, 0);
  }
  getClosestPointTo(point) {
    const { head, segments } = this;
    let closestPoint = head;
    let closestDistance = Vec2d.Dist(point, head);
    for (const segment of segments) {
      const p = segment.getClosestPointTo(point);
      if (p.distance < closestDistance) {
        closestDistance = p.distance;
        closestPoint = p.point;
      }
    }
    return { point: closestPoint, distance: closestDistance };
  }
}
export {
  BaseSpline2d
};
//# sourceMappingURL=BaseSpline2d.mjs.map
