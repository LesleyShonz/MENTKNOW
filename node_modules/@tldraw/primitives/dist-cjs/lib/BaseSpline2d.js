"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var BaseSpline2d_exports = {};
__export(BaseSpline2d_exports, {
  BaseSpline2d: () => BaseSpline2d
});
module.exports = __toCommonJS(BaseSpline2d_exports);
var import_Box2d = require("./Box2d");
var import_Vec2d = require("./Vec2d");
class BaseSpline2d {
  constructor(points, p = 50, k = 1) {
    this.points = points;
    this.p = p;
    this.k = k;
  }
  computed = {};
  get length() {
    if (this.computed.length !== void 0) {
      return this.computed.length;
    }
    const { segments } = this;
    const result = segments.reduce((acc, curr) => acc + curr.length, 0);
    this.computed.length = result;
    return result;
  }
  get bounds() {
    if (this.computed.bounds !== void 0) {
      return this.computed.bounds;
    }
    const { segments } = this;
    const result = import_Box2d.Box2d.Common(segments.map((segment) => segment.bounds));
    this.computed.bounds = result;
    return result;
  }
  get head() {
    const { points } = this;
    return points[0];
  }
  get tail() {
    const { points } = this;
    return points[points.length - 1];
  }
  get path() {
    if (this.computed.path !== void 0) {
      return this.computed.path;
    }
    const result = this.segments.map((segment) => segment.path).filter((i) => i !== void 0 && i !== null && i !== "").join(" ");
    this.computed.path = result;
    return result;
  }
  addPoint(point) {
    const { points, k, p } = this;
    points.push(point);
    this.computed = {};
    this.getSegmentsFromPoints(this.points, p, k);
    return this;
  }
  removePoint(point) {
    const { points, k, p } = this;
    const index = typeof point === "number" ? Math.floor(point) : points.indexOf(point);
    if (index === -1)
      return this;
    points.splice(index, 1);
    this.computed = {};
    this.getSegmentsFromPoints(this.points, p, k);
    return this;
  }
  getPointAtLength(length) {
    const { segments } = this;
    let remaining = length;
    if (length <= 0)
      return segments[0].getPoint(0);
    if (length >= this.length)
      return segments[segments.length - 1].getPoint(1);
    for (let i = 0; i < segments.length; i++) {
      const segment = segments[i];
      const { length: segmentLength } = segment;
      if (remaining < segmentLength) {
        return segment.getPoint(remaining / segmentLength);
      }
      remaining -= segment.length;
    }
    return segments[segments.length - 1].getPoint(1);
  }
  getPoint(t) {
    if (t <= 0)
      return this.segments[0].getPoint(0);
    if (t >= 1)
      return this.segments[this.segments.length - 1].getPoint(1);
    return this.getPointAtLength(t * this.length);
  }
  getNormal(t) {
    const { length } = this;
    return this.getNormalAtLength(t * length);
  }
  getNormalAtLength(t) {
    const { segments } = this;
    if (t < 0)
      return new import_Vec2d.Vec2d(0, 0);
    let remaining = t;
    for (const segment of segments) {
      const segmentLength = segment.length;
      if (remaining <= segmentLength) {
        return segment.getNormal(remaining / segmentLength);
      }
      remaining -= segmentLength;
    }
    return new import_Vec2d.Vec2d(0, 0);
  }
  getClosestPointTo(point) {
    const { head, segments } = this;
    let closestPoint = head;
    let closestDistance = import_Vec2d.Vec2d.Dist(point, head);
    for (const segment of segments) {
      const p = segment.getClosestPointTo(point);
      if (p.distance < closestDistance) {
        closestDistance = p.distance;
        closestPoint = p.point;
      }
    }
    return { point: closestPoint, distance: closestDistance };
  }
}
//# sourceMappingURL=BaseSpline2d.js.map
