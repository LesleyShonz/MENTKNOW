{"ast":null,"code":"import { Box2d, intersectLineSegmentPolygon, intersectLineSegmentPolyline, Matrix2d, Vec2d } from \"@tldraw/primitives\";\nimport { STROKE_SIZES } from \"../../shared/default-shape-constants.mjs\";\nimport { BOUND_ARROW_OFFSET, getArrowTerminalsInArrowSpace, getBoundShapeInfoForTerminal, MIN_ARROW_LENGTH } from \"./shared.mjs\";\nfunction getStraightArrowInfo(editor, shape) {\n  var _shape$props = shape.props,\n    start = _shape$props.start,\n    end = _shape$props.end,\n    arrowheadStart = _shape$props.arrowheadStart,\n    arrowheadEnd = _shape$props.arrowheadEnd;\n  var terminalsInArrowSpace = getArrowTerminalsInArrowSpace(editor, shape);\n  var a = terminalsInArrowSpace.start.clone();\n  var b = terminalsInArrowSpace.end.clone();\n  var c = Vec2d.Med(a, b);\n  var uAB = Vec2d.Sub(b, a).uni();\n  var startShapeInfo = getBoundShapeInfoForTerminal(editor, start);\n  var endShapeInfo = getBoundShapeInfoForTerminal(editor, end);\n  var arrowPageTransform = editor.getPageTransform(shape);\n  updateArrowheadPointWithBoundShape(b,\n  // <-- will be mutated\n  terminalsInArrowSpace.start, arrowPageTransform, endShapeInfo);\n  updateArrowheadPointWithBoundShape(a,\n  // <-- will be mutated\n  terminalsInArrowSpace.end, arrowPageTransform, startShapeInfo);\n  var minDist = MIN_ARROW_LENGTH;\n  var isSelfIntersection = startShapeInfo && endShapeInfo && startShapeInfo.shape === endShapeInfo.shape;\n  if (startShapeInfo && endShapeInfo && !isSelfIntersection && !startShapeInfo.isExact && !endShapeInfo.isExact) {\n    if (endShapeInfo.didIntersect && !startShapeInfo.didIntersect) {\n      if (startShapeInfo.util.isClosed(startShapeInfo.shape)) {\n        a.setTo(Vec2d.Nudge(b, a, minDist));\n      }\n    } else if (!endShapeInfo.didIntersect) {\n      if (endShapeInfo.util.isClosed(endShapeInfo.shape)) {\n        b.setTo(Vec2d.Nudge(a, b, minDist));\n      }\n    }\n  }\n  var u = Vec2d.Sub(b, a).uni();\n  var didFlip = !Vec2d.Equals(u, uAB);\n  if (!isSelfIntersection) {\n    if (startShapeInfo && arrowheadStart !== \"none\" && !startShapeInfo.isExact) {\n      var offset = BOUND_ARROW_OFFSET + STROKE_SIZES[shape.props.size] / 2 + (\"size\" in startShapeInfo.shape.props ? STROKE_SIZES[startShapeInfo.shape.props.size] / 2 : 0);\n      minDist -= offset;\n      a.nudge(b, offset * (didFlip ? -1 : 1));\n    }\n    if (endShapeInfo && arrowheadEnd !== \"none\" && !endShapeInfo.isExact) {\n      var _offset = BOUND_ARROW_OFFSET + STROKE_SIZES[shape.props.size] / 2 + (\"size\" in endShapeInfo.shape.props ? STROKE_SIZES[endShapeInfo.shape.props.size] / 2 : 0);\n      minDist -= _offset;\n      b.nudge(a, _offset * (didFlip ? -1 : 1));\n    }\n  }\n  if (startShapeInfo && endShapeInfo) {\n    if (didFlip) {\n      b.setTo(Vec2d.Add(a, u.mul(-minDist)));\n    } else if (Vec2d.Dist(a, b) < MIN_ARROW_LENGTH / 2) {\n      b.setTo(Vec2d.Add(a, u.mul(MIN_ARROW_LENGTH / 2)));\n    }\n  }\n  if (didFlip) {\n    c.setTo(Vec2d.Med(terminalsInArrowSpace.start, terminalsInArrowSpace.end));\n  } else {\n    c.setTo(Vec2d.Med(a, b));\n  }\n  var length = Vec2d.Dist(a, b);\n  return {\n    isStraight: true,\n    start: {\n      handle: terminalsInArrowSpace.start,\n      point: a,\n      arrowhead: shape.props.arrowheadStart\n    },\n    end: {\n      handle: terminalsInArrowSpace.end,\n      point: b,\n      arrowhead: shape.props.arrowheadEnd\n    },\n    middle: c,\n    isValid: length > 0,\n    length: length\n  };\n}\nfunction updateArrowheadPointWithBoundShape(point, opposite, arrowPageTransform, targetShapeInfo) {\n  if (targetShapeInfo === void 0) {\n    return;\n  }\n  if (targetShapeInfo.isExact) {\n    return;\n  }\n  var pageFrom = Matrix2d.applyToPoint(arrowPageTransform, opposite);\n  var pageTo = Matrix2d.applyToPoint(arrowPageTransform, point);\n  var targetFrom = Matrix2d.applyToPoint(Matrix2d.Inverse(targetShapeInfo.transform), pageFrom);\n  var targetTo = Matrix2d.applyToPoint(Matrix2d.Inverse(targetShapeInfo.transform), pageTo);\n  var isClosed = targetShapeInfo.util.isClosed(targetShapeInfo.shape);\n  var fn = isClosed ? intersectLineSegmentPolygon : intersectLineSegmentPolyline;\n  var intersection = fn(targetFrom, targetTo, targetShapeInfo.util.outline(targetShapeInfo.shape));\n  var targetInt;\n  if (intersection !== null) {\n    var _intersection$sort$;\n    targetInt = (_intersection$sort$ = intersection.sort(function (p1, p2) {\n      return Vec2d.Dist(p1, targetFrom) - Vec2d.Dist(p2, targetFrom);\n    })[0]) !== null && _intersection$sort$ !== void 0 ? _intersection$sort$ : isClosed ? void 0 : targetTo;\n  }\n  if (targetInt === void 0) {\n    return;\n  }\n  var pageInt = Matrix2d.applyToPoint(targetShapeInfo.transform, targetInt);\n  var arrowInt = Matrix2d.applyToPoint(Matrix2d.Inverse(arrowPageTransform), pageInt);\n  point.setTo(arrowInt);\n  targetShapeInfo.didIntersect = true;\n}\nfunction getStraightArrowHandlePath(info) {\n  return getArrowPath(info.start.handle, info.end.handle);\n}\nfunction getSolidStraightArrowPath(info) {\n  return getArrowPath(info.start.point, info.end.point);\n}\nfunction getArrowPath(start, end) {\n  return \"M\".concat(start.x, \",\").concat(start.y, \"L\").concat(end.x, \",\").concat(end.y);\n}\nfunction getStraightArrowBoundingBox(start, end) {\n  return new Box2d(Math.min(start.x, end.x), Math.min(start.y, end.y), Math.abs(start.x - end.x), Math.abs(start.y - end.y));\n}\nexport { getSolidStraightArrowPath, getStraightArrowBoundingBox, getStraightArrowHandlePath, getStraightArrowInfo };","map":{"version":3,"names":["Box2d","intersectLineSegmentPolygon","intersectLineSegmentPolyline","Matrix2d","Vec2d","STROKE_SIZES","BOUND_ARROW_OFFSET","getArrowTerminalsInArrowSpace","getBoundShapeInfoForTerminal","MIN_ARROW_LENGTH","getStraightArrowInfo","editor","shape","_shape$props","props","start","end","arrowheadStart","arrowheadEnd","terminalsInArrowSpace","a","clone","b","c","Med","uAB","Sub","uni","startShapeInfo","endShapeInfo","arrowPageTransform","getPageTransform","updateArrowheadPointWithBoundShape","minDist","isSelfIntersection","isExact","didIntersect","util","isClosed","setTo","Nudge","u","didFlip","Equals","offset","size","nudge","Add","mul","Dist","length","isStraight","handle","point","arrowhead","middle","isValid","opposite","targetShapeInfo","pageFrom","applyToPoint","pageTo","targetFrom","Inverse","transform","targetTo","fn","intersection","outline","targetInt","_intersection$sort$","sort","p1","p2","pageInt","arrowInt","getStraightArrowHandlePath","info","getArrowPath","getSolidStraightArrowPath","concat","x","y","getStraightArrowBoundingBox","Math","min","abs"],"sources":["/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@tldraw/editor/src/lib/editor/shapes/arrow/arrow/straight-arrow.ts"],"sourcesContent":["import {\n\tBox2d,\n\tintersectLineSegmentPolygon,\n\tintersectLineSegmentPolyline,\n\tMatrix2d,\n\tMatrix2dModel,\n\tVec2d,\n\tVecLike,\n} from '@tldraw/primitives'\nimport { TLArrowShape } from '@tldraw/tlschema'\nimport { Editor } from '../../../Editor'\nimport { STROKE_SIZES } from '../../shared/default-shape-constants'\nimport { ArrowInfo } from './arrow-types'\nimport {\n\tBOUND_ARROW_OFFSET,\n\tBoundShapeInfo,\n\tgetArrowTerminalsInArrowSpace,\n\tgetBoundShapeInfoForTerminal,\n\tMIN_ARROW_LENGTH,\n} from './shared'\n\nexport function getStraightArrowInfo(editor: Editor, shape: TLArrowShape): ArrowInfo {\n\tconst { start, end, arrowheadStart, arrowheadEnd } = shape.props\n\n\tconst terminalsInArrowSpace = getArrowTerminalsInArrowSpace(editor, shape)\n\n\tconst a = terminalsInArrowSpace.start.clone()\n\tconst b = terminalsInArrowSpace.end.clone()\n\tconst c = Vec2d.Med(a, b)\n\tconst uAB = Vec2d.Sub(b, a).uni()\n\n\t// Update the arrowhead points using intersections with the bound shapes, if any.\n\n\tconst startShapeInfo = getBoundShapeInfoForTerminal(editor, start)\n\tconst endShapeInfo = getBoundShapeInfoForTerminal(editor, end)\n\n\tconst arrowPageTransform = editor.getPageTransform(shape)!\n\n\t// Update the position of the arrowhead's end point\n\tupdateArrowheadPointWithBoundShape(\n\t\tb, // <-- will be mutated\n\t\tterminalsInArrowSpace.start,\n\t\tarrowPageTransform,\n\t\tendShapeInfo\n\t)\n\n\t// Then update the position of the arrowhead's end point\n\tupdateArrowheadPointWithBoundShape(\n\t\ta, // <-- will be mutated\n\t\tterminalsInArrowSpace.end,\n\t\tarrowPageTransform,\n\t\tstartShapeInfo\n\t)\n\n\tlet minDist = MIN_ARROW_LENGTH\n\n\tconst isSelfIntersection =\n\t\tstartShapeInfo && endShapeInfo && startShapeInfo.shape === endShapeInfo.shape\n\n\tif (\n\t\tstartShapeInfo &&\n\t\tendShapeInfo &&\n\t\t!isSelfIntersection &&\n\t\t!startShapeInfo.isExact &&\n\t\t!endShapeInfo.isExact\n\t) {\n\t\tif (endShapeInfo.didIntersect && !startShapeInfo.didIntersect) {\n\t\t\t// ...and if only the end shape intersected, then make it\n\t\t\t// a short arrow ending at the end shape intersection.\n\t\t\tif (startShapeInfo.util.isClosed(startShapeInfo.shape)) {\n\t\t\t\ta.setTo(Vec2d.Nudge(b, a, minDist))\n\t\t\t}\n\t\t} else if (!endShapeInfo.didIntersect) {\n\t\t\t// ...and if only the end shape intersected, or if neither\n\t\t\t// shape intersected, then make it a short arrow starting\n\t\t\t// at the start shape intersection.\n\t\t\tif (endShapeInfo.util.isClosed(endShapeInfo.shape)) {\n\t\t\t\tb.setTo(Vec2d.Nudge(a, b, minDist))\n\t\t\t}\n\t\t}\n\t}\n\n\tconst u = Vec2d.Sub(b, a).uni()\n\tconst didFlip = !Vec2d.Equals(u, uAB)\n\n\t// If the arrow is bound non-exact to a start shape and the\n\t// start point has an arrowhead offset the start point\n\tif (!isSelfIntersection) {\n\t\tif (startShapeInfo && arrowheadStart !== 'none' && !startShapeInfo.isExact) {\n\t\t\tconst offset =\n\t\t\t\tBOUND_ARROW_OFFSET +\n\t\t\t\tSTROKE_SIZES[shape.props.size] / 2 +\n\t\t\t\t('size' in startShapeInfo.shape.props\n\t\t\t\t\t? STROKE_SIZES[startShapeInfo.shape.props.size] / 2\n\t\t\t\t\t: 0)\n\n\t\t\tminDist -= offset\n\t\t\ta.nudge(b, offset * (didFlip ? -1 : 1))\n\t\t}\n\n\t\t// If the arrow is bound non-exact to an end shape and the\n\t\t// end point has an arrowhead offset the end point\n\t\tif (endShapeInfo && arrowheadEnd !== 'none' && !endShapeInfo.isExact) {\n\t\t\tconst offset =\n\t\t\t\tBOUND_ARROW_OFFSET +\n\t\t\t\tSTROKE_SIZES[shape.props.size] / 2 +\n\t\t\t\t('size' in endShapeInfo.shape.props ? STROKE_SIZES[endShapeInfo.shape.props.size] / 2 : 0)\n\n\t\t\tminDist -= offset\n\t\t\tb.nudge(a, offset * (didFlip ? -1 : 1))\n\t\t}\n\t}\n\n\tif (startShapeInfo && endShapeInfo) {\n\t\t// If we have two bound shapes...\n\t\tif (didFlip) {\n\t\t\t// If we flipped, then make the arrow a short arrow from\n\t\t\t// the start point towards where the end point should be.\n\t\t\tb.setTo(Vec2d.Add(a, u.mul(-minDist)))\n\t\t} else if (Vec2d.Dist(a, b) < MIN_ARROW_LENGTH / 2) {\n\t\t\t// Otherwise, if the arrow is too short, make it a short\n\t\t\t// arrow from the start point towards where the end point\n\t\t\t// should be.\n\t\t\tb.setTo(Vec2d.Add(a, u.mul(MIN_ARROW_LENGTH / 2)))\n\t\t}\n\t}\n\n\t// If the handles flipped their order, then set the center handle\n\t// to the midpoint of the terminals (rather than the midpoint of the\n\t// arrow body); otherwise, it may not be \"between\" the other terminals.\n\tif (didFlip) {\n\t\tc.setTo(Vec2d.Med(terminalsInArrowSpace.start, terminalsInArrowSpace.end))\n\t} else {\n\t\tc.setTo(Vec2d.Med(a, b))\n\t}\n\n\tconst length = Vec2d.Dist(a, b)\n\n\treturn {\n\t\tisStraight: true,\n\t\tstart: {\n\t\t\thandle: terminalsInArrowSpace.start,\n\t\t\tpoint: a,\n\t\t\tarrowhead: shape.props.arrowheadStart,\n\t\t},\n\t\tend: {\n\t\t\thandle: terminalsInArrowSpace.end,\n\t\t\tpoint: b,\n\t\t\tarrowhead: shape.props.arrowheadEnd,\n\t\t},\n\t\tmiddle: c,\n\t\tisValid: length > 0,\n\t\tlength,\n\t}\n}\n\n/** Get an intersection point from A -> B with bound shape (target) from shape (arrow). */\nfunction updateArrowheadPointWithBoundShape(\n\tpoint: Vec2d,\n\topposite: Vec2d,\n\tarrowPageTransform: Matrix2dModel,\n\ttargetShapeInfo?: BoundShapeInfo\n) {\n\tif (targetShapeInfo === undefined) {\n\t\t// No bound shape? The arrowhead point will be at the arrow terminal.\n\t\treturn\n\t}\n\n\tif (targetShapeInfo.isExact) {\n\t\t// Exact type binding? The arrowhead point will be at the arrow terminal.\n\t\treturn\n\t}\n\n\t// From and To in page space\n\tconst pageFrom = Matrix2d.applyToPoint(arrowPageTransform, opposite)\n\tconst pageTo = Matrix2d.applyToPoint(arrowPageTransform, point)\n\n\t// From and To in local space of the target shape\n\tconst targetFrom = Matrix2d.applyToPoint(Matrix2d.Inverse(targetShapeInfo.transform), pageFrom)\n\tconst targetTo = Matrix2d.applyToPoint(Matrix2d.Inverse(targetShapeInfo.transform), pageTo)\n\n\tconst isClosed = targetShapeInfo.util.isClosed(targetShapeInfo.shape)\n\tconst fn = isClosed ? intersectLineSegmentPolygon : intersectLineSegmentPolyline\n\n\tconst intersection = fn(targetFrom, targetTo, targetShapeInfo.util.outline(targetShapeInfo.shape))\n\n\tlet targetInt: VecLike | undefined\n\n\tif (intersection !== null) {\n\t\ttargetInt =\n\t\t\tintersection.sort((p1, p2) => Vec2d.Dist(p1, targetFrom) - Vec2d.Dist(p2, targetFrom))[0] ??\n\t\t\t(isClosed ? undefined : targetTo)\n\t}\n\n\tif (targetInt === undefined) {\n\t\t// No intersection? The arrowhead point will be at the arrow terminal.\n\t\treturn\n\t}\n\n\tconst pageInt = Matrix2d.applyToPoint(targetShapeInfo.transform, targetInt)\n\tconst arrowInt = Matrix2d.applyToPoint(Matrix2d.Inverse(arrowPageTransform), pageInt)\n\n\tpoint.setTo(arrowInt)\n\n\ttargetShapeInfo.didIntersect = true\n}\n\nexport function getStraightArrowHandlePath(info: ArrowInfo & { isStraight: true }) {\n\treturn getArrowPath(info.start.handle, info.end.handle)\n}\n\nexport function getSolidStraightArrowPath(info: ArrowInfo & { isStraight: true }) {\n\treturn getArrowPath(info.start.point, info.end.point)\n}\n\nfunction getArrowPath(start: VecLike, end: VecLike) {\n\treturn `M${start.x},${start.y}L${end.x},${end.y}`\n}\n\nexport function getStraightArrowBoundingBox(start: VecLike, end: VecLike) {\n\treturn new Box2d(\n\t\tMath.min(start.x, end.x),\n\t\tMath.min(start.y, end.y),\n\t\tMath.abs(start.x - end.x),\n\t\tMath.abs(start.y - end.y)\n\t)\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}