{"ast":null,"code":"import _objectSpread from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _createForOfIteratorHelper from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _inherits from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _defineProperty from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport { jsx, jsxs } from \"react/jsx-runtime\";\nimport { Box2d, getStrokeOutlinePoints, getStrokePoints, linesIntersect, pointInPolygon, setStrokePointRadii, toFixed, Vec2d } from \"@tldraw/primitives\";\nimport { last, rng } from \"@tldraw/utils\";\nimport { SVGContainer } from \"../../../components/SVGContainer.mjs\";\nimport { getSvgPathFromStroke, getSvgPathFromStrokePoints } from \"../../../utils/svg.mjs\";\nimport { ShapeUtil } from \"../ShapeUtil.mjs\";\nimport { STROKE_SIZES } from \"../shared/default-shape-constants.mjs\";\nimport { getShapeFillSvg, ShapeFill } from \"../shared/ShapeFill.mjs\";\nimport { useForceSolid } from \"../shared/useForceSolid.mjs\";\nimport { getDrawShapeStrokeDashArray, getFreehandOptions, getPointsFromSegments } from \"./getPath.mjs\";\nvar DrawShapeUtil = /*#__PURE__*/function (_ShapeUtil) {\n  _inherits(DrawShapeUtil, _ShapeUtil);\n  var _super = _createSuper(DrawShapeUtil);\n  function DrawShapeUtil() {\n    var _this;\n    _classCallCheck(this, DrawShapeUtil);\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    _this = _super.call.apply(_super, [this].concat(args));\n    _defineProperty(_assertThisInitialized(_this), \"hideResizeHandles\", function (shape) {\n      return getIsDot(shape);\n    });\n    _defineProperty(_assertThisInitialized(_this), \"hideRotateHandle\", function (shape) {\n      return getIsDot(shape);\n    });\n    _defineProperty(_assertThisInitialized(_this), \"hideSelectionBoundsBg\", function (shape) {\n      return getIsDot(shape);\n    });\n    _defineProperty(_assertThisInitialized(_this), \"hideSelectionBoundsFg\", function (shape) {\n      return getIsDot(shape);\n    });\n    _defineProperty(_assertThisInitialized(_this), \"isClosed\", function (shape) {\n      return shape.props.isClosed;\n    });\n    _defineProperty(_assertThisInitialized(_this), \"onResize\", function (shape, info) {\n      var scaleX = info.scaleX,\n        scaleY = info.scaleY;\n      var newSegments = [];\n      var _iterator = _createForOfIteratorHelper(shape.props.segments),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var segment = _step.value;\n          newSegments.push(_objectSpread(_objectSpread({}, segment), {}, {\n            points: segment.points.map(function (_ref) {\n              var x = _ref.x,\n                y = _ref.y,\n                z = _ref.z;\n              return {\n                x: toFixed(scaleX * x),\n                y: toFixed(scaleY * y),\n                z: z\n              };\n            })\n          }));\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return {\n        props: {\n          segments: newSegments\n        }\n      };\n    });\n    return _this;\n  }\n  _createClass(DrawShapeUtil, [{\n    key: \"defaultProps\",\n    value: function defaultProps() {\n      return {\n        segments: [],\n        color: \"black\",\n        fill: \"none\",\n        dash: \"draw\",\n        size: \"m\",\n        isComplete: false,\n        isClosed: false,\n        isPen: false\n      };\n    }\n  }, {\n    key: \"getBounds\",\n    value: function getBounds(shape) {\n      return Box2d.FromPoints(this.outline(shape));\n    }\n  }, {\n    key: \"getOutline\",\n    value: function getOutline(shape) {\n      return getPointsFromSegments(shape.props.segments);\n    }\n  }, {\n    key: \"getCenter\",\n    value: function getCenter(shape) {\n      return this.bounds(shape).center;\n    }\n  }, {\n    key: \"hitTestPoint\",\n    value: function hitTestPoint(shape, point) {\n      var outline = this.outline(shape);\n      var zoomLevel = this.editor.zoomLevel;\n      var offsetDist = STROKE_SIZES[shape.props.size] / zoomLevel;\n      if (shape.props.segments.length === 1 && shape.props.segments[0].points.length < 4) {\n        if (shape.props.segments[0].points.some(function (pt) {\n          return Vec2d.Dist(point, pt) < offsetDist * 1.5;\n        })) {\n          return true;\n        }\n      }\n      if (this.isClosed(shape)) {\n        return pointInPolygon(point, outline);\n      }\n      if (this.bounds(shape).containsPoint(point)) {\n        for (var i = 0; i < outline.length; i++) {\n          var C = outline[i];\n          var D = outline[(i + 1) % outline.length];\n          if (Vec2d.DistanceToLineSegment(C, D, point) < offsetDist) return true;\n        }\n      }\n      return false;\n    }\n  }, {\n    key: \"hitTestLineSegment\",\n    value: function hitTestLineSegment(shape, A, B) {\n      var outline = this.outline(shape);\n      if (shape.props.segments.length === 1 && shape.props.segments[0].points.length < 4) {\n        var zoomLevel = this.editor.zoomLevel;\n        var offsetDist = STROKE_SIZES[shape.props.size] / zoomLevel;\n        if (shape.props.segments[0].points.some(function (pt) {\n          return Vec2d.DistanceToLineSegment(A, B, pt) < offsetDist * 1.5;\n        })) {\n          return true;\n        }\n      }\n      if (this.isClosed(shape)) {\n        for (var i = 0; i < outline.length; i++) {\n          var C = outline[i];\n          var D = outline[(i + 1) % outline.length];\n          if (linesIntersect(A, B, C, D)) return true;\n        }\n      } else {\n        for (var _i = 0; _i < outline.length - 1; _i++) {\n          var _C = outline[_i];\n          var _D = outline[_i + 1];\n          if (linesIntersect(A, B, _C, _D)) return true;\n        }\n      }\n      return false;\n    }\n  }, {\n    key: \"component\",\n    value: function component(shape) {\n      var _last;\n      var forceSolid = useForceSolid();\n      var strokeWidth = STROKE_SIZES[shape.props.size];\n      var allPointsFromSegments = getPointsFromSegments(shape.props.segments);\n      var showAsComplete = shape.props.isComplete || ((_last = last(shape.props.segments)) === null || _last === void 0 ? void 0 : _last.type) === \"straight\";\n      var sw = strokeWidth;\n      if (!forceSolid && !shape.props.isPen && shape.props.dash === \"draw\" && allPointsFromSegments.length === 1) {\n        sw += rng(shape.id)() * (strokeWidth / 6);\n      }\n      var options = getFreehandOptions(shape.props, sw, showAsComplete, forceSolid);\n      var strokePoints = getStrokePoints(allPointsFromSegments, options);\n      var solidStrokePath = strokePoints.length > 1 ? getSvgPathFromStrokePoints(strokePoints, shape.props.isClosed) : getDot(allPointsFromSegments[0], sw);\n      if (!forceSolid && shape.props.dash === \"draw\" || strokePoints.length < 2) {\n        setStrokePointRadii(strokePoints, options);\n        var strokeOutlinePoints = getStrokeOutlinePoints(strokePoints, options);\n        return /* @__PURE__ */jsxs(SVGContainer, {\n          id: shape.id,\n          children: [/* @__PURE__ */jsx(ShapeFill, {\n            fill: shape.props.isClosed ? shape.props.fill : \"none\",\n            color: shape.props.color,\n            d: solidStrokePath\n          }), /* @__PURE__ */jsx(\"path\", {\n            d: getSvgPathFromStroke(strokeOutlinePoints, true),\n            strokeLinecap: \"round\",\n            fill: \"var(--palette-\".concat(shape.props.color, \")\")\n          })]\n        });\n      }\n      return /* @__PURE__ */jsxs(SVGContainer, {\n        id: shape.id,\n        children: [/* @__PURE__ */jsx(ShapeFill, {\n          color: shape.props.color,\n          fill: shape.props.isClosed ? shape.props.fill : \"none\",\n          d: solidStrokePath\n        }), /* @__PURE__ */jsx(\"path\", {\n          d: solidStrokePath,\n          strokeLinecap: \"round\",\n          fill: \"none\",\n          stroke: \"var(--palette-\".concat(shape.props.color, \")\"),\n          strokeWidth: strokeWidth,\n          strokeDasharray: getDrawShapeStrokeDashArray(shape, strokeWidth),\n          strokeDashoffset: \"0\"\n        })]\n      });\n    }\n  }, {\n    key: \"indicator\",\n    value: function indicator(shape) {\n      var _last2;\n      var forceSolid = useForceSolid();\n      var strokeWidth = STROKE_SIZES[shape.props.size];\n      var allPointsFromSegments = getPointsFromSegments(shape.props.segments);\n      var sw = strokeWidth;\n      if (!forceSolid && !shape.props.isPen && shape.props.dash === \"draw\" && allPointsFromSegments.length === 1) {\n        sw += rng(shape.id)() * (strokeWidth / 6);\n      }\n      var showAsComplete = shape.props.isComplete || ((_last2 = last(shape.props.segments)) === null || _last2 === void 0 ? void 0 : _last2.type) === \"straight\";\n      var options = getFreehandOptions(shape.props, sw, showAsComplete, true);\n      var strokePoints = getStrokePoints(allPointsFromSegments, options);\n      var solidStrokePath = strokePoints.length > 1 ? getSvgPathFromStrokePoints(strokePoints, shape.props.isClosed) : getDot(allPointsFromSegments[0], sw);\n      return /* @__PURE__ */jsx(\"path\", {\n        d: solidStrokePath\n      });\n    }\n  }, {\n    key: \"toSvg\",\n    value: function toSvg(shape, _font, colors) {\n      var _last3;\n      var color = shape.props.color;\n      var strokeWidth = STROKE_SIZES[shape.props.size];\n      var allPointsFromSegments = getPointsFromSegments(shape.props.segments);\n      var showAsComplete = shape.props.isComplete || ((_last3 = last(shape.props.segments)) === null || _last3 === void 0 ? void 0 : _last3.type) === \"straight\";\n      var sw = strokeWidth;\n      if (!shape.props.isPen && shape.props.dash === \"draw\" && allPointsFromSegments.length === 1) {\n        sw += rng(shape.id)() * (strokeWidth / 6);\n      }\n      var options = getFreehandOptions(shape.props, sw, showAsComplete, false);\n      var strokePoints = getStrokePoints(allPointsFromSegments, options);\n      var solidStrokePath = strokePoints.length > 1 ? getSvgPathFromStrokePoints(strokePoints, shape.props.isClosed) : getDot(allPointsFromSegments[0], sw);\n      var foregroundPath;\n      if (shape.props.dash === \"draw\" || strokePoints.length < 2) {\n        setStrokePointRadii(strokePoints, options);\n        var strokeOutlinePoints = getStrokeOutlinePoints(strokePoints, options);\n        var p = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n        p.setAttribute(\"d\", getSvgPathFromStroke(strokeOutlinePoints, true));\n        p.setAttribute(\"fill\", colors.fill[color]);\n        p.setAttribute(\"stroke-linecap\", \"round\");\n        foregroundPath = p;\n      } else {\n        var _p = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n        _p.setAttribute(\"d\", solidStrokePath);\n        _p.setAttribute(\"stroke\", colors.fill[color]);\n        _p.setAttribute(\"fill\", \"none\");\n        _p.setAttribute(\"stroke-linecap\", \"round\");\n        _p.setAttribute(\"stroke-width\", strokeWidth.toString());\n        _p.setAttribute(\"stroke-dasharray\", getDrawShapeStrokeDashArray(shape, strokeWidth));\n        _p.setAttribute(\"stroke-dashoffset\", \"0\");\n        foregroundPath = _p;\n      }\n      var fillPath = getShapeFillSvg({\n        fill: shape.props.isClosed ? shape.props.fill : \"none\",\n        d: solidStrokePath,\n        color: shape.props.color,\n        colors: colors\n      });\n      if (fillPath) {\n        var g = document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\");\n        g.appendChild(fillPath);\n        g.appendChild(foregroundPath);\n        return g;\n      }\n      return foregroundPath;\n    }\n  }, {\n    key: \"expandSelectionOutlinePx\",\n    value: function expandSelectionOutlinePx(shape) {\n      var multiplier = shape.props.dash === \"draw\" ? 1.6 : 1;\n      return STROKE_SIZES[shape.props.size] * multiplier / 2;\n    }\n  }]);\n  return DrawShapeUtil;\n}(ShapeUtil);\n_defineProperty(DrawShapeUtil, \"type\", \"draw\");\nfunction getDot(point, sw) {\n  var r = (sw + 1) * 0.5;\n  return \"M \".concat(point.x, \" \").concat(point.y, \" m -\").concat(r, \", 0 a \").concat(r, \",\").concat(r, \" 0 1,0 \").concat(r * 2, \",0 a \").concat(r, \",\").concat(r, \" 0 1,0 -\").concat(r * 2, \",0\");\n}\nfunction getIsDot(shape) {\n  return shape.props.segments.length === 1 && shape.props.segments[0].points.length < 2;\n}\nexport { DrawShapeUtil };","map":{"version":3,"names":["jsx","jsxs","Box2d","getStrokeOutlinePoints","getStrokePoints","linesIntersect","pointInPolygon","setStrokePointRadii","toFixed","Vec2d","last","rng","SVGContainer","getSvgPathFromStroke","getSvgPathFromStrokePoints","ShapeUtil","STROKE_SIZES","getShapeFillSvg","ShapeFill","useForceSolid","getDrawShapeStrokeDashArray","getFreehandOptions","getPointsFromSegments","DrawShapeUtil","_ShapeUtil","_inherits","_super","_createSuper","_this","_classCallCheck","_len","arguments","length","args","Array","_key","call","apply","concat","_defineProperty","_assertThisInitialized","shape","getIsDot","props","isClosed","info","scaleX","scaleY","newSegments","_iterator","_createForOfIteratorHelper","segments","_step","s","n","done","segment","value","push","_objectSpread","points","map","_ref","x","y","z","err","e","f","_createClass","key","defaultProps","color","fill","dash","size","isComplete","isPen","getBounds","FromPoints","outline","getOutline","getCenter","bounds","center","hitTestPoint","point","zoomLevel","editor","offsetDist","some","pt","Dist","containsPoint","i","C","D","DistanceToLineSegment","hitTestLineSegment","A","B","component","_last","forceSolid","strokeWidth","allPointsFromSegments","showAsComplete","type","sw","id","options","strokePoints","solidStrokePath","getDot","strokeOutlinePoints","children","d","strokeLinecap","stroke","strokeDasharray","strokeDashoffset","indicator","_last2","toSvg","_font","colors","_last3","foregroundPath","p","document","createElementNS","setAttribute","toString","fillPath","g","appendChild","expandSelectionOutlinePx","multiplier","r"],"sources":["/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@tldraw/editor/src/lib/editor/shapes/draw/DrawShapeUtil.tsx"],"sourcesContent":["/* eslint-disable react-hooks/rules-of-hooks */\nimport {\n\tBox2d,\n\tgetStrokeOutlinePoints,\n\tgetStrokePoints,\n\tlinesIntersect,\n\tpointInPolygon,\n\tsetStrokePointRadii,\n\ttoFixed,\n\tVec2d,\n\tVecLike,\n} from '@tldraw/primitives'\nimport { TLDrawShape, TLDrawShapeSegment } from '@tldraw/tlschema'\nimport { last, rng } from '@tldraw/utils'\nimport { SVGContainer } from '../../../components/SVGContainer'\nimport { getSvgPathFromStroke, getSvgPathFromStrokePoints } from '../../../utils/svg'\nimport { ShapeUtil, TLOnResizeHandler } from '../ShapeUtil'\nimport { STROKE_SIZES } from '../shared/default-shape-constants'\nimport { getShapeFillSvg, ShapeFill } from '../shared/ShapeFill'\nimport { TLExportColors } from '../shared/TLExportColors'\nimport { useForceSolid } from '../shared/useForceSolid'\nimport { getDrawShapeStrokeDashArray, getFreehandOptions, getPointsFromSegments } from './getPath'\n\n/** @public */\nexport class DrawShapeUtil extends ShapeUtil<TLDrawShape> {\n\tstatic override type = 'draw' as const\n\n\thideResizeHandles = (shape: TLDrawShape) => getIsDot(shape)\n\thideRotateHandle = (shape: TLDrawShape) => getIsDot(shape)\n\thideSelectionBoundsBg = (shape: TLDrawShape) => getIsDot(shape)\n\thideSelectionBoundsFg = (shape: TLDrawShape) => getIsDot(shape)\n\n\toverride defaultProps(): TLDrawShape['props'] {\n\t\treturn {\n\t\t\tsegments: [],\n\t\t\tcolor: 'black',\n\t\t\tfill: 'none',\n\t\t\tdash: 'draw',\n\t\t\tsize: 'm',\n\t\t\tisComplete: false,\n\t\t\tisClosed: false,\n\t\t\tisPen: false,\n\t\t}\n\t}\n\n\tisClosed = (shape: TLDrawShape) => shape.props.isClosed\n\n\tgetBounds(shape: TLDrawShape) {\n\t\treturn Box2d.FromPoints(this.outline(shape))\n\t}\n\n\tgetOutline(shape: TLDrawShape) {\n\t\treturn getPointsFromSegments(shape.props.segments)\n\t}\n\n\tgetCenter(shape: TLDrawShape): Vec2d {\n\t\treturn this.bounds(shape).center\n\t}\n\n\thitTestPoint(shape: TLDrawShape, point: VecLike): boolean {\n\t\tconst outline = this.outline(shape)\n\t\tconst zoomLevel = this.editor.zoomLevel\n\t\tconst offsetDist = STROKE_SIZES[shape.props.size] / zoomLevel\n\n\t\tif (shape.props.segments.length === 1 && shape.props.segments[0].points.length < 4) {\n\t\t\tif (shape.props.segments[0].points.some((pt) => Vec2d.Dist(point, pt) < offsetDist * 1.5)) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\n\t\tif (this.isClosed(shape)) {\n\t\t\treturn pointInPolygon(point, outline)\n\t\t}\n\n\t\tif (this.bounds(shape).containsPoint(point)) {\n\t\t\tfor (let i = 0; i < outline.length; i++) {\n\t\t\t\tconst C = outline[i]\n\t\t\t\tconst D = outline[(i + 1) % outline.length]\n\n\t\t\t\tif (Vec2d.DistanceToLineSegment(C, D, point) < offsetDist) return true\n\t\t\t}\n\t\t}\n\n\t\treturn false\n\t}\n\n\thitTestLineSegment(shape: TLDrawShape, A: VecLike, B: VecLike): boolean {\n\t\tconst outline = this.outline(shape)\n\n\t\tif (shape.props.segments.length === 1 && shape.props.segments[0].points.length < 4) {\n\t\t\tconst zoomLevel = this.editor.zoomLevel\n\t\t\tconst offsetDist = STROKE_SIZES[shape.props.size] / zoomLevel\n\n\t\t\tif (\n\t\t\t\tshape.props.segments[0].points.some(\n\t\t\t\t\t(pt) => Vec2d.DistanceToLineSegment(A, B, pt) < offsetDist * 1.5\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\n\t\tif (this.isClosed(shape)) {\n\t\t\tfor (let i = 0; i < outline.length; i++) {\n\t\t\t\tconst C = outline[i]\n\t\t\t\tconst D = outline[(i + 1) % outline.length]\n\t\t\t\tif (linesIntersect(A, B, C, D)) return true\n\t\t\t}\n\t\t} else {\n\t\t\tfor (let i = 0; i < outline.length - 1; i++) {\n\t\t\t\tconst C = outline[i]\n\t\t\t\tconst D = outline[i + 1]\n\t\t\t\tif (linesIntersect(A, B, C, D)) return true\n\t\t\t}\n\t\t}\n\n\t\treturn false\n\t}\n\n\tcomponent(shape: TLDrawShape) {\n\t\tconst forceSolid = useForceSolid()\n\t\tconst strokeWidth = STROKE_SIZES[shape.props.size]\n\t\tconst allPointsFromSegments = getPointsFromSegments(shape.props.segments)\n\n\t\tconst showAsComplete = shape.props.isComplete || last(shape.props.segments)?.type === 'straight'\n\n\t\tlet sw = strokeWidth\n\t\tif (\n\t\t\t!forceSolid &&\n\t\t\t!shape.props.isPen &&\n\t\t\tshape.props.dash === 'draw' &&\n\t\t\tallPointsFromSegments.length === 1\n\t\t) {\n\t\t\tsw += rng(shape.id)() * (strokeWidth / 6)\n\t\t}\n\n\t\tconst options = getFreehandOptions(shape.props, sw, showAsComplete, forceSolid)\n\t\tconst strokePoints = getStrokePoints(allPointsFromSegments, options)\n\n\t\tconst solidStrokePath =\n\t\t\tstrokePoints.length > 1\n\t\t\t\t? getSvgPathFromStrokePoints(strokePoints, shape.props.isClosed)\n\t\t\t\t: getDot(allPointsFromSegments[0], sw)\n\n\t\tif ((!forceSolid && shape.props.dash === 'draw') || strokePoints.length < 2) {\n\t\t\tsetStrokePointRadii(strokePoints, options)\n\t\t\tconst strokeOutlinePoints = getStrokeOutlinePoints(strokePoints, options)\n\n\t\t\treturn (\n\t\t\t\t<SVGContainer id={shape.id}>\n\t\t\t\t\t<ShapeFill\n\t\t\t\t\t\tfill={shape.props.isClosed ? shape.props.fill : 'none'}\n\t\t\t\t\t\tcolor={shape.props.color}\n\t\t\t\t\t\td={solidStrokePath}\n\t\t\t\t\t/>\n\t\t\t\t\t<path\n\t\t\t\t\t\td={getSvgPathFromStroke(strokeOutlinePoints, true)}\n\t\t\t\t\t\tstrokeLinecap=\"round\"\n\t\t\t\t\t\tfill={`var(--palette-${shape.props.color})`}\n\t\t\t\t\t/>\n\t\t\t\t</SVGContainer>\n\t\t\t)\n\t\t}\n\n\t\treturn (\n\t\t\t<SVGContainer id={shape.id}>\n\t\t\t\t<ShapeFill\n\t\t\t\t\tcolor={shape.props.color}\n\t\t\t\t\tfill={shape.props.isClosed ? shape.props.fill : 'none'}\n\t\t\t\t\td={solidStrokePath}\n\t\t\t\t/>\n\t\t\t\t<path\n\t\t\t\t\td={solidStrokePath}\n\t\t\t\t\tstrokeLinecap=\"round\"\n\t\t\t\t\tfill=\"none\"\n\t\t\t\t\tstroke={`var(--palette-${shape.props.color})`}\n\t\t\t\t\tstrokeWidth={strokeWidth}\n\t\t\t\t\tstrokeDasharray={getDrawShapeStrokeDashArray(shape, strokeWidth)}\n\t\t\t\t\tstrokeDashoffset=\"0\"\n\t\t\t\t/>\n\t\t\t</SVGContainer>\n\t\t)\n\t}\n\n\tindicator(shape: TLDrawShape) {\n\t\tconst forceSolid = useForceSolid()\n\t\tconst strokeWidth = STROKE_SIZES[shape.props.size]\n\t\tconst allPointsFromSegments = getPointsFromSegments(shape.props.segments)\n\n\t\tlet sw = strokeWidth\n\t\tif (\n\t\t\t!forceSolid &&\n\t\t\t!shape.props.isPen &&\n\t\t\tshape.props.dash === 'draw' &&\n\t\t\tallPointsFromSegments.length === 1\n\t\t) {\n\t\t\tsw += rng(shape.id)() * (strokeWidth / 6)\n\t\t}\n\n\t\tconst showAsComplete = shape.props.isComplete || last(shape.props.segments)?.type === 'straight'\n\t\tconst options = getFreehandOptions(shape.props, sw, showAsComplete, true)\n\t\tconst strokePoints = getStrokePoints(allPointsFromSegments, options)\n\t\tconst solidStrokePath =\n\t\t\tstrokePoints.length > 1\n\t\t\t\t? getSvgPathFromStrokePoints(strokePoints, shape.props.isClosed)\n\t\t\t\t: getDot(allPointsFromSegments[0], sw)\n\n\t\treturn <path d={solidStrokePath} />\n\t}\n\n\ttoSvg(shape: TLDrawShape, _font: string | undefined, colors: TLExportColors) {\n\t\tconst { color } = shape.props\n\n\t\tconst strokeWidth = STROKE_SIZES[shape.props.size]\n\t\tconst allPointsFromSegments = getPointsFromSegments(shape.props.segments)\n\n\t\tconst showAsComplete = shape.props.isComplete || last(shape.props.segments)?.type === 'straight'\n\n\t\tlet sw = strokeWidth\n\t\tif (!shape.props.isPen && shape.props.dash === 'draw' && allPointsFromSegments.length === 1) {\n\t\t\tsw += rng(shape.id)() * (strokeWidth / 6)\n\t\t}\n\n\t\tconst options = getFreehandOptions(shape.props, sw, showAsComplete, false)\n\t\tconst strokePoints = getStrokePoints(allPointsFromSegments, options)\n\t\tconst solidStrokePath =\n\t\t\tstrokePoints.length > 1\n\t\t\t\t? getSvgPathFromStrokePoints(strokePoints, shape.props.isClosed)\n\t\t\t\t: getDot(allPointsFromSegments[0], sw)\n\n\t\tlet foregroundPath: SVGPathElement | undefined\n\n\t\tif (shape.props.dash === 'draw' || strokePoints.length < 2) {\n\t\t\tsetStrokePointRadii(strokePoints, options)\n\t\t\tconst strokeOutlinePoints = getStrokeOutlinePoints(strokePoints, options)\n\n\t\t\tconst p = document.createElementNS('http://www.w3.org/2000/svg', 'path')\n\t\t\tp.setAttribute('d', getSvgPathFromStroke(strokeOutlinePoints, true))\n\t\t\tp.setAttribute('fill', colors.fill[color])\n\t\t\tp.setAttribute('stroke-linecap', 'round')\n\n\t\t\tforegroundPath = p\n\t\t} else {\n\t\t\tconst p = document.createElementNS('http://www.w3.org/2000/svg', 'path')\n\t\t\tp.setAttribute('d', solidStrokePath)\n\t\t\tp.setAttribute('stroke', colors.fill[color])\n\t\t\tp.setAttribute('fill', 'none')\n\t\t\tp.setAttribute('stroke-linecap', 'round')\n\t\t\tp.setAttribute('stroke-width', strokeWidth.toString())\n\t\t\tp.setAttribute('stroke-dasharray', getDrawShapeStrokeDashArray(shape, strokeWidth))\n\t\t\tp.setAttribute('stroke-dashoffset', '0')\n\n\t\t\tforegroundPath = p\n\t\t}\n\n\t\tconst fillPath = getShapeFillSvg({\n\t\t\tfill: shape.props.isClosed ? shape.props.fill : 'none',\n\t\t\td: solidStrokePath,\n\t\t\tcolor: shape.props.color,\n\t\t\tcolors,\n\t\t})\n\n\t\tif (fillPath) {\n\t\t\tconst g = document.createElementNS('http://www.w3.org/2000/svg', 'g')\n\t\t\tg.appendChild(fillPath)\n\t\t\tg.appendChild(foregroundPath)\n\t\t\treturn g\n\t\t}\n\n\t\treturn foregroundPath\n\t}\n\n\toverride onResize: TLOnResizeHandler<TLDrawShape> = (shape, info) => {\n\t\tconst { scaleX, scaleY } = info\n\n\t\tconst newSegments: TLDrawShapeSegment[] = []\n\n\t\tfor (const segment of shape.props.segments) {\n\t\t\tnewSegments.push({\n\t\t\t\t...segment,\n\t\t\t\tpoints: segment.points.map(({ x, y, z }) => {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tx: toFixed(scaleX * x),\n\t\t\t\t\t\ty: toFixed(scaleY * y),\n\t\t\t\t\t\tz,\n\t\t\t\t\t}\n\t\t\t\t}),\n\t\t\t})\n\t\t}\n\n\t\treturn {\n\t\t\tprops: {\n\t\t\t\tsegments: newSegments,\n\t\t\t},\n\t\t}\n\t}\n\n\texpandSelectionOutlinePx(shape: TLDrawShape): number {\n\t\tconst multiplier = shape.props.dash === 'draw' ? 1.6 : 1\n\t\treturn (STROKE_SIZES[shape.props.size] * multiplier) / 2\n\t}\n}\n\nfunction getDot(point: VecLike, sw: number) {\n\tconst r = (sw + 1) * 0.5\n\treturn `M ${point.x} ${point.y} m -${r}, 0 a ${r},${r} 0 1,0 ${r * 2},0 a ${r},${r} 0 1,0 -${\n\t\tr * 2\n\t},0`\n}\n\nfunction getIsDot(shape: TLDrawShape) {\n\treturn shape.props.segments.length === 1 && shape.props.segments[0].points.length < 2\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}