import { Vec2d } from "@tldraw/primitives";
import {
  AssetRecordType,
  createShapeId
} from "@tldraw/tlschema";
import { compact, getHashForString } from "@tldraw/utils";
import { MAX_ASSET_HEIGHT, MAX_ASSET_WIDTH } from "../../constants.mjs";
import {
  ACCEPTED_IMG_TYPE,
  ACCEPTED_VID_TYPE,
  containBoxSize,
  getFileMetaData,
  getImageSizeFromSrc,
  getResizedImageDataUrl,
  getVideoSizeFromSrc,
  isImage
} from "../../utils/assets.mjs";
import { truncateStringWithEllipsis } from "../../utils/dom.mjs";
import { getEmbedInfo } from "../../utils/embeds.mjs";
import { FONT_FAMILIES, FONT_SIZES, TEXT_PROPS } from "../shapes/shared/default-shape-constants.mjs";
import { INDENT } from "../shapes/text/TextHelpers.mjs";
import { TextShapeUtil } from "../shapes/text/TextShapeUtil.mjs";
class ExternalContentManager {
  constructor(editor) {
    this.editor = editor;
  }
  handleContent = async (info) => {
    switch (info.type) {
      case "text": {
        return await this.handleText(this.editor, info);
      }
      case "files": {
        return await this.handleFiles(this.editor, info);
      }
      case "embed": {
        return await this.handleEmbed(this.editor, info);
      }
      case "svg-text": {
        return await this.handleSvgText(this.editor, info);
      }
      case "url": {
        return await this.handleUrl(this.editor, info);
      }
    }
  };
  /**
   * Handle svg text from an external source. Feeling lucky? Overwrite this at runtime to change the way this type of external content is handled.
   *
   * @example
   * ```ts
   * editor.this.handleSvgText = myCustomMethod
   * ```
   *
   * @param editor - The editor instance.
   * @param info - The info object describing the external content.
   *
   * @public
   */
  async handleSvgText(editor, { point, text }) {
    const position = point ?? (editor.inputs.shiftKey ? editor.inputs.currentPagePoint : editor.viewportPageCenter);
    const svg = new DOMParser().parseFromString(text, "image/svg+xml").querySelector("svg");
    if (!svg) {
      throw new Error("No <svg/> element present");
    }
    let width = parseFloat(svg.getAttribute("width") || "0");
    let height = parseFloat(svg.getAttribute("height") || "0");
    if (!(width && height)) {
      document.body.appendChild(svg);
      const box = svg.getBoundingClientRect();
      document.body.removeChild(svg);
      width = box.width;
      height = box.height;
    }
    const asset = await this.createAssetFromFile(
      editor,
      new File([text], "asset.svg", { type: "image/svg+xml" })
    );
    this.createShapesForAssets(editor, [asset], position);
  }
  /**
   * Handle embed info from an external source. Feeling lucky? Overwrite this at runtime to change the way this type of external content is handled.
   *
   * @example
   * ```ts
   * editor.this.handleEmbed = myCustomMethod
   * ```
   *
   * @param editor - The editor instance
   * @param info - The info object describing the external content.
   *
   * @public
   */
  async handleEmbed(editor, { point, url, embed }) {
    const position = point ?? (editor.inputs.shiftKey ? editor.inputs.currentPagePoint : editor.viewportPageCenter);
    const { width, height } = embed;
    const shapePartial = {
      id: createShapeId(),
      type: "embed",
      x: position.x - (width || 450) / 2,
      y: position.y - (height || 450) / 2,
      props: {
        w: width,
        h: height,
        url
      }
    };
    editor.createShapes([shapePartial], true);
  }
  /**
   * Handle files from an external source. Feeling lucky? Overwrite this at runtime to change the way this type of external content is handled.
   *
   * @example
   * ```ts
   * editor.this.handleFiles = myCustomMethod
   * ```
   *
   * @param editor - The editor instance
   * @param info - The info object describing the external content.
   *
   * @public
   */
  async handleFiles(editor, { point, files }) {
    const position = point ?? (editor.inputs.shiftKey ? editor.inputs.currentPagePoint : editor.viewportPageCenter);
    const pagePoint = new Vec2d(position.x, position.y);
    const assets = [];
    await Promise.all(
      files.map(async (file, i) => {
        if (!file.type)
          throw new Error("No mime type");
        if (!ACCEPTED_IMG_TYPE.concat(ACCEPTED_VID_TYPE).includes(file.type)) {
          console.warn(`${file.name} not loaded - Extension not allowed.`);
          return null;
        }
        try {
          const asset = await this.createAssetFromFile(editor, file);
          if (!asset)
            throw Error("Could not create an asset");
          assets[i] = asset;
        } catch (error) {
          console.error(error);
          return null;
        }
      })
    );
    this.createShapesForAssets(editor, compact(assets), pagePoint);
  }
  /**
   * Handle plain text from an external source. Feeling lucky? Overwrite this at runtime to change the way this type of external content is handled.
   *
   * @example
   * ```ts
   * editor.this.handleText = myCustomMethod
   * ```
   *
   * @param editor - The editor instance
   * @param info - The info object describing the external content.
   *
   * @public
   */
  async handleText(editor, { point, text }) {
    const p = point ?? (editor.inputs.shiftKey ? editor.inputs.currentPagePoint : editor.viewportPageCenter);
    const defaultProps = editor.getShapeUtil(TextShapeUtil).defaultProps();
    const textToPaste = stripTrailingWhitespace(
      stripCommonMinimumIndentation(replaceTabsWithSpaces(text))
    );
    let w;
    let h;
    let autoSize;
    let align = "middle";
    const isMultiLine = textToPaste.split("\n").length > 1;
    const isRtl = rtlRegex.test(textToPaste);
    if (isMultiLine) {
      align = isMultiLine ? isRtl ? "end" : "start" : "middle";
    }
    const rawSize = editor.textMeasure.measureText(textToPaste, {
      ...TEXT_PROPS,
      fontFamily: FONT_FAMILIES[defaultProps.font],
      fontSize: FONT_SIZES[defaultProps.size],
      width: "fit-content"
    });
    const minWidth = Math.min(
      isMultiLine ? editor.viewportPageBounds.width * 0.9 : 920,
      Math.max(200, editor.viewportPageBounds.width * 0.9)
    );
    if (rawSize.w > minWidth) {
      const shrunkSize = editor.textMeasure.measureText(textToPaste, {
        ...TEXT_PROPS,
        fontFamily: FONT_FAMILIES[defaultProps.font],
        fontSize: FONT_SIZES[defaultProps.size],
        width: minWidth + "px"
      });
      w = shrunkSize.w;
      h = shrunkSize.h;
      autoSize = false;
      align = isRtl ? "end" : "start";
    } else {
      w = rawSize.w;
      h = rawSize.h;
      autoSize = true;
    }
    if (p.y - h / 2 < editor.viewportPageBounds.minY + 40) {
      p.y = editor.viewportPageBounds.minY + 40 + h / 2;
    }
    editor.createShapes([
      {
        id: createShapeId(),
        type: "text",
        x: p.x - w / 2,
        y: p.y - h / 2,
        props: {
          text: textToPaste,
          // if the text has more than one line, align it to the left
          align,
          autoSize,
          w
        }
      }
    ]);
  }
  /**
   * Handle urls from an external source. Feeling lucky? Overwrite this at runtime to change the way this type of external content is handled.
   *
   * @example
   * ```ts
   * editor.this.handleUrl = myCustomMethod
   * ```
   *
   * @param editor - The editor instance
   * @param info - The info object describing the external content.
   *
   * @public
   */
  handleUrl = async (editor, { point, url }) => {
    const embedInfo = getEmbedInfo(url);
    if (embedInfo) {
      return this.handleEmbed(editor, {
        type: "embed",
        url: embedInfo.url,
        point,
        embed: embedInfo.definition
      });
    }
    const position = point ?? (editor.inputs.shiftKey ? editor.inputs.currentPagePoint : editor.viewportPageCenter);
    const assetId = AssetRecordType.createId(getHashForString(url));
    let asset = editor.getAssetById(assetId);
    let shouldAlsoCreateAsset = false;
    if (!asset) {
      shouldAlsoCreateAsset = true;
      asset = await this.createAssetFromUrl(editor, url);
    }
    editor.batch(() => {
      if (shouldAlsoCreateAsset) {
        editor.createAssets([asset]);
      }
      this.createShapesForAssets(editor, [asset], position);
    });
  };
  async createShapesForAssets(editor, assets, position) {
    if (!assets.length)
      return;
    const currentPoint = Vec2d.From(position);
    const paritals = [];
    for (const asset of assets) {
      switch (asset.type) {
        case "bookmark": {
          paritals.push({
            id: createShapeId(),
            type: "bookmark",
            x: currentPoint.x - 150,
            y: currentPoint.y - 160,
            opacity: 1,
            props: {
              assetId: asset.id,
              url: asset.props.src
            }
          });
          currentPoint.x += 300;
          break;
        }
        case "image": {
          paritals.push({
            id: createShapeId(),
            type: "image",
            x: currentPoint.x - asset.props.w / 2,
            y: currentPoint.y - asset.props.h / 2,
            opacity: 1,
            props: {
              assetId: asset.id,
              w: asset.props.w,
              h: asset.props.h
            }
          });
          currentPoint.x += asset.props.w;
          break;
        }
        case "video": {
          paritals.push({
            id: createShapeId(),
            type: "video",
            x: currentPoint.x - asset.props.w / 2,
            y: currentPoint.y - asset.props.h / 2,
            opacity: 1,
            props: {
              assetId: asset.id,
              w: asset.props.w,
              h: asset.props.h
            }
          });
          currentPoint.x += asset.props.w;
        }
      }
    }
    editor.batch(() => {
      const assetsToCreate = assets.filter((asset) => !editor.getAssetById(asset.id));
      if (assetsToCreate.length) {
        editor.createAssets(assetsToCreate);
      }
      editor.createShapes(paritals, true);
      const { viewportPageBounds } = editor;
      let { selectedPageBounds } = editor;
      if (selectedPageBounds) {
        const offset = selectedPageBounds.center.sub(position);
        editor.updateShapes(
          paritals.map((partial) => {
            return {
              id: partial.id,
              type: partial.type,
              x: partial.x - offset.x,
              y: partial.y - offset.y
            };
          })
        );
      }
      selectedPageBounds = editor.selectedPageBounds;
      if (selectedPageBounds && !viewportPageBounds.contains(selectedPageBounds)) {
        editor.zoomToSelection();
      }
    });
  }
  /**
   * Override this method to change how assets are created from files.
   *
   * @param editor - The editor instance
   * @param file - The file to create the asset from.
   */
  async createAssetFromFile(_editor, file) {
    return await new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onerror = () => reject(reader.error);
      reader.onload = async () => {
        let dataUrl = reader.result;
        const isImageType = isImage(file.type);
        const sizeFn = isImageType ? getImageSizeFromSrc : getVideoSizeFromSrc;
        if (file.type === "video/quicktime" && dataUrl.includes("video/quicktime")) {
          dataUrl = dataUrl.replace("video/quicktime", "video/mp4");
        }
        const originalSize = await sizeFn(dataUrl);
        const size = containBoxSize(originalSize, { w: MAX_ASSET_WIDTH, h: MAX_ASSET_HEIGHT });
        if (size !== originalSize && (file.type === "image/jpeg" || file.type === "image/png")) {
          dataUrl = await getResizedImageDataUrl(dataUrl, size.w, size.h);
        }
        const assetId = AssetRecordType.createId(getHashForString(dataUrl));
        const metadata = await getFileMetaData(file);
        const asset = {
          id: assetId,
          type: isImageType ? "image" : "video",
          typeName: "asset",
          props: {
            name: file.name,
            src: dataUrl,
            w: size.w,
            h: size.h,
            mimeType: file.type,
            isAnimated: metadata.isAnimated
          }
        };
        resolve(asset);
      };
      reader.readAsDataURL(file);
    });
  }
  /**
   * Override me to change the way assets are created from urls.
   *
   * @param editor - The editor instance
   * @param url - The url to create the asset from
   */
  async createAssetFromUrl(_editor, url) {
    let meta;
    try {
      const resp = await fetch(url, { method: "GET", mode: "no-cors" });
      const html = await resp.text();
      const doc = new DOMParser().parseFromString(html, "text/html");
      meta = {
        image: doc.head.querySelector('meta[property="og:image"]')?.getAttribute("content") ?? "",
        title: doc.head.querySelector('meta[property="og:title"]')?.getAttribute("content") ?? truncateStringWithEllipsis(url, 32),
        description: doc.head.querySelector('meta[property="og:description"]')?.getAttribute("content") ?? ""
      };
    } catch (error) {
      console.error(error);
      meta = { image: "", title: truncateStringWithEllipsis(url, 32), description: "" };
    }
    return {
      id: AssetRecordType.createId(getHashForString(url)),
      typeName: "asset",
      type: "bookmark",
      props: {
        src: url,
        description: meta.description,
        image: meta.image,
        title: meta.title
      }
    };
  }
}
const rtlRegex = /[\u0590-\u05FF\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFF]/;
function replaceTabsWithSpaces(text) {
  return text.replace(/\t/g, INDENT);
}
function stripCommonMinimumIndentation(text) {
  const lines = text.split("\n");
  while (lines[0].trim().length === 0) {
    lines.shift();
  }
  let minIndentation = Infinity;
  for (const line of lines) {
    if (line.trim().length > 0) {
      const indentation = line.length - line.trimStart().length;
      minIndentation = Math.min(minIndentation, indentation);
    }
  }
  return lines.map((line) => line.slice(minIndentation)).join("\n");
}
function stripTrailingWhitespace(text) {
  return text.replace(/[ \t]+$/gm, "").replace(/\n+$/, "");
}
export {
  ExternalContentManager
};
//# sourceMappingURL=ExternalContentManager.mjs.map
