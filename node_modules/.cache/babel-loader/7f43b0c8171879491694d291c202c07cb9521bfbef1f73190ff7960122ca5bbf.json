{"ast":null,"code":"import _toConsumableArray from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _slicedToArray from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _createForOfIteratorHelper from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _defineProperty from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport { objectMapValues } from \"@tldraw/utils\";\nimport isEqual from \"lodash.isequal\";\nimport { computed, EMPTY_ARRAY, isUninitialized, RESET_VALUE, withDiff } from \"signia\";\nimport { executeQuery, objectMatchesQuery } from \"./executeQuery.mjs\";\nimport { IncrementalSetConstructor } from \"./IncrementalSetConstructor.mjs\";\nimport { diffSets } from \"./setUtils.mjs\";\nvar StoreQueries = /*#__PURE__*/function () {\n  function StoreQueries(atoms, history) {\n    _classCallCheck(this, StoreQueries);\n    /**\n     * A cache of derivations (indexes).\n     *\n     * @internal\n     */\n    _defineProperty(this, \"indexCache\", /* @__PURE__ */new Map());\n    /**\n     * A cache of derivations (filtered histories).\n     *\n     * @internal\n     */\n    _defineProperty(this, \"historyCache\", /* @__PURE__ */new Map());\n    this.atoms = atoms;\n    this.history = history;\n  }\n  _createClass(StoreQueries, [{\n    key: \"filterHistory\",\n    value:\n    /**\n     * Create a derivation that contains the hisotry for a given type\n     *\n     * @param typeName - The name of the type to filter by.\n     * @returns A derivation that returns the ids of all records of the given type.\n     * @public\n     */\n    function filterHistory(typeName) {\n      var _this = this;\n      if (this.historyCache.has(typeName)) {\n        return this.historyCache.get(typeName);\n      }\n      var filtered = computed(\"filterHistory:\" + typeName, function (lastValue, lastComputedEpoch) {\n        if (isUninitialized(lastValue)) {\n          return _this.history.value;\n        }\n        var diff = _this.history.getDiffSince(lastComputedEpoch);\n        if (diff === RESET_VALUE) return _this.history.value;\n        var res = {\n          added: {},\n          removed: {},\n          updated: {}\n        };\n        var numAdded = 0;\n        var numRemoved = 0;\n        var numUpdated = 0;\n        var _iterator = _createForOfIteratorHelper(diff),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var changes = _step.value;\n            var _iterator2 = _createForOfIteratorHelper(objectMapValues(changes.added)),\n              _step2;\n            try {\n              for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                var added = _step2.value;\n                if (added.typeName === typeName) {\n                  if (res.removed[added.id]) {\n                    var original = res.removed[added.id];\n                    delete res.removed[added.id];\n                    numRemoved--;\n                    if (original !== added) {\n                      res.updated[added.id] = [original, added];\n                      numUpdated++;\n                    }\n                  } else {\n                    res.added[added.id] = added;\n                    numAdded++;\n                  }\n                }\n              }\n            } catch (err) {\n              _iterator2.e(err);\n            } finally {\n              _iterator2.f();\n            }\n            var _iterator3 = _createForOfIteratorHelper(objectMapValues(changes.updated)),\n              _step3;\n            try {\n              for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                var _step3$value = _slicedToArray(_step3.value, 2),\n                  from = _step3$value[0],\n                  to = _step3$value[1];\n                if (to.typeName === typeName) {\n                  if (res.added[to.id]) {\n                    res.added[to.id] = to;\n                  } else if (res.updated[to.id]) {\n                    res.updated[to.id] = [res.updated[to.id][0], to];\n                  } else {\n                    res.updated[to.id] = [from, to];\n                    numUpdated++;\n                  }\n                }\n              }\n            } catch (err) {\n              _iterator3.e(err);\n            } finally {\n              _iterator3.f();\n            }\n            var _iterator4 = _createForOfIteratorHelper(objectMapValues(changes.removed)),\n              _step4;\n            try {\n              for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n                var removed = _step4.value;\n                if (removed.typeName === typeName) {\n                  if (res.added[removed.id]) {\n                    delete res.added[removed.id];\n                    numAdded--;\n                  } else if (res.updated[removed.id]) {\n                    res.removed[removed.id] = res.updated[removed.id][0];\n                    delete res.updated[removed.id];\n                    numUpdated--;\n                    numRemoved++;\n                  } else {\n                    res.removed[removed.id] = removed;\n                    numRemoved++;\n                  }\n                }\n              }\n            } catch (err) {\n              _iterator4.e(err);\n            } finally {\n              _iterator4.f();\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n        if (numAdded || numRemoved || numUpdated) {\n          return withDiff(_this.history.value, res);\n        } else {\n          return lastValue;\n        }\n      }, {\n        historyLength: 100\n      });\n      this.historyCache.set(typeName, filtered);\n      return filtered;\n    }\n    /**\n     * Create a derivation that returns an index on a property for the given type.\n     *\n     * @param typeName - The name of the type.\n     * @param property - The name of the property.\n     * @public\n     */\n  }, {\n    key: \"index\",\n    value: function index(typeName, property) {\n      var cacheKey = typeName + \":\" + property;\n      if (this.indexCache.has(cacheKey)) {\n        return this.indexCache.get(cacheKey);\n      }\n      var index = this.__uncached_createIndex(typeName, property);\n      this.indexCache.set(cacheKey, index);\n      return index;\n    }\n    /**\n     * Create a derivation that returns an index on a property for the given type.\n     *\n     * @param typeName - The name of the type?.\n     * @param property - The name of the property?.\n     * @internal\n     */\n  }, {\n    key: \"__uncached_createIndex\",\n    value: function __uncached_createIndex(typeName, property) {\n      var _this2 = this;\n      var typeHistory = this.filterHistory(typeName);\n      var fromScratch = function fromScratch() {\n        typeHistory.value;\n        var res = /* @__PURE__ */new Map();\n        var _iterator5 = _createForOfIteratorHelper(objectMapValues(_this2.atoms.value)),\n          _step5;\n        try {\n          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n            var atom = _step5.value;\n            var record = atom.value;\n            if (record.typeName === typeName) {\n              var value = record[property];\n              if (!res.has(value)) {\n                res.set(value, /* @__PURE__ */new Set());\n              }\n              res.get(value).add(record.id);\n            }\n          }\n        } catch (err) {\n          _iterator5.e(err);\n        } finally {\n          _iterator5.f();\n        }\n        return res;\n      };\n      return computed(\"index:\" + typeName + \":\" + property, function (prevValue, lastComputedEpoch) {\n        if (isUninitialized(prevValue)) return fromScratch();\n        var history = typeHistory.getDiffSince(lastComputedEpoch);\n        if (history === RESET_VALUE) {\n          return fromScratch();\n        }\n        var setConstructors = /* @__PURE__ */new Map();\n        var add = function add(value, id) {\n          var _prevValue$get;\n          var setConstructor = setConstructors.get(value);\n          if (!setConstructor) setConstructor = new IncrementalSetConstructor((_prevValue$get = prevValue.get(value)) !== null && _prevValue$get !== void 0 ? _prevValue$get : /* @__PURE__ */new Set());\n          setConstructor.add(id);\n          setConstructors.set(value, setConstructor);\n        };\n        var remove = function remove(value, id) {\n          var _prevValue$get2;\n          var set = setConstructors.get(value);\n          if (!set) set = new IncrementalSetConstructor((_prevValue$get2 = prevValue.get(value)) !== null && _prevValue$get2 !== void 0 ? _prevValue$get2 : /* @__PURE__ */new Set());\n          set.remove(id);\n          setConstructors.set(value, set);\n        };\n        var _iterator6 = _createForOfIteratorHelper(history),\n          _step6;\n        try {\n          for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n            var changes = _step6.value;\n            var _iterator8 = _createForOfIteratorHelper(objectMapValues(changes.added)),\n              _step8;\n            try {\n              for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n                var record = _step8.value;\n                if (record.typeName === typeName) {\n                  var value = record[property];\n                  add(value, record.id);\n                }\n              }\n            } catch (err) {\n              _iterator8.e(err);\n            } finally {\n              _iterator8.f();\n            }\n            var _iterator9 = _createForOfIteratorHelper(objectMapValues(changes.updated)),\n              _step9;\n            try {\n              for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n                var _step9$value = _slicedToArray(_step9.value, 2),\n                  from = _step9$value[0],\n                  to = _step9$value[1];\n                if (to.typeName === typeName) {\n                  var prev = from[property];\n                  var next = to[property];\n                  if (prev !== next) {\n                    remove(prev, to.id);\n                    add(next, to.id);\n                  }\n                }\n              }\n            } catch (err) {\n              _iterator9.e(err);\n            } finally {\n              _iterator9.f();\n            }\n            var _iterator10 = _createForOfIteratorHelper(objectMapValues(changes.removed)),\n              _step10;\n            try {\n              for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n                var _record = _step10.value;\n                if (_record.typeName === typeName) {\n                  var _value = _record[property];\n                  remove(_value, _record.id);\n                }\n              }\n            } catch (err) {\n              _iterator10.e(err);\n            } finally {\n              _iterator10.f();\n            }\n          }\n        } catch (err) {\n          _iterator6.e(err);\n        } finally {\n          _iterator6.f();\n        }\n        var nextValue = void 0;\n        var nextDiff = void 0;\n        var _iterator7 = _createForOfIteratorHelper(setConstructors),\n          _step7;\n        try {\n          for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n            var _step7$value = _slicedToArray(_step7.value, 2),\n              _value2 = _step7$value[0],\n              setConstructor = _step7$value[1];\n            var result = setConstructor.get();\n            if (!result) continue;\n            if (!nextValue) nextValue = new Map(prevValue);\n            if (!nextDiff) nextDiff = /* @__PURE__ */new Map();\n            if (result.value.size === 0) {\n              nextValue.delete(_value2);\n            } else {\n              nextValue.set(_value2, result.value);\n            }\n            nextDiff.set(_value2, result.diff);\n          }\n        } catch (err) {\n          _iterator7.e(err);\n        } finally {\n          _iterator7.f();\n        }\n        if (nextValue && nextDiff) {\n          return withDiff(nextValue, nextDiff);\n        }\n        return prevValue;\n      }, {\n        historyLength: 100\n      });\n    }\n    /**\n     * Create a derivation that will return a signle record matching the given query.\n     *\n     * It will return undefined if there is no matching record\n     *\n     * @param typeName - The name of the type?\n     * @param queryCreator - A function that returns the query expression.\n     * @param name - (optinal) The name of the query.\n     */\n  }, {\n    key: \"record\",\n    value: function record(typeName) {\n      var _this3 = this;\n      var queryCreator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {\n        return {};\n      };\n      var name = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"record:\" + typeName + (queryCreator ? \":\" + queryCreator.toString() : \"\");\n      var ids = this.ids(typeName, queryCreator, name);\n      return computed(name, function () {\n        var _iterator11 = _createForOfIteratorHelper(ids.value),\n          _step11;\n        try {\n          for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n            var _this3$atoms$value$id;\n            var id = _step11.value;\n            return (_this3$atoms$value$id = _this3.atoms.value[id]) === null || _this3$atoms$value$id === void 0 ? void 0 : _this3$atoms$value$id.value;\n          }\n        } catch (err) {\n          _iterator11.e(err);\n        } finally {\n          _iterator11.f();\n        }\n        return void 0;\n      });\n    }\n    /**\n     * Create a derivation that will return an array of records matching the given query\n     *\n     * @param typeName - The name of the type?\n     * @param queryCreator - A function that returns the query expression.\n     * @param name - (optinal) The name of the query.\n     */\n  }, {\n    key: \"records\",\n    value: function records(typeName) {\n      var _this4 = this;\n      var queryCreator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {\n        return {};\n      };\n      var name = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"records:\" + typeName + (queryCreator ? \":\" + queryCreator.toString() : \"\");\n      var ids = this.ids(typeName, queryCreator, \"ids:\" + name);\n      return computed(name, function () {\n        return _toConsumableArray(ids.value).map(function (id) {\n          var atom = _this4.atoms.value[id];\n          if (!atom) {\n            throw new Error(\"no atom found for record id: \" + id);\n          }\n          return atom.value;\n        });\n      });\n    }\n    /**\n     * Create a derivation that will return the ids of all records of the given type.\n     *\n     * @param typeName - The name of the type.\n     * @param queryCreator - A function that returns the query expression.\n     * @param name - (optinal) The name of the query.\n     */\n  }, {\n    key: \"ids\",\n    value: function ids(typeName) {\n      var _this5 = this;\n      var queryCreator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {\n        return {};\n      };\n      var name = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"ids:\" + typeName + (queryCreator ? \":\" + queryCreator.toString() : \"\");\n      var typeHistory = this.filterHistory(typeName);\n      var fromScratch = function fromScratch() {\n        typeHistory.value;\n        var query = queryCreator();\n        if (Object.keys(query).length === 0) {\n          return new Set(objectMapValues(_this5.atoms.value).flatMap(function (v) {\n            var r = v.value;\n            if (r.typeName === typeName) {\n              return r.id;\n            } else {\n              return [];\n            }\n          }));\n        }\n        return executeQuery(_this5, typeName, query);\n      };\n      var fromScratchWithDiff = function fromScratchWithDiff(prevValue) {\n        var nextValue = fromScratch();\n        var diff = diffSets(prevValue, nextValue);\n        if (diff) {\n          return withDiff(nextValue, diff);\n        } else {\n          return prevValue;\n        }\n      };\n      var cachedQuery = computed(\"ids_query:\" + name, queryCreator, {\n        isEqual: isEqual\n      });\n      return computed(\"query:\" + name, function (prevValue, lastComputedEpoch) {\n        var query = cachedQuery.value;\n        if (isUninitialized(prevValue)) {\n          return fromScratch();\n        }\n        if (lastComputedEpoch < cachedQuery.lastChangedEpoch) {\n          return fromScratchWithDiff(prevValue);\n        }\n        var history = typeHistory.getDiffSince(lastComputedEpoch);\n        if (history === RESET_VALUE) {\n          return fromScratchWithDiff(prevValue);\n        }\n        var setConstructor = new IncrementalSetConstructor(prevValue);\n        var _iterator12 = _createForOfIteratorHelper(history),\n          _step12;\n        try {\n          for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n            var changes = _step12.value;\n            var _iterator13 = _createForOfIteratorHelper(objectMapValues(changes.added)),\n              _step13;\n            try {\n              for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n                var added = _step13.value;\n                if (added.typeName === typeName && objectMatchesQuery(query, added)) {\n                  setConstructor.add(added.id);\n                }\n              }\n            } catch (err) {\n              _iterator13.e(err);\n            } finally {\n              _iterator13.f();\n            }\n            var _iterator14 = _createForOfIteratorHelper(objectMapValues(changes.updated)),\n              _step14;\n            try {\n              for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {\n                var _step14$value = _slicedToArray(_step14.value, 2),\n                  _ = _step14$value[0],\n                  updated = _step14$value[1];\n                if (updated.typeName === typeName) {\n                  if (objectMatchesQuery(query, updated)) {\n                    setConstructor.add(updated.id);\n                  } else {\n                    setConstructor.remove(updated.id);\n                  }\n                }\n              }\n            } catch (err) {\n              _iterator14.e(err);\n            } finally {\n              _iterator14.f();\n            }\n            var _iterator15 = _createForOfIteratorHelper(objectMapValues(changes.removed)),\n              _step15;\n            try {\n              for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {\n                var removed = _step15.value;\n                if (removed.typeName === typeName) {\n                  setConstructor.remove(removed.id);\n                }\n              }\n            } catch (err) {\n              _iterator15.e(err);\n            } finally {\n              _iterator15.f();\n            }\n          }\n        } catch (err) {\n          _iterator12.e(err);\n        } finally {\n          _iterator12.f();\n        }\n        var result = setConstructor.get();\n        if (!result) {\n          return prevValue;\n        }\n        return withDiff(result.value, result.diff);\n      }, {\n        historyLength: 50\n      });\n    }\n  }, {\n    key: \"exec\",\n    value: function exec(typeName, query) {\n      var ids = executeQuery(this, typeName, query);\n      if (ids.size === 0) {\n        return EMPTY_ARRAY;\n      }\n      var atoms = this.atoms.value;\n      return _toConsumableArray(ids).map(function (id) {\n        return atoms[id].value;\n      });\n    }\n  }]);\n  return StoreQueries;\n}();\nexport { StoreQueries };","map":{"version":3,"names":["objectMapValues","isEqual","computed","EMPTY_ARRAY","isUninitialized","RESET_VALUE","withDiff","executeQuery","objectMatchesQuery","IncrementalSetConstructor","diffSets","StoreQueries","atoms","history","_classCallCheck","_defineProperty","Map","_createClass","key","value","filterHistory","typeName","_this","historyCache","has","get","filtered","lastValue","lastComputedEpoch","diff","getDiffSince","res","added","removed","updated","numAdded","numRemoved","numUpdated","_iterator","_createForOfIteratorHelper","_step","s","n","done","changes","_iterator2","_step2","id","original","err","e","f","_iterator3","_step3","_step3$value","_slicedToArray","from","to","_iterator4","_step4","historyLength","set","index","property","cacheKey","indexCache","__uncached_createIndex","_this2","typeHistory","fromScratch","_iterator5","_step5","atom","record","Set","add","prevValue","setConstructors","_prevValue$get","setConstructor","remove","_prevValue$get2","_iterator6","_step6","_iterator8","_step8","_iterator9","_step9","_step9$value","prev","next","_iterator10","_step10","nextValue","nextDiff","_iterator7","_step7","_step7$value","result","size","delete","_this3","queryCreator","arguments","length","undefined","name","toString","ids","_iterator11","_step11","_this3$atoms$value$id","records","_this4","_toConsumableArray","map","Error","_this5","query","Object","keys","flatMap","v","r","fromScratchWithDiff","cachedQuery","lastChangedEpoch","_iterator12","_step12","_iterator13","_step13","_iterator14","_step14","_step14$value","_","_iterator15","_step15","exec"],"sources":["/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@tldraw/store/src/lib/StoreQueries.ts"],"sourcesContent":["import { objectMapValues } from '@tldraw/utils'\nimport isEqual from 'lodash.isequal'\nimport {\n\tAtom,\n\tcomputed,\n\tComputed,\n\tEMPTY_ARRAY,\n\tisUninitialized,\n\tRESET_VALUE,\n\twithDiff,\n} from 'signia'\nimport { IdOf, UnknownRecord } from './BaseRecord'\nimport { executeQuery, objectMatchesQuery, QueryExpression } from './executeQuery'\nimport { IncrementalSetConstructor } from './IncrementalSetConstructor'\nimport { diffSets } from './setUtils'\nimport { CollectionDiff, RecordsDiff } from './Store'\n\nexport type RSIndexDiff<\n\tR extends UnknownRecord,\n\tProperty extends string & keyof R = string & keyof R\n> = Map<R[Property], CollectionDiff<IdOf<R>>>\n\nexport type RSIndexMap<\n\tR extends UnknownRecord,\n\tProperty extends string & keyof R = string & keyof R\n> = Map<R[Property], Set<IdOf<R>>>\n\nexport type RSIndex<\n\tR extends UnknownRecord,\n\tProperty extends string & keyof R = string & keyof R\n> = Computed<Map<R[Property], Set<IdOf<R>>>, RSIndexDiff<R, Property>>\n\n/**\n * A class that provides a 'namespace' for the various kinds of indexes one may wish to derive from\n * the record store.\n */\nexport class StoreQueries<R extends UnknownRecord> {\n\tconstructor(\n\t\tprivate readonly atoms: Atom<Record<IdOf<R>, Atom<R>>>,\n\t\tprivate readonly history: Atom<number, RecordsDiff<R>>\n\t) {}\n\n\t/**\n\t * A cache of derivations (indexes).\n\t *\n\t * @internal\n\t */\n\tprivate indexCache = new Map<string, RSIndex<R>>()\n\n\t/**\n\t * A cache of derivations (filtered histories).\n\t *\n\t * @internal\n\t */\n\tprivate historyCache = new Map<string, Computed<number, RecordsDiff<R>>>()\n\n\t/**\n\t * Create a derivation that contains the hisotry for a given type\n\t *\n\t * @param typeName - The name of the type to filter by.\n\t * @returns A derivation that returns the ids of all records of the given type.\n\t * @public\n\t */\n\tpublic filterHistory<TypeName extends R['typeName']>(\n\t\ttypeName: TypeName\n\t): Computed<number, RecordsDiff<Extract<R, { typeName: TypeName }>>> {\n\t\ttype S = Extract<R, { typeName: TypeName }>\n\n\t\tif (this.historyCache.has(typeName)) {\n\t\t\treturn this.historyCache.get(typeName) as any\n\t\t}\n\n\t\tconst filtered = computed<number, RecordsDiff<S>>(\n\t\t\t'filterHistory:' + typeName,\n\t\t\t(lastValue, lastComputedEpoch) => {\n\t\t\t\tif (isUninitialized(lastValue)) {\n\t\t\t\t\treturn this.history.value\n\t\t\t\t}\n\n\t\t\t\tconst diff = this.history.getDiffSince(lastComputedEpoch)\n\t\t\t\tif (diff === RESET_VALUE) return this.history.value\n\n\t\t\t\tconst res = { added: {}, removed: {}, updated: {} } as RecordsDiff<S>\n\t\t\t\tlet numAdded = 0\n\t\t\t\tlet numRemoved = 0\n\t\t\t\tlet numUpdated = 0\n\n\t\t\t\tfor (const changes of diff) {\n\t\t\t\t\tfor (const added of objectMapValues(changes.added)) {\n\t\t\t\t\t\tif (added.typeName === typeName) {\n\t\t\t\t\t\t\tif (res.removed[added.id as IdOf<S>]) {\n\t\t\t\t\t\t\t\tconst original = res.removed[added.id as IdOf<S>]\n\t\t\t\t\t\t\t\tdelete res.removed[added.id as IdOf<S>]\n\t\t\t\t\t\t\t\tnumRemoved--\n\t\t\t\t\t\t\t\tif (original !== added) {\n\t\t\t\t\t\t\t\t\tres.updated[added.id as IdOf<S>] = [original, added as S]\n\t\t\t\t\t\t\t\t\tnumUpdated++\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tres.added[added.id as IdOf<S>] = added as S\n\t\t\t\t\t\t\t\tnumAdded++\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (const [from, to] of objectMapValues(changes.updated)) {\n\t\t\t\t\t\tif (to.typeName === typeName) {\n\t\t\t\t\t\t\tif (res.added[to.id as IdOf<S>]) {\n\t\t\t\t\t\t\t\tres.added[to.id as IdOf<S>] = to as S\n\t\t\t\t\t\t\t} else if (res.updated[to.id as IdOf<S>]) {\n\t\t\t\t\t\t\t\tres.updated[to.id as IdOf<S>] = [res.updated[to.id as IdOf<S>][0], to as S]\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tres.updated[to.id as IdOf<S>] = [from as S, to as S]\n\t\t\t\t\t\t\t\tnumUpdated++\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (const removed of objectMapValues(changes.removed)) {\n\t\t\t\t\t\tif (removed.typeName === typeName) {\n\t\t\t\t\t\t\tif (res.added[removed.id as IdOf<S>]) {\n\t\t\t\t\t\t\t\t// was added during this diff sequence, so just undo the add\n\t\t\t\t\t\t\t\tdelete res.added[removed.id as IdOf<S>]\n\t\t\t\t\t\t\t\tnumAdded--\n\t\t\t\t\t\t\t} else if (res.updated[removed.id as IdOf<S>]) {\n\t\t\t\t\t\t\t\t// remove oldest version\n\t\t\t\t\t\t\t\tres.removed[removed.id as IdOf<S>] = res.updated[removed.id as IdOf<S>][0]\n\t\t\t\t\t\t\t\tdelete res.updated[removed.id as IdOf<S>]\n\t\t\t\t\t\t\t\tnumUpdated--\n\t\t\t\t\t\t\t\tnumRemoved++\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tres.removed[removed.id as IdOf<S>] = removed as S\n\t\t\t\t\t\t\t\tnumRemoved++\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (numAdded || numRemoved || numUpdated) {\n\t\t\t\t\treturn withDiff(this.history.value, res)\n\t\t\t\t} else {\n\t\t\t\t\treturn lastValue\n\t\t\t\t}\n\t\t\t},\n\t\t\t{ historyLength: 100 }\n\t\t)\n\n\t\tthis.historyCache.set(typeName, filtered)\n\n\t\treturn filtered\n\t}\n\n\t/**\n\t * Create a derivation that returns an index on a property for the given type.\n\t *\n\t * @param typeName - The name of the type.\n\t * @param property - The name of the property.\n\t * @public\n\t */\n\tpublic index<\n\t\tTypeName extends R['typeName'],\n\t\tProperty extends string & keyof Extract<R, { typeName: TypeName }>\n\t>(typeName: TypeName, property: Property): RSIndex<Extract<R, { typeName: TypeName }>, Property> {\n\t\tconst cacheKey = typeName + ':' + property\n\n\t\tif (this.indexCache.has(cacheKey)) {\n\t\t\treturn this.indexCache.get(cacheKey) as any\n\t\t}\n\n\t\tconst index = this.__uncached_createIndex(typeName, property)\n\n\t\tthis.indexCache.set(cacheKey, index as any)\n\n\t\treturn index\n\t}\n\n\t/**\n\t * Create a derivation that returns an index on a property for the given type.\n\t *\n\t * @param typeName - The name of the type?.\n\t * @param property - The name of the property?.\n\t * @internal\n\t */\n\t__uncached_createIndex<\n\t\tTypeName extends R['typeName'],\n\t\tProperty extends string & keyof Extract<R, { typeName: TypeName }>\n\t>(typeName: TypeName, property: Property): RSIndex<Extract<R, { typeName: TypeName }>, Property> {\n\t\ttype S = Extract<R, { typeName: TypeName }>\n\n\t\tconst typeHistory = this.filterHistory(typeName)\n\n\t\tconst fromScratch = () => {\n\t\t\t// deref typeHistory early so that the first time the incremental version runs\n\t\t\t// it gets a diff to work with instead of having to bail to this from-scratch version\n\t\t\ttypeHistory.value\n\t\t\tconst res = new Map<S[Property], Set<IdOf<S>>>()\n\t\t\tfor (const atom of objectMapValues(this.atoms.value)) {\n\t\t\t\tconst record = atom.value\n\t\t\t\tif (record.typeName === typeName) {\n\t\t\t\t\tconst value = (record as S)[property]\n\t\t\t\t\tif (!res.has(value)) {\n\t\t\t\t\t\tres.set(value, new Set())\n\t\t\t\t\t}\n\t\t\t\t\tres.get(value)!.add(record.id)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn res\n\t\t}\n\n\t\treturn computed<RSIndexMap<S, Property>, RSIndexDiff<S, Property>>(\n\t\t\t'index:' + typeName + ':' + property,\n\t\t\t(prevValue, lastComputedEpoch) => {\n\t\t\t\tif (isUninitialized(prevValue)) return fromScratch()\n\n\t\t\t\tconst history = typeHistory.getDiffSince(lastComputedEpoch)\n\t\t\t\tif (history === RESET_VALUE) {\n\t\t\t\t\treturn fromScratch()\n\t\t\t\t}\n\n\t\t\t\tconst setConstructors = new Map<any, IncrementalSetConstructor<IdOf<S>>>()\n\n\t\t\t\tconst add = (value: S[Property], id: IdOf<S>) => {\n\t\t\t\t\tlet setConstructor = setConstructors.get(value)\n\t\t\t\t\tif (!setConstructor)\n\t\t\t\t\t\tsetConstructor = new IncrementalSetConstructor<IdOf<S>>(\n\t\t\t\t\t\t\tprevValue.get(value) ?? new Set()\n\t\t\t\t\t\t)\n\t\t\t\t\tsetConstructor.add(id)\n\t\t\t\t\tsetConstructors.set(value, setConstructor)\n\t\t\t\t}\n\n\t\t\t\tconst remove = (value: S[Property], id: IdOf<S>) => {\n\t\t\t\t\tlet set = setConstructors.get(value)\n\t\t\t\t\tif (!set) set = new IncrementalSetConstructor<IdOf<S>>(prevValue.get(value) ?? new Set())\n\t\t\t\t\tset.remove(id)\n\t\t\t\t\tsetConstructors.set(value, set)\n\t\t\t\t}\n\n\t\t\t\tfor (const changes of history) {\n\t\t\t\t\tfor (const record of objectMapValues(changes.added)) {\n\t\t\t\t\t\tif (record.typeName === typeName) {\n\t\t\t\t\t\t\tconst value = (record as S)[property]\n\t\t\t\t\t\t\tadd(value, record.id)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (const [from, to] of objectMapValues(changes.updated)) {\n\t\t\t\t\t\tif (to.typeName === typeName) {\n\t\t\t\t\t\t\tconst prev = (from as S)[property]\n\t\t\t\t\t\t\tconst next = (to as S)[property]\n\t\t\t\t\t\t\tif (prev !== next) {\n\t\t\t\t\t\t\t\tremove(prev, to.id)\n\t\t\t\t\t\t\t\tadd(next, to.id)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (const record of objectMapValues(changes.removed)) {\n\t\t\t\t\t\tif (record.typeName === typeName) {\n\t\t\t\t\t\t\tconst value = (record as S)[property]\n\t\t\t\t\t\t\tremove(value, record.id)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tlet nextValue: undefined | RSIndexMap<S, Property> = undefined\n\t\t\t\tlet nextDiff: undefined | RSIndexDiff<S, Property> = undefined\n\n\t\t\t\tfor (const [value, setConstructor] of setConstructors) {\n\t\t\t\t\tconst result = setConstructor.get()\n\t\t\t\t\tif (!result) continue\n\t\t\t\t\tif (!nextValue) nextValue = new Map(prevValue)\n\t\t\t\t\tif (!nextDiff) nextDiff = new Map()\n\t\t\t\t\tif (result.value.size === 0) {\n\t\t\t\t\t\tnextValue.delete(value)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnextValue.set(value, result.value)\n\t\t\t\t\t}\n\t\t\t\t\tnextDiff.set(value, result.diff)\n\t\t\t\t}\n\n\t\t\t\tif (nextValue && nextDiff) {\n\t\t\t\t\treturn withDiff(nextValue, nextDiff)\n\t\t\t\t}\n\n\t\t\t\treturn prevValue\n\t\t\t},\n\t\t\t{ historyLength: 100 }\n\t\t)\n\t}\n\n\t/**\n\t * Create a derivation that will return a signle record matching the given query.\n\t *\n\t * It will return undefined if there is no matching record\n\t *\n\t * @param typeName - The name of the type?\n\t * @param queryCreator - A function that returns the query expression.\n\t * @param name - (optinal) The name of the query.\n\t */\n\trecord<TypeName extends R['typeName']>(\n\t\ttypeName: TypeName,\n\t\tqueryCreator: () => QueryExpression<Extract<R, { typeName: TypeName }>> = () => ({}),\n\t\tname = 'record:' + typeName + (queryCreator ? ':' + queryCreator.toString() : '')\n\t): Computed<Extract<R, { typeName: TypeName }> | undefined> {\n\t\ttype S = Extract<R, { typeName: TypeName }>\n\t\tconst ids = this.ids(typeName, queryCreator, name)\n\n\t\treturn computed<S | undefined>(name, () => {\n\t\t\tfor (const id of ids.value) {\n\t\t\t\treturn this.atoms.value[id]?.value as S\n\t\t\t}\n\t\t\treturn undefined\n\t\t})\n\t}\n\n\t/**\n\t * Create a derivation that will return an array of records matching the given query\n\t *\n\t * @param typeName - The name of the type?\n\t * @param queryCreator - A function that returns the query expression.\n\t * @param name - (optinal) The name of the query.\n\t */\n\trecords<TypeName extends R['typeName']>(\n\t\ttypeName: TypeName,\n\t\tqueryCreator: () => QueryExpression<Extract<R, { typeName: TypeName }>> = () => ({}),\n\t\tname = 'records:' + typeName + (queryCreator ? ':' + queryCreator.toString() : '')\n\t): Computed<Array<Extract<R, { typeName: TypeName }>>> {\n\t\ttype S = Extract<R, { typeName: TypeName }>\n\t\tconst ids = this.ids(typeName, queryCreator, 'ids:' + name)\n\n\t\treturn computed<S[]>(name, () => {\n\t\t\treturn [...ids.value].map((id) => {\n\t\t\t\tconst atom = this.atoms.value[id]\n\t\t\t\tif (!atom) {\n\t\t\t\t\tthrow new Error('no atom found for record id: ' + id)\n\t\t\t\t}\n\t\t\t\treturn atom.value as S\n\t\t\t})\n\t\t})\n\t}\n\n\t/**\n\t * Create a derivation that will return the ids of all records of the given type.\n\t *\n\t * @param typeName - The name of the type.\n\t * @param queryCreator - A function that returns the query expression.\n\t * @param name - (optinal) The name of the query.\n\t */\n\tids<TypeName extends R['typeName']>(\n\t\ttypeName: TypeName,\n\t\tqueryCreator: () => QueryExpression<Extract<R, { typeName: TypeName }>> = () => ({}),\n\t\tname = 'ids:' + typeName + (queryCreator ? ':' + queryCreator.toString() : '')\n\t): Computed<\n\t\tSet<IdOf<Extract<R, { typeName: TypeName }>>>,\n\t\tCollectionDiff<IdOf<Extract<R, { typeName: TypeName }>>>\n\t> {\n\t\ttype S = Extract<R, { typeName: TypeName }>\n\n\t\tconst typeHistory = this.filterHistory(typeName)\n\n\t\tconst fromScratch = () => {\n\t\t\t// deref type history early to allow first incremental update to use diffs\n\t\t\ttypeHistory.value\n\t\t\tconst query: QueryExpression<S> = queryCreator()\n\t\t\tif (Object.keys(query).length === 0) {\n\t\t\t\treturn new Set<IdOf<S>>(\n\t\t\t\t\tobjectMapValues(this.atoms.value).flatMap((v) => {\n\t\t\t\t\t\tconst r = v.value\n\t\t\t\t\t\tif (r.typeName === typeName) {\n\t\t\t\t\t\t\treturn r.id\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn []\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t)\n\t\t\t}\n\n\t\t\treturn executeQuery(this, typeName, query)\n\t\t}\n\n\t\tconst fromScratchWithDiff = (prevValue: Set<IdOf<S>>) => {\n\t\t\tconst nextValue = fromScratch()\n\t\t\tconst diff = diffSets(prevValue, nextValue)\n\t\t\tif (diff) {\n\t\t\t\treturn withDiff(nextValue, diff)\n\t\t\t} else {\n\t\t\t\treturn prevValue\n\t\t\t}\n\t\t}\n\t\tconst cachedQuery = computed('ids_query:' + name, queryCreator, {\n\t\t\tisEqual,\n\t\t})\n\n\t\treturn computed(\n\t\t\t'query:' + name,\n\t\t\t(prevValue, lastComputedEpoch) => {\n\t\t\t\tconst query = cachedQuery.value\n\t\t\t\tif (isUninitialized(prevValue)) {\n\t\t\t\t\treturn fromScratch()\n\t\t\t\t}\n\n\t\t\t\t// if the query changed since last time this ran then we need to start again\n\t\t\t\tif (lastComputedEpoch < cachedQuery.lastChangedEpoch) {\n\t\t\t\t\treturn fromScratchWithDiff(prevValue)\n\t\t\t\t}\n\n\t\t\t\t// otherwise iterate over the changes from the store and apply them to the previous value if needed\n\t\t\t\tconst history = typeHistory.getDiffSince(lastComputedEpoch)\n\t\t\t\tif (history === RESET_VALUE) {\n\t\t\t\t\treturn fromScratchWithDiff(prevValue)\n\t\t\t\t}\n\n\t\t\t\tconst setConstructor = new IncrementalSetConstructor<IdOf<S>>(\n\t\t\t\t\tprevValue\n\t\t\t\t) as IncrementalSetConstructor<IdOf<S>>\n\n\t\t\t\tfor (const changes of history) {\n\t\t\t\t\tfor (const added of objectMapValues(changes.added)) {\n\t\t\t\t\t\tif (added.typeName === typeName && objectMatchesQuery(query, added)) {\n\t\t\t\t\t\t\tsetConstructor.add(added.id)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (const [_, updated] of objectMapValues(changes.updated)) {\n\t\t\t\t\t\tif (updated.typeName === typeName) {\n\t\t\t\t\t\t\tif (objectMatchesQuery(query, updated)) {\n\t\t\t\t\t\t\t\tsetConstructor.add(updated.id)\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tsetConstructor.remove(updated.id)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (const removed of objectMapValues(changes.removed)) {\n\t\t\t\t\t\tif (removed.typeName === typeName) {\n\t\t\t\t\t\t\tsetConstructor.remove(removed.id)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst result = setConstructor.get()\n\t\t\t\tif (!result) {\n\t\t\t\t\treturn prevValue\n\t\t\t\t}\n\n\t\t\t\treturn withDiff(result.value, result.diff)\n\t\t\t},\n\t\t\t{ historyLength: 50 }\n\t\t)\n\t}\n\n\texec<TypeName extends R['typeName']>(\n\t\ttypeName: TypeName,\n\t\tquery: QueryExpression<Extract<R, { typeName: TypeName }>>\n\t): Array<Extract<R, { typeName: TypeName }>> {\n\t\tconst ids = executeQuery(this, typeName, query)\n\t\tif (ids.size === 0) {\n\t\t\treturn EMPTY_ARRAY\n\t\t}\n\t\tconst atoms = this.atoms.value\n\t\treturn [...ids].map((id) => atoms[id].value as Extract<R, { typeName: TypeName }>)\n\t}\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}