#!/usr/bin/env node

// src/cli.ts
import path4 from "path";
import assert3 from "assert";
import * as fs3 from "fs";

// src/fetchResult.ts
import assert from "assert";
import { fetch } from "undici";
assert("https://api.partykit.dev", "PARTYKIT_API_BASE is not defined");
var API_BASE = process.env.PARTYKIT_API_BASE || "https://api.partykit.dev";
async function fetchResult(api, options = {}) {
  const res = await fetch(`${API_BASE}${api}`, {
    ...options,
    headers: {
      ...typeof options.body === "string" ? { "Content-Type": "application/json" } : {},
      Accept: "application/json",
      ...options.headers
    }
  });
  if (res.ok) {
    const resJson = await res.json();
    return resJson;
  } else {
    let errorText;
    try {
      errorText = await res.text();
    } catch (e) {
      errorText = `${res.status} ${res.statusText}`;
    }
    throw new Error(errorText);
  }
}

// src/cli.ts
import { File, FormData } from "undici";
import * as crypto2 from "crypto";
import WebSocket2 from "ws";
import onExit2 from "signal-exit";

// src/dev.tsx
import { Log, Miniflare, TypedEventTarget } from "miniflare";
import { fileURLToPath } from "url";
import onExit from "signal-exit";

// src/config.ts
import fs from "fs";
import os from "os";
import path from "path";
import * as dotenv from "dotenv";
import { z } from "zod";
import JSON5 from "json5";
import chalk from "chalk";
import findConfig from "find-config";
import { fetch as fetch2 } from "undici";
import open from "open";
var userConfigSchema = z.object({
  login: z.string(),
  access_token: z.string(),
  type: z.string()
});
var USER_CONFIG_PATH = path.join(os.homedir(), ".partykit", "config.json");
async function getUser() {
  let userConfig;
  try {
    userConfig = getUserConfig();
  } catch (e) {
    console.log("could not get user details, attempting to login");
    await fetchUserConfig();
    userConfig = getUserConfig();
  }
  return userConfig;
}
function getUserConfig() {
  if (process.env.GITHUB_TOKEN && process.env.GITHUB_LOGIN) {
    return {
      login: process.env.GITHUB_LOGIN,
      access_token: process.env.GITHUB_TOKEN,
      type: "github"
    };
  }
  if (!fs.existsSync(USER_CONFIG_PATH)) {
    throw new Error("user config not available");
  }
  const config = JSON5.parse(fs.readFileSync(USER_CONFIG_PATH, "utf8"));
  return userConfigSchema.parse(config);
}
var GITHUB_APP_ID = "670a9f76d6be706f5209";
async function fetchUserConfig() {
  const res = await fetch2("https://github.com/login/device/code", {
    method: "POST",
    headers: {
      Accept: "application/json",
      "Content-Type": "application/json"
    },
    body: JSON.stringify({
      client_id: GITHUB_APP_ID
    })
  });
  if (!res.ok) {
    throw new Error(
      `Failed to get device code: ${res.status} ${res.statusText}`
    );
  }
  const { device_code, user_code, verification_uri, expires_in, interval } = (
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    await res.json()
  );
  console.log(
    `Please visit ${chalk.bold(
      verification_uri
    )} and paste the code ${chalk.bold(user_code)}`
  );
  console.log(`This code will expire in ${expires_in} seconds`);
  console.log(`Waiting for you to authorize...`);
  const { default: clipboardy } = await import("clipboardy");
  clipboardy.writeSync(user_code);
  open(verification_uri).catch(() => {
    console.error(
      `Failed to open ${verification_uri}, please copy the code ${user_code} to your clipboard`
    );
  });
  const start = Date.now();
  while (Date.now() - start < expires_in * 1e3) {
    const res2 = await fetch2("https://github.com/login/oauth/access_token", {
      method: "POST",
      headers: {
        Accept: "application/json",
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        client_id: GITHUB_APP_ID,
        device_code,
        grant_type: "urn:ietf:params:oauth:grant-type:device_code"
      })
    });
    if (!res2.ok) {
      throw new Error(
        `Failed to get access token: ${res2.status} ${res2.statusText}`
      );
    }
    const { access_token, error } = await res2.json();
    const githubUserDetails = await (await fetch2("https://api.github.com/user", {
      headers: {
        Authorization: `Bearer ${access_token}`
      }
    })).json();
    if (access_token) {
      fs.mkdirSync(path.dirname(USER_CONFIG_PATH), { recursive: true });
      fs.writeFileSync(
        USER_CONFIG_PATH,
        JSON.stringify(
          userConfigSchema.parse({
            access_token,
            login: githubUserDetails.login,
            type: "github"
          }),
          null,
          2
        )
      );
      return;
    }
    if (error === "authorization_pending") {
      await new Promise((resolve) => setTimeout(resolve, interval * 1e3));
      continue;
    }
    throw new Error(`Unexpected error: ${error}`);
  }
}
async function logout() {
  if (fs.existsSync(USER_CONFIG_PATH)) {
    fs.rmSync(USER_CONFIG_PATH);
  }
}
var configSchema = z.object({
  account: z.string().optional(),
  name: z.string().optional(),
  main: z.string().optional(),
  port: z.number().optional(),
  assets: z.string().optional(),
  vars: z.record(z.unknown()).optional(),
  define: z.record(z.string()).optional(),
  build: z.object({
    command: z.string().optional(),
    cwd: z.string().optional(),
    watch: z.string().optional()
  }).strict().optional()
  // env: z
  //   .record(
  //     z.object({
  //       vars: z.record(z.unknown()).optional(),
  //     })
  //   )
  //   .optional(),
}).strict();
function getConfigPath() {
  return findConfig("partykit.json", { home: false }) || findConfig("partykit.json5", { home: false }) || findConfig("partykit.jsonc", { home: false });
}
function getConfig(configPath, overrides = {}, options) {
  const envPath = findConfig(".env");
  const envLocalPath = findConfig(".env.local");
  let envVars = {};
  if (envPath) {
    console.log(
      `Loading environment variables from ${path.relative(
        process.cwd(),
        envPath
      )}`
    );
    envVars = dotenv.parse(fs.readFileSync(envPath, "utf8"));
  }
  if (envLocalPath && options?.readEnvLocal) {
    console.log(
      `Loading environment variables from ${path.relative(
        process.cwd(),
        envLocalPath
      )}`
    );
    envVars = {
      ...envVars,
      ...dotenv.parse(fs.readFileSync(envLocalPath, "utf8"))
    };
  }
  configPath ||= getConfigPath();
  configSchema.parse(overrides);
  if (!configPath) {
    if (overrides.account) {
      console.warn('configuration field "account" is not yet operational');
    }
    let packageJsonConfig = {};
    const packageJsonPath = findConfig("package.json", { home: false });
    if (packageJsonPath) {
      packageJsonConfig = JSON.parse(fs.readFileSync(packageJsonPath, "utf8")).partykit || {};
      if (packageJsonConfig.partykit) {
        console.log(
          `Loading config from ${path.relative(
            process.cwd(),
            packageJsonPath
          )}#partykit`
        );
      }
    }
    const config2 = configSchema.parse({
      // defaults?
      ...packageJsonConfig,
      ...overrides,
      vars: {
        ...packageJsonConfig.vars,
        ...envVars,
        ...overrides.vars
      },
      define: {
        ...packageJsonConfig.define,
        ...overrides.define
      }
    });
    if (config2.main) {
      const absoluteMainPath = path.isAbsolute(config2.main) ? config2.main : path.join(process.cwd(), config2.main);
      if (!fs.existsSync(absoluteMainPath)) {
        throw new Error(`Could not find main: ${config2.main}`);
      } else {
        config2.main = "./" + path.relative(process.cwd(), absoluteMainPath);
      }
    }
    return config2;
  }
  console.log(
    `Loading config from ${path.relative(process.cwd(), configPath)}`
  );
  const parsedConfig = JSON5.parse(fs.readFileSync(configPath, "utf8"));
  configSchema.parse(parsedConfig);
  const config = configSchema.parse({
    ...overrides,
    ...parsedConfig,
    vars: {
      ...parsedConfig.vars,
      ...envVars,
      ...overrides.vars
    },
    define: {
      ...parsedConfig.define,
      ...overrides.define
    }
  });
  if (config.account) {
    console.warn('configuration field "account" is not yet operational');
  }
  if (config.main) {
    if (overrides.main) {
      const absoluteMainPath = path.isAbsolute(overrides.main) ? overrides.main : path.join(process.cwd(), overrides.main);
      if (!fs.existsSync(absoluteMainPath)) {
        throw new Error(`Could not find main: ${overrides.main}`);
      } else {
        config.main = "./" + path.relative(process.cwd(), absoluteMainPath);
      }
    } else if (parsedConfig.main) {
      const absoluteMainPath = path.isAbsolute(parsedConfig.main) ? parsedConfig.main : path.join(path.dirname(configPath), parsedConfig.main);
      if (!fs.existsSync(absoluteMainPath)) {
        throw new Error(`Could not find main: ${parsedConfig.main}`);
      } else {
        config.main = "./" + path.relative(process.cwd(), absoluteMainPath);
      }
    }
  }
  return config;
}

// src/dev.tsx
import fs2 from "fs";
import path3 from "path";
import { execaCommand } from "execa";
import esbuild from "esbuild";
import chalk2 from "chalk";
import chokidar from "chokidar";
import crypto from "crypto";
import { Suspense, useEffect as useEffect2, useState as useState2 } from "react";
import React from "react";
import { render } from "ink";

// src/inspect.ts
import { readFileSync } from "fs";
import { readFile } from "fs/promises";
import assert2 from "node:assert";
import { createServer } from "node:http";
import os2 from "node:os";
import { URL as URL2 } from "node:url";
import path2 from "path";
import open2 from "open";
import { useEffect, useRef, useState } from "react";
import { SourceMapConsumer } from "source-map";
import WebSocket, { WebSocketServer } from "ws";

// package.json
var version = "0.0.0-a16ecec";

// src/inspect.ts
import { createServer as createHttpServer } from "node:http";
import { createHttpTerminator } from "http-terminator";
var logger = console;
async function waitForPortToBeAvailable(port, options) {
  return new Promise((resolve, reject) => {
    options.abortSignal.addEventListener("abort", () => {
      const abortError = new Error("waitForPortToBeAvailable() aborted");
      abortError.code = "ABORT_ERR";
      doReject(abortError);
    });
    const timeout = setTimeout(() => {
      doReject(new Error(`Timed out waiting for port ${port}`));
    }, options.timeout);
    const interval = setInterval(checkPort, options.retryPeriod);
    checkPort();
    function doResolve() {
      clearTimeout(timeout);
      clearInterval(interval);
      resolve();
    }
    function doReject(err) {
      clearInterval(interval);
      clearTimeout(timeout);
      reject(err);
    }
    function checkPort() {
      if (port === 0) {
        doResolve();
        return;
      }
      const server = createHttpServer();
      const terminator = createHttpTerminator({
        server,
        gracefulTerminationTimeout: 0
        // default 1000
      });
      server.on("error", (err) => {
        if (err.code !== "EADDRINUSE") {
          doReject(err);
        }
      });
      server.listen(
        port,
        () => terminator.terminate().then(
          doResolve,
          () => logger.error("Failed to terminate the port checker.")
        )
      );
    }
  });
}
function useInspector(props) {
  const inspectorIdRef = useRef(randomId());
  const [localWebSocket, setLocalWebSocket] = useState();
  const [remoteWebSocket, setRemoteWebSocket] = useState();
  const serverRef = useRef();
  if (serverRef.current === void 0) {
    serverRef.current = createServer(
      (req, res) => {
        switch (req.url) {
          case "/json/version":
            res.setHeader("Content-Type", "application/json");
            res.end(
              JSON.stringify({
                Browser: `wrangler/v${version}`,
                // TODO: (someday): The DevTools protocol should match that of Edge Worker.
                // This could be exposed by the preview API.
                "Protocol-Version": "1.3"
              })
            );
            return;
          case "/json":
          case "/json/list":
            {
              res.setHeader("Content-Type", "application/json");
              const localHost = `localhost:${props.port}/ws`;
              const devtoolsFrontendUrl = `devtools://devtools/bundled/js_app.html?experiments=true&v8only=true&ws=${localHost}`;
              const devtoolsFrontendUrlCompat = `devtools://devtools/bundled/inspector.html?experiments=true&v8only=true&ws=${localHost}`;
              res.end(
                JSON.stringify([
                  {
                    id: inspectorIdRef.current,
                    type: "node",
                    description: "workers",
                    webSocketDebuggerUrl: `ws://${localHost}`,
                    devtoolsFrontendUrl,
                    devtoolsFrontendUrlCompat,
                    // Below are fields that are visible in the DevTools UI.
                    title: "Cloudflare Worker",
                    faviconUrl: "https://workers.cloudflare.com/favicon.ico",
                    url: "https://" + (remoteWebSocket ? new URL2(remoteWebSocket.url).host : "workers.dev")
                  }
                ])
              );
            }
            return;
          default:
            break;
        }
      }
    );
  }
  const server = serverRef.current;
  const wsServerRef = useRef();
  if (wsServerRef.current === void 0) {
    wsServerRef.current = new WebSocketServer({
      server,
      clientTracking: true
    });
  }
  const wsServer = wsServerRef.current;
  wsServer.on("connection", (ws) => {
    if (wsServer.clients.size > 1) {
      logger.error(
        "Tried to open a new devtools window when a previous one was already open."
      );
      ws.close(1013, "Too many clients; only one can be connected at a time");
    } else {
      remoteWebSocket?.send(
        JSON.stringify({
          // This number is arbitrary, and is chosen to be high so as not to conflict with messages that DevTools might actually send.
          // For completeness, these options don't work: 0, -1, or Number.MAX_SAFE_INTEGER
          id: 1e8,
          method: "Debugger.disable"
        })
      );
      setLocalWebSocket(ws);
      ws.addEventListener("close", () => {
        setLocalWebSocket(void 0);
      });
    }
  });
  useEffect(() => {
    const abortController = new AbortController();
    async function startInspectorProxy() {
      await waitForPortToBeAvailable(props.port, {
        retryPeriod: 200,
        timeout: 2e3,
        abortSignal: abortController.signal
      });
      server.listen(props.port);
    }
    startInspectorProxy().catch((err) => {
      if (err.code !== "ABORT_ERR") {
        logger.error("Failed to start inspector:", err);
      }
    });
    return () => {
      server.close();
      wsServer.clients.forEach((ws) => {
        ws.close();
      });
      wsServer.close();
      abortController.abort();
    };
  }, [props.port, server, wsServer]);
  const [
    retryRemoteWebSocketConnectionSigil,
    setRetryRemoteWebSocketConnectionSigil
  ] = useState(0);
  function retryRemoteWebSocketConnection() {
    setRetryRemoteWebSocketConnectionSigil((x) => x + 1);
  }
  const messageCounterRef = useRef(1);
  useEffect(() => {
    if (!props.inspectorUrl) {
      return;
    }
    const ws = new WebSocket(props.inspectorUrl);
    setRemoteWebSocket(ws);
    let keepAliveInterval;
    function isClosed() {
      return ws.readyState === WebSocket.CLOSED || ws.readyState === WebSocket.CLOSING;
    }
    function send(event) {
      if (!isClosed()) {
        ws.send(JSON.stringify(event));
      }
    }
    function close() {
      if (!isClosed() && ws.readyState !== WebSocket.CONNECTING) {
        try {
          ws.close();
        } catch (err) {
        }
      }
    }
    if (props.logToTerminal) {
      ws.addEventListener("message", async (event) => {
        if (typeof event.data === "string") {
          const evt = JSON.parse(event.data);
          if (evt.method === "Runtime.exceptionThrown") {
            const params = evt.params;
            if (props.sourceMapPath) {
              const mapContent = JSON.parse(
                await readFile(props.sourceMapPath, "utf-8")
              );
              const exceptionLines = [
                params.exceptionDetails.exception?.description?.split("\n")[0]
              ];
              await SourceMapConsumer.with(
                mapContent,
                null,
                async (consumer) => {
                  const stack = params.exceptionDetails.stackTrace?.callFrames;
                  stack?.forEach(
                    ({ functionName, lineNumber, columnNumber }, i) => {
                      try {
                        if (lineNumber) {
                          const pos = consumer.originalPositionFor({
                            line: lineNumber + 1,
                            column: columnNumber + 1
                          });
                          if (i === 0 && pos.source && pos.line) {
                            const fileSource = consumer.sourceContentFor(
                              pos.source
                            );
                            const fileSourceLine = fileSource?.split("\n")[pos.line - 1] || "";
                            exceptionLines.push(fileSourceLine.trim());
                            if (pos.column) {
                              exceptionLines.push(
                                `${" ".repeat(
                                  pos.column - fileSourceLine.search(/\S/)
                                )}^`
                              );
                            }
                          }
                          if (pos && pos.line != null) {
                            const convertedFnName = pos.name || functionName || "";
                            exceptionLines.push(
                              `    at ${convertedFnName} (${pos.source}:${pos.line}:${pos.column})`
                            );
                          }
                        }
                      } catch {
                      }
                    }
                  );
                }
              );
              logger.error(
                params.exceptionDetails.text,
                exceptionLines.join("\n")
              );
            } else {
              logger.error(
                params.exceptionDetails.text,
                params.exceptionDetails.exception?.description ?? ""
              );
            }
          }
          if (evt.method === "Runtime.consoleAPICalled") {
            logConsoleMessage(
              evt.params
            );
          }
        } else {
          logger.error("Unrecognised devtools event:", event);
        }
      });
    }
    ws.addEventListener("open", () => {
      send({ method: "Runtime.enable", id: messageCounterRef.current });
      send({ method: "Network.enable", id: messageCounterRef.current++ });
      keepAliveInterval = setInterval(() => {
        send({
          method: "Runtime.getIsolateId",
          id: messageCounterRef.current++
        });
      }, 1e4);
    });
    ws.on("unexpected-response", () => {
      logger.log("Waiting for connection...");
      retryRemoteWebSocketConnection();
    });
    ws.addEventListener("close", () => {
      clearInterval(keepAliveInterval);
    });
    return () => {
      clearInterval(keepAliveInterval);
      wsServer.clients.forEach((client) => {
        client.send(
          JSON.stringify({
            // TODO: This doesn't actually work. Must fix.
            method: "Log.clear",
            // we can disable the next eslint warning since
            // we're referencing a ref that stays alive
            // eslint-disable-next-line react-hooks/exhaustive-deps
            id: messageCounterRef.current++,
            params: {}
          })
        );
      });
      close();
      setRemoteWebSocket(void 0);
    };
  }, [
    props.inspectorUrl,
    props.logToTerminal,
    props.sourceMapPath,
    wsServer,
    // We use a state value as a sigil to trigger a retry of the
    // remote websocket connection. It's not used inside the effect,
    // so react-hooks/exhaustive-deps doesn't complain if it's not
    // included in the dependency array. But its presence is critical,
    // so do NOT remove it from the dependency list.
    retryRemoteWebSocketConnectionSigil
  ]);
  const messageBufferRef = useRef([]);
  useEffect(() => {
    function bufferMessageFromRemoteSocket(event) {
      messageBufferRef.current.push(event);
    }
    if (remoteWebSocket && !localWebSocket) {
      remoteWebSocket.addEventListener(
        "message",
        bufferMessageFromRemoteSocket
      );
    }
    function sendMessageToRemoteWebSocket(event) {
      try {
        const message = JSON.parse(event.data);
        if (message.method === "Network.loadNetworkResource" && props.sourceMapPath !== void 0 && props.sourceMapMetadata !== void 0) {
          const sourceMap = JSON.parse(
            readFileSync(props.sourceMapPath, "utf-8")
          );
          sourceMap.sourceRoot = "";
          const tmpDir = props.sourceMapMetadata.tmpDir;
          sourceMap.x_google_ignoreList = sourceMap.sources.map(
            (s, idx) => s.includes(tmpDir) || s.includes("wrangler/templates") ? idx : null
          ).filter((i) => i !== null);
          const entryDirectory = props.sourceMapMetadata.entryDirectory;
          sourceMap.sources = sourceMap.sources.map(
            (s) => (
              // These are never loaded by Wrangler or DevTools. However, the presence of a scheme is required for DevTools to show the path as folders in the Sources view
              // The scheme is intentially not the same as for the sourceMappingURL
              // Without this difference in scheme, DevTools will not strip prefix `../` path elements from top level folders (../node_modules -> node_modules, for instance)
              `worker://${props.name}/${path2.relative(entryDirectory, s)}`
            )
          );
          sendMessageToLocalWebSocket({
            data: JSON.stringify({
              id: message.id,
              result: {
                resource: {
                  success: true,
                  text: JSON.stringify(sourceMap)
                }
              }
            })
          });
          return;
        }
      } catch (e) {
        logger.debug(e);
      }
      try {
        assert2(
          remoteWebSocket,
          "Trying to send a message to an undefined `remoteWebSocket`"
        );
        remoteWebSocket.send(event.data);
      } catch (e) {
        if (e.message !== "WebSocket is not open: readyState 0 (CONNECTING)") {
          logger.error(e);
        }
      }
    }
    function sendMessageToLocalWebSocket(event) {
      assert2(
        localWebSocket,
        "Trying to send a message to an undefined `localWebSocket`"
      );
      try {
        const message = JSON.parse(event.data);
        if (message.method === "Debugger.scriptParsed") {
          message.params.url = new URL2(
            message.params.url,
            `worker://${props.name}`
          ).href;
          localWebSocket.send(JSON.stringify(message));
          return;
        }
      } catch (e) {
        logger.debug(e);
      }
      localWebSocket.send(event.data);
    }
    if (localWebSocket && remoteWebSocket) {
      localWebSocket.addEventListener("message", sendMessageToRemoteWebSocket);
      remoteWebSocket.addEventListener("message", sendMessageToLocalWebSocket);
      messageBufferRef.current.forEach(sendMessageToLocalWebSocket);
      messageBufferRef.current = [];
    }
    return () => {
      if (remoteWebSocket) {
        remoteWebSocket.removeEventListener(
          "message",
          bufferMessageFromRemoteSocket
        );
        remoteWebSocket.removeEventListener(
          "message",
          sendMessageToLocalWebSocket
        );
      }
      if (localWebSocket) {
        localWebSocket.removeEventListener(
          "message",
          sendMessageToRemoteWebSocket
        );
      }
    };
  }, [
    localWebSocket,
    remoteWebSocket,
    props.name,
    props.sourceMapMetadata,
    props.sourceMapPath
  ]);
}
function randomId() {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
    const r = Math.random() * 16 | 0, v = c == "x" ? r : r & 3 | 8;
    return v.toString(16);
  });
}
var mapConsoleAPIMessageTypeToConsoleMethod = {
  log: "log",
  debug: "debug",
  info: "info",
  warning: "warn",
  error: "error",
  dir: "dir",
  dirxml: "dirxml",
  table: "table",
  trace: "trace",
  clear: "clear",
  count: "count",
  assert: "assert",
  profile: "profile",
  profileEnd: "profileEnd",
  timeEnd: "timeEnd",
  startGroup: "group",
  startGroupCollapsed: "groupCollapsed",
  endGroup: "groupEnd"
};
function logConsoleMessage(evt) {
  const args = [];
  for (const ro of evt.args) {
    switch (ro.type) {
      case "string":
      case "number":
      case "boolean":
      case "undefined":
      case "symbol":
      case "bigint":
        args.push(ro.value);
        break;
      case "function":
        args.push(`[Function: ${ro.description ?? "<no-description>"}]`);
        break;
      case "object":
        if (!ro.preview) {
          args.push(
            ro.subtype === "null" ? "null" : ro.description ?? "<no-description>"
          );
        } else {
          args.push(ro.preview.description ?? "<no-description>");
          switch (ro.preview.subtype) {
            case "array":
              args.push(
                "[ " + ro.preview.properties.map(({ value }) => {
                  return value;
                }).join(", ") + (ro.preview.overflow ? "..." : "") + " ]"
              );
              break;
            case "weakmap":
            case "map":
              ro.preview.entries === void 0 ? args.push("{}") : args.push(
                "{\n" + ro.preview.entries.map(({ key, value }) => {
                  return `  ${key?.description ?? "<unknown>"} => ${value.description}`;
                }).join(",\n") + (ro.preview.overflow ? "\n  ..." : "") + "\n}"
              );
              break;
            case "weakset":
            case "set":
              ro.preview.entries === void 0 ? args.push("{}") : args.push(
                "{ " + ro.preview.entries.map(({ value }) => {
                  return `${value.description}`;
                }).join(", ") + (ro.preview.overflow ? ", ..." : "") + " }"
              );
              break;
            case "regexp":
              break;
            case "date":
              break;
            case "generator":
              args.push(ro.preview.properties[0].value || "");
              break;
            case "promise":
              if (ro.preview.properties[0].value === "pending") {
                args.push(`{<${ro.preview.properties[0].value}>}`);
              } else {
                args.push(
                  `{<${ro.preview.properties[0].value}>: ${ro.preview.properties[1].value}}`
                );
              }
              break;
            case "node":
            case "iterator":
            case "proxy":
            case "typedarray":
            case "arraybuffer":
            case "dataview":
            case "webassemblymemory":
            case "wasmvalue":
              break;
            case "error":
            default:
              args.push(
                "{\n" + ro.preview.properties.map(({ name, value }) => {
                  return `  ${name}: ${value}`;
                }).join(",\n") + (ro.preview.overflow ? "\n  ..." : "") + "\n}"
              );
          }
        }
        break;
      default:
        args.push(ro.description || ro.unserializableValue || "\u{1F98B}");
        break;
    }
  }
  const method = mapConsoleAPIMessageTypeToConsoleMethod[evt.type];
  if (method in console) {
    switch (method) {
      case "dir":
        console.dir(args);
        break;
      case "table":
        console.table(args);
        break;
      default:
        console[method].apply(console, args);
        break;
    }
  } else {
    logger.warn(`Unsupported console method: ${method}`);
    logger.warn("console event:", evt);
  }
}

// src/dev.tsx
import { fetch as fetch3 } from "undici";
var esbuildOptions = {
  format: "esm",
  bundle: true,
  write: false,
  target: "esnext",
  minify: true
  // TODO: remove this once https://github.com/vercel/edge-runtime/issues/243 is fixed
};
var ReloadedEvent = class extends Event {
  url;
  // readonly internalDurableObjects: CfDurableObject[];
  constructor(type, options) {
    super(type);
    this.url = options.url;
  }
};
var ErrorEvent = class extends Event {
  error;
  constructor(type, options) {
    super(type);
    this.error = options.error;
  }
};
var MiniflareServer = class extends TypedEventTarget {
  #log = console.log;
  #mf;
  async onBundleUpdate(options, opts) {
    if (opts?.signal?.aborted)
      return;
    try {
      if (opts?.signal?.aborted)
        return;
      if (this.#mf === void 0) {
        this.#mf = new Miniflare(options);
      } else {
        await this.#mf.setOptions(options);
      }
      const url = await this.#mf.ready;
      if (opts?.signal?.aborted)
        return;
      const event = new ReloadedEvent("reloaded", {
        url
        // internalDurableObjects: internalObjects,
      });
      this.dispatchEvent(event);
    } catch (error) {
      this.dispatchEvent(new ErrorEvent("error", { error }));
    }
  }
  onDispose = async () => {
    await this.#mf?.dispose();
    this.#mf = void 0;
  };
};
function Dev(props) {
  return /* @__PURE__ */ React.createElement(Suspense, null, /* @__PURE__ */ React.createElement(DevImpl, { ...props }));
}
function DevImpl(props) {
  const { inspectorUrl } = useDev(props);
  useInspector({
    port: 9230,
    inspectorUrl,
    logToTerminal: true,
    sourceMapPath: void 0,
    sourceMapMetadata: void 0
  });
  return null;
}
function useDev(options) {
  const [config] = useState2(
    () => getConfig(
      options.config,
      {
        main: options.main,
        vars: options.vars,
        define: options.define,
        assets: options.assets,
        port: options.port
      },
      { readEnvLocal: true }
    )
  );
  const [server] = useState2(() => new MiniflareServer());
  const [inspectorUrl, setInspectorUrl] = useState2(
    void 0
  );
  if (!config.main) {
    throw new Error(
      'Missing entry point, please specify "main" in your config'
    );
  }
  useEffect2(() => {
    if (config.assets) {
      console.warn("Warning: serving assets are not yet supported in dev mode");
    }
    async function runBuild() {
      let isFirstBuild = true;
      let wasmModules = {};
      const workerFacade = fs2.readFileSync(
        fileURLToPath(
          path3.join(path3.dirname(import.meta.url), "../facade/generated.js")
        ),
        "utf8"
      );
      const absoluteScriptPath = path3.join(process.cwd(), config.main);
      const ctx = await esbuild.context({
        stdin: {
          contents: workerFacade.replace("__WORKER__", absoluteScriptPath),
          resolveDir: process.cwd()
          // TODO: setting a sourcefile name crashes the whole thing???
          // sourcefile: "./" + path.relative(process.cwd(), scriptPath),
        },
        ...esbuildOptions,
        format: "esm",
        sourcemap: true,
        define: {
          ...esbuildOptions.define,
          ...config.define
        },
        plugins: [
          {
            name: "partykit",
            setup(build) {
              build.onEnd(async (result) => {
                if (result.errors.length > 0)
                  return;
                if (!result || !result.outputFiles) {
                  console.error(chalk2.red("Build failed: no result"));
                  return;
                }
                if (isFirstBuild) {
                  isFirstBuild = false;
                  console.log(
                    chalk2.green("Build succeeded, starting server...")
                  );
                } else {
                  console.log(
                    chalk2.green("Build succeeded, starting server...")
                  );
                }
                const code = result.outputFiles[0].text;
                return new Promise((resolve) => {
                  server.addEventListener("reloaded", () => resolve(), {
                    once: true
                  });
                  void server.onBundleUpdate({
                    log: new Log(5, { prefix: "pk" }),
                    // verbose: true,
                    inspectorPort: 9229,
                    compatibilityDate: "2021-05-26",
                    compatibilityFlags: ["nodejs_compat"],
                    port: config.port || 1999,
                    durableObjects: {
                      MAIN_DO: "MainDO"
                    },
                    // @ts-expect-error miniflare's types are wrong
                    modules: [
                      {
                        type: "ESModule",
                        path: absoluteScriptPath,
                        contents: code
                      },
                      ...Object.entries(wasmModules).map(([name, p]) => ({
                        type: "CompiledWasm",
                        path: name,
                        contents: fs2.readFileSync(p)
                      }))
                    ],
                    modulesRoot: process.cwd(),
                    script: code
                  });
                });
              });
            }
          },
          {
            name: "partykit-wasm-dev",
            setup(build) {
              build.onStart(() => {
                wasmModules = {};
              });
              build.onResolve({ filter: /\.wasm(\?module)?$/ }, (args) => {
                const filePath = path3.join(
                  args.resolveDir,
                  args.path.replace(/\?module$/, "")
                );
                const fileContent = fs2.readFileSync(filePath);
                const fileHash = crypto.createHash("sha1").update(fileContent).digest("hex");
                const fileName = `./${fileHash}-${path3.basename(args.path).replace(/\?module$/, "")}`;
                wasmModules[fileName] = filePath;
                return {
                  path: fileName,
                  // change the reference to the changed module
                  external: true,
                  // not an external in dev, we swap it with an identifier
                  namespace: `partykit-module-wasm-dev`,
                  // just a tag, this isn't strictly necessary
                  watchFiles: [filePath]
                  // we also add the file to esbuild's watch list
                };
              });
            }
          }
        ]
      });
      if (config.build?.command) {
        const buildCommand = config.build.command;
        const buildCwd = config.build.cwd;
        await execaCommand(buildCommand, {
          shell: true,
          // we keep these two as "inherit" so that
          // logs are still visible.
          stdout: "inherit",
          stderr: "inherit",
          ...buildCwd && { cwd: buildCwd }
        });
        const _watcher = chokidar.watch(config.build.watch || path3.join(process.cwd(), "./src"), {
          persistent: true,
          ignoreInitial: true
        }).on("all", async (_event, _path) => {
          execaCommand(buildCommand, {
            shell: true,
            // we keep these two as "inherit" so that
            // logs are still visible.
            stdout: "inherit",
            stderr: "inherit",
            ...buildCwd && { cwd: buildCwd }
          }).catch((err) => {
            console.error(chalk2.red("Custom build failed"), err);
          });
        });
      }
      await ctx.watch();
    }
    runBuild().catch((error) => {
      console.error(error);
      process.exit(1);
    });
  }, [config, server]);
  useEffect2(() => {
    server.addEventListener("reloaded", async (event) => {
      options.onReady?.(event.url.hostname, parseInt(event.url.port));
      try {
        const jsonUrl = `http://127.0.0.1:9229/json`;
        const res = await fetch3(jsonUrl);
        const body = await res.json();
        const debuggerUrl = body?.find(
          ({ id }) => id.startsWith("core:user")
        )?.webSocketDebuggerUrl;
        if (debuggerUrl === void 0) {
          setInspectorUrl(void 0);
        } else {
          const url = new URL(debuggerUrl);
          url.username = `${Date.now()}-${Math.floor(
            Math.random() * Number.MAX_SAFE_INTEGER
          )}`;
          setInspectorUrl(url.toString());
        }
      } catch (error) {
        console.error("Error attempting to retrieve debugger URL:", error);
      }
    });
    server.addEventListener("error", ({ error }) => {
      console.error("Error reloading local server:", error);
    });
  }, [inspectorUrl, options, server]);
  useEffect2(() => {
    return () => {
      const removeMiniflareServerExitListener = onExit(() => {
        console.log(chalk2.dim("\u2394 Shutting down local server..."));
        void server.onDispose();
      });
      server.onDispose().then(() => {
        console.log(chalk2.dim("\u2394 Local server shut down...."));
      }).catch((err) => {
        console.error("Error disposing local server:", err);
      });
      removeMiniflareServerExitListener();
    };
  }, [server]);
  return {
    inspectorUrl
  };
}

// src/cli.ts
import { execaCommand as execaCommand2 } from "execa";

// src/tail/filters.ts
function translateCLICommandToFilterMessage(cliFilters) {
  const apiFilters = [];
  if (cliFilters.samplingRate) {
    apiFilters.push(parseSamplingRate(cliFilters.samplingRate));
  }
  if (cliFilters.status) {
    apiFilters.push(parseOutcome(cliFilters.status));
  }
  if (cliFilters.method) {
    apiFilters.push(parseMethod(cliFilters.method));
  }
  if (cliFilters.header) {
    apiFilters.push(parseHeader(cliFilters.header));
  }
  if (cliFilters.clientIp) {
    apiFilters.push(parseIP(cliFilters.clientIp));
  }
  if (cliFilters.search) {
    apiFilters.push(parseQuery(cliFilters.search));
  }
  return {
    filters: apiFilters
  };
}
function parseSamplingRate(sampling_rate) {
  if (sampling_rate <= 0 || sampling_rate >= 1) {
    throw new Error(
      "A sampling rate must be between 0 and 1 in order to have any effect.\nFor example, a sampling rate of 0.25 means 25% of events will be logged."
    );
  }
  return { sampling_rate };
}
function parseOutcome(statuses) {
  const outcomes = /* @__PURE__ */ new Set();
  for (const status of statuses) {
    switch (status) {
      case "ok":
        outcomes.add("ok");
        break;
      case "canceled":
        outcomes.add("canceled");
        break;
      case "error":
        outcomes.add("exception");
        outcomes.add("exceededCpu");
        outcomes.add("exceededMemory");
        outcomes.add("unknown");
        break;
      default:
        break;
    }
  }
  return {
    outcome: Array.from(outcomes)
  };
}
function parseMethod(method) {
  return { method };
}
function parseHeader(header) {
  const [headerKey, headerQuery] = header.split(":", 2);
  return {
    header: {
      key: headerKey.trim(),
      query: headerQuery?.trim()
    }
  };
}
function parseIP(client_ip) {
  return { client_ip };
}
function parseQuery(query) {
  return { query };
}

// src/tail/printing.ts
function prettyPrintLogs(data) {
  const eventMessage = JSON.parse(data.toString());
  if (isScheduledEvent(eventMessage.event)) {
    const cronPattern = eventMessage.event.cron;
    const datetime = new Date(
      eventMessage.event.scheduledTime
    ).toLocaleString();
    const outcome = prettifyOutcome(eventMessage.outcome);
    console.log(`"${cronPattern}" @ ${datetime} - ${outcome}`);
  } else if (isRequestEvent(eventMessage.event)) {
    const requestMethod = eventMessage.event?.request.method.toUpperCase();
    const url = eventMessage.event?.request.url;
    const outcome = prettifyOutcome(eventMessage.outcome);
    const datetime = new Date(eventMessage.eventTimestamp).toLocaleString();
    console.log(
      url ? `${requestMethod} ${url} - ${outcome} @ ${datetime}` : `[missing request] - ${outcome} @ ${datetime}`
    );
  } else if (isEmailEvent(eventMessage.event)) {
    const outcome = prettifyOutcome(eventMessage.outcome);
    const datetime = new Date(eventMessage.eventTimestamp).toLocaleString();
    const mailFrom = eventMessage.event.mailFrom;
    const rcptTo = eventMessage.event.rcptTo;
    const rawSize = eventMessage.event.rawSize;
    console.log(
      `Email from:${mailFrom} to:${rcptTo} size:${rawSize} @ ${datetime} - ${outcome}`
    );
  } else if (isAlarmEvent(eventMessage.event)) {
    const outcome = prettifyOutcome(eventMessage.outcome);
    const datetime = new Date(
      eventMessage.event.scheduledTime
    ).toLocaleString();
    console.log(`Alarm @ ${datetime} - ${outcome}`);
  } else {
    const outcome = prettifyOutcome(eventMessage.outcome);
    const datetime = new Date(eventMessage.eventTimestamp).toLocaleString();
    console.log(`Unknown Event - ${outcome} @ ${datetime}`);
  }
  if (eventMessage.logs.length > 0) {
    eventMessage.logs.forEach(({ level, message }) => {
      console.log(`  (${level})`, ...message);
    });
  }
  if (eventMessage.exceptions.length > 0) {
    eventMessage.exceptions.forEach(({ name, message }) => {
      console.error(`  ${name}:`, message);
    });
  }
}
function jsonPrintLogs(data) {
  console.log(JSON.stringify(JSON.parse(data.toString()), null, 2));
}
function isRequestEvent(event) {
  return Boolean(event && "request" in event);
}
function isScheduledEvent(event) {
  return Boolean(event && "cron" in event);
}
function isEmailEvent(event) {
  return Boolean(event && "mailFrom" in event);
}
function isAlarmEvent(event) {
  return Boolean(event && "scheduledTime" in event && !("cron" in event));
}
function prettifyOutcome(outcome) {
  switch (outcome) {
    case "ok":
      return "Ok";
    case "canceled":
      return "Canceled";
    case "exceededCpu":
      return "Exceeded CPU Limit";
    case "exceededMemory":
      return "Exceeded Memory Limit";
    case "exception":
      return "Exception Thrown";
    case "unknown":
    default:
      return "Unknown";
  }
}

// src/cli.ts
function sleep(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
var esbuildOptions2 = {
  format: "esm",
  bundle: true,
  write: false,
  target: "esnext"
  // minify: true,
};
async function deploy(options) {
  const config = getConfig(options.config, {
    main: options.main,
    name: options.name,
    assets: options.assets,
    vars: options.vars,
    define: options.define
  });
  if (!config.main) {
    throw new Error(
      'Missing entry point, please specify "main" in your config'
    );
  }
  const configName = config.name;
  assert3(
    configName,
    'Missing project name, please specify "name" in your config'
  );
  if (config.build?.command) {
    const buildCommand = config.build.command;
    const buildCwd = config.build.cwd;
    await execaCommand2(buildCommand, {
      shell: true,
      // we keep these two as "inherit" so that
      // logs are still visible.
      stdout: "inherit",
      stderr: "inherit",
      ...buildCwd && { cwd: buildCwd }
    });
  }
  if (config.assets) {
    console.warn(
      "Warning: uploading assets are not yet supported in deploy mode"
    );
  }
  const absoluteScriptPath = path4.join(process.cwd(), config.main);
  const user = await getUser();
  const wasmModules = {};
  const esbuild2 = await import("esbuild");
  const code = (await esbuild2.build({
    entryPoints: [absoluteScriptPath],
    ...esbuildOptions2,
    define: {
      ...esbuildOptions2.define,
      ...config.define
    },
    plugins: [
      {
        name: "partykit-wasm-publish",
        setup(build) {
          build.onResolve({ filter: /\.wasm$/ }, (args) => {
            throw new Error(
              `Cannot import .wasm files directly. Use import "${args.path}?module" instead.`
            );
          });
          build.onResolve({ filter: /\.wasm\?module$/ }, (args) => {
            const filePath = path4.join(
              args.resolveDir,
              args.path.replace(/\?module$/, "")
            );
            const fileContent = fs3.readFileSync(filePath);
            const fileHash = crypto2.createHash("sha1").update(fileContent).digest("hex");
            const fileName = `${fileHash}-${path4.basename(
              args.path,
              ".wasm?module"
            )}`;
            wasmModules[fileName] = fs3.readFileSync(filePath);
            return {
              path: fileName,
              // change the reference to the changed module
              external: true,
              // mark it as external in the bundle
              namespace: "partykit-module-wasm-publish"
              // just a tag, this isn't strictly necessary
            };
          });
        }
      }
    ]
  })).outputFiles[0].text;
  const form = new FormData();
  form.set("code", code);
  const vars = options.withVars ? config.vars : (
    // only set vars passed in via cli with --var,
    // not from .env/partykit.json/etc
    options.vars
  );
  if (vars && Object.keys(vars).length > 0) {
    form.set("vars", JSON.stringify(vars));
  }
  for (const [fileName, buffer] of Object.entries(wasmModules)) {
    form.set(
      `upload/${fileName}`,
      new File([buffer], `upload/${fileName}`, { type: "application/wasm" })
    );
  }
  const urlSearchParams = new URLSearchParams();
  if (options.preview) {
    urlSearchParams.set("preview", options.preview);
  }
  await fetchResult(
    `/parties/${user.login}/${config.name}${options.preview ? `?${urlSearchParams.toString()}` : ""}`,
    {
      method: "POST",
      body: form,
      headers: {
        Authorization: `Bearer ${user.access_token}`,
        "X-PartyKit-User-Type": user.type
      }
    }
  );
  console.log(
    `Deployed ${config.main} as ${options.preview ? `${options.preview}.` : ""}${config.name}.${user.login.toLowerCase()}.partykit.dev`
  );
}
async function _delete(options) {
  const config = getConfig(options.config, options);
  if (!config.name) {
    throw new Error("project name is missing");
  }
  const user = await getUser();
  const urlSearchParams = new URLSearchParams();
  if (options.preview) {
    urlSearchParams.set("preview", options.preview);
  }
  await fetchResult(
    `/parties/${user.login}/${config.name}${options.preview ? `?${urlSearchParams.toString()}` : ""}`,
    {
      method: "DELETE",
      headers: {
        Authorization: `Bearer ${user.access_token}`
      }
    }
  );
  console.log(`Deleted ${config.name}.${user.login}.partykit.dev`);
}
var TRACE_VERSION = "trace-v1";
async function tail(options) {
  const user = await getUser();
  const config = getConfig(options.config, {
    name: options.name
  });
  if (!config.name) {
    throw new Error("project name is missing");
  }
  let scriptDisplayName = config.name;
  if (options.preview) {
    scriptDisplayName = `${scriptDisplayName} (preview: ${options.preview})`;
  }
  const filters = translateCLICommandToFilterMessage({
    status: options.status,
    header: options.header,
    method: options.method,
    search: options.search,
    samplingRate: options.samplingRate,
    clientIp: options.ip
  });
  const urlSearchParams = new URLSearchParams();
  if (options.preview) {
    urlSearchParams.set("preview", options.preview);
  }
  const {
    result: { id: tailId, url: websocketUrl, expires_at: expiration }
  } = await fetchResult(
    `/parties/${user.login}/${config.name}/tail${options.preview ? `?${urlSearchParams.toString()}` : ""}`,
    {
      method: "POST",
      body: JSON.stringify(filters),
      headers: {
        Authorization: `Bearer ${user.access_token}`
      }
    }
  );
  if (options.format === "pretty") {
    console.log(
      `Successfully created tail, expires at ${expiration.toLocaleString()}`
    );
  }
  async function deleteTail() {
    await fetchResult(
      `/parties/${user.login}/${config.name}/tail/${tailId}${options.preview ? `?${urlSearchParams.toString()}` : ""}`,
      {
        method: "DELETE",
        headers: {
          Authorization: `Bearer ${user.access_token}`
        }
      }
    );
  }
  const tailSocket = new WebSocket2(websocketUrl, TRACE_VERSION, {
    headers: {
      "Sec-WebSocket-Protocol": TRACE_VERSION,
      // needs to be `trace-v1` to be accepted
      "User-Agent": `partykit/${version}`
    }
  });
  tailSocket.on("open", function() {
    tailSocket.send(
      JSON.stringify({ debug: options.debug || false }),
      { binary: false, compress: false, mask: false, fin: true },
      (err) => {
        if (err) {
          throw err;
        }
      }
    );
  });
  onExit2(async () => {
    tailSocket.terminate();
    await deleteTail();
  });
  const printLog = options.format === "pretty" ? prettyPrintLogs : jsonPrintLogs;
  tailSocket.on("message", printLog);
  while (tailSocket.readyState !== tailSocket.OPEN) {
    switch (tailSocket.readyState) {
      case tailSocket.CONNECTING:
        await sleep(100);
        break;
      case tailSocket.CLOSING:
        await sleep(100);
        break;
      case tailSocket.CLOSED:
        throw new Error(
          `Connection to ${scriptDisplayName} closed unexpectedly.`
        );
    }
  }
  if (options.format === "pretty") {
    console.log(`Connected to ${scriptDisplayName}, waiting for logs...`);
  }
  tailSocket.on("close", async () => {
    tailSocket.terminate();
    await deleteTail();
  });
}
async function list() {
  const user = await getUser();
  const res = await fetchResult(`/parties/${user.login}`, {
    headers: {
      Authorization: `Bearer ${user.access_token}`
    }
  });
  console.log(res);
}
var env = {
  async list(options) {
    const user = await getUser();
    const config = getConfig(options.config, {
      name: options.name
    });
    if (!config.name) {
      throw new Error("project name is missing");
    }
    const urlSearchParams = new URLSearchParams();
    urlSearchParams.set("keys", "true");
    if (options.preview) {
      urlSearchParams.set("preview", options.preview);
    }
    const res = await fetchResult(
      `/parties/${user.login}/${config.name}/env?${urlSearchParams.toString()}`,
      {
        headers: {
          Authorization: `Bearer ${user.access_token}`
        }
      }
    );
    console.log(res);
  },
  async pull(fileName, options) {
    const user = await getUser();
    const config = getConfig(options.config, {
      name: options.name
    });
    if (!config.name) {
      throw new Error("project name is missing");
    }
    const urlSearchParams = new URLSearchParams();
    if (options.preview) {
      urlSearchParams.set("preview", options.preview);
    }
    const res = await fetchResult(
      `/parties/${user.login}/${config.name}/env${options.preview ? `?${urlSearchParams.toString()}` : ""}`,
      {
        headers: {
          Authorization: `Bearer ${user.access_token}`
        }
      }
    );
    const targetFileName = fileName || options.config || getConfigPath() || "partykit.json";
    if (!fs3.existsSync(targetFileName)) {
      console.log(`Creating ${targetFileName}...`);
      fs3.writeFileSync(targetFileName, "{}");
    } else {
      console.log(`Updating ${targetFileName}...`);
    }
    fs3.writeFileSync(
      targetFileName,
      JSON.stringify(
        {
          ...JSON.parse(fs3.readFileSync(targetFileName, "utf8")),
          name: config.name,
          vars: res
        },
        null,
        2
      ) + "\n"
    );
  },
  async push(options) {
    const user = await getUser();
    const config = getConfig(options.config, {
      name: options.name
    });
    if (!config.name) {
      throw new Error("project name is missing");
    }
    const urlSearchParams = new URLSearchParams();
    if (options.preview) {
      urlSearchParams.set("preview", options.preview);
    }
    if (Object.keys(config.vars || {}).length === 0) {
      console.warn("No environment variables to push, exiting...");
      return;
    }
    await fetchResult(
      `/parties/${user.login}/${config.name}/env${options.preview ? `?${urlSearchParams.toString()}` : ""}`,
      {
        method: "POST",
        body: JSON.stringify(config.vars || {}),
        headers: {
          Authorization: `Bearer ${user.access_token}`,
          "Content-Type": "application/json"
        }
      }
    );
    console.log("Pushed environment variables");
  },
  async add(key, options) {
    const user = await getUser();
    const config = getConfig(options.config, {
      name: options.name
    });
    if (!config.name) {
      throw new Error("project name is missing");
    }
    const { default: prompt } = await import("prompts");
    const { value } = !process.stdin.isTTY ? (
      // the value is being piped in
      await new Promise((resolve, reject) => {
        const stdin = process.openStdin();
        let data = "";
        stdin.on("data", function(chunk) {
          data += chunk;
        });
        stdin.on("end", function() {
          resolve({ value: data });
        });
        stdin.on("error", function(err) {
          reject(err);
        });
      })
    ) : (
      // the value is being entered manually
      await prompt({
        type: "password",
        name: "value",
        message: `Enter the value for ${key}`
      })
    );
    const urlSearchParams = new URLSearchParams();
    if (options.preview) {
      urlSearchParams.set("preview", options.preview);
    }
    const res = await fetchResult(
      `/parties/${user.login}/${config.name}/env/${key}${options.preview ? `?${urlSearchParams.toString()}` : ""}`,
      {
        method: "POST",
        body: value,
        headers: {
          Authorization: `Bearer ${user.access_token}`
        }
      }
    );
    console.log(res);
  },
  async remove(key, options) {
    const user = await getUser();
    const config = getConfig(options.config, {
      name: options.name
    });
    if (!config.name) {
      throw new Error("project name is missing");
    }
    const urlSearchParams = new URLSearchParams();
    if (options.preview) {
      urlSearchParams.set("preview", options.preview);
    }
    if (!key) {
      const { default: prompt } = await import("prompts");
      const { value } = await prompt({
        type: "confirm",
        name: "value",
        message: `Are you sure you want to delete all environment variables?`,
        initial: true
      });
      if (!value) {
        console.log("Aborted");
        return;
      } else {
        const res2 = await fetchResult(
          `/parties/${user.login}/${config.name}/env${options.preview ? `?${urlSearchParams.toString()}` : ""}`,
          {
            method: "DELETE",
            headers: {
              Authorization: `Bearer ${user.access_token}`
            }
          }
        );
        console.log(res2);
        return;
      }
    }
    const res = await fetchResult(
      `/parties/${user.login}/${config.name}/env/${key}${options.preview ? `?${urlSearchParams.toString()}` : ""}`,
      {
        method: "DELETE",
        headers: {
          Authorization: `Bearer ${user.access_token}`
        }
      }
    );
    console.log(res);
  }
};

// src/bin.tsx
import { Option, program } from "commander";
import React4, { Suspense as Suspense2 } from "react";

// src/commands/login.tsx
import React2 from "react";

// src/async-cache.ts
function asyncCache() {
  const promises = {};
  const states = {};
  return function read3(name, fn2) {
    if (!promises[name]) {
      promises[name] = fn2();
      states[name] = {
        status: "pending",
        value: void 0
      };
      promises[name].then((value) => {
        states[name] = {
          status: "success",
          value
        };
      }).catch((error) => {
        states[name] = {
          status: "error",
          value: error
        };
      });
    }
    if (states[name].status === "pending") {
      throw promises[name];
    }
    if (states[name].status === "error") {
      throw states[name].value;
    }
    if (states[name].status === "success") {
      return states[name].value;
    }
  };
}

// src/commands/login.tsx
import { Text } from "ink";
var read = asyncCache();
function Login() {
  const userConfig = read("get-user", getUser);
  return /* @__PURE__ */ React2.createElement(Text, null, "Logged in as ", /* @__PURE__ */ React2.createElement(Text, { bold: true }, userConfig.login));
}

// src/commands/logout.tsx
import React3 from "react";
import { Text as Text2 } from "ink";
var read2 = asyncCache();
function logout_default() {
  read2("logout", logout);
  return /* @__PURE__ */ React3.createElement(Text2, null, "Logged out");
}

// src/bin.tsx
import { render as render2 } from "ink";
process.on("SIGINT", () => {
  process.exit(0);
});
process.on("SIGTERM", () => {
  process.exit(0);
});
process.on("exit", (_code) => {
});
process.on("uncaughtExceptionMonitor", function(err) {
  throw err;
});
process.on("unhandledRejection", function(reason, _promise) {
  throw reason;
});
function getArrayKVOption(val = []) {
  return val.reduce((acc, curr) => {
    const [key, ...value] = curr.split("=");
    acc[key] = value.join("=");
    return acc;
  }, {});
}
program.name("partykit").version(version, "-v, --version", "output the current version").description("Welcome to the party, pal!");
program.command("dev").description("run a script in development mode").argument("[script]", "path to the script to run").option("-p, --port <number>", "port to run the server on").option("--assets <path>", "path to assets directory").option("-c, --config <path>", "path to config file").option(
  "-v, --var [vars...]",
  "A key-value pair to be injected into the script as a variable"
).option(
  "-d, --define [defines...]",
  "A key-value pair to be substituted in the project"
).action(async (scriptPath, options) => {
  render2(
    /* @__PURE__ */ React4.createElement(
      Dev,
      {
        main: scriptPath,
        port: options.port,
        config: options.config,
        vars: getArrayKVOption(options.var),
        define: getArrayKVOption(options.define)
      }
    )
  );
});
program.command("deploy").alias("publish").description("deploy a script to the internet").argument("[script]", "path to the script to deploy").option("--assets <path>", "path to assets directory").option("-c, --config <path>", "path to config file").option(
  "-v, --var [vars...]",
  "A key-value pair to be injected into the script as a variable"
).option(
  "-d, --define [defines...]",
  "A key-value pair to be substituted in the script"
).option("--with-vars", "include all variables in the deployment").option("-n, --name <name>", "name of the project").option("--preview [name]", "deploy to preview environment").action(async (scriptPath, options) => {
  if (options.withVars) {
    console.warn("--with-vars is not yet implemented");
  }
  await deploy({
    main: scriptPath,
    name: options.name,
    config: options.config,
    vars: getArrayKVOption(options.var),
    define: getArrayKVOption(options.define),
    preview: options.preview,
    withVars: options.withVars,
    assets: options.assets
  });
});
program.command("list").description("list all deployed projects").action(async () => {
  await list();
});
program.command("delete").description("delete a deployed project").option("-n, --name <name>", "name of the project").option("-c, --config <path>", "path to config file").option("--preview [name]", "delete preview").action(async (options) => {
  await _delete(options);
});
program.command("tail").description("tail logs from a deployed project").option("-n, --name <name>", "name of the project").option("-c, --config <path>", "path to config file").option("--preview [name]", "tail logs from preview").addOption(
  new Option("-f, --format", "format of the logs").choices(["json", "pretty"]).default("pretty")
).option("--debug", "show debug logs", false).addOption(
  new Option("--status", "filter by invocation status").choices([
    "ok",
    "error",
    "canceled"
  ])
).option("--header", "filter by HTTP header").option("--method <...methods>", "filter by HTTP method(s)").option("--sampling-rate <number>", "sampling rate of logs").option("--search <string>", "search for a string in the logs").option(
  "--ip <..ips>",
  'filter by the IP address the request originates from (use "self" to filter for your own IP)'
).action(async (options) => {
  await tail(options);
});
var envCommand = program.command("env");
envCommand.command("list").description("list all environment variables").option("-n, --name <name>", "name of the project").option("-c, --config <path>", "path to config file").action(async (options) => {
  await env.list(options);
});
envCommand.command("pull").description("pull environment variables to a file").argument("[file]", "file to pull development env vars to").option("-n, --name <name>", "name of the project").option("-c, --config <path>", "path to config file").option("--preview [name]", "pull from preview").action(async (fileName, options) => {
  await env.pull(fileName, options);
});
envCommand.command("push").description("push environment variables from config file(s)").option("-n, --name <name>", "name of the project").option("-c, --config <path>", "path to config file").option("--preview [name]", "push to preview").action(async (options) => {
  await env.push(options);
});
envCommand.command("add").description("add an environment variable").argument("<key>", "name of the environment variable").option("-n, --name <name>", "name of the project").option("-c, --config <path>", "path to config file").option("--preview [name]", "add to preview").action(async (key, options) => {
  await env.add(key, options);
});
envCommand.command("remove").description("remove an environment variable").argument("[key]", "name of the environment variable").option("-n, --name <name>", "name of the project").option("-c, --config <path>", "path to config file").option("--preview [name]", "remove from preview").action(async (key, options) => {
  await env.remove(key, options);
});
program.command("login").description("login to partykit").action(async () => {
  render2(
    /* @__PURE__ */ React4.createElement(Suspense2, null, /* @__PURE__ */ React4.createElement(Login, null))
  );
});
program.command("logout").description("logout from partykit").action(async () => {
  render2(
    /* @__PURE__ */ React4.createElement(Suspense2, null, /* @__PURE__ */ React4.createElement(logout_default, null))
  );
});
var fn = new Intl.Collator(void 0, { numeric: true }).compare;
function semiver(aStr, bStr, bool) {
  const a = aStr.split(".");
  const b = bStr.split(".");
  return fn(a[0], b[0]) || fn(a[1], b[1]) || (b[2] = b.slice(2).join("."), bool = /[.-]/.test(a[2] = a.slice(2).join(".")), bool == /[.-]/.test(b[2]) ? fn(a[2], b[2]) : bool ? -1 : 1);
}
var MIN_NODE_VERSION = "16.8.0";
if (semiver(process.versions.node, MIN_NODE_VERSION) < 0) {
  console.error(
    `Partykit requires at least node.js v${MIN_NODE_VERSION}. You are using v${process.versions.node}. Please update your version of node.js.`
  );
  process.exit(1);
}
program.parse(process.argv);
//# sourceMappingURL=bin.mjs.map
