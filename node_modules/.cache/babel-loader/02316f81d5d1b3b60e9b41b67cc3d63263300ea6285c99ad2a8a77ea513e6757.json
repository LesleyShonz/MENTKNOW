{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _slicedToArray from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _toConsumableArray from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _objectSpread from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { isShape } from \"@tldraw/tlschema\";\nimport { computed, isUninitialized, RESET_VALUE } from \"signia\";\nvar parentsToChildrenWithIndexes = function parentsToChildrenWithIndexes(store) {\n  var shapeIds = store.query.ids(\"shape\");\n  function fromScratch() {\n    var result = {};\n    shapeIds.value.forEach(function (id) {\n      var shape = store.get(id);\n      if (!result[shape.parentId]) {\n        result[shape.parentId] = [];\n      }\n      result[shape.parentId].push([id, shape.index]);\n    });\n    Object.values(result).forEach(function (arr) {\n      return arr.sort(function (a, b) {\n        return a[1] < b[1] ? -1 : 1;\n      });\n    });\n    return result;\n  }\n  return computed(\"parentsToChildrenWithIndexes\", function (lastValue, lastComputedEpoch) {\n    var _newValue;\n    if (isUninitialized(lastValue)) {\n      return fromScratch();\n    }\n    var diff = store.history.getDiffSince(lastComputedEpoch);\n    if (diff === RESET_VALUE) {\n      return fromScratch();\n    }\n    if (diff.length === 0) return lastValue;\n    var newValue = null;\n    var ensureNewArray = function ensureNewArray(parentId) {\n      if (!newValue) {\n        newValue = _objectSpread({}, lastValue);\n      }\n      if (!newValue[parentId]) {\n        newValue[parentId] = [];\n      } else if (newValue[parentId] === lastValue[parentId]) {\n        newValue[parentId] = _toConsumableArray(newValue[parentId]);\n      }\n    };\n    var toSort = /* @__PURE__ */new Set();\n    var changes;\n    for (var i = 0, n = diff.length; i < n; i++) {\n      changes = diff[i];\n      for (var _i = 0, _Object$values = Object.values(changes.added); _i < _Object$values.length; _i++) {\n        var record = _Object$values[_i];\n        if (!isShape(record)) continue;\n        ensureNewArray(record.parentId);\n        newValue[record.parentId].push([record.id, record.index]);\n        toSort.add(newValue[record.parentId]);\n      }\n      var _loop = function _loop() {\n          var _Object$values2$_i = _slicedToArray(_Object$values2[_i2], 2),\n            from = _Object$values2$_i[0],\n            to = _Object$values2$_i[1];\n          if (!isShape(to)) return 0; // continue\n          if (!isShape(from)) return 0; // continue\n          if (from.parentId !== to.parentId) {\n            ensureNewArray(from.parentId);\n            ensureNewArray(to.parentId);\n            newValue[from.parentId].splice(newValue[from.parentId].findIndex(function (i2) {\n              return i2[0] === to.id;\n            }), 1);\n            newValue[to.parentId].push([to.id, to.index]);\n            toSort.add(newValue[to.parentId]);\n          } else if (from.index !== to.index) {\n            ensureNewArray(to.parentId);\n            var idx = newValue[to.parentId].findIndex(function (i2) {\n              return i2[0] === to.id;\n            });\n            newValue[to.parentId][idx] = [to.id, to.index];\n            toSort.add(newValue[to.parentId]);\n          }\n        },\n        _ret;\n      for (var _i2 = 0, _Object$values2 = Object.values(changes.updated); _i2 < _Object$values2.length; _i2++) {\n        _ret = _loop();\n        if (_ret === 0) continue;\n      }\n      var _loop2 = function _loop2() {\n        var record = _Object$values3[_i3];\n        if (!isShape(record)) return 1; // continue\n        ensureNewArray(record.parentId);\n        newValue[record.parentId].splice(newValue[record.parentId].findIndex(function (i2) {\n          return i2[0] === record.id;\n        }), 1);\n      };\n      for (var _i3 = 0, _Object$values3 = Object.values(changes.removed); _i3 < _Object$values3.length; _i3++) {\n        if (_loop2()) continue;\n      }\n    }\n    var _iterator = _createForOfIteratorHelper(toSort),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var arr = _step.value;\n        arr.sort(function (a, b) {\n          return a[1] < b[1] ? -1 : 1;\n        });\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    return (_newValue = newValue) !== null && _newValue !== void 0 ? _newValue : lastValue;\n  });\n};\nexport { parentsToChildrenWithIndexes };","map":{"version":3,"names":["isShape","computed","isUninitialized","RESET_VALUE","parentsToChildrenWithIndexes","store","shapeIds","query","ids","fromScratch","result","value","forEach","id","shape","get","parentId","push","index","Object","values","arr","sort","a","b","lastValue","lastComputedEpoch","_newValue","diff","history","getDiffSince","length","newValue","ensureNewArray","_objectSpread","_toConsumableArray","toSort","Set","changes","i","n","_i","_Object$values","added","record","add","_loop","_Object$values2$_i","_slicedToArray","_Object$values2","_i2","from","to","splice","findIndex","i2","idx","_ret","updated","_loop2","_Object$values3","_i3","removed","_iterator","_createForOfIteratorHelper","_step","s","done","err","e","f"],"sources":["/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@tldraw/editor/src/lib/editor/derivations/parentsToChildrenWithIndexes.ts"],"sourcesContent":["import { RecordsDiff } from '@tldraw/store'\nimport { isShape, TLParentId, TLRecord, TLShapeId, TLStore } from '@tldraw/tlschema'\nimport { computed, isUninitialized, RESET_VALUE } from 'signia'\n\ntype Parents2Children = Record<TLParentId, [id: TLShapeId, index: string][]>\n\nexport const parentsToChildrenWithIndexes = (store: TLStore) => {\n\tconst shapeIds = store.query.ids<'shape'>('shape')\n\tfunction fromScratch() {\n\t\tconst result: Parents2Children = {}\n\n\t\t// Populate the result object with an array for each parent.\n\t\tshapeIds.value.forEach((id) => {\n\t\t\tconst shape = store.get(id)!\n\n\t\t\tif (!result[shape.parentId]) {\n\t\t\t\tresult[shape.parentId] = []\n\t\t\t}\n\n\t\t\tresult[shape.parentId].push([id, shape.index])\n\t\t})\n\n\t\t// Sort the children by index\n\t\tObject.values(result).forEach((arr) => arr.sort((a, b) => (a[1] < b[1] ? -1 : 1)))\n\n\t\treturn result\n\t}\n\treturn computed<Parents2Children>(\n\t\t'parentsToChildrenWithIndexes',\n\t\t(lastValue, lastComputedEpoch) => {\n\t\t\tif (isUninitialized(lastValue)) {\n\t\t\t\treturn fromScratch()\n\t\t\t}\n\n\t\t\tconst diff = store.history.getDiffSince(lastComputedEpoch)\n\n\t\t\tif (diff === RESET_VALUE) {\n\t\t\t\treturn fromScratch()\n\t\t\t}\n\n\t\t\tif (diff.length === 0) return lastValue\n\n\t\t\tlet newValue: Record<TLParentId, [id: TLShapeId, index: string][]> | null = null\n\n\t\t\tconst ensureNewArray = (parentId: TLParentId) => {\n\t\t\t\tif (!newValue) {\n\t\t\t\t\tnewValue = { ...lastValue }\n\t\t\t\t}\n\t\t\t\tif (!newValue[parentId]) {\n\t\t\t\t\tnewValue[parentId] = []\n\t\t\t\t} else if (newValue[parentId] === lastValue[parentId]) {\n\t\t\t\t\tnewValue[parentId] = [...newValue[parentId]!]\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst toSort = new Set<[id: TLShapeId, index: string][]>()\n\n\t\t\tlet changes: RecordsDiff<TLRecord>\n\n\t\t\tfor (let i = 0, n = diff.length; i < n; i++) {\n\t\t\t\tchanges = diff[i]\n\n\t\t\t\t// Iterate through the added shapes, add them to the new value and mark them for sorting\n\t\t\t\tfor (const record of Object.values(changes.added)) {\n\t\t\t\t\tif (!isShape(record)) continue\n\t\t\t\t\tensureNewArray(record.parentId)\n\t\t\t\t\tnewValue![record.parentId].push([record.id, record.index])\n\t\t\t\t\ttoSort.add(newValue![record.parentId])\n\t\t\t\t}\n\n\t\t\t\t// Iterate through the updated shapes, add them to their parents in the new value and mark them for sorting\n\t\t\t\tfor (const [from, to] of Object.values(changes.updated)) {\n\t\t\t\t\tif (!isShape(to)) continue\n\t\t\t\t\tif (!isShape(from)) continue\n\n\t\t\t\t\tif (from.parentId !== to.parentId) {\n\t\t\t\t\t\t// If the parents have changed, remove the new value from the old parent and add it to the new parent\n\t\t\t\t\t\tensureNewArray(from.parentId)\n\t\t\t\t\t\tensureNewArray(to.parentId)\n\t\t\t\t\t\tnewValue![from.parentId].splice(\n\t\t\t\t\t\t\tnewValue![from.parentId].findIndex((i) => i[0] === to.id),\n\t\t\t\t\t\t\t1\n\t\t\t\t\t\t)\n\t\t\t\t\t\tnewValue![to.parentId].push([to.id, to.index])\n\t\t\t\t\t\ttoSort.add(newValue![to.parentId])\n\t\t\t\t\t} else if (from.index !== to.index) {\n\t\t\t\t\t\t// If the parent is the same but the index has changed (e.g. if they've been reordered), update the parent's array at the new index\n\t\t\t\t\t\tensureNewArray(to.parentId)\n\t\t\t\t\t\tconst idx = newValue![to.parentId].findIndex((i) => i[0] === to.id)\n\t\t\t\t\t\tnewValue![to.parentId][idx] = [to.id, to.index]\n\t\t\t\t\t\ttoSort.add(newValue![to.parentId])\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Iterate through the removed shapes, remove them from their parents in new value\n\t\t\t\tfor (const record of Object.values(changes.removed)) {\n\t\t\t\t\tif (!isShape(record)) continue\n\t\t\t\t\tensureNewArray(record.parentId)\n\t\t\t\t\tnewValue![record.parentId].splice(\n\t\t\t\t\t\tnewValue![record.parentId].findIndex((i) => i[0] === record.id),\n\t\t\t\t\t\t1\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Sort the arrays that have been marked for sorting\n\t\t\tfor (const arr of toSort) {\n\t\t\t\tarr.sort((a, b) => (a[1] < b[1] ? -1 : 1))\n\t\t\t}\n\n\t\t\treturn newValue ?? lastValue\n\t\t}\n\t)\n}\n"],"mappings":";;;;AACA,SAASA,OAAA,QAAyD;AAClE,SAASC,QAAA,EAAUC,eAAA,EAAiBC,WAAA,QAAmB;AAIhD,IAAMC,4BAAA,GAA+B,SAA/BA,6BAAgCC,KAAA,EAAmB;EAC/D,IAAMC,QAAA,GAAWD,KAAA,CAAME,KAAA,CAAMC,GAAA,CAAa,OAAO;EACjD,SAASC,YAAA,EAAc;IACtB,IAAMC,MAAA,GAA2B,CAAC;IAGlCJ,QAAA,CAASK,KAAA,CAAMC,OAAA,CAAQ,UAACC,EAAA,EAAO;MAC9B,IAAMC,KAAA,GAAQT,KAAA,CAAMU,GAAA,CAAIF,EAAE;MAE1B,IAAI,CAACH,MAAA,CAAOI,KAAA,CAAME,QAAQ,GAAG;QAC5BN,MAAA,CAAOI,KAAA,CAAME,QAAQ,IAAI,EAAC;MAC3B;MAEAN,MAAA,CAAOI,KAAA,CAAME,QAAQ,EAAEC,IAAA,CAAK,CAACJ,EAAA,EAAIC,KAAA,CAAMI,KAAK,CAAC;IAC9C,CAAC;IAGDC,MAAA,CAAOC,MAAA,CAAOV,MAAM,EAAEE,OAAA,CAAQ,UAACS,GAAA;MAAA,OAAQA,GAAA,CAAIC,IAAA,CAAK,UAACC,CAAA,EAAGC,CAAA;QAAA,OAAOD,CAAA,CAAE,CAAC,IAAIC,CAAA,CAAE,CAAC,IAAI,KAAK,CAAE;MAAA,EAAC;IAAA;IAEjF,OAAOd,MAAA;EACR;EACA,OAAOT,QAAA,CACN,gCACA,UAACwB,SAAA,EAAWC,iBAAA,EAAsB;IAAA,IAAAC,SAAA;IACjC,IAAIzB,eAAA,CAAgBuB,SAAS,GAAG;MAC/B,OAAOhB,WAAA,CAAY;IACpB;IAEA,IAAMmB,IAAA,GAAOvB,KAAA,CAAMwB,OAAA,CAAQC,YAAA,CAAaJ,iBAAiB;IAEzD,IAAIE,IAAA,KAASzB,WAAA,EAAa;MACzB,OAAOM,WAAA,CAAY;IACpB;IAEA,IAAImB,IAAA,CAAKG,MAAA,KAAW,GAAG,OAAON,SAAA;IAE9B,IAAIO,QAAA,GAAwE;IAE5E,IAAMC,cAAA,GAAiB,SAAjBA,eAAkBjB,QAAA,EAAyB;MAChD,IAAI,CAACgB,QAAA,EAAU;QACdA,QAAA,GAAAE,aAAA,KAAgBT,SAAA,CAAU;MAC3B;MACA,IAAI,CAACO,QAAA,CAAShB,QAAQ,GAAG;QACxBgB,QAAA,CAAShB,QAAQ,IAAI,EAAC;MACvB,WAAWgB,QAAA,CAAShB,QAAQ,MAAMS,SAAA,CAAUT,QAAQ,GAAG;QACtDgB,QAAA,CAAShB,QAAQ,IAAAmB,kBAAA,CAAQH,QAAA,CAAShB,QAAQ,CAAE;MAC7C;IACD;IAEA,IAAMoB,MAAA,GAAS,mBAAIC,GAAA,CAAsC;IAEzD,IAAIC,OAAA;IAEJ,SAASC,CAAA,GAAI,GAAGC,CAAA,GAAIZ,IAAA,CAAKG,MAAA,EAAQQ,CAAA,GAAIC,CAAA,EAAGD,CAAA,IAAK;MAC5CD,OAAA,GAAUV,IAAA,CAAKW,CAAC;MAGhB,SAAAE,EAAA,MAAAC,cAAA,GAAqBvB,MAAA,CAAOC,MAAA,CAAOkB,OAAA,CAAQK,KAAK,GAAAF,EAAA,GAAAC,cAAA,CAAAX,MAAA,EAAAU,EAAA,IAAG;QAAnD,IAAWG,MAAA,GAAAF,cAAA,CAAAD,EAAA;QACV,IAAI,CAACzC,OAAA,CAAQ4C,MAAM,GAAG;QACtBX,cAAA,CAAeW,MAAA,CAAO5B,QAAQ;QAC9BgB,QAAA,CAAUY,MAAA,CAAO5B,QAAQ,EAAEC,IAAA,CAAK,CAAC2B,MAAA,CAAO/B,EAAA,EAAI+B,MAAA,CAAO1B,KAAK,CAAC;QACzDkB,MAAA,CAAOS,GAAA,CAAIb,QAAA,CAAUY,MAAA,CAAO5B,QAAQ,CAAC;MACtC;MAAA,IAAA8B,KAAA,YAAAA,MAAA,EAGyD;UAAzD,IAAAC,kBAAA,GAAAC,cAAA,CAAAC,eAAA,CAAAC,GAAA;YAAYC,IAAA,GAAAJ,kBAAA;YAAMK,EAAE,GAAAL,kBAAA;UACnB,IAAI,CAAC/C,OAAA,CAAQoD,EAAE;UACf,IAAI,CAACpD,OAAA,CAAQmD,IAAI;UAEjB,IAAIA,IAAA,CAAKnC,QAAA,KAAaoC,EAAA,CAAGpC,QAAA,EAAU;YAElCiB,cAAA,CAAekB,IAAA,CAAKnC,QAAQ;YAC5BiB,cAAA,CAAemB,EAAA,CAAGpC,QAAQ;YAC1BgB,QAAA,CAAUmB,IAAA,CAAKnC,QAAQ,EAAEqC,MAAA,CACxBrB,QAAA,CAAUmB,IAAA,CAAKnC,QAAQ,EAAEsC,SAAA,CAAU,UAACC,EAAA;cAAA,OAAMA,EAAA,CAAE,CAAC,MAAMH,EAAA,CAAGvC,EAAE;YAAA,IACxD,CACD;YACAmB,QAAA,CAAUoB,EAAA,CAAGpC,QAAQ,EAAEC,IAAA,CAAK,CAACmC,EAAA,CAAGvC,EAAA,EAAIuC,EAAA,CAAGlC,KAAK,CAAC;YAC7CkB,MAAA,CAAOS,GAAA,CAAIb,QAAA,CAAUoB,EAAA,CAAGpC,QAAQ,CAAC;UAClC,WAAWmC,IAAA,CAAKjC,KAAA,KAAUkC,EAAA,CAAGlC,KAAA,EAAO;YAEnCe,cAAA,CAAemB,EAAA,CAAGpC,QAAQ;YAC1B,IAAMwC,GAAA,GAAMxB,QAAA,CAAUoB,EAAA,CAAGpC,QAAQ,EAAEsC,SAAA,CAAU,UAACC,EAAA;cAAA,OAAMA,EAAA,CAAE,CAAC,MAAMH,EAAA,CAAGvC,EAAE;YAAA;YAClEmB,QAAA,CAAUoB,EAAA,CAAGpC,QAAQ,EAAEwC,GAAG,IAAI,CAACJ,EAAA,CAAGvC,EAAA,EAAIuC,EAAA,CAAGlC,KAAK;YAC9CkB,MAAA,CAAOS,GAAA,CAAIb,QAAA,CAAUoB,EAAA,CAAGpC,QAAQ,CAAC;UAClC;QACD;QAAAyC,IAAA;MArBA,SAAAP,GAAA,MAAAD,eAAA,GAAyB9B,MAAA,CAAOC,MAAA,CAAOkB,OAAA,CAAQoB,OAAO,GAAAR,GAAA,GAAAD,eAAA,CAAAlB,MAAA,EAAAmB,GAAA;QAAAO,IAAA,GAAAX,KAAA;QAAA,IAAAW,IAAA,QACnC;MAAA;MAoBnB,IAAAE,MAAA,YAAAA,OAAA,EAGqD;QAArD,IAAWf,MAAA,GAAAgB,eAAA,CAAAC,GAAA;QACV,IAAI,CAAC7D,OAAA,CAAQ4C,MAAM;QACnBX,cAAA,CAAeW,MAAA,CAAO5B,QAAQ;QAC9BgB,QAAA,CAAUY,MAAA,CAAO5B,QAAQ,EAAEqC,MAAA,CAC1BrB,QAAA,CAAUY,MAAA,CAAO5B,QAAQ,EAAEsC,SAAA,CAAU,UAACC,EAAA;UAAA,OAAMA,EAAA,CAAE,CAAC,MAAMX,MAAA,CAAO/B,EAAE;QAAA,IAC9D,CACD;MACD;MAPA,SAAAgD,GAAA,MAAAD,eAAA,GAAqBzC,MAAA,CAAOC,MAAA,CAAOkB,OAAA,CAAQwB,OAAO,GAAAD,GAAA,GAAAD,eAAA,CAAA7B,MAAA,EAAA8B,GAAA;QAAA,IAAAF,MAAA,IAC3B;MAAA;IAOxB;IAAA,IAAAI,SAAA,GAAAC,0BAAA,CAGkB5B,MAAA;MAAA6B,KAAA;IAAA;MAAlB,KAAAF,SAAA,CAAAG,CAAA,MAAAD,KAAA,GAAAF,SAAA,CAAAvB,CAAA,IAAA2B,IAAA,GAA0B;QAAA,IAAf9C,GAAA,GAAA4C,KAAA,CAAAtD,KAAA;QACVU,GAAA,CAAIC,IAAA,CAAK,UAACC,CAAA,EAAGC,CAAA;UAAA,OAAOD,CAAA,CAAE,CAAC,IAAIC,CAAA,CAAE,CAAC,IAAI,KAAK,CAAE;QAAA;MAC1C;IAAA,SAAA4C,GAAA;MAAAL,SAAA,CAAAM,CAAA,CAAAD,GAAA;IAAA;MAAAL,SAAA,CAAAO,CAAA;IAAA;IAEA,QAAA3C,SAAA,GAAOK,QAAA,cAAAL,SAAA,cAAAA,SAAA,GAAYF,SAAA;EACpB,CACD;AACD"},"metadata":{},"sourceType":"module","externalDependencies":[]}