{"ast":null,"code":"import _slicedToArray from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _toConsumableArray from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _objectSpread from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _createForOfIteratorHelper from \"/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport { RESET_VALUE, computed, isUninitialized } from \"signia\";\nimport { ArrowShapeUtil } from \"../shapes/arrow/ArrowShapeUtil.mjs\";\nvar arrowBindingsIndex = function arrowBindingsIndex(editor) {\n  var store = editor.store;\n  var shapeHistory = store.query.filterHistory(\"shape\");\n  var arrowQuery = store.query.records(\"shape\", function () {\n    return {\n      type: {\n        eq: \"arrow\"\n      }\n    };\n  });\n  function fromScratch() {\n    var allArrows = arrowQuery.value;\n    var bindings2Arrows = {};\n    var _iterator = _createForOfIteratorHelper(allArrows),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var arrow = _step.value;\n        var _arrow$props = arrow.props,\n          start = _arrow$props.start,\n          end = _arrow$props.end;\n        if (start.type === \"binding\") {\n          var arrows = bindings2Arrows[start.boundShapeId];\n          if (arrows) arrows.push({\n            arrowId: arrow.id,\n            handleId: \"start\"\n          });else bindings2Arrows[start.boundShapeId] = [{\n            arrowId: arrow.id,\n            handleId: \"start\"\n          }];\n        }\n        if (end.type === \"binding\") {\n          var _arrows = bindings2Arrows[end.boundShapeId];\n          if (_arrows) _arrows.push({\n            arrowId: arrow.id,\n            handleId: \"end\"\n          });else bindings2Arrows[end.boundShapeId] = [{\n            arrowId: arrow.id,\n            handleId: \"end\"\n          }];\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    return bindings2Arrows;\n  }\n  return computed(\"arrowBindingsIndex\", function (_lastValue, lastComputedEpoch) {\n    var _nextValue;\n    if (isUninitialized(_lastValue)) {\n      return fromScratch();\n    }\n    var lastValue = _lastValue;\n    var diff = shapeHistory.getDiffSince(lastComputedEpoch);\n    if (diff === RESET_VALUE) {\n      return fromScratch();\n    }\n    var nextValue = void 0;\n    function ensureNewArray(boundShapeId) {\n      if (!nextValue) {\n        nextValue = _objectSpread({}, lastValue);\n      }\n      if (!nextValue[boundShapeId]) {\n        nextValue[boundShapeId] = [];\n      } else if (nextValue[boundShapeId] === lastValue[boundShapeId]) {\n        nextValue[boundShapeId] = _toConsumableArray(nextValue[boundShapeId]);\n      }\n    }\n    function removingBinding(boundShapeId, arrowId, handleId) {\n      ensureNewArray(boundShapeId);\n      nextValue[boundShapeId] = nextValue[boundShapeId].filter(function (binding) {\n        return binding.arrowId !== arrowId || binding.handleId !== handleId;\n      });\n      if (nextValue[boundShapeId].length === 0) {\n        delete nextValue[boundShapeId];\n      }\n    }\n    function addBinding(boundShapeId, arrowId, handleId) {\n      ensureNewArray(boundShapeId);\n      nextValue[boundShapeId].push({\n        arrowId: arrowId,\n        handleId: handleId\n      });\n    }\n    var _iterator2 = _createForOfIteratorHelper(diff),\n      _step2;\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var changes = _step2.value;\n        for (var _i = 0, _Object$values = Object.values(changes.added); _i < _Object$values.length; _i++) {\n          var newShape = _Object$values[_i];\n          if (editor.isShapeOfType(newShape, ArrowShapeUtil)) {\n            var _newShape$props = newShape.props,\n              start = _newShape$props.start,\n              end = _newShape$props.end;\n            if (start.type === \"binding\") {\n              addBinding(start.boundShapeId, newShape.id, \"start\");\n            }\n            if (end.type === \"binding\") {\n              addBinding(end.boundShapeId, newShape.id, \"end\");\n            }\n          }\n        }\n        for (var _i2 = 0, _Object$values2 = Object.values(changes.updated); _i2 < _Object$values2.length; _i2++) {\n          var _Object$values2$_i = _slicedToArray(_Object$values2[_i2], 2),\n            prev = _Object$values2$_i[0],\n            next = _Object$values2$_i[1];\n          if (!editor.isShapeOfType(prev, ArrowShapeUtil) || !editor.isShapeOfType(next, ArrowShapeUtil)) continue;\n          for (var _i3 = 0, _arr = [\"start\", \"end\"]; _i3 < _arr.length; _i3++) {\n            var handle = _arr[_i3];\n            var prevTerminal = prev.props[handle];\n            var nextTerminal = next.props[handle];\n            if (prevTerminal.type === \"binding\" && nextTerminal.type === \"point\") {\n              removingBinding(prevTerminal.boundShapeId, prev.id, handle);\n            } else if (prevTerminal.type === \"point\" && nextTerminal.type === \"binding\") {\n              addBinding(nextTerminal.boundShapeId, next.id, handle);\n            } else if (prevTerminal.type === \"binding\" && nextTerminal.type === \"binding\" && prevTerminal.boundShapeId !== nextTerminal.boundShapeId) {\n              removingBinding(prevTerminal.boundShapeId, prev.id, handle);\n              addBinding(nextTerminal.boundShapeId, next.id, handle);\n            }\n          }\n        }\n        for (var _i4 = 0, _Object$values3 = Object.values(changes.removed); _i4 < _Object$values3.length; _i4++) {\n          var _prev = _Object$values3[_i4];\n          if (editor.isShapeOfType(_prev, ArrowShapeUtil)) {\n            var _prev$props = _prev.props,\n              _start = _prev$props.start,\n              _end = _prev$props.end;\n            if (_start.type === \"binding\") {\n              removingBinding(_start.boundShapeId, _prev.id, \"start\");\n            }\n            if (_end.type === \"binding\") {\n              removingBinding(_end.boundShapeId, _prev.id, \"end\");\n            }\n          }\n        }\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n    return (_nextValue = nextValue) !== null && _nextValue !== void 0 ? _nextValue : lastValue;\n  });\n};\nexport { arrowBindingsIndex };","map":{"version":3,"names":["RESET_VALUE","computed","isUninitialized","ArrowShapeUtil","arrowBindingsIndex","editor","store","shapeHistory","query","filterHistory","arrowQuery","records","type","eq","fromScratch","allArrows","value","bindings2Arrows","_iterator","_createForOfIteratorHelper","_step","s","n","done","arrow","_arrow$props","props","start","end","arrows","boundShapeId","push","arrowId","id","handleId","err","e","f","_lastValue","lastComputedEpoch","_nextValue","lastValue","diff","getDiffSince","nextValue","ensureNewArray","_objectSpread","_toConsumableArray","removingBinding","filter","binding","length","addBinding","_iterator2","_step2","changes","_i","_Object$values","Object","values","added","newShape","isShapeOfType","_newShape$props","_i2","_Object$values2","updated","_Object$values2$_i","_slicedToArray","prev","next","_i3","_arr","handle","prevTerminal","nextTerminal","_i4","_Object$values3","removed","_prev$props"],"sources":["/Users/lesleyshinhiwa/Downloads/tldraw-partykit-example-2/Co/node_modules/@tldraw/editor/src/lib/editor/derivations/arrowBindingsIndex.ts"],"sourcesContent":["import { TLArrowShape, TLShape, TLShapeId } from '@tldraw/tlschema'\nimport { Computed, RESET_VALUE, computed, isUninitialized } from 'signia'\nimport { Editor } from '../Editor'\nimport { ArrowShapeUtil } from '../shapes/arrow/ArrowShapeUtil'\n\nexport type TLArrowBindingsIndex = Record<\n\tTLShapeId,\n\tundefined | { arrowId: TLShapeId; handleId: 'start' | 'end' }[]\n>\n\nexport const arrowBindingsIndex = (editor: Editor): Computed<TLArrowBindingsIndex> => {\n\tconst { store } = editor\n\tconst shapeHistory = store.query.filterHistory('shape')\n\tconst arrowQuery = store.query.records('shape', () => ({ type: { eq: 'arrow' as const } }))\n\tfunction fromScratch() {\n\t\tconst allArrows = arrowQuery.value as TLArrowShape[]\n\n\t\tconst bindings2Arrows: TLArrowBindingsIndex = {}\n\n\t\tfor (const arrow of allArrows) {\n\t\t\tconst { start, end } = arrow.props\n\t\t\tif (start.type === 'binding') {\n\t\t\t\tconst arrows = bindings2Arrows[start.boundShapeId]\n\t\t\t\tif (arrows) arrows.push({ arrowId: arrow.id, handleId: 'start' })\n\t\t\t\telse bindings2Arrows[start.boundShapeId] = [{ arrowId: arrow.id, handleId: 'start' }]\n\t\t\t}\n\n\t\t\tif (end.type === 'binding') {\n\t\t\t\tconst arrows = bindings2Arrows[end.boundShapeId]\n\t\t\t\tif (arrows) arrows.push({ arrowId: arrow.id, handleId: 'end' })\n\t\t\t\telse bindings2Arrows[end.boundShapeId] = [{ arrowId: arrow.id, handleId: 'end' }]\n\t\t\t}\n\t\t}\n\n\t\treturn bindings2Arrows\n\t}\n\n\treturn computed<TLArrowBindingsIndex>('arrowBindingsIndex', (_lastValue, lastComputedEpoch) => {\n\t\tif (isUninitialized(_lastValue)) {\n\t\t\treturn fromScratch()\n\t\t}\n\n\t\tconst lastValue = _lastValue\n\n\t\tconst diff = shapeHistory.getDiffSince(lastComputedEpoch)\n\n\t\tif (diff === RESET_VALUE) {\n\t\t\treturn fromScratch()\n\t\t}\n\n\t\tlet nextValue: TLArrowBindingsIndex | undefined = undefined\n\n\t\tfunction ensureNewArray(boundShapeId: TLShapeId) {\n\t\t\t// this will never happen\n\t\t\tif (!nextValue) {\n\t\t\t\tnextValue = { ...lastValue }\n\t\t\t}\n\t\t\tif (!nextValue[boundShapeId]) {\n\t\t\t\tnextValue[boundShapeId] = []\n\t\t\t} else if (nextValue[boundShapeId] === lastValue[boundShapeId]) {\n\t\t\t\tnextValue[boundShapeId] = [...nextValue[boundShapeId]!]\n\t\t\t}\n\t\t}\n\n\t\tfunction removingBinding(\n\t\t\tboundShapeId: TLShapeId,\n\t\t\tarrowId: TLShapeId,\n\t\t\thandleId: 'start' | 'end'\n\t\t) {\n\t\t\tensureNewArray(boundShapeId)\n\t\t\tnextValue![boundShapeId] = nextValue![boundShapeId]!.filter(\n\t\t\t\t(binding) => binding.arrowId !== arrowId || binding.handleId !== handleId\n\t\t\t)\n\t\t\tif (nextValue![boundShapeId]!.length === 0) {\n\t\t\t\tdelete nextValue![boundShapeId]\n\t\t\t}\n\t\t}\n\n\t\tfunction addBinding(boundShapeId: TLShapeId, arrowId: TLShapeId, handleId: 'start' | 'end') {\n\t\t\tensureNewArray(boundShapeId)\n\t\t\tnextValue![boundShapeId]!.push({ arrowId, handleId })\n\t\t}\n\n\t\tfor (const changes of diff) {\n\t\t\tfor (const newShape of Object.values(changes.added)) {\n\t\t\t\tif (editor.isShapeOfType(newShape, ArrowShapeUtil)) {\n\t\t\t\t\tconst { start, end } = newShape.props\n\t\t\t\t\tif (start.type === 'binding') {\n\t\t\t\t\t\taddBinding(start.boundShapeId, newShape.id, 'start')\n\t\t\t\t\t}\n\t\t\t\t\tif (end.type === 'binding') {\n\t\t\t\t\t\taddBinding(end.boundShapeId, newShape.id, 'end')\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (const [prev, next] of Object.values(changes.updated) as [TLShape, TLShape][]) {\n\t\t\t\tif (\n\t\t\t\t\t!editor.isShapeOfType(prev, ArrowShapeUtil) ||\n\t\t\t\t\t!editor.isShapeOfType(next, ArrowShapeUtil)\n\t\t\t\t)\n\t\t\t\t\tcontinue\n\n\t\t\t\tfor (const handle of ['start', 'end'] as const) {\n\t\t\t\t\tconst prevTerminal = prev.props[handle]\n\t\t\t\t\tconst nextTerminal = next.props[handle]\n\n\t\t\t\t\tif (prevTerminal.type === 'binding' && nextTerminal.type === 'point') {\n\t\t\t\t\t\t// if the binding was removed\n\t\t\t\t\t\tremovingBinding(prevTerminal.boundShapeId, prev.id, handle)\n\t\t\t\t\t} else if (prevTerminal.type === 'point' && nextTerminal.type === 'binding') {\n\t\t\t\t\t\t// if the binding was added\n\t\t\t\t\t\taddBinding(nextTerminal.boundShapeId, next.id, handle)\n\t\t\t\t\t} else if (\n\t\t\t\t\t\tprevTerminal.type === 'binding' &&\n\t\t\t\t\t\tnextTerminal.type === 'binding' &&\n\t\t\t\t\t\tprevTerminal.boundShapeId !== nextTerminal.boundShapeId\n\t\t\t\t\t) {\n\t\t\t\t\t\t// if the binding was changed\n\t\t\t\t\t\tremovingBinding(prevTerminal.boundShapeId, prev.id, handle)\n\t\t\t\t\t\taddBinding(nextTerminal.boundShapeId, next.id, handle)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (const prev of Object.values(changes.removed)) {\n\t\t\t\tif (editor.isShapeOfType(prev, ArrowShapeUtil)) {\n\t\t\t\t\tconst { start, end } = prev.props\n\t\t\t\t\tif (start.type === 'binding') {\n\t\t\t\t\t\tremovingBinding(start.boundShapeId, prev.id, 'start')\n\t\t\t\t\t}\n\t\t\t\t\tif (end.type === 'binding') {\n\t\t\t\t\t\tremovingBinding(end.boundShapeId, prev.id, 'end')\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// TODO: add diff entries if we need them\n\t\treturn nextValue ?? lastValue\n\t})\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}